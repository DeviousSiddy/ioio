Disassembly Listing for AppLayerV1
Generated From:
/Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/bootloader/dist/MINT0010/debug/bootloader.debug.cof
Nov 6, 2013 11:42:04 PM
/Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/app_layer_v1/dist/IOIO0023/debug/app_layer_v1.debug.cof
Nov 6, 2013 11:51:40 PM

---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/microchip/usb/usb_host.c  
000566  F80036     PUSH RCOUNT
000568  BE9F80     MOV.D W0, [W15++]
00056A  BE9F82     MOV.D W2, [W15++]
00056C  BE9F84     MOV.D W4, [W15++]
00056E  BE9F86     MOV.D W6, [W15++]
000EB0  FA0002     LNK #0x2
000EB2  BE9F88     MOV.D W8, [W15++]
001A76  4787F0     ADD W15, #0x10, W15
001A78  BE9F88     MOV.D W8, [W15++]
001A7A  BE9F8A     MOV.D W10, [W15++]
001A7C  BE9F8C     MOV.D W12, [W15++]
001A7E  781F8E     MOV W14, [W15++]
001F10  BE9F88     MOV.D W8, [W15++]
001F12  BE9F8A     MOV.D W10, [W15++]
00292A  784180     MOV.B W0, W3
00292C  21ECC0     MOV #0x1ECC, W0
002A1E  E8878F     INC2 W15, W15
002A20  BE9F88     MOV.D W8, [W15++]
002A22  BE9F8A     MOV.D W10, [W15++]
002A24  BE9F8C     MOV.D W12, [W15++]
002A26  781F8E     MOV W14, [W15++]
002A28  784601     MOV.B W1, W12
002A2A  784582     MOV.B W2, W11
002A2C  780403     MOV W3, W8
002A2E  780484     MOV W4, W9
002A30  780505     MOV W5, W10
002A32  780686     MOV W6, W13
002A34  784707     MOV.B W7, W14
002C40  784200     MOV.B W0, W4
002E2C  FA0008     LNK #0x8
002E2E  781F88     MOV W8, [W15++]
002E30  784200     MOV.B W0, W4
002E32  780403     MOV W3, W8
002E98  BE9F88     MOV.D W8, [W15++]
002E9A  781F8A     MOV W10, [W15++]
002E9C  784181     MOV.B W1, W3
002E9E  780502     MOV W2, W10
002EA0  BE0404     MOV.D W4, W8
002F02  BE9F88     MOV.D W8, [W15++]
002F04  781F8A     MOV W10, [W15++]
002F06  784181     MOV.B W1, W3
002F08  780502     MOV W2, W10
002F0A  BE0404     MOV.D W4, W8
002FD0  BE9F88     MOV.D W8, [W15++]
002FD2  784201     MOV.B W1, W4
002FD4  BE0402     MOV.D W2, W8
003090  BE9F88     MOV.D W8, [W15++]
003092  BE9F8A     MOV.D W10, [W15++]
003094  781F8C     MOV W12, [W15++]
003096  784600     MOV.B W0, W12
003098  780481     MOV W1, W9
00309A  BE0502     MOV.D W2, W10
0030EC  780180     MOV W0, W3
0030EE  780201     MOV W1, W4
003144  780180     MOV W0, W3
003146  780201     MOV W1, W4
0031F4  781F88     MOV W8, [W15++]
0031F6  780400     MOV W0, W8
003298  BE9F88     MOV.D W8, [W15++]
00329A  781F8A     MOV W10, [W15++]
00329C  37001B     BRA 0x32D4
00336C  784200     MOV.B W0, W4
0033E6  781F88     MOV W8, [W15++]
0033E8  784401     MOV.B W1, W8
003422  BE9F88     MOV.D W8, [W15++]
003424  370009     BRA 0x3438
003504  FA0002     LNK #0x2
003506  781F88     MOV W8, [W15++]
003640  BE9F88     MOV.D W8, [W15++]
003642  784201     MOV.B W1, W4
003644  BE0402     MOV.D W2, W8
0036A4  784180     MOV.B W0, W3
0036D4  784181     MOV.B W1, W3
0036FE  780180     MOV W0, W3
00374A  784101     MOV.B W1, W2
1:                 /******************************************************************************
2:                 
3:                     USB Host Driver
4:                 
5:                 This file provides the hardware interface for a USB Embedded Host application.
6:                 Most applications will not make direct use of the functions in this file.
7:                 Instead, one or more client driver files should also be included in the project
8:                 to support the devices that will be attached to the host.  Application
9:                 interface will be through the client drivers.
10:                
11:                Note: USB interrupts are cleared by writing a "1" to the interrupt flag.  This
12:                means that read-modify-write instructions cannot be used to clear the flag.  A
13:                bit manipulation instruction, such as "U1OTGIRbits.T1MSECIF = 1;" will read the
14:                value of the U1OTGIR register, set the T1MSECIF bit in that value to "1", and
15:                then write that value back to U1OTGIR.  If U1OTGIR had any other flags set,
16:                those flags are written back as "1", which will clear those flags.  To avoid
17:                this issue, a constant value must be written to U1OTGIR where only the interrupt
18:                flag in question is set, such as "U1OTGIR = USB_INTERRUPT_T1MSECIF;", where
19:                USB_INTERRUPT_T1MSECIF equals 0x40.
20:                
21:                *******************************************************************************/
22:                //DOM-IGNORE-BEGIN
23:                /******************************************************************************
24:                
25:                 File Name:       usb_host.c
26:                 Dependencies:    None
27:                 Processor:       PIC24F/PIC32MX
28:                 Compiler:        C30/C32
29:                 Company:         Microchip Technology, Inc.
30:                
31:                Software License Agreement
32:                
33:                The software supplied herewith by Microchip Technology Incorporated
34:                (the ‰??Company‰??) for its PICmicroå¨ Microcontroller is intended and
35:                supplied to you, the Company‰??s customer, for use solely and
36:                exclusively on Microchip PICmicro Microcontroller products. The
37:                software is owned by the Company and/or its supplier, and is
38:                protected under applicable copyright laws. All rights are reserved.
39:                Any use in violation of the foregoing restrictions may subject the
40:                user to criminal sanctions under applicable laws, as well as to
41:                civil liability for the breach of the terms and conditions of this
42:                license.
43:                
44:                THIS SOFTWARE IS PROVIDED IN AN ‰??AS IS‰?? CONDITION. NO WARRANTIES,
45:                WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
46:                TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
47:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
48:                IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
49:                CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
50:                
51:                Change History:
52:                  Rev         Description
53:                  ----------  ----------------------------------------------------------
54:                  2.6 - 2.6a  No change
55:                  
56:                  2.7         Fixed an error where the USBHostClearEndpointErrors() function
57:                              didn't properly return USB_SUCCESS if the errors were successfully
58:                              cleared.
59:                              http://www.microchip.com/forums/fb.aspx?m=490651
60:                
61:                              Fixed an error where the DTS bits for the attached device could
62:                              be accidentally reset on a class specific request with the same
63:                              bRequest and wValue as a HALT_ENDPOINT request.
64:                
65:                              Fixed an error where device may never be able to enumerate if it
66:                              is already attached when the host stack initializes.
67:                
68:                *******************************************************************************/
69:                
70:                #include <stdlib.h>
71:                #include <string.h>
72:                #include "GenericTypeDefs.h"
73:                #include "USB/usb.h"
74:                #include "usb_host_local.h"
75:                #include "usb_hal_local.h"
76:                #include "HardwareProfile.h"
77:                //#include "USB/usb_hal.h"
78:                
79:                //#define DEBUG_HEAP
80:                #if defined(DEBUG_HEAP) && defined(ENABLE_LOGGING)
81:                #include "logging.h"
82:                
83:                static unsigned _total_nodes = 0;
84:                static unsigned _total_mem = 0;
85:                
86:                void *_debug_malloc(const char *file, int line, size_t size) {
87:                  static unsigned counter = 1;
88:                  void *ptr = malloc(size + 2 * sizeof(unsigned));
89:                  if (ptr) {
90:                    log_printf("malloc #%u, size=%u from %s: %d", counter, size, file, line);
91:                    ((unsigned *) ptr)[0] = counter;
92:                    ((unsigned *) ptr)[1] = size;
93:                    ++counter;
94:                    ++_total_nodes;
95:                    _total_mem += size;
96:                    log_printf("nodes=%u, mem=%u", _total_nodes, _total_mem);
97:                    return ((unsigned *) ptr) + 2;
98:                  } else {
99:                    log_printf("malloc FAILED, size=%u from %s: %d", size, file, line);
100:                   return NULL;
101:                 }
102:               }
103:               
104:               void _debug_free(const char *file, int line, void *ptr) {
105:                 if (ptr) {
106:                   unsigned *p = ((unsigned *) ptr) - 2;
107:                   unsigned counter = p[0];
108:                   unsigned size = p[1];
109:                   if (!(counter & 0x8000)) {
110:                     log_printf("free #%u from %s: %d", counter, file, line);
111:                     *p |= 0x8000;
112:                     free(p);
113:                     --_total_nodes;
114:                     _total_mem -= size;
115:                     log_printf("nodes=%u, mem=%u", _total_nodes, _total_mem);
116:                   } else {
117:                     log_printf("free ERROR, already freed #%u from %s: %d", counter & 0x7FFF, file, line);
118:                   }
119:                 } else {
120:                   log_printf("free ERROR: NULL from %s: %d", file, line);
121:                 }
122:               }
123:               
124:               #define debug_malloc(size) _debug_malloc(__FILE__, __LINE__, size)
125:               #define debug_free(ptr) _debug_free(__FILE__, __LINE__, ptr)
126:               
127:               #ifndef USB_MALLOC
128:                   #define USB_MALLOC(size) debug_malloc(size)
129:               #endif
130:               
131:               #ifndef USB_FREE
132:                   #define USB_FREE(ptr) debug_free(ptr)
133:               #endif
134:               
135:               #else
136:               
137:               #ifndef USB_MALLOC
138:                   #define USB_MALLOC(size) malloc(size)
139:               #endif
140:               
141:               #ifndef USB_FREE
142:                   #define USB_FREE(ptr) free(ptr)
143:               #endif
144:               
145:               #endif  // defined(DEBUG_HEAP) && defined(ENABLE_LOGGING)
146:               
147:               #define USB_FREE_AND_CLEAR(ptr) {USB_FREE(ptr); ptr = NULL;}
148:               
149:               #if defined( USB_ENABLE_TRANSFER_EVENT )
150:                   #include "struct_queue.h"
151:               #endif
152:               
153:               // *****************************************************************************
154:               // Low Level Functionality Configurations.
155:               
156:               //#define DEBUG_MODE
157:               #ifdef DEBUG_MODE
158:                   #include "uart2.h"
159:               #endif
160:               
161:               // If the TPL includes an entry specifying a VID of 0xFFFF and a PID of 0xFFFF,
162:               // the specified client driver will be used for any device that attaches.  This
163:               // can be useful for debugging or for providing generic charging functionality.
164:               #define ALLOW_GLOBAL_VID_AND_PID
165:               
166:               // If we allow multiple control transactions during a frame and a NAK is
167:               // generated, we don't get TRNIF.  So we will allow only one control transaction
168:               // per frame.
169:               #define ONE_CONTROL_TRANSACTION_PER_FRAME
170:               
171:               // This definition allow Bulk transfers to take all of the remaining bandwidth
172:               // of a frame.
173:               #define ALLOW_MULTIPLE_BULK_TRANSACTIONS_PER_FRAME
174:               
175:               // If this is defined, then we will repeat a NAK'd request in the same frame.
176:               // Otherwise, we will wait until the next frame to repeat the request.  Some
177:               // mass storage devices require the host to wait until the next frame to
178:               // repeat the request.
179:               //#define ALLOW_MULTIPLE_NAKS_PER_FRAME
180:               
181:               //#define USE_MANUAL_DETACH_DETECT
182:               
183:               // The USB specification states that transactions should be tried three times
184:               // if there is a bus error.  We will allow that number to be configurable. The
185:               // maximum value is 31.
186:               #define USB_TRANSACTION_RETRY_ATTEMPTS  20
187:               
188:               //******************************************************************************
189:               //******************************************************************************
190:               // Section: Host Global Variables
191:               //******************************************************************************
192:               //******************************************************************************
193:               
194:               // When using the PIC32, ping pong mode must be set to FULL.
195:               #if defined (__PIC32MX__)
196:                   #if (USB_PING_PONG_MODE != USB_PING_PONG__FULL_PING_PONG)
197:                       #undef USB_PING_PONG_MODE
198:                       #define USB_PING_PONG_MODE USB_PING_PONG__FULL_PING_PONG
199:                   #endif
200:               #endif
201:               
202:               #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
203:                   #if !defined(USB_SUPPORT_OTG) && !defined(USB_SUPPORT_DEVICE)
204:                   static BDT_ENTRY __attribute__ ((aligned(512)))    BDT[2];
205:                   #endif
206:                   #define BDT_IN                                  (&BDT[0])           // EP0 IN Buffer Descriptor
207:                   #define BDT_OUT                                 (&BDT[1])           // EP0 OUT Buffer Descriptor
208:               #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
209:                   #if !defined(USB_SUPPORT_OTG) && !defined(USB_SUPPORT_DEVICE)
210:                   static BDT_ENTRY __attribute__ ((aligned(512)))    BDT[3];
211:                   #endif
212:                   #define BDT_IN                                  (&BDT[0])           // EP0 IN Buffer Descriptor
213:                   #define BDT_OUT                                 (&BDT[1])           // EP0 OUT Even Buffer Descriptor
214:                   #define BDT_OUT_ODD                             (&BDT[2])           // EP0 OUT Odd Buffer Descriptor
215:               #elif (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
216:                   #if !defined(USB_SUPPORT_OTG) && !defined(USB_SUPPORT_DEVICE)
217:                   static BDT_ENTRY __attribute__ ((aligned(512)))    BDT[4];
218:                   #endif
219:                   #define BDT_IN                                  (&BDT[0])           // EP0 IN Even Buffer Descriptor
220:                   #define BDT_IN_ODD                              (&BDT[1])           // EP0 IN Odd Buffer Descriptor
221:                   #define BDT_OUT                                 (&BDT[2])           // EP0 OUT Even Buffer Descriptor
222:                   #define BDT_OUT_ODD                             (&BDT[3])           // EP0 OUT Odd Buffer Descriptor
223:               #endif
224:               
225:               #if defined(USB_SUPPORT_OTG) || defined(USB_SUPPORT_DEVICE)
226:                   extern BDT_ENTRY BDT[] __attribute__ ((aligned (512)));
227:               #endif
228:               
229:               // These should all be moved into the USB_DEVICE_INFO structure.
230:               static BYTE                          countConfigurations;                        // Count the Configuration Descriptors read during enumeration.
231:               static BYTE                          numCommandTries;                            // The number of times the current command has been tried.
232:               static BYTE                          numEnumerationTries;                        // The number of times enumeration has been attempted on the attached device.
233:               static volatile WORD                 numTimerInterrupts;                         // The number of milliseconds elapsed during the current waiting period.
234:               static volatile USB_ENDPOINT_INFO   *pCurrentEndpoint;                           // Pointer to the endpoint currently performing a transfer.
235:               BYTE                                *pCurrentConfigurationDescriptor    = NULL;  // Pointer to the current configuration descriptor of the attached device.
236:               BYTE                                *pDeviceDescriptor                  = NULL;  // Pointer to the Device Descriptor of the attached device.
237:               static BYTE                         *pEP0Data                           = NULL;  // A data buffer for use by EP0.
238:               static volatile WORD                 usbHostState;                               // State machine state of the attached device.
239:               volatile WORD                 usbOverrideHostState;                       // Next state machine state, when set by interrupt processing.
240:               #ifdef ENABLE_STATE_TRACE   // Debug trace support
241:                   static WORD prevHostState;
242:               #endif
243:               
244:               
245:               static USB_BUS_INFO                  usbBusInfo;                                 // Information about the USB bus.
246:               static USB_DEVICE_INFO               usbDeviceInfo;                              // A collection of information about the attached device.
247:               #if defined( USB_ENABLE_TRANSFER_EVENT )
248:                   static USB_EVENT_QUEUE           usbEventQueue;                              // Queue of USB events used to synchronize ISR to main tasks loop.
249:               #endif
250:               static USB_ROOT_HUB_INFO             usbRootHubInfo;                             // Information about a specific port.
251:               
252:               static volatile WORD msec_count = 0;                                             // The current millisecond count.
253:               
254:               USB_DEVICE_INFO* USBHostGetDeviceInfo() { return &usbDeviceInfo; }
255:               
256:               extern const char* accessoryDescs[6];
257:               static int currentDesc;
258:               
259:               
260:               // *****************************************************************************
261:               // *****************************************************************************
262:               // Section: Application Callable Functions
263:               // *****************************************************************************
264:               // *****************************************************************************
265:               
266:               /****************************************************************************
267:                 Function:
268:                   BYTE USBHostClearEndpointErrors( BYTE deviceAddress, BYTE endpoint )
269:               
270:                 Summary:
271:                   This function clears an endpoint's internal error condition.
272:               
273:                 Description:
274:                   This function is called to clear the internal error condition of a device's
275:                   endpoint.  It should be called after the application has dealt with the
276:                   error condition on the device.  This routine clears internal status only;
277:                   it does not interact with the device.
278:               
279:                 Precondition:
280:                   None
281:               
282:                 Parameters:
283:                   BYTE deviceAddress  - Address of device
284:                   BYTE endpoint       - Endpoint to clear error condition
285:               
286:                 Return Values:
287:                   USB_SUCCESS             - Errors cleared
288:                   USB_UNKNOWN_DEVICE      - Device not found
289:                   USB_ENDPOINT_NOT_FOUND  - Specified endpoint not found
290:               
291:                 Remarks:
292:                   None
293:                 ***************************************************************************/
294:               
295:               BYTE USBHostClearEndpointErrors( BYTE deviceAddress, BYTE endpoint )
296:               {
297:                   USB_ENDPOINT_INFO *ep;
298:               
299:                   // Find the required device
300:                   if (deviceAddress != usbDeviceInfo.deviceAddress)
0036D6  200062     MOV #0x6, W2
0036D8  21EBF1     MOV #0x1EBF, W1
0036DA  504F91     SUB.B W0, [W1], [W15]
0036DC  3A000E     BRA NZ, 0x36FA
301:                   {
302:                       return USB_UNKNOWN_DEVICE;
303:                   }
304:               
305:                   ep = _USB_FindEndpoint( endpoint );
0036DE  784003     MOV.B W3, W0
0036E0  0236A4     CALL _USB_FindEndpoint
0036E2  000000     NOP
0036E4  780080     MOV W0, W1
306:               
307:                   if (ep != NULL)
0036E6  200142     MOV #0x14, W2
0036E8  E00000     CP0 W0
0036EA  320007     BRA Z, 0x36FA
308:                   {
309:                       ep->status.bfStalled    = 0;
0036EC  904020     MOV.B [W0+2], W0
0036EE  A15400     BCLR.B W0, #5
0036F0  9840A0     MOV.B W0, [W1+2]
310:                       ep->status.bfError      = 0;
0036F2  904021     MOV.B [W1+2], W0
0036F4  A16400     BCLR.B W0, #6
0036F6  9840A0     MOV.B W0, [W1+2]
0036F8  EB0100     CLR W2
311:               
312:                       return USB_SUCCESS;
313:                   }
314:                   return USB_ENDPOINT_NOT_FOUND;
315:               }
316:               
317:               
318:               /****************************************************************************
319:                 Function:
320:                   BOOL    USBHostDeviceSpecificClientDriver( BYTE deviceAddress )
321:               
322:                 Summary:
323:                   This function indicates if the specified device has explicit client
324:                   driver support specified in the TPL.
325:               
326:                 Description:
327:                   This function indicates if the specified device has explicit client
328:                   driver support specified in the TPL.  It is used in client drivers'
329:                   USB_CLIENT_INIT routines to indicate that the client driver should be
330:                   used even though the class, subclass, and protocol values may not match
331:                   those normally required by the class.  For example, some printing devices
332:                   do not fulfill all of the requirements of the printer class, so their
333:                   class, subclass, and protocol fields indicate a custom driver rather than
334:                   the printer class.  But the printer class driver can still be used, with
335:                   minor limitations.
336:               
337:                 Precondition:
338:                   None
339:               
340:                 Parameters:
341:                   BYTE deviceAddress  - Address of device
342:               
343:                 Return Values:
344:                   TRUE    - This device is listed in the TPL by VID andPID, and has explicit
345:                               client driver support.
346:                   FALSE   - This device is not listed in the TPL by VID and PID.
347:               
348:                 Remarks:
349:                   This function is used so client drivers can allow certain
350:                   devices to enumerate.  For example, some printer devices indicate a custom
351:                   class rather than the printer class, even though the device has only minor
352:                   limitations from the full printer class.   The printer client driver will
353:                   fail to initialize the device if it does not indicate printer class support
354:                   in its interface descriptor.  The printer client driver could allow any
355:                   device with an interface that matches the printer class endpoint
356:                   configuration, but both printer and mass storage devices utilize one bulk
357:                   IN and one bulk OUT endpoint.  So a mass storage device would be
358:                   erroneously initialized as a printer device.  This function allows a
359:                   client driver to know that the client driver support was specified
360:                   explicitly in the TPL, so for this particular device only, the class,
361:                   subclass, and protocol fields can be safely ignored.
362:                 ***************************************************************************/
363:               
364:               BOOL    USBHostDeviceSpecificClientDriver( BYTE deviceAddress )
365:               {
366:                   return usbDeviceInfo.flags.bfUseDeviceClientDriver;
0038F8  21ECC0     MOV #0x1ECC, W0
0038FA  FB8010     ZE [W0], W0
0038FC  DE0046     LSR W0, #6, W0
0038FE  600061     AND W0, #0x1, W0
367:               }
368:               
369:               
370:               /****************************************************************************
371:                 Function:
372:                   BYTE USBHostDeviceStatus( BYTE deviceAddress )
373:               
374:                 Summary:
375:                   This function returns the current status of a device.
376:               
377:                 Description:
378:                   This function returns the current status of a device.  If the device is
379:                   in a holding state due to an error, the error is returned.
380:               
381:                 Preconditions:
382:                   None
383:               
384:                 Parameters:
385:                   BYTE deviceAddress  - Device address
386:               
387:                 Return Values:
388:                   USB_DEVICE_ATTACHED                 - Device is attached and running
389:                   USB_DEVICE_DETACHED                 - No device is attached
390:                   USB_DEVICE_ENUMERATING              - Device is enumerating
391:                   USB_HOLDING_OUT_OF_MEMORY           - Not enough heap space available
392:                   USB_HOLDING_UNSUPPORTED_DEVICE      - Invalid configuration or
393:                                                           unsupported class
394:                   USB_HOLDING_UNSUPPORTED_HUB         - Hubs are not supported
395:                   USB_HOLDING_INVALID_CONFIGURATION   - Invalid configuration requested
396:                   USB_HOLDING_PROCESSING_CAPACITY     - Processing requirement excessive
397:                   USB_HOLDING_POWER_REQUIREMENT       - Power requirement excessive
398:                   USB_HOLDING_CLIENT_INIT_ERROR       - Client driver failed to initialize
399:                   USB_DEVICE_SUSPENDED                - Device is suspended
400:                   Other                               - Device is holding in an error
401:                                                           state. The return value
402:                                                           indicates the error.
403:               
404:                 Remarks:
405:                   None
406:                 ***************************************************************************/
407:               
408:               BYTE USBHostDeviceStatus( BYTE deviceAddress )
409:               {
410:                   if ((usbHostState & STATE_MASK) == STATE_DETACHED)
003498  80F690     MOV usbHostState, W0
00349A  20F003     MOV #0xF00, W3
00349C  600003     AND W0, W3, W0
00349E  200312     MOV #0x31, W2
0034A0  320014     BRA Z, 0x34CA
411:                   {
412:                       return USB_DEVICE_DETACHED;
413:                   }
414:               
415:                   if ((usbHostState & STATE_MASK) == STATE_RUNNING)
0034A2  80F690     MOV usbHostState, W0
0034A4  600003     AND W0, W3, W0
0034A6  204001     MOV #0x400, W1
0034A8  500F81     SUB W0, W1, [W15]
0034AA  3A0007     BRA NZ, 0x34BA
416:                   {
417:                       if ((usbHostState & SUBSTATE_MASK) == SUBSTATE_SUSPEND_AND_RESUME)
0034AC  80F690     MOV usbHostState, W0
0034AE  B20F00     AND #0xF0, W0
0034B0  410169     ADD W2, #0x9, W2
0034B2  500FF0     SUB W0, #0x10, [W15]
0034B4  32000A     BRA Z, 0x34CA
0034B6  51016A     SUB W2, #0xA, W2
0034B8  370008     BRA 0x34CA
418:                       {
419:                           return USB_DEVICE_SUSPENDED;
420:                       }
421:                       else
422:                       {
423:                           return USB_DEVICE_ATTACHED;
424:                       }
425:                   }
426:               
427:                   if ((usbHostState & STATE_MASK) == STATE_HOLDING)
0034BA  80F690     MOV usbHostState, W0
0034BC  600003     AND W0, W3, W0
0034BE  200322     MOV #0x32, W2
0034C0  205001     MOV #0x500, W1
0034C2  500F81     SUB W0, W1, [W15]
0034C4  3A0002     BRA NZ, 0x34CA
428:                   {
429:                       return usbDeviceInfo.errorCode;
0034C6  21EC00     MOV #0x1EC0, W0
0034C8  FB8110     ZE [W0], W2
430:                   }
431:               
432:                   return USB_DEVICE_ENUMERATING;
433:               }
434:               
435:               /****************************************************************************
436:                 Function:
437:                   BOOL USBHostInit(  unsigned long flags  )
438:               
439:                 Summary:
440:                   This function initializes the variables of the USB host stack.
441:               
442:                 Description:
443:                   This function initializes the variables of the USB host stack.  It does
444:                   not initialize the hardware.  The peripheral itself is initialized in one
445:                   of the state machine states.  Therefore, USBHostTasks() should be called
446:                   soon after this function.
447:               
448:                 Precondition:
449:                   None
450:               
451:                 Parameters:
452:                   flags - reserved
453:               
454:                 Return Values:
455:                   TRUE  - Initialization successful
456:                   FALSE - Could not allocate memory.
457:               
458:                 Remarks:
459:                   If the endpoint list is empty, an entry is created in the endpoint list
460:                   for EP0.  If the list is not empty, free all allocated memory other than
461:                   the EP0 node.  This allows the routine to be called multiple times by the
462:                   application.
463:                 ***************************************************************************/
464:               
465:               BOOL USBHostInit(  unsigned long flags  )
466:               {
467:                   // Allocate space for Endpoint 0.  We will initialize it in the state machine,
468:                   // so we can reinitialize when another device connects.  If the Endpoint 0
469:                   // node already exists, free all other allocated memory.
470:                   if (usbDeviceInfo.pEndpoint0 == NULL)
0034CE  21ECA0     MOV #0x1ECA, W0
0034D0  E00010     CP0 [W0]
0034D2  3A0008     BRA NZ, 0x34E4
471:                   {
472:                       if ((usbDeviceInfo.pEndpoint0 = (USB_ENDPOINT_INFO*)USB_MALLOC( sizeof(USB_ENDPOINT_INFO) )) == NULL)
0034D4  200220     MOV #0x22, W0
0034D6  02038C     CALL malloc
0034D8  000000     NOP
0034DA  88F650     MOV W0, 0x1ECA
0034DC  E00000     CP0 W0
0034DE  320011     BRA Z, 0x3502
473:                       {
474:                           #ifdef DEBUG_MODE
475:                               UART2PrintString( "HOST: Cannot allocate for endpoint 0.\r\n" );
476:                           #endif
477:                           //return USB_MEMORY_ALLOCATION_ERROR;
478:                           return FALSE;
479:                       }
480:                       usbDeviceInfo.pEndpoint0->next = NULL;
0034E0  EB0800     CLR [W0]
0034E2  370002     BRA 0x34E8
481:                   }
482:                   else
483:                   {
484:                       _USB_FreeMemory();
0034E4  023422     CALL _USB_FreeMemory
0034E6  000000     NOP
485:                   }
486:               
487:                   // Initialize other variables.
488:                   pCurrentEndpoint                        = usbDeviceInfo.pEndpoint0;
0034E8  80F650     MOV 0x1ECA, W0
0034EA  88F6A0     MOV W0, pCurrentEndpoint
489:                   usbHostState                            = STATE_DETACHED;
0034EC  EB0080     CLR W1
0034EE  88F691     MOV W1, usbHostState
490:                   usbOverrideHostState                    = NO_STATE;
0034F0  EB8000     SETM W0
0034F2  88F5B0     MOV W0, usbOverrideHostState
491:                   usbDeviceInfo.deviceAddressAndSpeed     = 0;
0034F4  21EBE0     MOV #0x1EBE, W0
0034F6  784801     MOV.B W1, [W0]
492:                   usbDeviceInfo.deviceAddress             = 0;
0034F8  21EBF0     MOV #0x1EBF, W0
0034FA  784801     MOV.B W1, [W0]
493:                   usbRootHubInfo.flags.bPowerGoodPort0    = 1;
0034FC  21EB80     MOV #0x1EB8, W0
0034FE  A00410     BSET.B [W0], #0
003500  200010     MOV #0x1, W0
494:               
495:                   // Initialize event queue
496:                   #if defined( USB_ENABLE_TRANSFER_EVENT )
497:                       StructQueueInit(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
498:                   #endif
499:               
500:                   return TRUE;
501:               }
502:               
503:               
504:               /****************************************************************************
505:                 Function:
506:                   BOOL USBHostIsochronousBuffersCreate( ISOCHRONOUS_DATA * isocData,
507:                           BYTE numberOfBuffers, WORD bufferSize )
508:               
509:                 Description:
510:                   This function initializes the isochronous data buffer information and
511:                   allocates memory for each buffer.  This function will not allocate memory
512:                   if the buffer pointer is not NULL.
513:               
514:                 Precondition:
515:                   None
516:               
517:                 Parameters:
518:                   None
519:               
520:                 Return Values:
521:                   TRUE    - All buffers are allocated successfully.
522:                   FALSE   - Not enough heap space to allocate all buffers - adjust the
523:                               project to provide more heap space.
524:               
525:                 Remarks:
526:                   This function is available only if USB_SUPPORT_ISOCHRONOUS_TRANSFERS
527:                   is defined in usb_config.h.
528:               ***************************************************************************/
529:               #ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
530:               
531:               BOOL USBHostIsochronousBuffersCreate( ISOCHRONOUS_DATA * isocData, BYTE numberOfBuffers, WORD bufferSize )
532:               {
533:                   BYTE i;
534:                   BYTE j;
535:               
536:                   USBHostIsochronousBuffersReset( isocData, numberOfBuffers );
537:                   for (i=0; i<numberOfBuffers; i++)
538:                   {
539:                       if (isocData->buffers[i].pBuffer == NULL)
540:                       {
541:                           isocData->buffers[i].pBuffer = USB_MALLOC( bufferSize );
542:                           if (isocData->buffers[i].pBuffer == NULL)
543:                           {
544:                               #ifdef DEBUG_MODE
545:                                   UART2PrintString( "HOST:  Not enough memory for isoc buffers.\r\n" );
546:                               #endif
547:                   
548:                               // Release all previous buffers.
549:                               for (j=0; j<i; j++)
550:                               {
551:                                   USB_FREE_AND_CLEAR( isocData->buffers[j].pBuffer );
552:                                   isocData->buffers[j].pBuffer = NULL;
553:                               }
554:                               return FALSE;
555:                           }
556:                       }
557:                   }
558:                   return TRUE;
559:               }
560:               #endif
561:               
562:               /****************************************************************************
563:                 Function:
564:                   void USBHostIsochronousBuffersDestroy( ISOCHRONOUS_DATA * isocData, BYTE numberOfBuffers )
565:               
566:                 Description:
567:                   This function releases all of the memory allocated for the isochronous
568:                   data buffers.  It also resets all other information about the buffers.
569:               
570:                 Precondition:
571:                   None
572:               
573:                 Parameters:
574:                   None
575:               
576:                 Returns:
577:                   None
578:               
579:                 Remarks:
580:                   This function is available only if USB_SUPPORT_ISOCHRONOUS_TRANSFERS
581:                   is defined in usb_config.h.
582:               ***************************************************************************/
583:               #ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
584:               
585:               void USBHostIsochronousBuffersDestroy( ISOCHRONOUS_DATA * isocData, BYTE numberOfBuffers )
586:               {
587:                   BYTE i;
588:               
589:                   USBHostIsochronousBuffersReset( isocData, numberOfBuffers );
590:                   for (i=0; i<numberOfBuffers; i++)
591:                   {
592:                       if (isocData->buffers[i].pBuffer != NULL)
593:                       {
594:                           USB_FREE_AND_CLEAR( isocData->buffers[i].pBuffer );
595:                           isocData->buffers[i].pBuffer = NULL;
596:                       }
597:                   }
598:               }
599:               #endif
600:               
601:               
602:               /****************************************************************************
603:                 Function:
604:                   void USBHostIsochronousBuffersReset( ISOCHRONOUS_DATA * isocData, BYTE numberOfBuffers )
605:               
606:                 Description:
607:                   This function resets all the isochronous data buffers.  It does not do
608:                   anything with the space allocated for the buffers.
609:               
610:                 Precondition:
611:                   None
612:               
613:                 Parameters:
614:                   None
615:               
616:                 Returns:
617:                   None
618:               
619:                 Remarks:
620:                   This function is available only if USB_SUPPORT_ISOCHRONOUS_TRANSFERS
621:                   is defined in usb_config.h.
622:               ***************************************************************************/
623:               #ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
624:               
625:               void USBHostIsochronousBuffersReset( ISOCHRONOUS_DATA * isocData, BYTE numberOfBuffers )
626:               {
627:                   BYTE    i;
628:               
629:                   for (i=0; i<numberOfBuffers; i++)
630:                   {
631:                       isocData->buffers[i].dataLength        = 0;
632:                       isocData->buffers[i].bfDataLengthValid = 0;
633:                   }
634:               
635:                   isocData->totalBuffers         = numberOfBuffers;
636:                   isocData->currentBufferUser    = 0;
637:                   isocData->currentBufferUSB     = 0;
638:                   isocData->pDataUser            = NULL;
639:               }
640:               #endif
641:               
642:               /****************************************************************************
643:                 Function:
644:                   BYTE USBHostIssueDeviceRequest( BYTE deviceAddress, BYTE bmRequestType,
645:                                   BYTE bRequest, WORD wValue, WORD wIndex, WORD wLength,
646:                                   BYTE *data, BYTE dataDirection, BYTE clientDriverID )
647:               
648:                 Summary:
649:                   This function sends a standard device request to the attached device.
650:               
651:                 Description:
652:                   This function sends a standard device request to the attached device.
653:                   The user must pass in the parameters of the device request.  If there is
654:                   input or output data associated with the request, a pointer to the data
655:                   must be provided.  The direction of the associated data (input or output)
656:                   must also be indicated.
657:               
658:                   This function does no special processing in regards to the request except
659:                   for three requests.  If SET INTERFACE is sent, then DTS is reset for all
660:                   endpoints.  If CLEAR FEATURE (ENDPOINT HALT) is sent, then DTS is reset
661:                   for that endpoint.
662:               
663:                   If the application wishes to change the device configuration, it should
664:                   use the function USBHostSetDeviceConfiguration() rather than this function
665:                   with the SET CONFIGURATION request, since endpoint definitions may
666:                   change.
667:               
668:                 Precondition:
669:                   The host state machine should be in the running state, and no reads or
670:                   writes to EP0 should be in progress.
671:               
672:                 Parameters:
673:                   BYTE deviceAddress  - Device address
674:                   BYTE bmRequestType  - The request type as defined by the USB
675:                                           specification.
676:                   BYTE bRequest       - The request as defined by the USB specification.
677:                   WORD wValue         - The value for the request as defined by the USB
678:                                           specification.
679:                   WORD wIndex         - The index for the request as defined by the USB
680:                                           specification.
681:                   WORD wLength        - The data length for the request as defined by the
682:                                           USB specification.
683:                   BYTE *data          - Pointer to the data for the request.
684:                   BYTE dataDirection  - USB_DEVICE_REQUEST_SET or USB_DEVICE_REQUEST_GET
685:                   BYTE clientDriverID - Client driver to send the event to.
686:               
687:                 Return Values:
688:                   USB_SUCCESS                 - Request processing started
689:                   USB_UNKNOWN_DEVICE          - Device not found
690:                   USB_INVALID_STATE           - The host must be in a normal running state
691:                                                   to do this request
692:                   USB_ENDPOINT_BUSY           - A read or write is already in progress
693:                   USB_ILLEGAL_REQUEST         - SET CONFIGURATION cannot be performed with
694:                                                   this function.
695:               
696:                 Remarks:
697:                   DTS reset is done before the command is issued.
698:                 ***************************************************************************/
699:               
700:               BYTE USBHostIssueDeviceRequest( BYTE deviceAddress, BYTE bmRequestType, BYTE bRequest,
701:                           WORD wValue, WORD wIndex, WORD wLength, BYTE *data, BYTE dataDirection,
702:                           BYTE clientDriverID )
703:               {
704:                   // Find the required device
705:                   if (deviceAddress != usbDeviceInfo.deviceAddress)
002A36  200062     MOV #0x6, W2
002A38  21EBF1     MOV #0x1EBF, W1
002A3A  504F91     SUB.B W0, [W1], [W15]
002A3C  3A0057     BRA NZ, 0x2AEC
706:                   {
707:                       return USB_UNKNOWN_DEVICE;
708:                   }
709:               
710:                   // If we are not in a normal user running state, we cannot do this.
711:                   if ((usbHostState & STATE_MASK) != STATE_RUNNING)
002A3E  80F690     MOV usbHostState, W0
002A40  20F001     MOV #0xF00, W1
002A42  600001     AND W0, W1, W0
002A44  200012     MOV #0x1, W2
002A46  204001     MOV #0x400, W1
002A48  500F81     SUB W0, W1, [W15]
002A4A  3A0050     BRA NZ, 0x2AEC
712:                   {
713:                       return USB_INVALID_STATE;
714:                   }
715:               
716:                   // Make sure no other reads or writes on EP0 are in progress.
717:                   if (!usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
002A4C  80F650     MOV 0x1ECA, W0
002A4E  904030     MOV.B [W0+3], W0
002A50  200102     MOV #0x10, W2
002A52  A31800     BTST.Z W0, #1
002A54  32004B     BRA Z, 0x2AEC
718:                   {
719:                       return USB_ENDPOINT_BUSY;
720:                   }
721:               
722:                   // We can't do a SET CONFIGURATION here.  Must use USBHostSetDeviceConfiguration().
723:                   // ***** Some USB classes need to be able to do this, so we'll remove
724:                   // the constraint.
725:               //    if (bRequest == USB_REQUEST_SET_CONFIGURATION)
726:               //    {
727:               //        return USB_ILLEGAL_REQUEST;
728:               //    }
729:               
730:                   // If the user is doing a SET INTERFACE, we must reset DATA0 for all endpoints.
731:                   if (bRequest == USB_REQUEST_SET_INTERFACE)
002A56  55CFEB     SUB.B W11, #0xB, [W15]
002A58  3A001F     BRA NZ, 0x2A98
732:                   {
733:                       USB_ENDPOINT_INFO           *pEndpoint;
734:                       USB_INTERFACE_INFO          *pInterface;
735:                       USB_INTERFACE_SETTING_INFO  *pSetting;
736:               
737:                       // Make sure there are no transfers currently in progress on the current
738:                       // interface setting.
739:                       pInterface = usbDeviceInfo.pInterfaceList;
002A5A  80F642     MOV 0x1EC8, W2
002A5C  370001     BRA 0x2A60
740:                       while (pInterface && (pInterface->interface != wIndex))
002A60  E00002     CP0 W2
002A62  320043     BRA Z, 0x2AEA
002A64  904062     MOV.B [W2+6], W0
002A66  FB8000     ZE W0, W0
002A68  500F89     SUB W0, W9, [W15]
002A6A  3AFFF9     BRA NZ, 0x2A5E
741:                       {
742:                           pInterface = pInterface->next;
002A5E  780112     MOV [W2], W2
743:                       }
744:                       if ((pInterface == NULL) || (pInterface->pCurrentSetting == NULL))
002A6C  900022     MOV [W2+4], W0
002A6E  E00000     CP0 W0
002A70  32003C     BRA Z, 0x2AEA
745:                       {
746:                           // The specified interface was not found.
747:                           return USB_ILLEGAL_REQUEST;
748:                       }
749:                       pEndpoint = pInterface->pCurrentSetting->pEndpointList;
002A72  9000A0     MOV [W0+4], W1
002A74  370004     BRA 0x2A7E
750:                       while (pEndpoint)
002A7E  E00001     CP0 W1
002A80  3AFFFA     BRA NZ, 0x2A76
751:                       {
752:                           if (!pEndpoint->status.bfTransferComplete)
002A76  904031     MOV.B [W1+3], W0
002A78  A31800     BTST.Z W0, #1
002A7A  320037     BRA Z, 0x2AEA
753:                           {
754:                               // An endpoint on this setting is still transferring data.
755:                               return USB_ILLEGAL_REQUEST;
756:                           }
757:                           pEndpoint = pEndpoint->next;
002A7C  780091     MOV [W1], W1
758:                       }
759:               
760:                       // Make sure the new setting is valid.
761:                       pSetting = pInterface->pInterfaceSettings;
002A82  900092     MOV [W2+2], W1
002A84  370001     BRA 0x2A88
762:                       while( pSetting && (pSetting->interfaceAltSetting != wValue))
002A88  E00001     CP0 W1
002A8A  32002F     BRA Z, 0x2AEA
002A8C  904021     MOV.B [W1+2], W0
002A8E  FB8000     ZE W0, W0
002A90  500F88     SUB W0, W8, [W15]
002A92  3AFFF9     BRA NZ, 0x2A86
763:                       {
764:                           pSetting = pSetting->next;
002A86  780091     MOV [W1], W1
765:                       }
766:                       if (pSetting == NULL)
767:                       {
768:                           return USB_ILLEGAL_REQUEST;
769:                       }
770:               
771:                       // Set the pointer to the new setting.
772:                       pInterface->pCurrentSetting = pSetting;
002A94  980121     MOV W1, [W2+4]
002A96  370009     BRA 0x2AAA
773:                   }
774:               
775:                   // If the user is doing a CLEAR FEATURE(ENDPOINT_HALT), we must reset DATA0 for that endpoint.
776:                   if ((bRequest == USB_REQUEST_CLEAR_FEATURE) && (wValue == USB_FEATURE_ENDPOINT_HALT))
002A98  55CFE1     SUB.B W11, #0x1, [W15]
002A9A  3A0007     BRA NZ, 0x2AAA
002A9C  E00003     CP0 W3
002A9E  3A0005     BRA NZ, 0x2AAA
777:                   {
778:                       switch(bmRequestType)
002AA0  564FE2     SUB.B W12, #0x2, [W15]
002AA2  3E0003     BRA GTU, 0x2AAA
779:                       {
780:                           case 0x00:
781:                           case 0x01:
782:                           case 0x02:
783:                               _USB_ResetDATA0( (BYTE)wIndex );
002AA4  784004     MOV.B W4, W0
002AA6  0233AA     CALL _USB_ResetDATA0
002AA8  000000     NOP
784:                               break;
785:                           default:
786:                               break;
787:                       }
788:                   }
789:               
790:                   // Set up the control packet.
791:                   pEP0Data[0] = bmRequestType;
002AAA  80F591     MOV pEP0Data, W1
002AAC  78488C     MOV.B W12, [W1]
792:                   pEP0Data[1] = bRequest;
002AAE  98409B     MOV.B W11, [W1+1]
793:                   pEP0Data[2] = wValue & 0xFF;
002AB0  9840A8     MOV.B W8, [W1+2]
794:                   pEP0Data[3] = (wValue >> 8) & 0xFF;
002AB2  DE4048     LSR W8, #8, W0
002AB4  9840B0     MOV.B W0, [W1+3]
795:                   pEP0Data[4] = wIndex & 0xFF;
002AB6  9840C9     MOV.B W9, [W1+4]
796:                   pEP0Data[5] = (wIndex >> 8) & 0xFF;
002AB8  DE4848     LSR W9, #8, W0
002ABA  9840D0     MOV.B W0, [W1+5]
797:                   pEP0Data[6] = wLength & 0xFF;
002ABC  9840EA     MOV.B W10, [W1+6]
798:                   pEP0Data[7] = (wLength >> 8) & 0xFF;
002ABE  DE5048     LSR W10, #8, W0
002AC0  9840F0     MOV.B W0, [W1+7]
799:               
800:                   // Set up the client driver for the event.
801:                   usbDeviceInfo.pEndpoint0->clientDriver = clientDriverID;
002AC2  80F650     MOV 0x1ECA, W0
002AC4  97E92F     MOV.B [W15-22], W2
002AC6  985812     MOV.B W2, [W0+25]
802:               
803:                   if (dataDirection == USB_DEVICE_REQUEST_SET)
002AC8  E0040E     CP0.B W14
002ACA  3A0007     BRA NZ, 0x2ADA
804:                   {
805:                       // We are doing a SET command that requires data be sent.
806:                       _USB_InitControlWrite( usbDeviceInfo.pEndpoint0, pEP0Data,8, data, wLength );
002ACC  78020A     MOV W10, W4
002ACE  78018D     MOV W13, W3
002AD0  200082     MOV #0x8, W2
002AD2  80F650     MOV 0x1ECA, W0
002AD4  0231F4     CALL _USB_InitControlWrite
002AD6  000000     NOP
002AD8  370006     BRA 0x2AE6
807:                   }
808:                   else
809:                   {
810:                       // We are doing a GET request.
811:                       _USB_InitControlRead( usbDeviceInfo.pEndpoint0, pEP0Data, 8, data, wLength );
002ADA  78020A     MOV W10, W4
002ADC  78018D     MOV W13, W3
002ADE  200082     MOV #0x8, W2
002AE0  80F650     MOV 0x1ECA, W0
002AE2  0232E4     CALL _USB_InitControlRead
002AE4  000000     NOP
002AE6  EB0100     CLR W2
002AE8  370001     BRA 0x2AEC
002AEA  200032     MOV #0x3, W2
812:                   }
813:               
814:                   return USB_SUCCESS;
815:               }
816:               
817:               /****************************************************************************
818:                 Function:
819:                   BYTE USBHostRead( BYTE deviceAddress, BYTE endpoint, BYTE *pData,
820:                                       DWORD size )
821:                 Summary:
822:                   This function initiates a read from the attached device.
823:               
824:                 Description:
825:                   This function initiates a read from the attached device.
826:               
827:                   If the endpoint is isochronous, special conditions apply.  The pData and
828:                   size parameters have slightly different meanings, since multiple buffers
829:                   are required.  Once started, an isochronous transfer will continue with
830:                   no upper layer intervention until USBHostTerminateTransfer() is called.
831:                   The ISOCHRONOUS_DATA_BUFFERS structure should not be manipulated until
832:                   the transfer is terminated.
833:               
834:                   To clarify parameter usage and to simplify casting, use the macro
835:                   USBHostReadIsochronous() when reading from an isochronous endpoint.
836:               
837:                 Precondition:
838:                   None
839:               
840:                 Parameters:
841:                   BYTE deviceAddress  - Device address
842:                   BYTE endpoint       - Endpoint number
843:                   BYTE *pData         - Pointer to where to store the data. If the endpoint
844:                                           is isochronous, this points to an
845:                                           ISOCHRONOUS_DATA_BUFFERS structure, with multiple
846:                                           data buffer pointers.
847:                   DWORD size          - Number of data bytes to read. If the endpoint is
848:                                           isochronous, this is the number of data buffer
849:                                           pointers pointed to by pData.
850:               
851:                 Return Values:
852:                   USB_SUCCESS                     - Read started successfully.
853:                   USB_UNKNOWN_DEVICE              - Device with the specified address not found.
854:                   USB_INVALID_STATE               - We are not in a normal running state.
855:                   USB_ENDPOINT_ILLEGAL_TYPE       - Must use USBHostControlRead to read
856:                                                       from a control endpoint.
857:                   USB_ENDPOINT_ILLEGAL_DIRECTION  - Must read from an IN endpoint.
858:                   USB_ENDPOINT_STALLED            - Endpoint is stalled.  Must be cleared
859:                                                       by the application.
860:                   USB_ENDPOINT_ERROR              - Endpoint has too many errors.  Must be
861:                                                       cleared by the application.
862:                   USB_ENDPOINT_BUSY               - A Read is already in progress.
863:                   USB_ENDPOINT_NOT_FOUND          - Invalid endpoint.
864:               
865:                 Remarks:
866:                   None
867:                 ***************************************************************************/
868:               
869:               BYTE USBHostRead( BYTE deviceAddress, BYTE endpoint, BYTE *pData, DWORD size )
870:               {
871:                   USB_ENDPOINT_INFO *ep;
872:               
873:                   // Find the required device
874:                   if (deviceAddress != usbDeviceInfo.deviceAddress)
002EA2  200062     MOV #0x6, W2
002EA4  21EBF1     MOV #0x1EBF, W1
002EA6  504F91     SUB.B W0, [W1], [W15]
002EA8  3A0028     BRA NZ, 0x2EFA
875:                   {
876:                       return USB_UNKNOWN_DEVICE;
877:                   }
878:               
879:                   // If we are not in a normal user running state, we cannot do this.
880:                   if ((usbHostState & STATE_MASK) != STATE_RUNNING)
002EAA  80F690     MOV usbHostState, W0
002EAC  20F001     MOV #0xF00, W1
002EAE  600001     AND W0, W1, W0
002EB0  200012     MOV #0x1, W2
002EB2  204001     MOV #0x400, W1
002EB4  500F81     SUB W0, W1, [W15]
002EB6  3A0021     BRA NZ, 0x2EFA
881:                   {
882:                       return USB_INVALID_STATE;
883:                   }
884:               
885:                   ep = _USB_FindEndpoint( endpoint );
002EB8  784003     MOV.B W3, W0
002EBA  0236A4     CALL _USB_FindEndpoint
002EBC  000000     NOP
002EBE  780180     MOV W0, W3
886:                   if (ep)
002EC0  200142     MOV #0x14, W2
002EC2  E00000     CP0 W0
002EC4  32001A     BRA Z, 0x2EFA
887:                   {
888:                       if (ep->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_CONTROL)
002EC6  900850     MOV [W0+26], W0
002EC8  B23000     AND #0x300, W0
002ECA  200182     MOV #0x18, W2
002ECC  320016     BRA Z, 0x2EFA
889:                       {
890:                           // Must not be a control endpoint.
891:                           return USB_ENDPOINT_ILLEGAL_TYPE;
892:                       }
893:               
894:                       if (!(ep->bEndpointAddress & 0x80))
002ECE  905823     MOV.B [W3+26], W0
002ED0  200152     MOV #0x15, W2
002ED2  E00400     CP0.B W0
002ED4  3D0012     BRA GE, 0x2EFA
895:                       {
896:                           // Trying to do an IN with an OUT endpoint.
897:                           return USB_ENDPOINT_ILLEGAL_DIRECTION;
898:                       }
899:               
900:                       if (ep->status.bfStalled)
002ED6  904023     MOV.B [W3+2], W0
002ED8  200112     MOV #0x11, W2
002EDA  A35800     BTST.Z W0, #5
002EDC  3A000E     BRA NZ, 0x2EFA
901:                       {
902:                           // The endpoint is stalled.  It must be restarted before a write
903:                           // can be performed.
904:                           return USB_ENDPOINT_STALLED;
905:                       }
906:               
907:                       if (ep->status.bfError)
002EDE  904023     MOV.B [W3+2], W0
002EE0  200122     MOV #0x12, W2
002EE2  A36800     BTST.Z W0, #6
002EE4  3A000A     BRA NZ, 0x2EFA
908:                       {
909:                           // The endpoint has errored.  The error must be cleared before a
910:                           // write can be performed.
911:                           return USB_ENDPOINT_ERROR;
912:                       }
913:               
914:                       if (!ep->status.bfTransferComplete)
002EE6  904033     MOV.B [W3+3], W0
002EE8  200102     MOV #0x10, W2
002EEA  A31800     BTST.Z W0, #1
002EEC  320006     BRA Z, 0x2EFA
915:                       {
916:                           // We are already processing a request for this endpoint.
917:                           return USB_ENDPOINT_BUSY;
918:                       }
919:               
920:                       _USB_InitRead( ep, pData, size );
002EEE  780108     MOV W8, W2
002EF0  78008A     MOV W10, W1
002EF2  780003     MOV W3, W0
002EF4  0230EC     CALL _USB_InitRead
002EF6  000000     NOP
002EF8  EB0100     CLR W2
921:               
922:                       return USB_SUCCESS;
923:                   }
924:                   return USB_ENDPOINT_NOT_FOUND;   // Endpoint not found
925:               }
926:               
927:               /****************************************************************************
928:                 Function:
929:                   BYTE USBHostResetDevice( BYTE deviceAddress )
930:               
931:                 Summary:
932:                   This function resets an attached device.
933:               
934:                 Description:
935:                   This function places the device back in the RESET state, to issue RESET
936:                   signaling.  It can be called only if the state machine is not in the
937:                   DETACHED state.
938:               
939:                 Precondition:
940:                   None
941:               
942:                 Parameters:
943:                   BYTE deviceAddress  - Device address
944:               
945:                 Return Values:
946:                   USB_SUCCESS         - Success
947:                   USB_UNKNOWN_DEVICE  - Device not found
948:                   USB_ILLEGAL_REQUEST - Device cannot RESUME unless it is suspended
949:               
950:                 Remarks:
951:                   In order to do a full clean-up, the state is set back to STATE_DETACHED
952:                   rather than a reset state.  The ATTACH interrupt will automatically be
953:                   triggered when the module is re-enabled, and the proper reset will be
954:                   performed.
955:                 ***************************************************************************/
956:               
957:               BYTE USBHostResetDevice( BYTE deviceAddress )
958:               {
959:                   // Find the required device
960:                   if (deviceAddress != usbDeviceInfo.deviceAddress)
00382A  200062     MOV #0x6, W2
00382C  21EBF1     MOV #0x1EBF, W1
00382E  504F91     SUB.B W0, [W1], [W15]
003830  3A0008     BRA NZ, 0x3842
961:                   {
962:                       return USB_UNKNOWN_DEVICE;
963:                   }
964:               
965:                   if ((usbHostState & STATE_MASK) == STATE_DETACHED)
003832  80F690     MOV usbHostState, W0
003834  20F001     MOV #0xF00, W1
003836  600001     AND W0, W1, W0
003838  200032     MOV #0x3, W2
00383A  320003     BRA Z, 0x3842
966:                   {
967:                       return USB_ILLEGAL_REQUEST;
968:                   }
969:               
970:                   usbHostState = STATE_DETACHED;
00383C  EB0000     CLR W0
00383E  88F690     MOV W0, usbHostState
003840  780100     MOV W0, W2
971:               
972:                   return USB_SUCCESS;
973:               }
974:               
975:               /****************************************************************************
976:                 Function:
977:                   BYTE USBHostResumeDevice( BYTE deviceAddress )
978:               
979:                 Summary:
980:                   This function issues a RESUME to the attached device.
981:               
982:                 Description:
983:                   This function issues a RESUME to the attached device.  It can called only
984:                   if the state machine is in the suspend state.
985:               
986:                 Precondition:
987:                   None
988:               
989:                 Parameters:
990:                   BYTE deviceAddress  - Device address
991:               
992:                 Return Values:
993:                   USB_SUCCESS         - Success
994:                   USB_UNKNOWN_DEVICE  - Device not found
995:                   USB_ILLEGAL_REQUEST - Device cannot RESUME unless it is suspended
996:               
997:                 Remarks:
998:                   None
999:                 ***************************************************************************/
1000:              
1001:              BYTE USBHostResumeDevice( BYTE deviceAddress )
1002:              {
1003:                  // Find the required device
1004:                  if (deviceAddress != usbDeviceInfo.deviceAddress)
0037D0  200062     MOV #0x6, W2
0037D2  21EBF1     MOV #0x1EBF, W1
0037D4  504F91     SUB.B W0, [W1], [W15]
0037D6  3A0009     BRA NZ, 0x37EA
1005:                  {
1006:                      return USB_UNKNOWN_DEVICE;
1007:                  }
1008:              
1009:                  if (usbHostState != (STATE_RUNNING | SUBSTATE_SUSPEND_AND_RESUME | SUBSUBSTATE_SUSPEND))
0037D8  80F691     MOV usbHostState, W1
0037DA  200032     MOV #0x3, W2
0037DC  204100     MOV #0x410, W0
0037DE  508F80     SUB W1, W0, [W15]
0037E0  3A0004     BRA NZ, 0x37EA
1010:                  {
1011:                      return USB_ILLEGAL_REQUEST;
1012:                  }
1013:              
1014:                  // Advance the state machine to issue resume signalling.
1015:                  _USB_SetNextSubSubState();
0037E2  80F690     MOV usbHostState, W0
0037E4  E80000     INC W0, W0
0037E6  88F690     MOV W0, usbHostState
0037E8  EB0100     CLR W2
1016:              
1017:                  return USB_SUCCESS;
1018:              }
1019:              
1020:              /****************************************************************************
1021:                Function:
1022:                  BYTE USBHostSetDeviceConfiguration( BYTE deviceAddress, BYTE configuration )
1023:              
1024:                Summary:
1025:                  This function changes the device's configuration.
1026:              
1027:                Description:
1028:                  This function is used by the application to change the device's
1029:                  Configuration.  This function must be used instead of
1030:                  USBHostIssueDeviceRequest(), because the endpoint definitions may change.
1031:              
1032:                  To see when the reconfiguration is complete, use the USBHostDeviceStatus()
1033:                  function.  If configuration is still in progress, this function will
1034:                  return USB_DEVICE_ENUMERATING.
1035:              
1036:                Precondition:
1037:                  The host state machine should be in the running state, and no reads or
1038:                  writes should be in progress.
1039:              
1040:                Parameters:
1041:                  BYTE deviceAddress  - Device address
1042:                  BYTE configuration  - Index of the new configuration
1043:              
1044:                Return Values:
1045:                  USB_SUCCESS         - Process of changing the configuration was started
1046:                                          successfully.
1047:                  USB_UNKNOWN_DEVICE  - Device not found
1048:                  USB_INVALID_STATE   - This function cannot be called during enumeration
1049:                                          or while performing a device request.
1050:                  USB_BUSY            - No IN or OUT transfers may be in progress.
1051:              
1052:                Example:
1053:                  <code>
1054:                  rc = USBHostSetDeviceConfiguration( attachedDevice, configuration );
1055:                  if (rc)
1056:                  {
1057:                      // Error - cannot set configuration.
1058:                  }
1059:                  else
1060:                  {
1061:                      while (USBHostDeviceStatus( attachedDevice ) == USB_DEVICE_ENUMERATING)
1062:                      {
1063:                          USBHostTasks();
1064:                      }
1065:                  }
1066:                  if (USBHostDeviceStatus( attachedDevice ) != USB_DEVICE_ATTACHED)
1067:                  {
1068:                      // Error - cannot set configuration.
1069:                  }
1070:                  </code>
1071:              
1072:                Remarks:
1073:                  If an invalid configuration is specified, this function cannot return
1074:                  an error.  Instead, the event USB_UNSUPPORTED_DEVICE will the sent to the
1075:                  application layer and the device will be placed in a holding state with a
1076:                  USB_HOLDING_UNSUPPORTED_DEVICE error returned by USBHostDeviceStatus().
1077:                ***************************************************************************/
1078:              
1079:              BYTE USBHostSetDeviceConfiguration( BYTE deviceAddress, BYTE configuration )
1080:              {
1081:                  // Find the required device
1082:                  if (deviceAddress != usbDeviceInfo.deviceAddress)
0033EA  200062     MOV #0x6, W2
0033EC  21EBF1     MOV #0x1EBF, W1
0033EE  504F91     SUB.B W0, [W1], [W15]
0033F0  3A0015     BRA NZ, 0x341C
1083:                  {
1084:                      return USB_UNKNOWN_DEVICE;
1085:                  }
1086:              
1087:                  // If we are not in a normal user running state, we cannot do this.
1088:                  if ((usbHostState & STATE_MASK) != STATE_RUNNING)
0033F2  80F690     MOV usbHostState, W0
0033F4  20F001     MOV #0xF00, W1
0033F6  600001     AND W0, W1, W0
0033F8  200012     MOV #0x1, W2
0033FA  204001     MOV #0x400, W1
0033FC  500F81     SUB W0, W1, [W15]
0033FE  3A000E     BRA NZ, 0x341C
1089:                  {
1090:                      return USB_INVALID_STATE;
1091:                  }
1092:              
1093:                  // Make sure no other reads or writes are in progress.
1094:                  if (_USB_TransferInProgress())
003400  02360E     CALL _USB_TransferInProgress
003402  000000     NOP
003404  780180     MOV W0, W3
003406  200022     MOV #0x2, W2
003408  E00000     CP0 W0
00340A  3A0008     BRA NZ, 0x341C
1095:                  {
1096:                      return USB_BUSY;
1097:                  }
1098:              
1099:                  // Set the new device configuration.
1100:                  usbDeviceInfo.currentConfiguration = configuration;
00340C  21EBC0     MOV #0x1EBC, W0
00340E  784808     MOV.B W8, [W0]
1101:              
1102:                  // We're going to be sending Endpoint 0 commands, so be sure the
1103:                  // client driver indicates the host driver, so we do not send events up
1104:                  // to a client driver.
1105:                  usbDeviceInfo.pEndpoint0->clientDriver = CLIENT_DRIVER_HOST;
003410  EBC080     SETM.B W1
003412  80F650     MOV 0x1ECA, W0
003414  985811     MOV.B W1, [W0+25]
1106:              
1107:                  // Set the state back to configure the device.  This will destroy the
1108:                  // endpoint list and terminate any current transactions.  We already have
1109:                  // the configuration, so we can jump into the Select Configuration state.
1110:                  // If the configuration value is invalid, the state machine will error and
1111:                  // put the device into a holding state.
1112:                  usbHostState = STATE_CONFIGURING | SUBSTATE_SELECT_CONFIGURATION;
003416  203300     MOV #0x330, W0
003418  88F690     MOV W0, usbHostState
00341A  780103     MOV W3, W2
1113:              
1114:                  return USB_SUCCESS;
1115:              }
1116:              
1117:              
1118:              /****************************************************************************
1119:                Function:
1120:                  BYTE USBHostSetNAKTimeout( BYTE deviceAddress, BYTE endpoint, WORD flags,
1121:                              WORD timeoutCount )
1122:              
1123:                Summary:
1124:                  This function specifies NAK timeout capability.
1125:              
1126:                Description:
1127:                  This function is used to set whether or not an endpoint on a device
1128:                  should time out a transaction based on the number of NAKs received, and
1129:                  if so, how many NAKs are allowed before the timeout.
1130:              
1131:                Precondition:
1132:                  None
1133:              
1134:                Parameters:
1135:                  BYTE deviceAddress  - Device address
1136:                  BYTE endpoint       - Endpoint number to configure
1137:                  WORD flags          - Bit 0:
1138:                                          * 0 = disable NAK timeout
1139:                                          * 1 = enable NAK timeout
1140:                  WORD timeoutCount   - Number of NAKs allowed before a timeout
1141:              
1142:                Return Values:
1143:                  USB_SUCCESS             - NAK timeout was configured successfully.
1144:                  USB_UNKNOWN_DEVICE      - Device not found.
1145:                  USB_ENDPOINT_NOT_FOUND  - The specified endpoint was not found.
1146:              
1147:                Remarks:
1148:                  None
1149:                ***************************************************************************/
1150:              
1151:              BYTE USBHostSetNAKTimeout( BYTE deviceAddress, BYTE endpoint, WORD flags, WORD timeoutCount )
1152:              {
1153:                  USB_ENDPOINT_INFO *ep;
1154:              
1155:                  // Find the required device
1156:                  if (deviceAddress != usbDeviceInfo.deviceAddress)
003646  200062     MOV #0x6, W2
003648  21EBF1     MOV #0x1EBF, W1
00364A  504F91     SUB.B W0, [W1], [W15]
00364C  3A000F     BRA NZ, 0x366C
1157:                  {
1158:                      return USB_UNKNOWN_DEVICE;
1159:                  }
1160:              
1161:                  ep = _USB_FindEndpoint( endpoint );
00364E  784004     MOV.B W4, W0
003650  0236A4     CALL _USB_FindEndpoint
003652  000000     NOP
003654  780180     MOV W0, W3
1162:                  if (ep)
003656  200142     MOV #0x14, W2
003658  E00000     CP0 W0
00365A  320008     BRA Z, 0x366C
1163:                  {
1164:                      ep->status.bfNAKTimeoutEnabled  = flags & 0x01;
00365C  6440E1     AND.B W8, #0x1, W1
00365E  DD08C5     SL W1, #5, W1
003660  904030     MOV.B [W0+3], W0
003662  A15400     BCLR.B W0, #5
003664  704001     IOR.B W0, W1, W0
003666  9841B0     MOV.B W0, [W3+3]
1165:                      ep->timeoutNAKs                 = timeoutCount;
003668  981189     MOV W9, [W3+32]
00366A  EB0100     CLR W2
1166:              
1167:                      return USB_SUCCESS;
1168:                  }
1169:                  return USB_ENDPOINT_NOT_FOUND;
1170:              }
1171:              
1172:              
1173:              /****************************************************************************
1174:                Function:
1175:                  void USBHostShutdown( void )
1176:              
1177:                Description:
1178:                  This function turns off the USB module and frees all unnecessary memory.
1179:                  This routine can be called by the application layer to shut down all
1180:                  USB activity, which effectively detaches all devices.  The event
1181:                  EVENT_DETACH will be sent to the client drivers for the attached device,
1182:                  and the event EVENT_VBUS_RELEASE_POWER will be sent to the application
1183:                  layer.
1184:              
1185:                Precondition:
1186:                  None
1187:              
1188:                Parameters:
1189:                  None - None
1190:              
1191:                Returns:
1192:                  None
1193:              
1194:                Remarks:
1195:                  None
1196:                ***************************************************************************/
1197:              
1198:              void USBHostShutdown( void )
1199:              {
1200:                  // Shut off the power to the module first, in case we are in an
1201:                  // overcurrent situation.
1202:              
1203:                  #ifdef  USB_SUPPORT_OTG
1204:                      if (!USBOTGHnpIsActive())
1205:                      {
1206:                          // If we currently have an attached device, notify the higher layers that
1207:                          // the device is being removed.
1208:                          if (usbDeviceInfo.deviceAddress)
1209:                          {
1210:                              USB_VBUS_POWER_EVENT_DATA   powerRequest;
1211:              
1212:                              powerRequest.port = 0;  // Currently was have only one port.
1213:              
1214:                              USB_HOST_APP_EVENT_HANDLER( usbDeviceInfo.deviceAddress, EVENT_VBUS_RELEASE_POWER,
1215:                                  &powerRequest, sizeof(USB_VBUS_POWER_EVENT_DATA) );
1216:                              _USB_NotifyClients(usbDeviceInfo.deviceAddress, EVENT_DETACH,
1217:                                  &usbDeviceInfo.deviceAddress, sizeof(BYTE) );
1218:              
1219:              
1220:                          }
1221:                      }
1222:                  #else
1223:                      U1PWRC = USB_NORMAL_OPERATION | USB_DISABLED;  //MR - Turning off Module will cause unwanted Suspends in OTG
003508  EF2488     CLR U1PWRC
1224:              
1225:                      // If we currently have an attached device, notify the higher layers that
1226:                      // the device is being removed.
1227:                      if (usbDeviceInfo.deviceAddress)
00350A  21EBF8     MOV #0x1EBF, W8
00350C  784018     MOV.B [W8], W0
00350E  E00400     CP0.B W0
003510  32000E     BRA Z, 0x352E
1228:                      {
1229:                          USB_VBUS_POWER_EVENT_DATA   powerRequest;
1230:              
1231:                          powerRequest.port = 0;  // Currently was have only one port.
003512  EB4080     CLR.B W1
003514  9FFFC1     MOV.B W1, [W15-4]
1232:              
1233:                          USB_HOST_APP_EVENT_HANDLER( usbDeviceInfo.deviceAddress, EVENT_VBUS_RELEASE_POWER,
003516  200024     MOV #0x2, W4
003518  200005     MOV #0x0, W5
00351A  578164     SUB W15, #0x4, W2
00351C  2006A1     MOV #0x6A, W1
00351E  022C18     CALL USB_ApplicationEventHandler
003520  000000     NOP
1234:                              &powerRequest, sizeof(USB_VBUS_POWER_EVENT_DATA) );
1235:                          _USB_NotifyClients(usbDeviceInfo.deviceAddress, EVENT_DETACH,
003522  200013     MOV #0x1, W3
003524  780108     MOV W8, W2
003526  200711     MOV #0x71, W1
003528  784018     MOV.B [W8], W0
00352A  023090     CALL _USB_NotifyClients
00352C  000000     NOP
1236:                              &usbDeviceInfo.deviceAddress, sizeof(BYTE) );
1237:              
1238:              
1239:                      }
1240:                  #endif
1241:              
1242:                  // Free all extra allocated memory, initialize variables, and reset the
1243:                  // state machine.
1244:                  USBHostInit( 0 );
00352E  B80060     MUL.UU W0, #0, W0
003530  0234CE     CALL USBHostInit
003532  000000     NOP
1245:              }
1246:              
1247:              
1248:              /****************************************************************************
1249:                Function:
1250:                  BYTE USBHostSuspendDevice( BYTE deviceAddress )
1251:              
1252:                Summary:
1253:                  This function suspends a device.
1254:              
1255:                Description:
1256:                  This function put a device into an IDLE state.  It can only be called
1257:                  while the state machine is in normal running mode.  After 3ms, the
1258:                  attached device should go into SUSPEND mode.
1259:              
1260:                Precondition:
1261:                  None
1262:              
1263:                Parameters:
1264:                  BYTE deviceAddress  - Device to suspend
1265:              
1266:                Return Values:
1267:                  USB_SUCCESS         - Success
1268:                  USB_UNKNOWN_DEVICE  - Device not found
1269:                  USB_ILLEGAL_REQUEST - Cannot suspend unless device is in normal run mode
1270:              
1271:                Remarks:
1272:                  None
1273:                ***************************************************************************/
1274:              
1275:              BYTE USBHostSuspendDevice( BYTE deviceAddress )
1276:              {
1277:                  // Find the required device
1278:                  if (deviceAddress != usbDeviceInfo.deviceAddress)
0037EE  200062     MOV #0x6, W2
0037F0  21EBF1     MOV #0x1EBF, W1
0037F2  504F91     SUB.B W0, [W1], [W15]
0037F4  3A0009     BRA NZ, 0x3808
1279:                  {
1280:                      return USB_UNKNOWN_DEVICE;
1281:                  }
1282:              
1283:                  if (usbHostState != (STATE_RUNNING | SUBSTATE_NORMAL_RUN))
0037F6  80F691     MOV usbHostState, W1
0037F8  200032     MOV #0x3, W2
0037FA  204000     MOV #0x400, W0
0037FC  508F80     SUB W1, W0, [W15]
0037FE  3A0004     BRA NZ, 0x3808
1284:                  {
1285:                      return USB_ILLEGAL_REQUEST;
1286:                  }
1287:              
1288:                  // Turn off SOF's, so the bus is idle.
1289:                  U1CONbits.SOFEN = 0;
003800  A90494     BCLR U1CON, #0
1290:              
1291:                  // Put the state machine in suspend mode.
1292:                  usbHostState = STATE_RUNNING | SUBSTATE_SUSPEND_AND_RESUME | SUBSUBSTATE_SUSPEND;
003802  400070     ADD W0, #0x10, W0
003804  88F690     MOV W0, usbHostState
003806  EB0100     CLR W2
1293:              
1294:                  return USB_SUCCESS;
1295:              }
1296:              
1297:              /****************************************************************************
1298:                Function:
1299:                  void USBHostTasks( void )
1300:              
1301:                Summary:
1302:                  This function executes the host tasks for USB host operation.
1303:              
1304:                Description:
1305:                  This function executes the host tasks for USB host operation.  It must be
1306:                  executed on a regular basis to keep everything functioning.
1307:              
1308:                  The primary purpose of this function is to handle device attach/detach
1309:                  and enumeration.  It does not handle USB packet transmission or
1310:                  reception; that must be done in the USB interrupt handler to ensure
1311:                  timely operation.
1312:              
1313:                  This routine should be called on a regular basis, but there is no
1314:                  specific time requirement.  Devices will still be able to attach,
1315:                  enumerate, and detach, but the operations will occur more slowly as the
1316:                  calling interval increases.
1317:              
1318:                Precondition:
1319:                  USBHostInit() has been called.
1320:              
1321:                Parameters:
1322:                  None
1323:              
1324:                Returns:
1325:                  None
1326:              
1327:                Remarks:
1328:                  None
1329:                ***************************************************************************/
1330:              
1331:              void USBHostTasks( void )
1332:              {
1333:                  static USB_CONFIGURATION    *pCurrentConfigurationNode;  //MR - made static for OTG
1334:                  USB_INTERFACE_INFO          *pCurrentInterface;
1335:                  BYTE                        *pTemp;
1336:                  BYTE                        temp;
1337:                  USB_VBUS_POWER_EVENT_DATA   powerRequest;
1338:              
1339:                  #ifdef DEBUG_MODE
1340:              //        UART2PutChar('<');
1341:              //        UART2PutHex( usbHostState>>8 );
1342:              //        UART2PutHex( usbHostState & 0xff );
1343:              //        UART2PutChar('-');
1344:              //        UART2PutHex( pCurrentEndpoint->transferState );
1345:              //        UART2PutChar('>');
1346:                  #endif
1347:              
1348:                  // The PIC32MX detach interrupt is not reliable.  If we are not in one of
1349:                  // the detached states, we'll do a check here to see if we've detached.
1350:                  // If the ATTACH bit is 0, we have detached.
1351:                  #ifdef __PIC32MX__
1352:                      #ifdef USE_MANUAL_DETACH_DETECT
1353:                          if (((usbHostState & STATE_MASK) != STATE_DETACHED) && !U1IRbits.ATTACHIF)
1354:                          {
1355:                              #ifdef DEBUG_MODE
1356:                                  UART2PutChar( '>' );
1357:                                  UART2PutChar( ']' );
1358:                              #endif
1359:                              usbHostState = STATE_DETACHED;
1360:                          }
1361:                      #endif
1362:                  #endif
1363:              
1364:                  // Send any queued events to the client and application layers.
1365:                  #if defined ( USB_ENABLE_TRANSFER_EVENT )
1366:                  {
1367:                      USB_EVENT_DATA *item;
1368:                      #if defined( __C30__ )
1369:                          WORD        interrupt_mask;
1370:                      #elif defined( __PIC32MX__ )
1371:                          UINT32      interrupt_mask;
1372:                      #else
1373:                          #error Cannot save interrupt status
1374:                      #endif
1375:              
1376:                      while (StructQueueIsNotEmpty(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
1377:                      {
1378:                          item = StructQueuePeekTail(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
1379:              
1380:                          switch(item->event)
1381:                          {
1382:                              case EVENT_TRANSFER:
1383:                              case EVENT_BUS_ERROR:
1384:                                  _USB_NotifyClients( usbDeviceInfo.deviceAddress, item->event, &item->TransferData, sizeof(HOST_TRANSFER_DATA) );
1385:                                  break;
1386:                              default:
1387:                                  break;
1388:                          }
1389:              
1390:                          // Guard against USB interrupts
1391:                          interrupt_mask = U1IE;
1392:                          U1IE = 0;
1393:              
1394:                          item = StructQueueRemove(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
1395:              
1396:                          // Re-enable USB interrupts
1397:                          U1IE = interrupt_mask;
1398:                      }
1399:                  }
1400:                  #endif
1401:              
1402:                  // See if we got an interrupt to change our state.
1403:                  if (usbOverrideHostState != NO_STATE)
000EB4  80F5B0     MOV usbOverrideHostState, W0
000EB6  400FE1     ADD W0, #0x1, [W15]
000EB8  320004     BRA Z, 0xEC2
1404:                  {
1405:                      #ifdef DEBUG_MODE
1406:                          UART2PutChar('>');
1407:                      #endif
1408:                      usbHostState = usbOverrideHostState;
000EBA  80F5B0     MOV usbOverrideHostState, W0
000EBC  88F690     MOV W0, usbHostState
1409:                      usbOverrideHostState = NO_STATE;
000EBE  EB8000     SETM W0
000EC0  88F5B0     MOV W0, usbOverrideHostState
1410:                  }
1411:              
1412:                  //-------------------------------------------------------------------------
1413:                  // Main State Machine
1414:              
1415:                  switch (usbHostState & STATE_MASK)
000EC2  80F690     MOV usbHostState, W0
000EC4  20F009     MOV #0xF00, W9
000EC6  600409     AND W0, W9, W8
000EC8  202000     MOV #0x200, W0
000ECA  540F80     SUB W8, W0, [W15]
000ECC  320154     BRA Z, 0x1176
000ECE  3E0006     BRA GTU, 0xEDC
000ED0  E00008     CP0 W8
000ED2  32000E     BRA Z, 0xEF0
000ED4  201000     MOV #0x100, W0
000ED6  540F80     SUB W8, W0, [W15]
000ED8  3A032C     BRA NZ, 0x1532
000EDA  370083     BRA 0xFE2
000EDC  204000     MOV #0x400, W0
000EDE  540F80     SUB W8, W0, [W15]
000EE0  3202D6     BRA Z, 0x148E
000EE2  B01000     ADD #0x100, W0
000EE4  540F80     SUB W8, W0, [W15]
000EE6  3202EE     BRA Z, 0x14C4
000EE8  203000     MOV #0x300, W0
000EEA  540F80     SUB W8, W0, [W15]
000EEC  3A0322     BRA NZ, 0x1532
000EEE  37016C     BRA 0x11C8
1416:                  {
1417:                      case STATE_DETACHED:
1418:                          switch (usbHostState & SUBSTATE_MASK)
000EF0  80F691     MOV usbHostState, W1
000EF2  B20F01     AND #0xF0, W1
000EF4  508FF0     SUB W1, #0x10, [W15]
000EF6  320051     BRA Z, 0xF9A
000EF8  200200     MOV #0x20, W0
000EFA  508F80     SUB W1, W0, [W15]
000EFC  320053     BRA Z, 0xFA4
000EFE  E00001     CP0 W1
000F00  3A0318     BRA NZ, 0x1532
1419:                          {
1420:                              case SUBSTATE_INITIALIZE:
1421:                                  // We got here either from initialization or from the user
1422:                                  // unplugging the device at any point in time.
1423:              
1424:                                  // Turn off the module and free up memory.
1425:                                  USBHostShutdown();
000F02  023504     CALL USBHostShutdown
000F04  000000     NOP
1426:              
1427:                                  #ifdef DEBUG_MODE
1428:                                      UART2PrintString( "HOST: Initializing DETACHED state.\r\n" );
1429:                                  #endif
1430:              
1431:                                  // Initialize Endpoint 0 attributes.
1432:                                  usbDeviceInfo.pEndpoint0->next                         = NULL;
000F06  80F650     MOV 0x1ECA, W0
000F08  780808     MOV W8, [W0]
1433:                                  usbDeviceInfo.pEndpoint0->status.val                   = 0x00;
000F0A  80F650     MOV 0x1ECA, W0
000F0C  980018     MOV W8, [W0+2]
1434:                                  usbDeviceInfo.pEndpoint0->status.bfUseDTS              = 1;
000F0E  80F651     MOV 0x1ECA, W1
000F10  904031     MOV.B [W1+3], W0
000F12  A02400     BSET.B W0, #2
000F14  9840B0     MOV.B W0, [W1+3]
1435:                                  usbDeviceInfo.pEndpoint0->status.bfTransferComplete    = 1;    // Initialize to success to allow preprocessing loops.
000F16  80F651     MOV 0x1ECA, W1
000F18  904031     MOV.B [W1+3], W0
000F1A  A01400     BSET.B W0, #1
000F1C  9840B0     MOV.B W0, [W1+3]
1436:                                  usbDeviceInfo.pEndpoint0->status.bfNAKTimeoutEnabled   = 1;    // So we can catch devices that NAK forever during enumeration
000F1E  80F651     MOV 0x1ECA, W1
000F20  904031     MOV.B [W1+3], W0
000F22  A05400     BSET.B W0, #5
000F24  9840B0     MOV.B W0, [W1+3]
1437:                                  usbDeviceInfo.pEndpoint0->timeoutNAKs                  = USB_NUM_CONTROL_NAKS;
000F26  80F652     MOV 0x1ECA, W2
000F28  201C20     MOV #0x1C2, W0
000F2A  981100     MOV W0, [W2+32]
1438:                                  usbDeviceInfo.pEndpoint0->wMaxPacketSize               = 64;
000F2C  200400     MOV #0x40, W0
000F2E  980140     MOV W0, [W2+8]
1439:                                  usbDeviceInfo.pEndpoint0->dataCount                    = 0;    // Initialize to 0 since we set bfTransferComplete.
000F30  B80060     MUL.UU W0, #0, W0
000F32  980900     MOV W0, [W2+16]
000F34  980911     MOV W1, [W2+18]
1440:                                  usbDeviceInfo.pEndpoint0->bEndpointAddress             = 0;
000F36  985928     MOV.B W8, [W2+26]
1441:                                  usbDeviceInfo.pEndpoint0->transferState                = TSTATE_IDLE;
000F38  80F650     MOV 0x1ECA, W0
000F3A  985808     MOV.B W8, [W0+24]
1442:                                  usbDeviceInfo.pEndpoint0->bmAttributes.bfTransferType  = USB_TRANSFER_TYPE_CONTROL;
000F3C  80F652     MOV 0x1ECA, W2
000F3E  900852     MOV [W2+26], W0
000F40  2FCFF1     MOV #0xFCFF, W1
000F42  600001     AND W0, W1, W0
000F44  980950     MOV W0, [W2+26]
1443:                                  usbDeviceInfo.pEndpoint0->clientDriver                 = CLIENT_DRIVER_HOST;
000F46  EBC080     SETM.B W1
000F48  80F650     MOV 0x1ECA, W0
000F4A  985811     MOV.B W1, [W0+25]
1444:              
1445:                                  // Initialize any device specific information.
1446:                                  numEnumerationTries                 = USB_NUM_ENUMERATION_TRIES;
000F4C  B3C031     MOV #0x3, W1
000F4E  21ED80     MOV #0x1ED8, W0
000F50  784801     MOV.B W1, [W0]
1447:                                  usbDeviceInfo.currentConfiguration  = 0; // Will be overwritten by config process or the user later
000F52  21EBC0     MOV #0x1EBC, W0
000F54  784808     MOV.B W8, [W0]
1448:                                  usbDeviceInfo.attributesOTG         = 0;
000F56  21EBD0     MOV #0x1EBD, W0
000F58  784808     MOV.B W8, [W0]
1449:                                  usbDeviceInfo.deviceAddressAndSpeed = 0;
000F5A  21EBE0     MOV #0x1EBE, W0
000F5C  784808     MOV.B W8, [W0]
1450:                                  usbDeviceInfo.flags.val             = 0;
000F5E  88F668     MOV W8, 0x1ECC
1451:                                  usbDeviceInfo.pInterfaceList        = NULL;
000F60  88F648     MOV W8, 0x1EC8
1452:                                  usbBusInfo.flags.val                = 0;
000F62  88F678     MOV W8, usbBusInfo
1453:                                  
1454:                                  // Set up the hardware.
1455:                                  U1IE                = 0;        // Clear and turn off interrupts.
000F64  882468     MOV W8, U1IE
1456:                                  U1IR                = 0xFF;
000F66  200FF1     MOV #0xFF, W1
000F68  882451     MOV W1, U1IR
1457:                                  U1OTGIE             &= 0x8C;
000F6A  2008C0     MOV #0x8C, W0
000F6C  B62482     AND U1OTGIE
1458:                                  U1OTGIR             = 0x7D;
000F6E  50006F     SUB W0, #0xF, W0
000F70  882400     MOV W0, U1OTGIR
1459:                                  U1EIE               = 0;
000F72  882488     MOV W8, U1EIE
1460:                                  U1EIR               = 0xFF;
000F74  882471     MOV W1, U1EIR
1461:              
1462:                                  // Initialize the Buffer Descriptor Table pointer.
1463:                                  #if defined(__C30__)
1464:                                     U1BDTP1 = (WORD)(&BDT) >> 8;
000F76  21E000     MOV #0x1E00, W0
000F78  DE0048     LSR W0, #8, W0
000F7A  8824C0     MOV W0, U1BDTP1
1465:                                  #elif defined(__PIC32MX__)
1466:                                     U1BDTP1 = ((DWORD)KVA_TO_PA(&BDT) & 0x0000FF00) >> 8;
1467:                                     U1BDTP2 = ((DWORD)KVA_TO_PA(&BDT) & 0x00FF0000) >> 16;
1468:                                     U1BDTP3 = ((DWORD)KVA_TO_PA(&BDT) & 0xFF000000) >> 24;
1469:                                  #else
1470:                                      #error Cannot set up the Buffer Descriptor Table pointer.
1471:                                  #endif
1472:              
1473:                                  // Configure the module
1474:                                  U1CON               = USB_HOST_MODE_ENABLE | USB_SOF_DISABLE;                       // Turn of SOF's to cut down noise
000F7C  200081     MOV #0x8, W1
000F7E  8824A1     MOV W1, U1CON
1475:                                  U1CON               = USB_HOST_MODE_ENABLE | USB_PINGPONG_RESET | USB_SOF_DISABLE;  // Reset the ping-pong buffers
000F80  2000A0     MOV #0xA, W0
000F82  8824A0     MOV W0, U1CON
1476:                                  U1CON               = USB_HOST_MODE_ENABLE | USB_SOF_DISABLE;                       // Release the ping-pong buffers
000F84  8824A1     MOV W1, U1CON
1477:                                  #ifdef  USB_SUPPORT_OTG
1478:                                      U1OTGCON            |= USB_DPLUS_PULLDOWN_ENABLE | USB_DMINUS_PULLDOWN_ENABLE | USB_OTG_ENABLE; // Pull down D+ and D-
1479:                                  #else
1480:                                      U1OTGCON            = USB_DPLUS_PULLDOWN_ENABLE | USB_DMINUS_PULLDOWN_ENABLE; // Pull down D+ and D-
000F86  200300     MOV #0x30, W0
000F88  882430     MOV W0, U1OTGCON
1481:                                  #endif
1482:              
1483:                                  #if defined(__PIC32MX__)
1484:                                      U1OTGCON |= USB_VBUS_ON;
1485:                                  #endif
1486:              
1487:                                  U1CNFG1             = USB_PING_PONG_MODE;
000F8A  200020     MOV #0x2, W0
000F8C  882530     MOV W0, U1CNFG1
1488:                                  #if defined(__C30__)
1489:                                      U1CNFG2         = USB_VBUS_BOOST_ENABLE | USB_VBUS_COMPARE_ENABLE | USB_ONCHIP_ENABLE;
000F8E  882548     MOV W8, U1CNFG2
1490:                                  #endif
1491:                                  U1ADDR              = 0;                        // Set default address and LSPDEN to 0
000F90  8824B8     MOV W8, U1ADDR
1492:                                  U1EP0bits.LSPD      = 0;
000F92  A9E4AA     BCLR U1EP0, #7
1493:                                  U1SOF               = USB_SOF_THRESHOLD_64;     // Maximum EP0 packet size
000F94  2004A0     MOV #0x4A, W0
000F96  882500     MOV W0, U1SOF
000F98  3702C7     BRA 0x1528
1494:              
1495:                                  // Set the next substate.  We do this before we enable
1496:                                  // interrupts in case the interrupt changes states.
1497:                                  _USB_SetNextSubState();
1498:                                  break;
1499:              
1500:                              case SUBSTATE_WAIT_FOR_POWER:
1501:                                  // We will wait here until the application tells us we can
1502:                                  // turn on power.
1503:                                  if (usbRootHubInfo.flags.bPowerGoodPort0)
000F9A  21EB80     MOV #0x1EB8, W0
000F9C  784010     MOV.B [W0], W0
000F9E  604061     AND.B W0, #0x1, W0
000FA0  3202C8     BRA Z, 0x1532
000FA2  3702C2     BRA 0x1528
1504:                                  {
1505:                                      _USB_SetNextSubState();
1506:                                  }
1507:                                  break;
1508:              
1509:                              case SUBSTATE_TURN_ON_POWER:
1510:                                  powerRequest.port       = 0;
000FA4  9FFFA8     MOV.B W8, [W15-6]
1511:                                  powerRequest.current    = USB_INITIAL_VBUS_CURRENT;
000FA6  B3C320     MOV #0x32, W0
000FA8  9FFFB0     MOV.B W0, [W15-5]
1512:                                  if (USB_HOST_APP_EVENT_HANDLER( USB_ROOT_HUB, EVENT_VBUS_REQUEST_POWER,
000FAA  200024     MOV #0x2, W4
000FAC  200005     MOV #0x0, W5
000FAE  578166     SUB W15, #0x6, W2
000FB0  200691     MOV #0x69, W1
000FB2  EBC000     SETM.B W0
000FB4  022C18     CALL USB_ApplicationEventHandler
000FB6  000000     NOP
000FB8  E00000     CP0 W0
000FBA  32000F     BRA Z, 0xFDA
1513:                                          &powerRequest, sizeof(USB_VBUS_POWER_EVENT_DATA) ))
1514:                                  {
1515:                                      // Power on the module
1516:                                      U1PWRC                = USB_NORMAL_OPERATION | USB_ENABLED;
000FBC  200010     MOV #0x1, W0
000FBE  882440     MOV W0, U1PWRC
1517:              
1518:                                      #if defined( __C30__ )
1519:                                          IFS5            &= 0xFFBF;
000FC0  A9C08E     BCLR IFS5, #6
1520:                                          IPC21           &= 0xF0FF;
000FC2  2F0FF0     MOV #0xF0FF, W0
000FC4  B620CE     AND IPC21
1521:                                          IPC21           |= 0x0500;
000FC6  205000     MOV #0x500, W0
000FC8  B720CE     IOR IPC21
1522:                                          IEC5            |= 0x0040;
000FCA  A8C09E     BSET IEC5, #6
1523:                                      #elif defined( __PIC32MX__ )
1524:                                          // Enable the USB interrupt.
1525:                                          IFS1CLR         = 0x02000000;
1526:                                          IPC11CLR        = 0x0000FF00;
1527:                                          IPC11SET        = 0x00001000;
1528:                                          IEC1SET         = 0x02000000;
1529:                                      #else
1530:                                          #error Cannot enable USB interrupt.
1531:                                      #endif
1532:              
1533:                                      // Set the next substate.  We do this before we enable
1534:                                      // interrupts in case the interrupt changes states.
1535:                                      _USB_SetNextSubState();
000FCC  80F690     MOV usbHostState, W0
000FCE  20FF01     MOV #0xFF0, W1
000FD0  600001     AND W0, W1, W0
000FD2  400070     ADD W0, #0x10, W0
000FD4  88F690     MOV W0, usbHostState
1536:              
1537:                                      // Enable the ATTACH interrupt.
1538:                                      U1IEbits.ATTACHIE = 1;
000FD6  A8C48C     BSET U1IE, #6
000FD8  3702AC     BRA 0x1532
1539:              
1540:                                      #if defined(USB_ENABLE_1MS_EVENT)
1541:                                          U1OTGIR                 = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
1542:                                          U1OTGIEbits.T1MSECIE    = 1;
1543:                                      #endif
1544:                                  }
1545:                                  else
1546:                                  {
1547:                                      usbRootHubInfo.flags.bPowerGoodPort0 = 0;
000FDA  21EB80     MOV #0x1EB8, W0
000FDC  A10410     BCLR.B [W0], #0
1548:                                      usbHostState = STATE_DETACHED | SUBSTATE_WAIT_FOR_POWER;
000FDE  200100     MOV #0x10, W0
000FE0  3702A7     BRA 0x1530
1549:                                  }
1550:                                  break;
1551:              
1552:                              case SUBSTATE_WAIT_FOR_DEVICE:
1553:                                  // Wait here for the ATTACH interrupt.
1554:                                  #ifdef  USB_SUPPORT_OTG
1555:                                      U1IEbits.ATTACHIE = 1;
1556:                                  #endif
1557:                              break;
1558:                          }
1559:                          break;
1560:              
1561:                      case STATE_ATTACHED:
1562:                          switch (usbHostState & SUBSTATE_MASK)
000FE2  80F691     MOV usbHostState, W1
000FE4  B20F01     AND #0xF0, W1
000FE6  200200     MOV #0x20, W0
000FE8  508F80     SUB W1, W0, [W15]
000FEA  320065     BRA Z, 0x10B6
000FEC  3E0005     BRA GTU, 0xFF8
000FEE  E00001     CP0 W1
000FF0  32000A     BRA Z, 0x1006
000FF2  508FF0     SUB W1, #0x10, [W15]
000FF4  3A029E     BRA NZ, 0x1532
000FF6  370012     BRA 0x101C
000FF8  200300     MOV #0x30, W0
000FFA  508F80     SUB W1, W0, [W15]
000FFC  32009C     BRA Z, 0x1136
000FFE  400070     ADD W0, #0x10, W0
001000  508F80     SUB W1, W0, [W15]
001002  3A0297     BRA NZ, 0x1532
001004  3700B5     BRA 0x1170
1563:                          {
1564:                              case SUBSTATE_SETTLE:
1565:                                  // Wait 100ms for the insertion process to complete and power
1566:                                  // at the device to be stable.
1567:                                  switch (usbHostState & SUBSUBSTATE_MASK)
001006  80F690     MOV usbHostState, W0
001008  60006F     AND W0, #0xF, W0
00100A  320003     BRA Z, 0x1012
00100C  500FE2     SUB W0, #0x2, [W15]
00100E  3A0291     BRA NZ, 0x1532
001010  37028B     BRA 0x1528
1568:                                  {
1569:                                      case SUBSUBSTATE_START_SETTLING_DELAY:
1570:                                          #ifdef DEBUG_MODE
1571:                                              UART2PrintString( "HOST: Starting settling delay.\r\n" );
1572:                                          #endif
1573:              
1574:                                          // Clear and turn on the DETACH interrupt.
1575:                                          U1IR                    = USB_INTERRUPT_DETACH;   // The interrupt is cleared by writing a '1' to the flag.
001012  200010     MOV #0x1, W0
001014  882450     MOV W0, U1IR
1576:                                          U1IEbits.DETACHIE       = 1;
001016  A8048C     BSET U1IE, #0
1577:              
1578:                                          // Configure and turn on the settling timer - 100ms.
1579:                                          numTimerInterrupts      = USB_INSERT_TIME;
001018  200FB0     MOV #0xFB, W0
00101A  37024B     BRA 0x14B2
1580:                                          U1OTGIR                 = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
1581:                                          U1OTGIEbits.T1MSECIE    = 1;
1582:                                          _USB_SetNextSubSubState();
1583:                                          break;
1584:              
1585:                                      case SUBSUBSTATE_WAIT_FOR_SETTLING:
1586:                                          // Wait for the timer to finish in the background.
1587:                                          break;
1588:              
1589:                                      case SUBSUBSTATE_SETTLING_DONE:
1590:                                          _USB_SetNextSubState();
1591:                                          break;
1592:              
1593:                                      default:
1594:                                          // We shouldn't get here.
1595:                                          break;
1596:                                  }
1597:                                  break;
1598:              
1599:                              case SUBSTATE_RESET_DEVICE:
1600:                                  // Reset the device.  We have to do the reset timing ourselves.
1601:                                  switch (usbHostState & SUBSUBSTATE_MASK)
00101C  80F690     MOV usbHostState, W0
00101E  60046F     AND W0, #0xF, W8
001020  540FE2     SUB W8, #0x2, [W15]
001022  320042     BRA Z, 0x10A8
001024  540FE4     SUB W8, #0x4, [W15]
001026  320042     BRA Z, 0x10AC
001028  E00008     CP0 W8
00102A  3A0283     BRA NZ, 0x1532
1602:                                  {
1603:                                      case SUBSUBSTATE_SET_RESET:
1604:                                          #ifdef DEBUG_MODE
1605:                                              UART2PrintString( "HOST: Resetting the device.\r\n" );
1606:                                          #endif
1607:              
1608:                                          // Prepare a data buffer for us to use.  We'll make it 8 bytes for now,
1609:                                          // which is the minimum wMaxPacketSize for EP0.
1610:                                          if (pEP0Data != NULL)
00102C  80F590     MOV pEP0Data, W0
00102E  E00000     CP0 W0
001030  320003     BRA Z, 0x1038
1611:                                          {
1612:                                              USB_FREE_AND_CLEAR( pEP0Data );
001032  0204B0     CALL free
001034  000000     NOP
001036  88F598     MOV W8, pEP0Data
1613:                                          }
1614:                                          if ((pEP0Data = (BYTE *)USB_MALLOC( 8 )) == NULL)
001038  200080     MOV #0x8, W0
00103A  02038C     CALL malloc
00103C  000000     NOP
00103E  88F590     MOV W0, pEP0Data
001040  E00000     CP0 W0
001042  32011D     BRA Z, 0x127E
001044  21EBE3     MOV #0x1EBE, W3
1615:                                          {
1616:                                              #ifdef DEBUG_MODE
1617:                                                  UART2PrintString( "HOST: Error alloc-ing pEP0Data\r\n" );
1618:                                              #endif
1619:                                              _USB_SetErrorCode( USB_HOLDING_OUT_OF_MEMORY );
1620:                                              _USB_SetHoldState();
1621:                                              break;
1622:                                          }
1623:              
1624:                                          // Initialize the USB Device information
1625:                                          usbDeviceInfo.currentConfiguration      = 0;
001046  21EBC0     MOV #0x1EBC, W0
001048  784808     MOV.B W8, [W0]
1626:                                          usbDeviceInfo.attributesOTG             = 0;
00104A  21EBD0     MOV #0x1EBD, W0
00104C  784808     MOV.B W8, [W0]
1627:                                          usbDeviceInfo.flags.val                 = 0;
00104E  21ECC2     MOV #0x1ECC, W2
001050  88F668     MOV W8, 0x1ECC
1628:              
1629:                                          _USB_InitErrorCounters();
001052  B3C031     MOV #0x3, W1
001054  21ED90     MOV #0x1ED9, W0
001056  784801     MOV.B W1, [W0]
1630:              
1631:                                          // Disable all EP's except EP0.
1632:                                          U1EP0  = USB_ENDPOINT_CONTROL_SETUP;
001058  2000D0     MOV #0xD, W0
00105A  882550     MOV W0, U1EP0
1633:                                          U1EP1  = USB_DISABLE_ENDPOINT;
00105C  882568     MOV W8, U1EP1
1634:                                          U1EP2  = USB_DISABLE_ENDPOINT;
00105E  882578     MOV W8, U1EP2
1635:                                          U1EP3  = USB_DISABLE_ENDPOINT;
001060  882588     MOV W8, U1EP3
1636:                                          U1EP4  = USB_DISABLE_ENDPOINT;
001062  882598     MOV W8, U1EP4
1637:                                          U1EP5  = USB_DISABLE_ENDPOINT;
001064  8825A8     MOV W8, U1EP5
1638:                                          U1EP6  = USB_DISABLE_ENDPOINT;
001066  8825B8     MOV W8, U1EP6
1639:                                          U1EP7  = USB_DISABLE_ENDPOINT;
001068  8825C8     MOV W8, U1EP7
1640:                                          U1EP8  = USB_DISABLE_ENDPOINT;
00106A  8825D8     MOV W8, U1EP8
1641:                                          U1EP9  = USB_DISABLE_ENDPOINT;
00106C  8825E8     MOV W8, U1EP9
1642:                                          U1EP10 = USB_DISABLE_ENDPOINT;
00106E  8825F8     MOV W8, U1EP10
1643:                                          U1EP11 = USB_DISABLE_ENDPOINT;
001070  882608     MOV W8, U1EP11
1644:                                          U1EP12 = USB_DISABLE_ENDPOINT;
001072  882618     MOV W8, U1EP12
1645:                                          U1EP13 = USB_DISABLE_ENDPOINT;
001074  882628     MOV W8, U1EP13
1646:                                          U1EP14 = USB_DISABLE_ENDPOINT;
001076  882638     MOV W8, U1EP14
1647:                                          U1EP15 = USB_DISABLE_ENDPOINT;
001078  882648     MOV W8, U1EP15
1648:              
1649:                                          // See if the device is low speed.
1650:                                          if (!U1CONbits.JSTATE)
00107A  E24494     CP0.B U1CON
00107C  350007     BRA LT, 0x108C
1651:                                          {
1652:                                              #ifdef DEBUG_MODE
1653:                                                  UART2PrintString( "HOST: Low Speed!\r\n" );
1654:                                              #endif
1655:                                              usbDeviceInfo.flags.bfIsLowSpeed    = 1;
00107E  A00412     BSET.B [W2], #0
1656:                                              usbDeviceInfo.deviceAddressAndSpeed = 0x80;
001080  B3C800     MOV #0x80, W0
001082  784980     MOV.B W0, [W3]
1657:                                              U1ADDR                              = 0x80;
001084  200800     MOV #0x80, W0
001086  8824B0     MOV W0, U1ADDR
1658:                                              U1EP0bits.LSPD                      = 1;
001088  A8E4AA     BSET U1EP0, #7
00108A  370004     BRA 0x1094
1659:                                          } else {
1660:                                              // FIX (ytai):
1661:                                              // We may reach this point after a failed
1662:                                              // enumeration (thus not passing through init
1663:                                              // state). It may be that the address has
1664:                                              // already been set. We want to set it back to
1665:                                              // 0 either way.
1666:                                              usbDeviceInfo.flags.bfIsLowSpeed    = 0;
00108C  A10412     BCLR.B [W2], #0
1667:                                              usbDeviceInfo.deviceAddressAndSpeed = 0x00;
00108E  784988     MOV.B W8, [W3]
1668:                                              U1ADDR                              = 0x00;
001090  8824B8     MOV W8, U1ADDR
1669:                                              U1EP0bits.LSPD                      = 0;
001092  A9E4AA     BCLR U1EP0, #7
1670:                                          }
1671:              
1672:                                          // Reset all ping-pong buffers if they are being used.
1673:                                          U1CONbits.PPBRST                    = 1;
001094  A82494     BSET U1CON, #1
1674:                                          U1CONbits.PPBRST                    = 0;
001096  A92494     BCLR U1CON, #1
1675:                                          usbDeviceInfo.flags.bfPingPongIn    = 0;
001098  21ECC0     MOV #0x1ECC, W0
00109A  A14410     BCLR.B [W0], #4
1676:                                          usbDeviceInfo.flags.bfPingPongOut   = 0;
00109C  A15410     BCLR.B [W0], #5
1677:              
1678:                                          #ifdef  USB_SUPPORT_OTG
1679:                                              //Disable HNP
1680:                                              USBOTGDisableHnp();
1681:                                              USBOTGDeactivateHnp();
1682:                                          #endif
1683:              
1684:                                          // Assert reset for 10ms.  Start a timer countdown.
1685:                                          U1CONbits.USBRST                    = 1;
00109E  A88494     BSET U1CON, #4
1686:                                          numTimerInterrupts                  = USB_RESET_TIME;
0010A0  200330     MOV #0x33, W0
0010A2  88F6B0     MOV W0, numTimerInterrupts
1687:                                          //U1OTGIRbits.T1MSECIF                = 1;       // The interrupt is cleared by writing a '1' to the flag.
1688:                                          U1OTGIR                             = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
0010A4  40006D     ADD W0, #0xD, W0
0010A6  370207     BRA 0x14B6
1689:                                          U1OTGIEbits.T1MSECIE                = 1;
1690:              
1691:                                          _USB_SetNextSubSubState();
1692:                                          break;
1693:              
1694:                                      case SUBSUBSTATE_RESET_WAIT:
1695:                                          // Wait for the timer to finish in the background.
1696:                                          break;
1697:              
1698:                                      case SUBSUBSTATE_RESET_RECOVERY:
1699:                                          #ifdef DEBUG_MODE
1700:                                              UART2PrintString( "HOST: Reset complete.\r\n" );
1701:                                          #endif
1702:              
1703:                                          // Deassert reset.
1704:                                          U1CONbits.USBRST        = 0;
0010A8  A98494     BCLR U1CON, #4
0010AA  370201     BRA 0x14AE
1705:              
1706:                                          // Start sending SOF's.
1707:                                          U1CONbits.SOFEN         = 1;
1708:              
1709:                                          // Wait for the reset recovery time.
1710:                                          numTimerInterrupts      = USB_RESET_RECOVERY_TIME;
1711:                                          U1OTGIR                 = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
1712:                                          U1OTGIEbits.T1MSECIE    = 1;
1713:              
1714:                                          _USB_SetNextSubSubState();
1715:                                          break;
1716:              
1717:                                      case SUBSUBSTATE_RECOVERY_WAIT:
1718:                                          // Wait for the timer to finish in the background.
1719:                                          break;
1720:              
1721:                                      case SUBSUBSTATE_RESET_COMPLETE:
1722:                                          #ifdef DEBUG_MODE
1723:                                              UART2PrintString( "HOST: Reset complete.\r\n" );
1724:                                          #endif
1725:              
1726:                                          // Enable USB interrupts
1727:                                          U1IE                    = USB_INTERRUPT_TRANSFER | USB_INTERRUPT_SOF | USB_INTERRUPT_ERROR | USB_INTERRUPT_DETACH;
0010AC  2000F0     MOV #0xF, W0
0010AE  882460     MOV W0, U1IE
1728:                                          U1EIE                   = 0xFF;
0010B0  200FF0     MOV #0xFF, W0
0010B2  882480     MOV W0, U1EIE
0010B4  370239     BRA 0x1528
1729:              
1730:                                          _USB_SetNextSubState();
1731:                                          break;
1732:              
1733:                                      default:
1734:                                          // We shouldn't get here.
1735:                                          break;
1736:                                  }
1737:                                  break;
1738:              
1739:                              case SUBSTATE_GET_DEVICE_DESCRIPTOR_SIZE:
1740:                                  // Send the GET DEVICE DESCRIPTOR command to get just the size
1741:                                  // of the descriptor and the max packet size, so we can allocate
1742:                                  // a large enough buffer for getting the whole thing and enough
1743:                                  // buffer space for each piece.
1744:                                  switch (usbHostState & SUBSUBSTATE_MASK)
0010B6  80F690     MOV usbHostState, W0
0010B8  60006F     AND W0, #0xF, W0
0010BA  500FE1     SUB W0, #0x1, [W15]
0010BC  320015     BRA Z, 0x10E8
0010BE  390003     BRA NC, 0x10C6
0010C0  500FE2     SUB W0, #0x2, [W15]
0010C2  3A0237     BRA NZ, 0x1532
0010C4  37001E     BRA 0x1102
1745:                                  {
1746:                                      case SUBSUBSTATE_SEND_GET_DEVICE_DESCRIPTOR_SIZE:
1747:                                          #ifdef DEBUG_MODE
1748:                                              UART2PrintString( "HOST: Getting Device Descriptor size.\r\n" );
1749:                                          #endif
1750:              
1751:                                          // Set up and send GET DEVICE DESCRIPTOR
1752:                                          if (pDeviceDescriptor != NULL)
0010C6  80FA70     MOV pDeviceDescriptor, W0
0010C8  E00000     CP0 W0
0010CA  320004     BRA Z, 0x10D4
1753:                                          {
1754:                                              USB_FREE_AND_CLEAR( pDeviceDescriptor );
0010CC  0204B0     CALL free
0010CE  000000     NOP
0010D0  EB0000     CLR W0
0010D2  88FA70     MOV W0, pDeviceDescriptor
1755:                                          }
1756:              
1757:                                          pEP0Data[0] = USB_SETUP_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
0010D4  80F593     MOV pEP0Data, W3
0010D6  B3C800     MOV #0x80, W0
0010D8  784980     MOV.B W0, [W3]
1758:                                          pEP0Data[1] = USB_REQUEST_GET_DESCRIPTOR;
0010DA  B3C060     MOV #0x6, W0
0010DC  984190     MOV.B W0, [W3+1]
1759:                                          pEP0Data[2] = 0; // Index
0010DE  EB4080     CLR.B W1
0010E0  9841A1     MOV.B W1, [W3+2]
1760:                                          pEP0Data[3] = USB_DESCRIPTOR_DEVICE; // Type
0010E2  B3C010     MOV #0x1, W0
0010E4  9841B0     MOV.B W0, [W3+3]
0010E6  3700AA     BRA 0x123C
1761:                                          pEP0Data[4] = 0;
1762:                                          pEP0Data[5] = 0;
1763:                                          pEP0Data[6] = 8;
1764:                                          pEP0Data[7] = 0;
1765:              
1766:                                          _USB_InitControlRead( usbDeviceInfo.pEndpoint0, pEP0Data, 8, pEP0Data, 8 );
1767:                                          _USB_SetNextSubSubState();
1768:                                          break;
1769:              
1770:                                      case SUBSUBSTATE_WAIT_FOR_GET_DEVICE_DESCRIPTOR_SIZE:
1771:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
0010E8  80F651     MOV 0x1ECA, W1
0010EA  904031     MOV.B [W1+3], W0
0010EC  A31800     BTST.Z W0, #1
0010EE  320221     BRA Z, 0x1532
1772:                                          {
1773:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
0010F0  904031     MOV.B [W1+3], W0
0010F2  A30800     BTST.Z W0, #0
0010F4  32018A     BRA Z, 0x140A
1774:                                              {
1775:                                                  #ifndef USB_HUB_SUPPORT_INCLUDED
1776:                                                      // See if a hub is attached.  Hubs are not supported.
1777:                                                      if (pEP0Data[4] == USB_HUB_CLASSCODE)   // bDeviceClass
0010F6  80F590     MOV pEP0Data, W0
0010F8  904040     MOV.B [W0+4], W0
0010FA  504FE9     SUB.B W0, #0x9, [W15]
0010FC  3A01DE     BRA NZ, 0x14BA
1778:                                                      {
1779:                                                          _USB_SetErrorCode( USB_HOLDING_UNSUPPORTED_HUB );
0010FE  B3C350     MOV #0x35, W0
001100  3701A8     BRA 0x1452
1780:                                                          _USB_SetHoldState();
1781:                                                      }
1782:                                                      else
1783:                                                      {
1784:                                                          _USB_SetNextSubSubState();
1785:                                                      }
1786:                                                  #else
1787:                                                      _USB_SetNextSubSubState();
1788:                                                  #endif
1789:                                              }
1790:                                              else
1791:                                              {
1792:                                                  // We are here because of either a STALL or a NAK.  See if
1793:                                                  // we have retries left to try the command again or try to
1794:                                                  // enumerate again.
1795:                                                  _USB_CheckCommandAndEnumerationAttempts();
1796:                                              }
1797:                                          }
1798:                                          break;
1799:              
1800:                                      case SUBSUBSTATE_GET_DEVICE_DESCRIPTOR_SIZE_COMPLETE:
1801:                                          // Allocate a buffer for the entire Device Descriptor
1802:                                          if ((pDeviceDescriptor = (BYTE *)USB_MALLOC( *pEP0Data )) == NULL)
001102  80F590     MOV pEP0Data, W0
001104  FB8010     ZE [W0], W0
001106  02038C     CALL malloc
001108  000000     NOP
00110A  780080     MOV W0, W1
00110C  88FA70     MOV W0, pDeviceDescriptor
00110E  E00000     CP0 W0
001110  3200B6     BRA Z, 0x127E
1803:                                          {
1804:                                              // We cannot continue.  Freeze until the device is removed.
1805:                                              _USB_SetErrorCode( USB_HOLDING_OUT_OF_MEMORY );
1806:                                              _USB_SetHoldState();
1807:                                              break;
1808:                                          }
1809:                                          // Save the descriptor size in the descriptor (bLength)
1810:                                          *pDeviceDescriptor = *pEP0Data;
001112  80F590     MOV pEP0Data, W0
001114  784890     MOV.B [W0], [W1]
1811:              
1812:                                          // Set the EP0 packet size.
1813:                                          usbDeviceInfo.pEndpoint0->wMaxPacketSize = ((USB_DEVICE_DESCRIPTOR *)pEP0Data)->bMaxPacketSize0;
001116  9040F0     MOV.B [W0+7], W1
001118  FB8081     ZE W1, W1
00111A  80F652     MOV 0x1ECA, W2
00111C  980141     MOV W1, [W2+8]
1814:              
1815:                                          // Make our pEP0Data buffer the size of the max packet.
1816:                                          USB_FREE_AND_CLEAR( pEP0Data );
00111E  0204B0     CALL free
001120  000000     NOP
001122  EB0000     CLR W0
001124  88F590     MOV W0, pEP0Data
1817:                                          if ((pEP0Data = (BYTE *)USB_MALLOC( usbDeviceInfo.pEndpoint0->wMaxPacketSize )) == NULL)
001126  80F650     MOV 0x1ECA, W0
001128  900040     MOV [W0+8], W0
00112A  02038C     CALL malloc
00112C  000000     NOP
00112E  88F590     MOV W0, pEP0Data
001130  E00000     CP0 W0
001132  3200A5     BRA Z, 0x127E
001134  3700B6     BRA 0x12A2
1818:                                          {
1819:                                              // We cannot continue.  Freeze until the device is removed.
1820:                                              #ifdef DEBUG_MODE
1821:                                                  UART2PrintString( "HOST: Error re-alloc-ing pEP0Data\r\n" );
1822:                                              #endif
1823:                                              _USB_SetErrorCode( USB_HOLDING_OUT_OF_MEMORY );
1824:                                              _USB_SetHoldState();
1825:                                              break;
1826:                                          }
1827:              
1828:                                          // Clean up and advance to the next substate.
1829:                                          _USB_InitErrorCounters();
1830:                                          _USB_SetNextSubState();
1831:                                          break;
1832:              
1833:                                      default:
1834:                                          break;
1835:                                  }
1836:                                  break;
1837:              
1838:                              case SUBSTATE_GET_DEVICE_DESCRIPTOR:
1839:                                  // Send the GET DEVICE DESCRIPTOR command and receive the response
1840:                                  switch (usbHostState & SUBSUBSTATE_MASK)
001136  80F690     MOV usbHostState, W0
001138  60006F     AND W0, #0xF, W0
00113A  500FE1     SUB W0, #0x1, [W15]
00113C  32015F     BRA Z, 0x13FC
00113E  390003     BRA NC, 0x1146
001140  500FE2     SUB W0, #0x2, [W15]
001142  3A01F7     BRA NZ, 0x1532
001144  3700AE     BRA 0x12A2
1841:                                  {
1842:                                      case SUBSUBSTATE_SEND_GET_DEVICE_DESCRIPTOR:
1843:                                          #ifdef DEBUG_MODE
1844:                                              UART2PrintString( "HOST: Getting device descriptor.\r\n" );
1845:                                          #endif
1846:              
1847:                                          // If we are currently sending a token, we cannot do anything.
1848:                                          if (usbBusInfo.flags.bfTokenAlreadyWritten)   //(U1CONbits.TOKBUSY)
001146  21ECE0     MOV #0x1ECE, W0
001148  784010     MOV.B [W0], W0
00114A  604170     AND.B W0, #0x10, W2
00114C  3A01F2     BRA NZ, 0x1532
1849:                                              break;
1850:              
1851:                                          // Set up and send GET DEVICE DESCRIPTOR
1852:                                          pEP0Data[0] = USB_SETUP_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
00114E  80F591     MOV pEP0Data, W1
001150  B3C800     MOV #0x80, W0
001152  784880     MOV.B W0, [W1]
1853:                                          pEP0Data[1] = USB_REQUEST_GET_DESCRIPTOR;
001154  B3C060     MOV #0x6, W0
001156  984090     MOV.B W0, [W1+1]
1854:                                          pEP0Data[2] = 0; // Index
001158  9840A2     MOV.B W2, [W1+2]
1855:                                          pEP0Data[3] = USB_DESCRIPTOR_DEVICE; // Type
00115A  B3C010     MOV #0x1, W0
00115C  9840B0     MOV.B W0, [W1+3]
1856:                                          pEP0Data[4] = 0;
00115E  9840C2     MOV.B W2, [W1+4]
1857:                                          pEP0Data[5] = 0;
001160  9840D2     MOV.B W2, [W1+5]
1858:                                          pEP0Data[6] = *pDeviceDescriptor;
001162  80FA70     MOV pDeviceDescriptor, W0
001164  784010     MOV.B [W0], W0
001166  9840E0     MOV.B W0, [W1+6]
1859:                                          pEP0Data[7] = 0;
001168  9840F2     MOV.B W2, [W1+7]
1860:                                          _USB_InitControlRead( usbDeviceInfo.pEndpoint0, pEP0Data, 8, pDeviceDescriptor, *pDeviceDescriptor  );
00116A  80FA73     MOV pDeviceDescriptor, W3
00116C  FB8213     ZE [W3], W4
00116E  3700C1     BRA 0x12F2
1861:                                          _USB_SetNextSubSubState();
1862:                                          break;
1863:              
1864:                                      case SUBSUBSTATE_WAIT_FOR_GET_DEVICE_DESCRIPTOR:
1865:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
1866:                                          {
1867:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
1868:                                              {
1869:                                                  _USB_SetNextSubSubState();
1870:                                              }
1871:                                              else
1872:                                              {
1873:                                                  // We are here because of either a STALL or a NAK.  See if
1874:                                                  // we have retries left to try the command again or try to
1875:                                                  // enumerate again.
1876:                                                  _USB_CheckCommandAndEnumerationAttempts();
1877:                                              }
1878:                                          }
1879:                                          break;
1880:              
1881:                                      case SUBSUBSTATE_GET_DEVICE_DESCRIPTOR_COMPLETE:
1882:                                          // Clean up and advance to the next substate.
1883:                                          _USB_InitErrorCounters();
1884:                                          _USB_SetNextSubState();
1885:                                          break;
1886:              
1887:                                      default:
1888:                                          break;
1889:                                  }
1890:                                  break;
1891:              
1892:                              case SUBSTATE_VALIDATE_VID_PID:
1893:                                  #ifdef DEBUG_MODE
1894:                                      UART2PrintString( "HOST: Validating VID and PID.\r\n" );
1895:                                  #endif
1896:              
1897:                                  // Search the TPL for the device's VID & PID.  If a client driver is
1898:                                  // available for the over-all device, use it.  Otherwise, we'll search
1899:                                  // again later for an appropriate class driver.
1900:                                  _USB_FindDeviceLevelClientDriver();
001170  022CC6     CALL _USB_FindDeviceLevelClientDriver
001172  000000     NOP
001174  370025     BRA 0x11C0
1901:              
1902:                                  // Advance to the next state to assign an address to the device.
1903:                                  //
1904:                                  // Note: We assign an address to all devices and hold later if
1905:                                  // we can't find a supported configuration.
1906:                                  _USB_SetNextState();
1907:                                  break;
1908:                          }
1909:                          break;
1910:              
1911:                      case STATE_ADDRESSING:
1912:                          switch (usbHostState & SUBSTATE_MASK)
001176  80F694     MOV usbHostState, W4
001178  B20F04     AND #0xF0, W4
00117A  3A01DB     BRA NZ, 0x1532
1913:                          {
1914:                              case SUBSTATE_SET_DEVICE_ADDRESS:
1915:                                  // Send the SET ADDRESS command.  We can't set the device address
1916:                                  // in hardware until the entire transaction is complete.
1917:                                  switch (usbHostState & SUBSUBSTATE_MASK)
00117C  80F690     MOV usbHostState, W0
00117E  60006F     AND W0, #0xF, W0
001180  500FE1     SUB W0, #0x1, [W15]
001182  32013C     BRA Z, 0x13FC
001184  390003     BRA NC, 0x118C
001186  500FE2     SUB W0, #0x2, [W15]
001188  3A01D4     BRA NZ, 0x1532
00118A  37000F     BRA 0x11AA
1918:                                  {
1919:                                      case SUBSUBSTATE_SEND_SET_DEVICE_ADDRESS:
1920:                                          #ifdef DEBUG_MODE
1921:                                              UART2PrintString( "HOST: Setting device address.\r\n" );
1922:                                          #endif
1923:              
1924:                                          // Select an address for the device.  Store it so we can access it again
1925:                                          // easily.  We'll put the low speed indicator on later.
1926:                                          // This has been broken out so when we allow multiple devices, we have
1927:                                          // a single interface point to allocate a new address.
1928:                                          usbDeviceInfo.deviceAddress = USB_SINGLE_DEVICE_ADDRESS;
00118C  21EBF2     MOV #0x1EBF, W2
00118E  B3C010     MOV #0x1, W0
001190  784900     MOV.B W0, [W2]
1929:              
1930:                                          // Set up and send SET ADDRESS
1931:                                          pEP0Data[0] = USB_SETUP_HOST_TO_DEVICE | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
001192  80F591     MOV pEP0Data, W1
001194  784884     MOV.B W4, [W1]
1932:                                          pEP0Data[1] = USB_REQUEST_SET_ADDRESS;
001196  B3C050     MOV #0x5, W0
001198  984090     MOV.B W0, [W1+1]
1933:                                          pEP0Data[2] = usbDeviceInfo.deviceAddress;
00119A  784112     MOV.B [W2], W2
00119C  9840A2     MOV.B W2, [W1+2]
1934:                                          pEP0Data[3] = 0;
00119E  9840B4     MOV.B W4, [W1+3]
1935:                                          pEP0Data[4] = 0;
0011A0  9840C4     MOV.B W4, [W1+4]
1936:                                          pEP0Data[5] = 0;
0011A2  9840D4     MOV.B W4, [W1+5]
1937:                                          pEP0Data[6] = 0;
0011A4  9840E4     MOV.B W4, [W1+6]
1938:                                          pEP0Data[7] = 0;
0011A6  9840F4     MOV.B W4, [W1+7]
0011A8  370103     BRA 0x13B0
1939:                                          _USB_InitControlWrite( usbDeviceInfo.pEndpoint0, pEP0Data, 8, NULL, 0 );
1940:                                          _USB_SetNextSubSubState();
1941:                                          break;
1942:              
1943:                                      case SUBSUBSTATE_WAIT_FOR_SET_DEVICE_ADDRESS:
1944:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
1945:                                          {
1946:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
1947:                                              {
1948:                                                  _USB_SetNextSubSubState();
1949:                                              }
1950:                                              else
1951:                                              {
1952:                                                  // We are here because of either a STALL or a NAK.  See if
1953:                                                  // we have retries left to try the command again or try to
1954:                                                  // enumerate again.
1955:                                                  _USB_CheckCommandAndEnumerationAttempts();
1956:                                              }
1957:                                          }
1958:                                          break;
1959:              
1960:                                      case SUBSUBSTATE_SET_DEVICE_ADDRESS_COMPLETE:
1961:                                          // Set the device's address here.
1962:                                          usbDeviceInfo.deviceAddressAndSpeed = (usbDeviceInfo.flags.bfIsLowSpeed << 7) | usbDeviceInfo.deviceAddress;
0011AA  21ECC0     MOV #0x1ECC, W0
0011AC  784010     MOV.B [W0], W0
0011AE  604061     AND.B W0, #0x1, W0
0011B0  FB8000     ZE W0, W0
0011B2  DD0047     SL W0, #7, W0
0011B4  21EBF2     MOV #0x1EBF, W2
0011B6  21EBE1     MOV #0x1EBE, W1
0011B8  704892     IOR.B W0, [W2], [W1]
1963:              
1964:                                          // Clean up and advance to the next state.
1965:                                          _USB_InitErrorCounters();
0011BA  B3C031     MOV #0x3, W1
0011BC  21ED90     MOV #0x1ED9, W0
0011BE  784801     MOV.B W1, [W0]
1966:                                          _USB_SetNextState();
0011C0  80F690     MOV usbHostState, W0
0011C2  600009     AND W0, W9, W0
0011C4  B01000     ADD #0x100, W0
0011C6  3701B4     BRA 0x1530
1967:                                          break;
1968:              
1969:                                      default:
1970:                                          break;
1971:                                  }
1972:                                  break;
1973:                          }
1974:                          break;
1975:              
1976:                      case STATE_CONFIGURING:
1977:                          switch (usbHostState & SUBSTATE_MASK)
0011C8  80F691     MOV usbHostState, W1
0011CA  B20F01     AND #0xF0, W1
0011CC  200200     MOV #0x20, W0
0011CE  508F80     SUB W1, W0, [W15]
0011D0  32006C     BRA Z, 0x12AA
0011D2  3E0005     BRA GTU, 0x11DE
0011D4  E00001     CP0 W1
0011D6  32000D     BRA Z, 0x11F2
0011D8  508FF0     SUB W1, #0x10, [W15]
0011DA  3A01AB     BRA NZ, 0x1532
0011DC  37001C     BRA 0x1216
0011DE  200400     MOV #0x40, W0
0011E0  508F80     SUB W1, W0, [W15]
0011E2  3201A2     BRA Z, 0x1528
0011E4  400070     ADD W0, #0x10, W0
0011E6  508F80     SUB W1, W0, [W15]
0011E8  3200E9     BRA Z, 0x13BC
0011EA  200300     MOV #0x30, W0
0011EC  508F80     SUB W1, W0, [W15]
0011EE  3A01A1     BRA NZ, 0x1532
0011F0  37008B     BRA 0x1308
1978:                          {
1979:                              case SUBSTATE_INIT_CONFIGURATION:
1980:                                  // Delete the old list of configuration descriptors and
1981:                                  // initialize the counter.  We will request the descriptors
1982:                                  // from highest to lowest so the lowest will be first in
1983:                                  // the list.
1984:                                  countConfigurations = ((USB_DEVICE_DESCRIPTOR *)pDeviceDescriptor)->bNumConfigurations;
0011F2  80FA71     MOV pDeviceDescriptor, W1
0011F4  21EDA0     MOV #0x1EDA, W0
0011F6  905091     MOV.B [W1+17], W1
0011F8  784801     MOV.B W1, [W0]
0011FA  370009     BRA 0x120E
1985:                                  while (usbDeviceInfo.pConfigurationDescriptorList != NULL)
00120E  80F630     MOV 0x1EC6, W0
001210  E00000     CP0 W0
001212  3AFFF4     BRA NZ, 0x11FC
001214  370189     BRA 0x1528
1986:                                  {
1987:                                      pTemp = (BYTE *)usbDeviceInfo.pConfigurationDescriptorList->next;
0011FC  900410     MOV [W0+2], W8
1988:                                      USB_FREE_AND_CLEAR( usbDeviceInfo.pConfigurationDescriptorList->descriptor );
0011FE  780010     MOV [W0], W0
001200  0204B0     CALL free
001202  000000     NOP
001204  80F630     MOV 0x1EC6, W0
001206  EB0800     CLR [W0]
1989:                                      USB_FREE_AND_CLEAR( usbDeviceInfo.pConfigurationDescriptorList );
001208  0204B0     CALL free
00120A  000000     NOP
1990:                                      usbDeviceInfo.pConfigurationDescriptorList = (USB_CONFIGURATION *)pTemp;
00120C  88F638     MOV W8, 0x1EC6
1991:                                  }
1992:                                  _USB_SetNextSubState();
1993:                                  break;
1994:              
1995:                              case SUBSTATE_GET_CONFIG_DESCRIPTOR_SIZE:
1996:                                  // Get the size of the Configuration Descriptor for the current configuration
1997:                                  switch (usbHostState & SUBSUBSTATE_MASK)
001216  80F690     MOV usbHostState, W0
001218  60006F     AND W0, #0xF, W0
00121A  500FE1     SUB W0, #0x1, [W15]
00121C  3200EF     BRA Z, 0x13FC
00121E  390003     BRA NC, 0x1226
001220  500FE2     SUB W0, #0x2, [W15]
001222  3A0187     BRA NZ, 0x1532
001224  370017     BRA 0x1254
1998:                                  {
1999:                                      case SUBSUBSTATE_SEND_GET_CONFIG_DESCRIPTOR_SIZE:
2000:                                          #ifdef DEBUG_MODE
2001:                                              UART2PrintString( "HOST: Getting Config Descriptor size.\r\n" );
2002:                                          #endif
2003:              
2004:                                          // Set up and send GET CONFIGURATION (n) DESCRIPTOR with a length of 8
2005:                                          pEP0Data[0] = USB_SETUP_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
001226  80F593     MOV pEP0Data, W3
001228  B3C800     MOV #0x80, W0
00122A  784980     MOV.B W0, [W3]
2006:                                          pEP0Data[1] = USB_REQUEST_GET_DESCRIPTOR;
00122C  B3C060     MOV #0x6, W0
00122E  984190     MOV.B W0, [W3+1]
2007:                                          pEP0Data[2] = countConfigurations-1;    // USB 2.0 - range is 0 - count-1
001230  21EDA0     MOV #0x1EDA, W0
001232  E94010     DEC.B [W0], W0
001234  9841A0     MOV.B W0, [W3+2]
2008:                                          pEP0Data[3] = USB_DESCRIPTOR_CONFIGURATION;
001236  B3C020     MOV #0x2, W0
001238  9841B0     MOV.B W0, [W3+3]
2009:                                          pEP0Data[4] = 0;
00123A  EB4080     CLR.B W1
00123C  9841C1     MOV.B W1, [W3+4]
2010:                                          pEP0Data[5] = 0;
00123E  9841D1     MOV.B W1, [W3+5]
2011:                                          pEP0Data[6] = 8;
001240  B3C080     MOV #0x8, W0
001242  9841E0     MOV.B W0, [W3+6]
2012:                                          pEP0Data[7] = 0;
001244  9841F1     MOV.B W1, [W3+7]
2013:                                          _USB_InitControlRead( usbDeviceInfo.pEndpoint0, pEP0Data, 8, pEP0Data, 8 );
001246  200084     MOV #0x8, W4
001248  780104     MOV W4, W2
00124A  780083     MOV W3, W1
00124C  80F650     MOV 0x1ECA, W0
00124E  0232E4     CALL _USB_InitControlRead
001250  000000     NOP
001252  370133     BRA 0x14BA
2014:                                          _USB_SetNextSubSubState();
2015:                                          break;
2016:              
2017:                                      case SUBSUBSTATE_WAIT_FOR_GET_CONFIG_DESCRIPTOR_SIZE:
2018:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
2019:                                          {
2020:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
2021:                                              {
2022:                                                  _USB_SetNextSubSubState();
2023:                                              }
2024:                                              else
2025:                                              {
2026:                                                  // We are here because of either a STALL or a NAK.  See if
2027:                                                  // we have retries left to try the command again or try to
2028:                                                  // enumerate again.
2029:                                                  _USB_CheckCommandAndEnumerationAttempts();
2030:                                              }
2031:                                          }
2032:                                          break;
2033:              
2034:                                      case SUBSUBSTATE_GET_CONFIG_DESCRIPTOR_SIZECOMPLETE:
2035:                                          // Allocate a buffer for an entry in the configuration descriptor list.
2036:                                          if ((pTemp = (BYTE *)USB_MALLOC( sizeof (USB_CONFIGURATION) )) == NULL)
001254  200060     MOV #0x6, W0
001256  02038C     CALL malloc
001258  000000     NOP
00125A  780400     MOV W0, W8
00125C  E00000     CP0 W0
00125E  32000F     BRA Z, 0x127E
2037:                                          {
2038:                                              // We cannot continue.  Freeze until the device is removed.
2039:                                              _USB_SetErrorCode( USB_HOLDING_OUT_OF_MEMORY );
2040:                                              _USB_SetHoldState();
2041:                                              break;
2042:                                          }
2043:              
2044:                                          // Allocate a buffer for the entire Configuration Descriptor
2045:                                          if ((((USB_CONFIGURATION *)pTemp)->descriptor = (BYTE *)USB_MALLOC( ((WORD)pEP0Data[3] << 8) + (WORD)pEP0Data[2] )) == NULL)
001260  80F591     MOV pEP0Data, W1
001262  904031     MOV.B [W1+3], W0
001264  DD0048     SL W0, #8, W0
001266  9040A1     MOV.B [W1+2], W1
001268  FB8081     ZE W1, W1
00126A  400001     ADD W0, W1, W0
00126C  02038C     CALL malloc
00126E  000000     NOP
001270  780100     MOV W0, W2
001272  780C00     MOV W0, [W8]
001274  E00000     CP0 W0
001276  3A0005     BRA NZ, 0x1282
2046:                                          {
2047:                                              // Not enough memory for the descriptor!
2048:                                              USB_FREE_AND_CLEAR( pTemp );
001278  780008     MOV W8, W0
00127A  0204B0     CALL free
00127C  000000     NOP
2049:              
2050:                                              // We cannot continue.  Freeze until the device is removed.
2051:                                              _USB_SetErrorCode( USB_HOLDING_OUT_OF_MEMORY );
00127E  B3C330     MOV #0x33, W0
001280  3700E8     BRA 0x1452
2052:                                              _USB_SetHoldState();
2053:                                              break;
2054:                                          }
2055:              
2056:                                          // Save wTotalLength
2057:                                          ((USB_CONFIGURATION_DESCRIPTOR *)((USB_CONFIGURATION *)pTemp)->descriptor)->wTotalLength =
001282  80F590     MOV pEP0Data, W0
001284  9040B0     MOV.B [W0+3], W1
001286  DD08C8     SL W1, #8, W1
001288  904020     MOV.B [W0+2], W0
00128A  FB8000     ZE W0, W0
00128C  408080     ADD W1, W0, W1
00128E  984121     MOV.B W1, [W2+2]
001290  DE08C8     LSR W1, #8, W1
001292  984131     MOV.B W1, [W2+3]
2058:                                                  ((WORD)pEP0Data[3] << 8) + (WORD)pEP0Data[2];
2059:              
2060:                                          // Put the new node at the front of the list.
2061:                                          ((USB_CONFIGURATION *)pTemp)->next = usbDeviceInfo.pConfigurationDescriptorList;
001294  80F631     MOV 0x1EC6, W1
001296  980411     MOV W1, [W8+2]
2062:                                          usbDeviceInfo.pConfigurationDescriptorList = (USB_CONFIGURATION *)pTemp;
001298  88F638     MOV W8, 0x1EC6
2063:              
2064:                                          // Save the configuration descriptor pointer and number
2065:                                          pCurrentConfigurationDescriptor            = ((USB_CONFIGURATION *)pTemp)->descriptor;
00129A  88FA82     MOV W2, pCurrentConfigurationDescriptor
2066:                                          ((USB_CONFIGURATION *)pTemp)->configNumber = countConfigurations;
00129C  21EDA0     MOV #0x1EDA, W0
00129E  784010     MOV.B [W0], W0
0012A0  984440     MOV.B W0, [W8+4]
2067:              
2068:                                          // Clean up and advance to the next state.
2069:                                          _USB_InitErrorCounters();
0012A2  B3C031     MOV #0x3, W1
0012A4  21ED90     MOV #0x1ED9, W0
0012A6  784801     MOV.B W1, [W0]
0012A8  37013F     BRA 0x1528
2070:                                          _USB_SetNextSubState();
2071:                                          break;
2072:              
2073:                                      default:
2074:                                          break;
2075:                                  }
2076:                                  break;
2077:              
2078:                              case SUBSTATE_GET_CONFIG_DESCRIPTOR:
2079:                                  // Get the entire Configuration Descriptor for this configuration
2080:                                  switch (usbHostState & SUBSUBSTATE_MASK)
0012AA  80F690     MOV usbHostState, W0
0012AC  60006F     AND W0, #0xF, W0
0012AE  500FE1     SUB W0, #0x1, [W15]
0012B0  3200A5     BRA Z, 0x13FC
0012B2  390003     BRA NC, 0x12BA
0012B4  500FE2     SUB W0, #0x2, [W15]
0012B6  3A013D     BRA NZ, 0x1532
0012B8  37001E     BRA 0x12F6
2081:                                  {
2082:                                      case SUBSUBSTATE_SEND_GET_CONFIG_DESCRIPTOR:
2083:                                          #ifdef DEBUG_MODE
2084:                                              UART2PrintString( "HOST: Getting Config Descriptor.\r\n" );
2085:                                          #endif
2086:              
2087:                                          // Set up and send GET CONFIGURATION (n) DESCRIPTOR.
2088:                                          pEP0Data[0] = USB_SETUP_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
0012BA  80F591     MOV pEP0Data, W1
0012BC  B3C800     MOV #0x80, W0
0012BE  784880     MOV.B W0, [W1]
2089:                                          pEP0Data[1] = USB_REQUEST_GET_DESCRIPTOR;
0012C0  B3C060     MOV #0x6, W0
0012C2  984090     MOV.B W0, [W1+1]
2090:                                          pEP0Data[2] = countConfigurations-1;
0012C4  21EDA0     MOV #0x1EDA, W0
0012C6  E94010     DEC.B [W0], W0
0012C8  9840A0     MOV.B W0, [W1+2]
2091:                                          pEP0Data[3] = USB_DESCRIPTOR_CONFIGURATION;
0012CA  B3C020     MOV #0x2, W0
0012CC  9840B0     MOV.B W0, [W1+3]
2092:                                          pEP0Data[4] = 0;
0012CE  EB4000     CLR.B W0
0012D0  9840C0     MOV.B W0, [W1+4]
2093:                                          pEP0Data[5] = 0;
0012D2  9840D0     MOV.B W0, [W1+5]
2094:                                          pEP0Data[6] = usbDeviceInfo.pConfigurationDescriptorList->descriptor[2];    // wTotalLength
0012D4  80F630     MOV 0x1EC6, W0
0012D6  780010     MOV [W0], W0
0012D8  904020     MOV.B [W0+2], W0
0012DA  9840E0     MOV.B W0, [W1+6]
2095:                                          pEP0Data[7] = usbDeviceInfo.pConfigurationDescriptorList->descriptor[3];
0012DC  80F630     MOV 0x1EC6, W0
0012DE  780010     MOV [W0], W0
0012E0  904030     MOV.B [W0+3], W0
0012E2  9840F0     MOV.B W0, [W1+7]
2096:                                          _USB_InitControlRead( usbDeviceInfo.pEndpoint0, pEP0Data, 8, usbDeviceInfo.pConfigurationDescriptorList->descriptor,
0012E4  80F630     MOV 0x1EC6, W0
0012E6  780190     MOV [W0], W3
0012E8  904023     MOV.B [W3+2], W0
0012EA  FB8000     ZE W0, W0
0012EC  904233     MOV.B [W3+3], W4
0012EE  DD2248     SL W4, #8, W4
0012F0  720200     IOR W4, W0, W4
0012F2  200082     MOV #0x8, W2
0012F4  37FFAB     BRA 0x124C
2097:                                                  ((USB_CONFIGURATION_DESCRIPTOR *)usbDeviceInfo.pConfigurationDescriptorList->descriptor)->wTotalLength );
2098:                                          _USB_SetNextSubSubState();
2099:                                          break;
2100:              
2101:                                      case SUBSUBSTATE_WAIT_FOR_GET_CONFIG_DESCRIPTOR:
2102:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
2103:                                          {
2104:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
2105:                                              {
2106:                                                  _USB_SetNextSubSubState();
2107:                                              }
2108:                                              else
2109:                                              {
2110:                                                  // We are here because of either a STALL or a NAK.  See if
2111:                                                  // we have retries left to try the command again or try to
2112:                                                  // enumerate again.
2113:                                                  _USB_CheckCommandAndEnumerationAttempts();
2114:                                              }
2115:                                          }
2116:                                          break;
2117:              
2118:                                      case SUBSUBSTATE_GET_CONFIG_DESCRIPTOR_COMPLETE:
2119:                                          // Clean up and advance to the next state.  Keep the data for later use.
2120:                                          _USB_InitErrorCounters();
0012F6  B3C031     MOV #0x3, W1
0012F8  21ED90     MOV #0x1ED9, W0
0012FA  784801     MOV.B W1, [W0]
2121:                                          countConfigurations --;
0012FC  21EDA0     MOV #0x1EDA, W0
0012FE  E94090     DEC.B [W0], W1
001300  784801     MOV.B W1, [W0]
2122:                                          if (countConfigurations)
001304  3A0115     BRA NZ, 0x1530
001306  370110     BRA 0x1528
2123:                                          {
2124:                                              // There are more descriptors that we need to get.
2125:                                              usbHostState = STATE_CONFIGURING | SUBSTATE_GET_CONFIG_DESCRIPTOR_SIZE;
001302  203100     MOV #0x310, W0
2126:                                          }
2127:                                          else
2128:                                          {
2129:                                              // Start configuring the device.
2130:                                              _USB_SetNextSubState();
2131:                                            }
2132:                                          break;
2133:              
2134:                                      default:
2135:                                          break;
2136:                                  }
2137:                                  break;
2138:              
2139:                              case SUBSTATE_SELECT_CONFIGURATION:
2140:                                  // Set the OTG configuration of the device
2141:                                  switch (usbHostState & SUBSUBSTATE_MASK)
001308  80F690     MOV usbHostState, W0
00130A  6000EF     AND W0, #0xF, W1
00130C  508FE1     SUB W1, #0x1, [W15]
00130E  320039     BRA Z, 0x1382
001310  390005     BRA NC, 0x131C
001312  508FE2     SUB W1, #0x2, [W15]
001314  320073     BRA Z, 0x13FC
001316  508FE3     SUB W1, #0x3, [W15]
001318  3A010C     BRA NZ, 0x1532
00131A  37FFC4     BRA 0x12A4
2142:                                  {
2143:                                      case SUBSUBSTATE_SELECT_CONFIGURATION:
2144:                                          // Free the old configuration (if any)
2145:                                          _USB_FreeConfigMemory();
00131C  023298     CALL _USB_FreeConfigMemory
00131E  000000     NOP
2146:              
2147:                                          // If the configuration wasn't selected based on the VID & PID
2148:                                          if (usbDeviceInfo.currentConfiguration == 0)
001320  21EBC0     MOV #0x1EBC, W0
001322  784110     MOV.B [W0], W2
001324  E00402     CP0.B W2
001326  3A0011     BRA NZ, 0x134A
2149:                                          {
2150:                                              // Search for a supported class-specific configuration.
2151:                                              pCurrentConfigurationNode = usbDeviceInfo.pConfigurationDescriptorList;
001328  80F630     MOV 0x1EC6, W0
00132A  37000A     BRA 0x1340
2152:                                              while (pCurrentConfigurationNode)
001342  80F5A0     MOV pCurrentConfigurationNode, W0
001344  E00000     CP0 W0
001346  3AFFF2     BRA NZ, 0x132C
001348  370014     BRA 0x1372
2153:                                              {
2154:                                                  pCurrentConfigurationDescriptor = pCurrentConfigurationNode->descriptor;
00132C  780010     MOV [W0], W0
00132E  88FA80     MOV W0, pCurrentConfigurationDescriptor
2155:                                                  if (_USB_ParseConfigurationDescriptor())
001330  021A76     CALL _USB_ParseConfigurationDescriptor
001332  000000     NOP
001334  E00000     CP0 W0
001336  3A001D     BRA NZ, 0x1372
2156:                                                  {
2157:                                                      break;
2158:                                                  }
2159:                                                  else
2160:                                                  {
2161:                                                      // Free the memory allocated and
2162:                                                      // advance to  next configuration
2163:                                                      _USB_FreeConfigMemory();
001338  023298     CALL _USB_FreeConfigMemory
00133A  000000     NOP
2164:                                                      pCurrentConfigurationNode = pCurrentConfigurationNode->next;
00133C  80F5A0     MOV pCurrentConfigurationNode, W0
00133E  900010     MOV [W0+2], W0
001340  88F5A0     MOV W0, pCurrentConfigurationNode
2165:                                                  }
2166:                                              }
2167:                                          }
2168:                                          else
2169:                                          {
2170:                                              // Configuration selected by VID & PID, initialize data structures
2171:                                              pCurrentConfigurationNode = usbDeviceInfo.pConfigurationDescriptorList;
00134A  80F631     MOV 0x1EC6, W1
00134C  88F5A1     MOV W1, pCurrentConfigurationNode
00134E  370001     BRA 0x1352
2172:                                              while (pCurrentConfigurationNode && pCurrentConfigurationNode->configNumber != usbDeviceInfo.currentConfiguration)
001352  E00001     CP0 W1
001354  320003     BRA Z, 0x135C
001356  904041     MOV.B [W1+4], W0
001358  504F82     SUB.B W0, W2, [W15]
00135A  3AFFFA     BRA NZ, 0x1350
00135C  88F5A1     MOV W1, pCurrentConfigurationNode
2173:                                              {
2174:                                                  pCurrentConfigurationNode = pCurrentConfigurationNode->next;
001350  900091     MOV [W1+2], W1
2175:                                              }
2176:                                              pCurrentConfigurationDescriptor = pCurrentConfigurationNode->descriptor;
00135E  780091     MOV [W1], W1
001360  88FA81     MOV W1, pCurrentConfigurationDescriptor
2177:                                              if (!_USB_ParseConfigurationDescriptor())
001362  021A76     CALL _USB_ParseConfigurationDescriptor
001364  000000     NOP
001366  780400     MOV W0, W8
001368  E00000     CP0 W0
00136A  3A0003     BRA NZ, 0x1372
2178:                                              {
2179:                                                  // Free the memory allocated, config attempt failed.
2180:                                                  _USB_FreeConfigMemory();
00136C  023298     CALL _USB_FreeConfigMemory
00136E  000000     NOP
2181:                                                  pCurrentConfigurationNode = NULL;
001370  88F5A8     MOV W8, pCurrentConfigurationNode
2182:                                              }
2183:                                          }
2184:              
2185:                                          //If No OTG Then
2186:                                          if (usbDeviceInfo.flags.bfConfiguredOTG)
001372  21ECC0     MOV #0x1ECC, W0
001374  784010     MOV.B [W0], W0
001376  604064     AND.B W0, #0x4, W0
001378  3200A0     BRA Z, 0x14BA
2187:                                          {
2188:                                              // Did we fail to configure?
2189:                                              if (pCurrentConfigurationNode == NULL)
00137A  80F5A0     MOV pCurrentConfigurationNode, W0
00137C  E00000     CP0 W0
00137E  3200D4     BRA Z, 0x1528
001380  37009C     BRA 0x14BA
2190:                                              {
2191:                                                  _USB_SetNextSubState();
2192:                                              }
2193:                                              else
2194:                                              {
2195:                                                  _USB_SetNextSubSubState();
2196:                                              }
2197:                                          }
2198:                                          else
2199:                                          {
2200:                                              _USB_SetNextSubSubState();
2201:                                          }
2202:                                          break;
2203:              
2204:                                      case SUBSUBSTATE_SEND_SET_OTG:
2205:                                          #ifdef DEBUG_MODE
2206:                                              UART2PrintString( "HOST: Determine OTG capability.\r\n" );
2207:                                          #endif
2208:              
2209:                                          // If the device does not support OTG, or
2210:                                          // if the device has already been configured, bail.
2211:                                          // Otherwise, send SET FEATURE to configure it.
2212:                                          if (!usbDeviceInfo.flags.bfConfiguredOTG)
001382  21ECC0     MOV #0x1ECC, W0
001384  784090     MOV.B [W0], W1
001386  60C164     AND.B W1, #0x4, W2
001388  3A00CF     BRA NZ, 0x1528
2213:                                          {
2214:                                              #ifdef DEBUG_MODE
2215:                                                  UART2PrintString( "HOST: ...OTG needs configuring.\r\n" );
2216:                                              #endif
2217:                                              usbDeviceInfo.flags.bfConfiguredOTG = 1;
00138A  A02410     BSET.B [W0], #2
2218:              
2219:                                              // Send SET FEATURE
2220:                                              pEP0Data[0] = USB_SETUP_HOST_TO_DEVICE | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
00138C  80F591     MOV pEP0Data, W1
00138E  784882     MOV.B W2, [W1]
2221:                                              pEP0Data[1] = USB_REQUEST_SET_FEATURE;
001390  B3C032     MOV #0x3, W2
001392  984092     MOV.B W2, [W1+1]
2222:                                              if (usbDeviceInfo.flags.bfAllowHNP) // Needs to be set by the user
001394  784010     MOV.B [W0], W0
001396  604068     AND.B W0, #0x8, W0
001398  320002     BRA Z, 0x139E
2223:                                              {
2224:                                                  pEP0Data[2] = OTG_FEATURE_B_HNP_ENABLE;
00139A  9840A2     MOV.B W2, [W1+2]
00139C  370002     BRA 0x13A2
2225:                                              }
2226:                                              else
2227:                                              {
2228:                                                  pEP0Data[2] = OTG_FEATURE_A_HNP_SUPPORT;
00139E  B3C040     MOV #0x4, W0
0013A0  9840A0     MOV.B W0, [W1+2]
2229:                                              }
2230:                                              pEP0Data[3] = 0;
0013A2  EB4000     CLR.B W0
0013A4  9840B0     MOV.B W0, [W1+3]
2231:                                              pEP0Data[4] = 0;
0013A6  9840C0     MOV.B W0, [W1+4]
2232:                                              pEP0Data[5] = 0;
0013A8  9840D0     MOV.B W0, [W1+5]
2233:                                              pEP0Data[6] = 0;
0013AA  9840E0     MOV.B W0, [W1+6]
2234:                                              pEP0Data[7] = 0;
0013AC  9840F0     MOV.B W0, [W1+7]
2235:                                              _USB_InitControlWrite( usbDeviceInfo.pEndpoint0, pEP0Data, 8, NULL, 0 );
0013AE  EB0200     CLR W4
0013B0  780184     MOV W4, W3
0013B2  200082     MOV #0x8, W2
0013B4  80F650     MOV 0x1ECA, W0
0013B6  0231F4     CALL _USB_InitControlWrite
0013B8  000000     NOP
0013BA  37007F     BRA 0x14BA
2236:                                              _USB_SetNextSubSubState();
2237:                                          }
2238:                                          else
2239:                                          {
2240:                                              #ifdef DEBUG_MODE
2241:                                                  UART2PrintString( "HOST: ...No OTG.\r\n" );
2242:                                              #endif
2243:                                              _USB_SetNextSubState();
2244:                                          }
2245:                                          break;
2246:              
2247:                                      case SUBSUBSTATE_WAIT_FOR_SET_OTG_DONE:
2248:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
2249:                                          {
2250:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
2251:                                              {
2252:                                                  #ifdef  USB_SUPPORT_OTG
2253:                                                      if (usbDeviceInfo.flags.bfAllowHNP)
2254:                                                      {
2255:                                                          USBOTGEnableHnp();
2256:                                                      }
2257:                                                   #endif
2258:                                                  _USB_SetNextSubSubState();
2259:                                              }
2260:                                              else
2261:                                              {
2262:                                                  #ifdef  USB_SUPPORT_OTG
2263:                                                      USBOTGDisableHnp();
2264:                                                  #endif
2265:                                                  // We are here because of either a STALL or a NAK.  See if
2266:                                                  // we have retries left to try the command again or try to
2267:                                                  // enumerate again.
2268:                                                  _USB_CheckCommandAndEnumerationAttempts();
2269:              
2270:                                                  #if defined(DEBUG_MODE) && defined(USB_SUPPORT_OTG)
2271:                                                      UART2PrintString( "\r\n***** USB OTG Error - Set Feature B_HNP_ENABLE Stalled - Device Not Responding *****\r\n" );
2272:                                                  #endif
2273:                                              }
2274:                                          }
2275:                                          break;
2276:              
2277:                                      case SUBSUBSTATE_SET_OTG_COMPLETE:
2278:                                           // Clean up and advance to the next state.
2279:                                         _USB_InitErrorCounters();
2280:              
2281:                                          //MR - Moved For OTG Set Feature Support For Unsupported Devices
2282:                                          // Did we fail to configure?
2283:                                          if (pCurrentConfigurationNode == NULL)
2284:                                          {
2285:                                              _USB_SetNextSubState();
2286:                                          }
2287:                                          else
2288:                                          {
2289:                                              //_USB_SetNextSubSubState();
2290:                                              _USB_InitErrorCounters();
2291:                                              _USB_SetNextSubState();
2292:                                          }
2293:                                          break;
2294:              
2295:                                      default:
2296:                                          break;
2297:                                  }
2298:                                  break;
2299:              
2300:                              case SUBSTATE_ENABLE_ACCESSORY:
2301:                                  #ifdef DISABLE_ACCESSORY
2302:                                      _USB_SetNextSubState();
2303:                                  #else
2304:                                      if (pCurrentConfigurationNode == NULL) {
2305:                                          // we haven't found any matching configuration.
2306:                                          // last resort: try to enable the device as an
2307:                                          // android accessory
2308:                                          switch (usbHostState & SUBSUBSTATE_MASK)
2309:                                          {
2310:                                              case SUBSUBSTATE_SEND_GET_PROTOCOL:
2311:                                                  #ifdef DEBUG_MODE
2312:                                                      UART2PrintString( "HOST: Trying to enable accessory mode.\r\n" );
2313:                                                  #endif
2314:                                                  // Set up and send GET DEVICE DESCRIPTOR
2315:                                                  pEP0Data[0] = USB_SETUP_DEVICE_TO_HOST | USB_SETUP_TYPE_VENDOR | USB_SETUP_RECIPIENT_DEVICE;
2316:                                                  pEP0Data[1] = 51;
2317:                                                  pEP0Data[2] = 0;
2318:                                                  pEP0Data[3] = 0;
2319:                                                  pEP0Data[4] = 0;
2320:                                                  pEP0Data[5] = 0;
2321:                                                  pEP0Data[6] = 2;
2322:                                                  pEP0Data[7] = 0;
2323:                                                  _USB_InitControlRead( usbDeviceInfo.pEndpoint0, pEP0Data, 8, (BYTE*)&usbDeviceInfo.accessoryVersion, 2 );
2324:                                                  _USB_SetNextSubSubState();
2325:                                                  break;
2326:              
2327:                                              case SUBSUBSTATE_WAIT_FOR_GET_PROTOCOL:
2328:                                                  if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
2329:                                                  {
2330:                                                      if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
2331:                                                      {
2332:                                                          #ifdef DEBUG_MODE
2333:                                                              UART2PrintString( "HOST: Accessory mode version is: 0x" );
2334:                                                              UART2PutHexWord(usbDeviceInfo.accessoryVersion);
2335:                                                              UART2PrintString( "\r\n" );
2336:                                                          #endif
2337:                                                          if (usbDeviceInfo.accessoryVersion == 0) {
2338:                                                              // failed
2339:                                                              #ifdef DEBUG_MODE
2340:                                                                  UART2PrintString( "HOST: Accessory mode is not supported\r\n" );
2341:                                                              #endif
2342:                                                              _USB_SetNextSubState();
2343:                                                          } else {
2344:                                                            #ifdef DEBUG_MODE
2345:                                                                UART2PrintString( "HOST: Accessory mode is supported\r\n" );
2346:                                                            #endif
2347:                                                            currentDesc = 0;
2348:                                                            _USB_SetNextSubSubState();
2349:                                                          }
2350:                                                      }
2351:                                                      else
2352:                                                      {
2353:                                                          #ifdef DEBUG_MODE
2354:                                                              UART2PrintString( "HOST: Accessory mode version failed.\r\n" );
2355:                                                          #endif
2356:                                                          _USB_SetNextSubState();
2357:                                                      }
2358:                                                  }
2359:                                                  break;
2360:              
2361:                                              case SUBSUBSTATE_SEND_ACCESSORY_STRING:
2362:                                                  #ifdef DEBUG_MODE
2363:                                                      UART2PrintString( "HOST: Sending string\r\n" );
2364:                                                  #endif
2365:                                                  pEP0Data[0] = USB_SETUP_HOST_TO_DEVICE | USB_SETUP_TYPE_VENDOR | USB_SETUP_RECIPIENT_DEVICE;
2366:                                                  pEP0Data[1] = 52;
2367:                                                  pEP0Data[2] = 0;
2368:                                                  pEP0Data[3] = 0;
2369:                                                  pEP0Data[4] = currentDesc;
2370:                                                  pEP0Data[5] = 0;
2371:                                                  pEP0Data[6] = strlen(accessoryDescs[currentDesc]) + 1;
2372:                                                  pEP0Data[7] = 0;
2373:                                                  _USB_InitControlWrite( usbDeviceInfo.pEndpoint0, pEP0Data, 8, (BYTE*) accessoryDescs[currentDesc], pEP0Data[6] );
2374:                                                  _USB_SetNextSubSubState();
2375:                                                  break;
2376:              
2377:                                            case SUBSUBSTATE_WAIT_FOR_ACCESSORY_STRING:
2378:                                                  if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
2379:                                                  {
2380:                                                      if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
2381:                                                      {
2382:                                                          #ifdef DEBUG_MODE
2383:                                                              UART2PrintString( "HOST: Wrote string\r\n" );
2384:                                                          #endif
2385:                                                          if (++currentDesc == 6) {
2386:                                                              // done
2387:                                                              _USB_SetNextSubSubState();
2388:                                                          } else {
2389:                                                              _USB_SetPreviousSubSubState();
2390:                                                          }
2391:                                                      } else {
2392:                                                          #ifdef DEBUG_MODE
2393:                                                              UART2PrintString( "HOST: Failed to write string\r\n" );
2394:                                                          #endif
2395:                                                          _USB_SetNextSubState();
2396:                                                      }
2397:                                                  }
2398:                                                  break;
2399:              
2400:                                            case SUBSUBSTATE_SEND_START_ACCESSORY:
2401:                                                pEP0Data[0] = USB_SETUP_HOST_TO_DEVICE | USB_SETUP_TYPE_VENDOR | USB_SETUP_RECIPIENT_DEVICE;
2402:                                                pEP0Data[1] = 53;
2403:                                                pEP0Data[2] = 0;
2404:                                                pEP0Data[3] = 0;
2405:                                                pEP0Data[4] = 0;
2406:                                                pEP0Data[5] = 0;
2407:                                                pEP0Data[6] = 0;
2408:                                                pEP0Data[7] = 0;
2409:                                                _USB_InitControlWrite( usbDeviceInfo.pEndpoint0, pEP0Data, 8, NULL, 0 );
2410:                                                _USB_SetNextSubSubState();
2411:                                                break;
2412:              
2413:                                            case SUBSUBSTATE_WAIT_FOR_START_ACCESSORY:
2414:                                                  if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
2415:                                                  {
2416:                                                      if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
2417:                                                      {
2418:                                                        #ifdef DEBUG_MODE
2419:                                                            UART2PrintString( "HOST: Started accessory mode. Waiting for reconnect\r\n" );
2420:                                                        #endif
2421:                                                        _USB_SetHoldState();
2422:                                                      } else {
2423:                                                        #ifdef DEBUG_MODE
2424:                                                            UART2PrintString( "HOST: Failed to start accessory mode\r\n" );
2425:                                                        #endif
2426:                                                        _USB_SetNextSubState();
2427:                                                      }
2428:                                                  }
2429:                                                break;
2430:                                          }
2431:                                      } else {
2432:                                        // we're good, move on
2433:                                        _USB_SetNextSubState();
2434:                                      }
2435:                                  #endif
2436:                                  break;
2437:              
2438:                              case SUBSTATE_SET_CONFIGURATION:
2439:                                  if (pCurrentConfigurationNode == NULL) {
0013BC  80F5A2     MOV pCurrentConfigurationNode, W2
0013BE  E00002     CP0 W2
0013C0  3A0005     BRA NZ, 0x13CC
2440:                                      #ifdef CONFIGURE_UNKNOWN_DEVICE
2441:                                              // set usbDeviceInfo.currentConfiguration to a valid value (first)
2442:                                              usbDeviceInfo.currentConfiguration = ((USB_CONFIGURATION_DESCRIPTOR *) usbDeviceInfo.pConfigurationDescriptorList->descriptor)->bConfigurationValue;
0013C2  80F630     MOV 0x1EC6, W0
0013C4  780090     MOV [W0], W1
0013C6  21EBC0     MOV #0x1EBC, W0
0013C8  9040D1     MOV.B [W1+5], W1
0013CA  784801     MOV.B W1, [W0]
2443:                                      #else
2444:                                              // failed
2445:                                              #ifdef DEBUG_MODE
2446:                                                  UART2PrintString( "HOST: Device is not supported\r\n" );
2447:                                              #endif
2448:                                              // Failed to find a supported configuration.
2449:                                              _USB_SetErrorCode( USB_HOLDING_UNSUPPORTED_DEVICE );
2450:                                              _USB_SetHoldState();
2451:                                              break;
2452:                                      #endif
2453:                                  }
2454:              
2455:                                  // Set the configuration to the one specified for this device
2456:                                  switch (usbHostState & SUBSUBSTATE_MASK)
0013CC  80F690     MOV usbHostState, W0
0013CE  60006F     AND W0, #0xF, W0
0013D0  500FE1     SUB W0, #0x1, [W15]
0013D2  320014     BRA Z, 0x13FC
0013D4  390005     BRA NC, 0x13E0
0013D6  500FE2     SUB W0, #0x2, [W15]
0013D8  32001B     BRA Z, 0x1410
0013DA  500FE3     SUB W0, #0x3, [W15]
0013DC  3A00AA     BRA NZ, 0x1532
0013DE  37001F     BRA 0x141E
2457:                                  {
2458:                                      case SUBSUBSTATE_SEND_SET_CONFIGURATION:
2459:                                          #ifdef DEBUG_MODE
2460:                                              UART2PrintString( "HOST: Set configuration.\r\n" );
2461:                                          #endif
2462:              
2463:                                          // Set up and send SET CONFIGURATION.
2464:                                          pEP0Data[0] = USB_SETUP_HOST_TO_DEVICE | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
0013E0  80F591     MOV pEP0Data, W1
0013E2  EB4100     CLR.B W2
0013E4  784882     MOV.B W2, [W1]
2465:                                          pEP0Data[1] = USB_REQUEST_SET_CONFIGURATION;
0013E6  B3C090     MOV #0x9, W0
0013E8  984090     MOV.B W0, [W1+1]
2466:                                          pEP0Data[2] = usbDeviceInfo.currentConfiguration;
0013EA  21EBC0     MOV #0x1EBC, W0
0013EC  784010     MOV.B [W0], W0
0013EE  9840A0     MOV.B W0, [W1+2]
2467:                                          pEP0Data[3] = 0;
0013F0  9840B2     MOV.B W2, [W1+3]
2468:                                          pEP0Data[4] = 0;
0013F2  9840C2     MOV.B W2, [W1+4]
2469:                                          pEP0Data[5] = 0;
0013F4  9840D2     MOV.B W2, [W1+5]
2470:                                          pEP0Data[6] = 0;
0013F6  9840E2     MOV.B W2, [W1+6]
2471:                                          pEP0Data[7] = 0;
0013F8  9840F2     MOV.B W2, [W1+7]
0013FA  37FFD9     BRA 0x13AE
2472:                                          _USB_InitControlWrite( usbDeviceInfo.pEndpoint0, pEP0Data, 8, NULL, 0 );
2473:                                          _USB_SetNextSubSubState();
2474:                                          break;
2475:              
2476:                                      case SUBSUBSTATE_WAIT_FOR_SET_CONFIGURATION:
2477:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
0013FC  80F651     MOV 0x1ECA, W1
0013FE  904031     MOV.B [W1+3], W0
001400  A31800     BTST.Z W0, #1
001402  320097     BRA Z, 0x1532
2478:                                          {
2479:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
001404  904031     MOV.B [W1+3], W0
001406  A30800     BTST.Z W0, #0
001408  3A0058     BRA NZ, 0x14BA
2480:                                              {
2481:                                                  _USB_SetNextSubSubState();
2482:                                              }
2483:                                              else
2484:                                              {
2485:                                                  // We are here because of either a STALL or a NAK.  See if
2486:                                                  // we have retries left to try the command again or try to
2487:                                                  // enumerate again.
2488:                                                  _USB_CheckCommandAndEnumerationAttempts();
00140A  0235A6     CALL _USB_CheckCommandAndEnumerationAttempts
00140C  000000     NOP
00140E  370091     BRA 0x1532
2489:                                              }
2490:                                          }
2491:                                          break;
2492:              
2493:                                      case SUBSUBSTATE_SET_CONFIGURATION_COMPLETE:
2494:                                          if (pCurrentConfigurationNode == NULL) {
001412  E00002     CP0 W2
001414  32001E     BRA Z, 0x1452
2495:                                              // Failed to find a supported configuration.
2496:                                              _USB_SetErrorCode( USB_HOLDING_UNSUPPORTED_DEVICE );
001410  B3C340     MOV #0x34, W0
2497:                                              _USB_SetHoldState();
2498:                                          } else {
2499:                                              // Clean up and advance to the next state.
2500:                                              _USB_InitErrorCounters();
001416  B3C031     MOV #0x3, W1
001418  21ED90     MOV #0x1ED9, W0
00141A  784801     MOV.B W1, [W0]
00141C  37004E     BRA 0x14BA
2501:                                              _USB_SetNextSubSubState();
2502:                                          }
2503:                                          break;
2504:              
2505:                                      case SUBSUBSTATE_INIT_CLIENT_DRIVERS:
2506:                                          #ifdef DEBUG_MODE
2507:                                              UART2PrintString( "HOST: Initializing client drivers...\r\n" );
2508:                                          #endif
2509:                                          _USB_SetNextState();
00141E  80F690     MOV usbHostState, W0
001420  20F001     MOV #0xF00, W1
001422  600001     AND W0, W1, W0
001424  B01000     ADD #0x100, W0
001426  88F690     MOV W0, usbHostState
2510:                                          // Initialize client driver(s) for this configuration.
2511:                                          if (usbDeviceInfo.flags.bfUseDeviceClientDriver)
001428  21ECC0     MOV #0x1ECC, W0
00142A  B3C401     MOV #0x40, W1
00142C  60C010     AND.B W1, [W0], W0
00142E  320015     BRA Z, 0x145A
2512:                                          {
2513:                                              // We have a device that requires only one client driver.  Make sure
2514:                                              // that client driver can initialize this device.  If the client
2515:                                              // driver initialization fails, we cannot enumerate this device.
2516:                                              #ifdef DEBUG_MODE
2517:                                                  UART2PrintString( "HOST: Using device client driver.\r\n" );
2518:                                              #endif
2519:                                              temp = usbDeviceInfo.deviceClientDriver;
001430  21EC10     MOV #0x1EC1, W0
001432  784090     MOV.B [W0], W1
2520:                                              if (!usbClientDrvTable[temp].Initialize(usbDeviceInfo.deviceAddress, usbClientDrvTable[temp].flags, temp, &usbDeviceInfo, NULL))
001434  FB8001     ZE W1, W0
001436  DD0043     SL W0, #3, W0
001438  21F182     MOV #0x1F18, W2
00143A  400182     ADD W0, W2, W3
00143C  780362     MOV [W2+W0], W6
00143E  EB0280     CLR W5
001440  21EBA4     MOV #0x1EBA, W4
001442  900123     MOV [W3+4], W2
001444  9001B3     MOV [W3+6], W3
001446  21EBF0     MOV #0x1EBF, W0
001448  784010     MOV.B [W0], W0
00144A  010006     CALL W6
00144C  E00000     CP0 W0
00144E  3A0071     BRA NZ, 0x1532
2521:                                              {
2522:                                                  _USB_SetErrorCode( USB_HOLDING_CLIENT_INIT_ERROR );
001450  B3C390     MOV #0x39, W0
001452  21EC01     MOV #0x1EC0, W1
001454  784880     MOV.B W0, [W1]
2523:                                                  _USB_SetHoldState();
001456  205000     MOV #0x500, W0
001458  37006B     BRA 0x1530
2524:                                              }
2525:                                          }
2526:                                          else
2527:                                          {
2528:                                              // We have a device that requires multiple client drivers.  Make sure
2529:                                              // every required client driver can initialize this device.  If any
2530:                                              // client driver initialization fails, we cannot enumerate the device.
2531:                                              #ifdef DEBUG_MODE
2532:                                                  UART2PrintString( "HOST: Scanning interfaces.\r\n" );
2533:                                              #endif
2534:                                              pCurrentInterface = usbDeviceInfo.pInterfaceList;
00145A  80F648     MOV 0x1EC8, W8
00145C  370015     BRA 0x1488
2535:                                              while (pCurrentInterface)
001488  E00008     CP0 W8
00148A  3AFFE9     BRA NZ, 0x145E
00148C  370052     BRA 0x1532
2536:                                              {
2537:                                                  temp = pCurrentInterface->clientDriver;
00145E  9040F8     MOV.B [W8+7], W1
2538:                                                  if (!usbClientDrvTable[temp].Initialize(usbDeviceInfo.deviceAddress, usbClientDrvTable[temp].flags, temp, &usbDeviceInfo, pCurrentInterface))
001460  FB8001     ZE W1, W0
001462  DD0043     SL W0, #3, W0
001464  21F182     MOV #0x1F18, W2
001466  400182     ADD W0, W2, W3
001468  780362     MOV [W2+W0], W6
00146A  780288     MOV W8, W5
00146C  21EBA4     MOV #0x1EBA, W4
00146E  900123     MOV [W3+4], W2
001470  9001B3     MOV [W3+6], W3
001472  21EBF0     MOV #0x1EBF, W0
001474  784010     MOV.B [W0], W0
001476  010006     CALL W6
001478  E00000     CP0 W0
00147A  3A0005     BRA NZ, 0x1486
2539:                                                  {
2540:                                                      _USB_SetErrorCode( USB_HOLDING_CLIENT_INIT_ERROR );
00147C  B3C390     MOV #0x39, W0
00147E  21EC01     MOV #0x1EC0, W1
001480  784880     MOV.B W0, [W1]
2541:                                                      _USB_SetHoldState();
001482  205000     MOV #0x500, W0
001484  88F690     MOV W0, usbHostState
2542:                                                  }
2543:                                                  pCurrentInterface = pCurrentInterface->next;
001486  780418     MOV [W8], W8
2544:                                              }
2545:                                          }
2546:                                          break;
2547:              
2548:                                      default:
2549:                                          break;
2550:                                  }
2551:                                  break;
2552:                          }
2553:                          break;
2554:              
2555:                      case STATE_RUNNING:
2556:                          switch (usbHostState & SUBSTATE_MASK)
00148E  80F690     MOV usbHostState, W0
001490  B20F00     AND #0xF0, W0
001492  500FF0     SUB W0, #0x10, [W15]
001494  3A004E     BRA NZ, 0x1532
2557:                          {
2558:                              case SUBSTATE_NORMAL_RUN:
2559:                                  break;
2560:              
2561:                              case SUBSTATE_SUSPEND_AND_RESUME:
2562:                                  switch (usbHostState & SUBSUBSTATE_MASK)
001496  80F690     MOV usbHostState, W0
001498  60006F     AND W0, #0xF, W0
00149A  500FE3     SUB W0, #0x3, [W15]
00149C  320007     BRA Z, 0x14AC
00149E  500FE5     SUB W0, #0x5, [W15]
0014A0  32000F     BRA Z, 0x14C0
0014A2  500FE1     SUB W0, #0x1, [W15]
0014A4  3A0046     BRA NZ, 0x1532
2563:                                  {
2564:                                      case SUBSUBSTATE_SUSPEND:
2565:                                          // The IDLE state has already been set.  We need to wait here
2566:                                          // until the application decides to RESUME.
2567:                                          break;
2568:              
2569:                                      case SUBSUBSTATE_RESUME:
2570:                                          // Issue a RESUME.
2571:                                          U1CONbits.RESUME = 1;
0014A6  A84494     BSET U1CON, #2
2572:              
2573:                                          // Wait for the RESUME time.
2574:                                          numTimerInterrupts      = USB_RESUME_TIME;
0014A8  200150     MOV #0x15, W0
0014AA  370003     BRA 0x14B2
2575:                                          U1OTGIR                 = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
2576:                                          U1OTGIEbits.T1MSECIE    = 1;
2577:              
2578:                                          _USB_SetNextSubSubState();
2579:                                          break;
2580:              
2581:                                      case SUBSUBSTATE_RESUME_WAIT:
2582:                                          // Wait here until the timer expires.
2583:                                          break;
2584:              
2585:                                      case SUBSUBSTATE_RESUME_RECOVERY:
2586:                                          // Turn off RESUME.
2587:                                          U1CONbits.RESUME        = 0;
0014AC  A94494     BCLR U1CON, #2
2588:              
2589:                                          // Start sending SOF's, so the device doesn't go back into the SUSPEND state.
2590:                                          U1CONbits.SOFEN         = 1;
0014AE  A80494     BSET U1CON, #0
2591:              
2592:                                          // Wait for the RESUME recovery time.
2593:                                          numTimerInterrupts      = USB_RESUME_RECOVERY_TIME;
0014B0  2000B0     MOV #0xB, W0
0014B2  88F6B0     MOV W0, numTimerInterrupts
2594:                                          U1OTGIR                 = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
0014B4  200400     MOV #0x40, W0
0014B6  882400     MOV W0, U1OTGIR
2595:                                          U1OTGIEbits.T1MSECIE    = 1;
0014B8  A8C482     BSET U1OTGIE, #6
2596:              
2597:                                          _USB_SetNextSubSubState();
0014BA  80F690     MOV usbHostState, W0
0014BC  E80000     INC W0, W0
0014BE  370038     BRA 0x1530
2598:                                          break;
2599:              
2600:                                      case SUBSUBSTATE_RESUME_RECOVERY_WAIT:
2601:                                          // Wait here until the timer expires.
2602:                                          break;
2603:              
2604:                                      case SUBSUBSTATE_RESUME_COMPLETE:
2605:                                          // Go back to normal running.
2606:                                          usbHostState = STATE_RUNNING | SUBSTATE_NORMAL_RUN;
0014C0  88F698     MOV W8, usbHostState
0014C2  370037     BRA 0x1532
2607:                                          break;
2608:                                  }
2609:                          }
2610:                          break;
2611:              
2612:                      case STATE_HOLDING:
2613:                          switch (usbHostState & SUBSTATE_MASK)
0014C4  80F692     MOV usbHostState, W2
0014C6  B20F02     AND #0xF0, W2
0014C8  3A0034     BRA NZ, 0x1532
2614:                          {
2615:                              case SUBSTATE_HOLD_INIT:
2616:                                  // We're here because we cannot communicate with the current device
2617:                                  // that is plugged in.  Turn off SOF's and all interrupts except
2618:                                  // the DETACH interrupt.
2619:                                  #ifdef DEBUG_MODE
2620:                                      UART2PrintString( "HOST: Holding.\r\n" );
2621:                                  #endif
2622:                                  U1CON               = USB_HOST_MODE_ENABLE | USB_SOF_DISABLE;                       // Turn of SOF's to cut down noise
0014CA  200080     MOV #0x8, W0
0014CC  8824A0     MOV W0, U1CON
2623:                                  U1IE                = 0;
0014CE  882462     MOV W2, U1IE
2624:                                  U1IR                = 0xFF;
0014D0  200FF1     MOV #0xFF, W1
0014D2  882451     MOV W1, U1IR
2625:                                  U1OTGIE             &= 0x8C;
0014D4  2008C0     MOV #0x8C, W0
0014D6  B62482     AND U1OTGIE
2626:                                  U1OTGIR             = 0x7D;
0014D8  50006F     SUB W0, #0xF, W0
0014DA  882400     MOV W0, U1OTGIR
2627:                                  U1EIE               = 0;
0014DC  882482     MOV W2, U1EIE
2628:                                  U1EIR               = 0xFF;
0014DE  882471     MOV W1, U1EIR
2629:                                  U1IEbits.DETACHIE   = 1;
0014E0  A8048C     BSET U1IE, #0
2630:              
2631:                                  #if defined(USB_ENABLE_1MS_EVENT)
2632:                                      U1OTGIR                 = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
2633:                                      U1OTGIEbits.T1MSECIE    = 1;
2634:                                  #endif
2635:              
2636:                                  switch (usbDeviceInfo.errorCode )
0014E2  21EC00     MOV #0x1EC0, W0
0014E4  784110     MOV.B [W0], W2
0014E6  B3C340     MOV #0x34, W0
0014EA  514F80     SUB.B W2, W0, [W15]
0014EC  320015     BRA Z, 0x1518
0014EE  3E0007     BRA GTU, 0x14FE
0014F2  514FE7     SUB.B W2, #0x7, [W15]
0014F4  320011     BRA Z, 0x1518
0014F6  E94000     DEC.B W0, W0
0014F8  514F80     SUB.B W2, W0, [W15]
0014FA  3A000B     BRA NZ, 0x1512
0014FC  370008     BRA 0x150E
0014FE  B3C651     MOV #0x65, W1
001500  B3C350     MOV #0x35, W0
001502  514F80     SUB.B W2, W0, [W15]
001504  320009     BRA Z, 0x1518
001506  404064     ADD.B W0, #0x4, W0
001508  514F80     SUB.B W2, W0, [W15]
00150A  3A0003     BRA NZ, 0x1512
00150C  370004     BRA 0x1516
00150E  B3C6F1     MOV #0x6F, W1
001510  370003     BRA 0x1518
001512  B3C701     MOV #0x70, W1
001514  370001     BRA 0x1518
2637:                                  {
2638:                                      case USB_HOLDING_UNSUPPORTED_HUB:
2639:                                          temp = EVENT_HUB_ATTACH;
2640:                                          break;
0014E8  B3C6C1     MOV #0x6C, W1
2641:              
2642:                                      case USB_HOLDING_UNSUPPORTED_DEVICE:
2643:                                          temp = EVENT_UNSUPPORTED_DEVICE;
2644:              
2645:                                          #ifdef  USB_SUPPORT_OTG
2646:                                          //Abort HNP
2647:                                          USB_OTGEventHandler (0, OTG_EVENT_HNP_ABORT , 0, 0 );
2648:                                          #endif
2649:              
2650:                                          break;
0014F0  E84081     INC.B W1, W1
2651:              
2652:                                      case USB_CANNOT_ENUMERATE:
2653:                                          temp = EVENT_CANNOT_ENUMERATE;
2654:                                          break;
001516  B3C6E1     MOV #0x6E, W1
2655:              
2656:                                      case USB_HOLDING_CLIENT_INIT_ERROR:
2657:                                          temp = EVENT_CLIENT_INIT_ERROR;
2658:                                          break;
2659:              
2660:                                      case USB_HOLDING_OUT_OF_MEMORY:
2661:                                          temp = EVENT_OUT_OF_MEMORY;
2662:                                          break;
2663:              
2664:                                      default:
2665:                                          temp = EVENT_UNSPECIFIED_ERROR; // This should never occur
2666:                                          break;
2667:                                  }
2668:              
2669:                                  // Report the problem to the application.
2670:                                  USB_HOST_APP_EVENT_HANDLER( usbDeviceInfo.deviceAddress, temp, &usbDeviceInfo.currentConfigurationPower , 1 );
001518  FB8081     ZE W1, W1
00151A  200014     MOV #0x1, W4
00151C  200005     MOV #0x0, W5
00151E  21EC22     MOV #0x1EC2, W2
001520  21EBF0     MOV #0x1EBF, W0
001522  784010     MOV.B [W0], W0
001524  022C18     CALL USB_ApplicationEventHandler
001526  000000     NOP
2671:              
2672:                                  _USB_SetNextSubState();
001528  80F690     MOV usbHostState, W0
00152A  20FF01     MOV #0xFF0, W1
00152C  600001     AND W0, W1, W0
00152E  400070     ADD W0, #0x10, W0
001530  88F690     MOV W0, usbHostState
2673:                                  break;
2674:              
2675:                              case SUBSTATE_HOLD:
2676:                                  // Hold here until a DETACH interrupt frees us.
2677:                                  break;
2678:              
2679:                              default:
2680:                                  break;
2681:                          }
2682:                          break;
2683:                  }
2684:              
2685:              }
2686:              
2687:              /****************************************************************************
2688:                Function:
2689:                  void USBHostTerminateTransfer( BYTE deviceAddress, BYTE endpoint )
2690:              
2691:              
2692:                Summary:
2693:                  This function terminates the current transfer for the given endpoint.
2694:              
2695:                Description:
2696:                  This function terminates the current transfer for the given endpoint.  It
2697:                  can be used to terminate reads or writes that the device is not
2698:                  responding to.  It is also the only way to terminate an isochronous
2699:                  transfer.
2700:              
2701:                Precondition:
2702:                  None
2703:              
2704:                Parameters:
2705:                  BYTE deviceAddress  - Device address
2706:                  BYTE endpoint       - Endpoint number
2707:              
2708:                Returns:
2709:                  None
2710:              
2711:                Remarks:
2712:                  None
2713:                ***************************************************************************/
2714:              
2715:              void USBHostTerminateTransfer( BYTE deviceAddress, BYTE endpoint )
2716:              {
2717:                  USB_ENDPOINT_INFO *ep;
2718:              
2719:                  // Find the required device
2720:                  if (deviceAddress != usbDeviceInfo.deviceAddress)
00374C  21EBF1     MOV #0x1EBF, W1
00374E  504F91     SUB.B W0, [W1], [W15]
003750  3A000C     BRA NZ, 0x376A
2721:                  {
2722:                      return; // USB_UNKNOWN_DEVICE;
2723:                  }
2724:              
2725:                  ep = _USB_FindEndpoint( endpoint );
003752  784002     MOV.B W2, W0
003754  0236A4     CALL _USB_FindEndpoint
003756  000000     NOP
003758  780080     MOV W0, W1
2726:                  if (ep != NULL)
00375A  E00000     CP0 W0
00375C  320006     BRA Z, 0x376A
2727:                  {
2728:                      ep->status.bfUserAbort          = 1;
00375E  904020     MOV.B [W0+2], W0
003760  A07400     BSET.B W0, #7
003762  9840A0     MOV.B W0, [W1+2]
2729:                      ep->status.bfTransferComplete   = 1;
2730:                  }
2731:              }
2732:              
2733:              /****************************************************************************
2734:                Function:
2735:                  BOOL USBHostTransferIsComplete( BYTE deviceAddress, BYTE endpoint,
2736:                                      BYTE *errorCode, DWORD *byteCount )
2737:              
2738:                Summary:
2739:                  This function initiates whether or not the last endpoint transaction is
2740:                  complete.
2741:              
2742:                Description:
2743:                  This function initiates whether or not the last endpoint transaction is
2744:                  complete.  If it is complete, an error code and the number of bytes
2745:                  transferred are returned.
2746:              
2747:                  For isochronous transfers, byteCount is not valid.  Instead, use the
2748:                  returned byte counts for each EVENT_TRANSFER event that was generated
2749:                  during the transfer.
2750:              
2751:                Precondition:
2752:                  None
2753:              
2754:                Parameters:
2755:                  BYTE deviceAddress  - Device address
2756:                  BYTE endpoint       - Endpoint number
2757:                  BYTE *errorCode     - Error code indicating the status of the transfer.
2758:                                          Only valid if the transfer is complete.
2759:                  DWORD *byteCount    - The number of bytes sent or received.  Invalid
2760:                                          for isochronous transfers.
2761:              
2762:                Return Values:
2763:                  TRUE    - Transfer is complete.
2764:                  FALSE   - Transfer is not complete.
2765:              
2766:                Remarks:
2767:                  Possible values for errorCode are:
2768:                      * USB_SUCCESS                     - Transfer successful
2769:                      * USB_UNKNOWN_DEVICE              - Device not attached
2770:                      * USB_ENDPOINT_STALLED            - Endpoint STALL'd
2771:                      * USB_ENDPOINT_ERROR_ILLEGAL_PID  - Illegal PID returned
2772:                      * USB_ENDPOINT_ERROR_BIT_STUFF
2773:                      * USB_ENDPOINT_ERROR_DMA
2774:                      * USB_ENDPOINT_ERROR_TIMEOUT
2775:                      * USB_ENDPOINT_ERROR_DATA_FIELD
2776:                      * USB_ENDPOINT_ERROR_CRC16
2777:                      * USB_ENDPOINT_ERROR_END_OF_FRAME
2778:                      * USB_ENDPOINT_ERROR_PID_CHECK
2779:                      * USB_ENDPOINT_ERROR              - Other error
2780:                ***************************************************************************/
2781:              
2782:              BOOL USBHostTransferIsComplete( BYTE deviceAddress, BYTE endpoint, BYTE *errorCode,
2783:                          DWORD *byteCount )
2784:              {
2785:                  USB_ENDPOINT_INFO   *ep;
2786:                  BYTE                transferComplete;
2787:              
2788:                  // Find the required device
2789:                  if (deviceAddress != usbDeviceInfo.deviceAddress)
002FD6  21EBF1     MOV #0x1EBF, W1
002FD8  504F91     SUB.B W0, [W1], [W15]
002FDA  320005     BRA Z, 0x2FE6
2790:                  {
2791:                      *errorCode = USB_UNKNOWN_DEVICE;
002FDC  B3C060     MOV #0x6, W0
002FDE  784900     MOV.B W0, [W2]
2792:                      *byteCount = 0;
002FE0  EB0980     CLR [W3]
002FE2  7811B3     MOV [W3++], [W3--]
002FE4  370022     BRA 0x302A
2793:                      return TRUE;
2794:                  }
2795:              
2796:                  ep = _USB_FindEndpoint( endpoint );
002FE6  784004     MOV.B W4, W0
002FE8  0236A4     CALL _USB_FindEndpoint
002FEA  000000     NOP
002FEC  780080     MOV W0, W1
2797:                  if (ep != NULL)
002FEE  E00000     CP0 W0
002FF0  32001A     BRA Z, 0x3026
2798:                  {
2799:                      // bfTransferComplete, the status flags, and byte count can be
2800:                      // changed in an interrupt service routine.  Therefore, we'll
2801:                      // grab it first, save it locally, and then determine the rest of
2802:                      // the information.  It is better to say that the transfer is not
2803:                      // yet complete, since the caller will simply try again.
2804:              
2805:                      // Save off the Transfer Complete status.  That way, we won't
2806:                      // load up bad values and then say the transfer is complete.
2807:                      transferComplete = ep->status.bfTransferComplete;
002FF2  904030     MOV.B [W0+3], W0
002FF4  D10000     LSR W0, W0
002FF6  600161     AND W0, #0x1, W2
2808:              
2809:                      // Set up error code.  This is only valid if the transfer is complete.
2810:                      if (ep->status.bfTransferSuccessful)
002FF8  904031     MOV.B [W1+3], W0
002FFA  A30800     BTST.Z W0, #0
002FFC  320005     BRA Z, 0x3008
2811:                      {
2812:                          *errorCode = USB_SUCCESS;
002FFE  EB4C00     CLR.B [W8]
2813:                          *byteCount = ep->dataCount;
003000  900A01     MOV [W1+16], W4
003002  900A91     MOV [W1+18], W5
003004  BE8C84     MOV.D W4, [W9]
003006  37000D     BRA 0x3022
2814:                      }
2815:                      else if (ep->status.bfStalled)
003008  904021     MOV.B [W1+2], W0
00300A  A35800     BTST.Z W0, #5
00300C  320002     BRA Z, 0x3012
2816:                      {
2817:                          *errorCode = USB_ENDPOINT_STALLED;
00300E  B3C110     MOV #0x11, W0
003010  370007     BRA 0x3020
2818:                      }
2819:                      else if (ep->status.bfError)
003012  904021     MOV.B [W1+2], W0
003014  A36800     BTST.Z W0, #6
003016  320003     BRA Z, 0x301E
2820:                      {
2821:                          *errorCode = ep->bErrorCode;
003018  9058C1     MOV.B [W1+28], W1
00301A  784C01     MOV.B W1, [W8]
00301C  370002     BRA 0x3022
2822:                      }
2823:                      else
2824:                      {
2825:                          *errorCode = USB_ENDPOINT_UNRESOLVED_STATE;
00301E  B3C190     MOV #0x19, W0
003020  784C00     MOV.B W0, [W8]
2826:                      }
2827:              
2828:                      return transferComplete;
003022  FB8002     ZE W2, W0
003024  370003     BRA 0x302C
2829:                  }
2830:              
2831:                  // The endpoint was not found.  Return TRUE so we can return a valid error code.
2832:                  *errorCode = USB_ENDPOINT_NOT_FOUND;
003026  B3C140     MOV #0x14, W0
003028  784C00     MOV.B W0, [W8]
00302A  200010     MOV #0x1, W0
2833:                  return TRUE;
2834:              }
2835:              
2836:              /****************************************************************************
2837:                Function:
2838:                  BYTE  USBHostVbusEvent( USB_EVENT vbusEvent, BYTE hubAddress,
2839:                                                      BYTE portNumber)
2840:              
2841:                Summary:
2842:                  This function handles Vbus events that are detected by the application.
2843:              
2844:                Description:
2845:                  This function handles Vbus events that are detected by the application.
2846:                  Since Vbus management is application dependent, the application is
2847:                  responsible for monitoring Vbus and detecting overcurrent conditions
2848:                  and removal of the overcurrent condition.  If the application detects
2849:                  an overcurrent condition, it should call this function with the event
2850:                  EVENT_VBUS_OVERCURRENT with the address of the hub and port number that
2851:                  has the condition.  When a port returns to normal operation, the
2852:                  application should call this function with the event
2853:                  EVENT_VBUS_POWER_AVAILABLE so the stack knows that it can allow devices
2854:                  to attach to that port.
2855:              
2856:                Precondition:
2857:                  None
2858:              
2859:                Parameters:
2860:                  USB_EVENT vbusEvent     - Vbus event that occured.  Valid events:
2861:                                                  * EVENT_VBUS_OVERCURRENT
2862:                                                  * EVENT_VBUS_POWER_AVAILABLE
2863:                  BYTE hubAddress         - Address of the hub device (USB_ROOT_HUB for the
2864:                                              root hub)
2865:                  BYTE portNumber         - Number of the physical port on the hub (0 - based)
2866:              
2867:                Return Values:
2868:                  USB_SUCCESS             - Event handled
2869:                  USB_ILLEGAL_REQUEST     - Invalid event, hub, or port
2870:              
2871:                Remarks:
2872:                  None
2873:                ***************************************************************************/
2874:              
2875:              BYTE  USBHostVbusEvent(USB_EVENT vbusEvent, BYTE hubAddress, BYTE portNumber)
2876:              {
2877:                  if ((hubAddress == USB_ROOT_HUB) &&
003700  40CFE1     ADD.B W1, #0x1, [W15]
003702  3A0010     BRA NZ, 0x3724
003704  E00402     CP0.B W2
003706  3A000E     BRA NZ, 0x3724
2878:                      (portNumber == 0 ))
2879:                  {
2880:                      if (vbusEvent == EVENT_VBUS_OVERCURRENT)
003708  200680     MOV #0x68, W0
00370A  518F80     SUB W3, W0, [W15]
00370C  3A0005     BRA NZ, 0x3718
2881:                      {
2882:                          USBHostShutdown();
00370E  023504     CALL USBHostShutdown
003710  000000     NOP
2883:                          usbRootHubInfo.flags.bPowerGoodPort0 = 0;
003712  21EB80     MOV #0x1EB8, W0
003714  A10410     BCLR.B [W0], #0
003716  370005     BRA 0x3722
2884:                          return USB_SUCCESS;
2885:                      }
2886:                      if (vbusEvent == EVENT_VBUS_POWER_AVAILABLE)
003718  2006B0     MOV #0x6B, W0
00371A  518F80     SUB W3, W0, [W15]
00371C  3A0003     BRA NZ, 0x3724
2887:                      {
2888:                          usbRootHubInfo.flags.bPowerGoodPort0 = 1;
00371E  21EB80     MOV #0x1EB8, W0
003720  A00410     BSET.B [W0], #0
003722  050000     RETLW #0x0, W0
2889:                          return USB_SUCCESS;
2890:                      }
2891:                  }
2892:              
2893:                  return USB_ILLEGAL_REQUEST;
2894:              }
2895:              
2896:              
2897:              /****************************************************************************
2898:                Function:
2899:                  BYTE USBHostWrite( BYTE deviceAddress, BYTE endpoint, BYTE *data,
2900:                                      DWORD size )
2901:              
2902:                Summary:
2903:                  This function initiates a write to the attached device.
2904:              
2905:                Description:
2906:                  This function initiates a write to the attached device.  The data buffer
2907:                  pointed to by *data must remain valid during the entire time that the
2908:                  write is taking place; the data is not buffered by the stack.
2909:              
2910:                  If the endpoint is isochronous, special conditions apply.  The pData and
2911:                  size parameters have slightly different meanings, since multiple buffers
2912:                  are required.  Once started, an isochronous transfer will continue with
2913:                  no upper layer intervention until USBHostTerminateTransfer() is called.
2914:                  The ISOCHRONOUS_DATA_BUFFERS structure should not be manipulated until
2915:                  the transfer is terminated.
2916:              
2917:                  To clarify parameter usage and to simplify casting, use the macro
2918:                  USBHostWriteIsochronous() when writing to an isochronous endpoint.
2919:              
2920:                Precondition:
2921:                  None
2922:              
2923:                Parameters:
2924:                  BYTE deviceAddress  - Device address
2925:                  BYTE endpoint       - Endpoint number
2926:                  BYTE *data          - Pointer to where the data is stored. If the endpoint
2927:                                          is isochronous, this points to an
2928:                                          ISOCHRONOUS_DATA_BUFFERS structure, with multiple
2929:                                          data buffer pointers.
2930:                  DWORD size          - Number of data bytes to send. If the endpoint is
2931:                                          isochronous, this is the number of data buffer
2932:                                          pointers pointed to by pData.
2933:              
2934:                Return Values:
2935:                  USB_SUCCESS                     - Write started successfully.
2936:                  USB_UNKNOWN_DEVICE              - Device with the specified address not found.
2937:                  USB_INVALID_STATE               - We are not in a normal running state.
2938:                  USB_ENDPOINT_ILLEGAL_TYPE       - Must use USBHostControlWrite to write
2939:                                                      to a control endpoint.
2940:                  USB_ENDPOINT_ILLEGAL_DIRECTION  - Must write to an OUT endpoint.
2941:                  USB_ENDPOINT_STALLED            - Endpoint is stalled.  Must be cleared
2942:                                                      by the application.
2943:                  USB_ENDPOINT_ERROR              - Endpoint has too many errors.  Must be
2944:                                                      cleared by the application.
2945:                  USB_ENDPOINT_BUSY               - A Write is already in progress.
2946:                  USB_ENDPOINT_NOT_FOUND          - Invalid endpoint.
2947:              
2948:                Remarks:
2949:                  None
2950:                ***************************************************************************/
2951:              
2952:              BYTE USBHostWrite( BYTE deviceAddress, BYTE endpoint, BYTE *data, DWORD size )
2953:              {
2954:                  USB_ENDPOINT_INFO *ep;
2955:              
2956:                  // Find the required device
2957:                  if (deviceAddress != usbDeviceInfo.deviceAddress)
002F0C  200062     MOV #0x6, W2
002F0E  21EBF1     MOV #0x1EBF, W1
002F10  504F91     SUB.B W0, [W1], [W15]
002F12  3A0028     BRA NZ, 0x2F64
2958:                  {
2959:                      return USB_UNKNOWN_DEVICE;
2960:                  }
2961:              
2962:                  // If we are not in a normal user running state, we cannot do this.
2963:                  if ((usbHostState & STATE_MASK) != STATE_RUNNING)
002F14  80F690     MOV usbHostState, W0
002F16  20F001     MOV #0xF00, W1
002F18  600001     AND W0, W1, W0
002F1A  200012     MOV #0x1, W2
002F1C  204001     MOV #0x400, W1
002F1E  500F81     SUB W0, W1, [W15]
002F20  3A0021     BRA NZ, 0x2F64
2964:                  {
2965:                      return USB_INVALID_STATE;
2966:                  }
2967:              
2968:                  ep = _USB_FindEndpoint( endpoint );
002F22  784003     MOV.B W3, W0
002F24  0236A4     CALL _USB_FindEndpoint
002F26  000000     NOP
002F28  780180     MOV W0, W3
2969:                  if (ep != NULL)
002F2A  200142     MOV #0x14, W2
002F2C  E00000     CP0 W0
002F2E  32001A     BRA Z, 0x2F64
2970:                  {
2971:                      if (ep->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_CONTROL)
002F30  900850     MOV [W0+26], W0
002F32  B23000     AND #0x300, W0
002F34  200182     MOV #0x18, W2
002F36  320016     BRA Z, 0x2F64
2972:                      {
2973:                          // Must not be a control endpoint.
2974:                          return USB_ENDPOINT_ILLEGAL_TYPE;
2975:                      }
2976:              
2977:                      if (ep->bEndpointAddress & 0x80)
002F38  905823     MOV.B [W3+26], W0
002F3A  200152     MOV #0x15, W2
002F3C  E00400     CP0.B W0
002F3E  350012     BRA LT, 0x2F64
2978:                      {
2979:                          // Trying to do an OUT with an IN endpoint.
2980:                          return USB_ENDPOINT_ILLEGAL_DIRECTION;
2981:                      }
2982:              
2983:                      if (ep->status.bfStalled)
002F40  904023     MOV.B [W3+2], W0
002F42  200112     MOV #0x11, W2
002F44  A35800     BTST.Z W0, #5
002F46  3A000E     BRA NZ, 0x2F64
2984:                      {
2985:                          // The endpoint is stalled.  It must be restarted before a write
2986:                          // can be performed.
2987:                          return USB_ENDPOINT_STALLED;
2988:                      }
2989:              
2990:                      if (ep->status.bfError)
002F48  904023     MOV.B [W3+2], W0
002F4A  200122     MOV #0x12, W2
002F4C  A36800     BTST.Z W0, #6
002F4E  3A000A     BRA NZ, 0x2F64
2991:                      {
2992:                          // The endpoint has errored.  The error must be cleared before a
2993:                          // write can be performed.
2994:                          return USB_ENDPOINT_ERROR;
2995:                      }
2996:              
2997:                      if (!ep->status.bfTransferComplete)
002F50  904033     MOV.B [W3+3], W0
002F52  200102     MOV #0x10, W2
002F54  A31800     BTST.Z W0, #1
002F56  320006     BRA Z, 0x2F64
2998:                      {
2999:                          // We are already processing a request for this endpoint.
3000:                          return USB_ENDPOINT_BUSY;
3001:                      }
3002:              
3003:                      _USB_InitWrite( ep, data, size );
002F58  780108     MOV W8, W2
002F5A  78008A     MOV W10, W1
002F5C  780003     MOV W3, W0
002F5E  023144     CALL _USB_InitWrite
002F60  000000     NOP
002F62  EB0100     CLR W2
3004:              
3005:                      return USB_SUCCESS;
3006:                  }
3007:                  return USB_ENDPOINT_NOT_FOUND;   // Endpoint not found
3008:              }
3009:              
3010:              
3011:              // *****************************************************************************
3012:              // *****************************************************************************
3013:              // Section: Internal Functions
3014:              // *****************************************************************************
3015:              // *****************************************************************************
3016:              
3017:              /****************************************************************************
3018:                Function:
3019:                  void _USB_CheckCommandAndEnumerationAttempts( void )
3020:              
3021:                Summary:
3022:                  This function is called when we've received a STALL or a NAK when trying
3023:                  to enumerate.
3024:              
3025:                Description:
3026:                  This function is called when we've received a STALL or a NAK when trying
3027:                  to enumerate.  We allow so many attempts at each command, and so many
3028:                  attempts at enumeration.  If the command fails and there are more command
3029:                  attempts, we try the command again.  If the command fails and there are
3030:                  more enumeration attempts, we reset and try to enumerate again.
3031:                  Otherwise, we go to the holding state.
3032:              
3033:                Precondition:
3034:                  usbHostState != STATE_RUNNING
3035:              
3036:                Parameters:
3037:                  None - None
3038:              
3039:                Returns:
3040:                  None
3041:              
3042:                Remarks:
3043:                  None
3044:                ***************************************************************************/
3045:              
3046:              void _USB_CheckCommandAndEnumerationAttempts( void )
3047:              {
3048:                  #ifdef DEBUG_MODE
3049:                      UART2PutChar( '=' );
3050:                  #endif
3051:              
3052:                  // Clear the error and stall flags.  A stall here does not require
3053:                  // host intervention to clear.
3054:                  pCurrentEndpoint->status.bfError    = 0;
0035A6  80F6A1     MOV pCurrentEndpoint, W1
0035A8  904021     MOV.B [W1+2], W0
0035AA  A16400     BCLR.B W0, #6
0035AC  9840A0     MOV.B W0, [W1+2]
3055:                  pCurrentEndpoint->status.bfStalled  = 0;
0035AE  904021     MOV.B [W1+2], W0
0035B0  A15400     BCLR.B W0, #5
0035B2  9840A0     MOV.B W0, [W1+2]
3056:              
3057:                  numCommandTries --;
0035B4  21ED90     MOV #0x1ED9, W0
0035B6  E94090     DEC.B [W0], W1
0035B8  784801     MOV.B W1, [W0]
3058:                  if (numCommandTries != 0)
0035BA  320004     BRA Z, 0x35C4
3059:                  {
3060:                      // We still have retries left on this command.  Try again.
3061:                      usbHostState &= ~SUBSUBSTATE_MASK;
0035BC  80F690     MOV usbHostState, W0
0035BE  2FFF01     MOV #0xFFF0, W1
0035C0  600001     AND W0, W1, W0
0035C2  370009     BRA 0x35D6
3062:                  }
3063:                  else
3064:                  {
3065:                      // This command has timed out.
3066:                      // We are enumerating.  See if we can try to enumerate again.
3067:                      numEnumerationTries --;
0035C4  21ED80     MOV #0x1ED8, W0
0035C6  E94090     DEC.B [W0], W1
0035C8  784801     MOV.B W1, [W0]
3068:                      if (numEnumerationTries != 0)
0035CC  3A0004     BRA NZ, 0x35D6
3069:                      {
3070:                          // We still have retries left to try to enumerate.  Reset and try again.
3071:                          usbHostState = STATE_ATTACHED | SUBSTATE_RESET_DEVICE;
0035CA  201100     MOV #0x110, W0
3072:                      }
3073:                      else
3074:                      {
3075:                          // Give up.  The device is not responding properly.
3076:                          _USB_SetErrorCode( USB_CANNOT_ENUMERATE );
0035CE  B3C070     MOV #0x7, W0
0035D0  21EC01     MOV #0x1EC0, W1
0035D2  784880     MOV.B W0, [W1]
3077:                          _USB_SetHoldState();
3078:                      }
3079:                  }
3080:              }
3081:              
3082:              
3083:              /****************************************************************************
3084:                Function:
3085:                  BOOL _USB_FindClassDriver( BYTE bClass, BYTE bSubClass, BYTE bProtocol, BYTE *pbClientDrv )
3086:              
3087:                Summary:
3088:              
3089:              
3090:                Description:
3091:                  This routine scans the TPL table looking for the entry with
3092:                              the given class, subclass, and protocol values.
3093:              
3094:                Precondition:
3095:                  usbTPL must be define by the application.
3096:              
3097:                Parameters:
3098:                  bClass      - The class of the desired entry
3099:                  bSubClass   - The subclass of the desired entry
3100:                  bProtocol   - The protocol of the desired entry
3101:                  pbClientDrv - Returned index to the client driver in the client driver
3102:                                  table.
3103:              
3104:                Return Values:
3105:                  TRUE    - A class driver was found.
3106:                  FALSE   - A class driver was not found.
3107:              
3108:                Remarks:
3109:                  None
3110:                ***************************************************************************/
3111:              
3112:              BOOL _USB_FindClassDriver( BYTE bClass, BYTE bSubClass, BYTE bProtocol, BYTE *pbClientDrv )
3113:              {
3114:                  USB_OVERRIDE_CLIENT_DRIVER_EVENT_DATA   eventData;
3115:                  int                                     i;
3116:                  USB_DEVICE_DESCRIPTOR                   *pDesc = (USB_DEVICE_DESCRIPTOR *)pDeviceDescriptor;
002E34  80FA73     MOV pDeviceDescriptor, W3
3117:              
3118:                  i = 0;
3119:                  while (i < NUM_TPL_ENTRIES)
3120:                  {
3121:                      if (usbTPL[i].flags.bfIsInterfaceDriver)
002E36  80F8B0     MOV 0x1F16, W0
002E38  A34800     BTST.Z W0, #4
002E3A  32002A     BRA Z, 0x2E90
3122:                      {
3123:                          if ((usbTPL[i].flags.bfIsClassDriver == 1        ) &&
002E3C  A31800     BTST.Z W0, #1
002E3E  320028     BRA Z, 0x2E90
002E40  21F100     MOV #0x1F10, W0
002E42  784310     MOV.B [W0], W6
002E44  534F84     SUB.B W6, W4, [W15]
002E46  3A0024     BRA NZ, 0x2E90
002E48  21F110     MOV #0x1F11, W0
002E4A  784290     MOV.B [W0], W5
002E4C  52CF81     SUB.B W5, W1, [W15]
002E4E  3A0020     BRA NZ, 0x2E90
002E50  21F120     MOV #0x1F12, W0
002E52  784210     MOV.B [W0], W4
002E54  524F82     SUB.B W4, W2, [W15]
002E56  3A001C     BRA NZ, 0x2E90
3124:                              (usbTPL[i].device.bClass         == bClass   ) &&
3125:                              (usbTPL[i].device.bSubClass      == bSubClass) &&
3126:                              (usbTPL[i].device.bProtocol      == bProtocol)   )
3127:                          {
3128:                              // Make sure the application layer does not have a problem with the selection.
3129:                              // If the application layer returns FALSE, which it should if the event is not
3130:                              // defined, then accept the selection.
3131:                              eventData.idVendor          = pDesc->idVendor;
002E58  904883     MOV.B [W3+8], W1
002E5A  FB8081     ZE W1, W1
002E5C  904813     MOV.B [W3+9], W0
002E5E  DD0048     SL W0, #8, W0
002E60  700081     IOR W0, W1, W1
002E62  9FBFB1     MOV W1, [W15-10]
3132:                              eventData.idProduct         = pDesc->idProduct;
002E64  9048A3     MOV.B [W3+10], W1
002E66  FB8081     ZE W1, W1
002E68  904833     MOV.B [W3+11], W0
002E6A  DD0048     SL W0, #8, W0
002E6C  700001     IOR W0, W1, W0
002E6E  9FBFC0     MOV W0, [W15-8]
3133:                              eventData.bDeviceClass      = bClass;
002E70  9FFFA6     MOV.B W6, [W15-6]
3134:                              eventData.bDeviceSubClass   = bSubClass;
002E72  9FFFB5     MOV.B W5, [W15-5]
3135:                              eventData.bDeviceProtocol   = bProtocol;
002E74  9FFFC4     MOV.B W4, [W15-4]
3136:              
3137:                              if (!USB_HOST_APP_EVENT_HANDLER( USB_ROOT_HUB, EVENT_OVERRIDE_CLIENT_DRIVER_SELECTION,
002E76  200084     MOV #0x8, W4
002E78  200005     MOV #0x0, W5
002E7A  57816A     SUB W15, #0xA, W2
002E7C  200791     MOV #0x79, W1
002E7E  EBC000     SETM.B W0
002E80  022C18     CALL USB_ApplicationEventHandler
002E82  000000     NOP
002E84  E00000     CP0 W0
002E86  3A0004     BRA NZ, 0x2E90
3138:                                              &eventData, sizeof(USB_OVERRIDE_CLIENT_DRIVER_EVENT_DATA) ))
3139:                              {
3140:                                  *pbClientDrv = usbTPL[i].ClientDriver;
002E88  21F150     MOV #0x1F15, W0
002E8A  784C10     MOV.B [W0], [W8]
002E8C  200010     MOV #0x1, W0
002E8E  370001     BRA 0x2E92
3141:                                  #ifdef DEBUG_MODE
3142:                                      UART2PrintString( "HOST: Client driver found.\r\n" );
3143:                                  #endif
3144:                                  return TRUE;
002E90  EB0000     CLR W0
3145:                              }
3146:                          }
3147:                      }
3148:                      i++;
3149:                  }
3150:              
3151:                  #ifdef DEBUG_MODE
3152:                      UART2PrintString( "HOST: Client driver NOT found.\r\n" );
3153:                  #endif
3154:                  return FALSE;
3155:              
3156:              } // _USB_FindClassDriver
3157:              
3158:              
3159:              /****************************************************************************
3160:                Function:
3161:                  BOOL _USB_FindDeviceLevelClientDriver( void )
3162:              
3163:                Description:
3164:                  This function searches the TPL to try to find a device-level client
3165:                  driver.
3166:              
3167:                Precondition:
3168:                  * usbHostState == STATE_ATTACHED|SUBSTATE_VALIDATE_VID_PID
3169:                  * usbTPL must be define by the application.
3170:              
3171:                Parameters:
3172:                  None - None
3173:              
3174:                Return Values:
3175:                  TRUE    - Client driver found
3176:                  FALSE   - Client driver not found
3177:              
3178:                Remarks:
3179:                  If successful, this function preserves the client's index from the client
3180:                  driver table and sets flags indicating that the device should use a
3181:                  single client driver.
3182:                ***************************************************************************/
3183:              
3184:              BOOL _USB_FindDeviceLevelClientDriver( void )
3185:              {
3186:                  WORD                   i;
3187:                  USB_DEVICE_DESCRIPTOR *pDesc = (USB_DEVICE_DESCRIPTOR *)pDeviceDescriptor;
002CC6  80FA72     MOV pDeviceDescriptor, W2
3188:              
3189:                  // Scan TPL
3190:                  i = 0;
3191:                  usbDeviceInfo.flags.bfUseDeviceClientDriver = 0;
002CC8  21ECC3     MOV #0x1ECC, W3
002CCA  A16413     BCLR.B [W3], #6
3192:                  while (i < NUM_TPL_ENTRIES)
3193:                  {
3194:                      if (usbTPL[i].flags.bfIsDeviceDriver)
002CCC  80F8B0     MOV 0x1F16, W0
002CCE  A33800     BTST.Z W0, #3
002CD0  320038     BRA Z, 0x2D42
3195:                      {
3196:                        if (usbTPL[i].flags.bfIsClassDriver)
002CD2  A31800     BTST.Z W0, #1
002CD4  32000E     BRA Z, 0x2CF2
3197:                        {
3198:                            // Check for a device-class client driver
3199:                            if ((usbTPL[i].device.bClass    == pDesc->bDeviceClass   ) &&
002CD6  9040C2     MOV.B [W2+4], W1
002CD8  21F100     MOV #0x1F10, W0
002CDA  10CF90     SUBR.B W1, [W0], [W15]
002CDC  3A0022     BRA NZ, 0x2D22
002CDE  9040D2     MOV.B [W2+5], W1
002CE0  21F110     MOV #0x1F11, W0
002CE2  10CF90     SUBR.B W1, [W0], [W15]
002CE4  3A001E     BRA NZ, 0x2D22
002CE6  9040E2     MOV.B [W2+6], W1
002CE8  21F120     MOV #0x1F12, W0
002CEA  10CF90     SUBR.B W1, [W0], [W15]
002CEC  3A001A     BRA NZ, 0x2D22
3200:                                (usbTPL[i].device.bSubClass == pDesc->bDeviceSubClass) &&
3201:                                (usbTPL[i].device.bProtocol == pDesc->bDeviceProtocol)   )
3202:                            {
3203:                                #ifdef DEBUG_MODE
3204:                                    UART2PrintString( "HOST: Device validated by class\r\n" );
3205:                                #endif
3206:                                usbDeviceInfo.flags.bfUseDeviceClientDriver = 1;
002CEE  A06413     BSET.B [W3], #6
002CF0  370018     BRA 0x2D22
3207:                            }
3208:                        }
3209:                        else
3210:                        {
3211:                            // Check for a device-specific client driver by VID & PID
3212:                            #ifdef ALLOW_GLOBAL_VID_AND_PID
3213:                            if (((usbTPL[i].device.idVendor  == pDesc->idVendor ) &&
002CF2  80F883     MOV usbTPL, W3
002CF4  904882     MOV.B [W2+8], W1
002CF6  FB8081     ZE W1, W1
002CF8  904812     MOV.B [W2+9], W0
002CFA  DD0048     SL W0, #8, W0
002CFC  700001     IOR W0, W1, W0
002CFE  518F80     SUB W3, W0, [W15]
002D00  3A0008     BRA NZ, 0x2D12
002D02  904822     MOV.B [W2+10], W0
002D04  FB8000     ZE W0, W0
002D06  9048B2     MOV.B [W2+11], W1
002D08  DD08C8     SL W1, #8, W1
002D0A  708080     IOR W1, W0, W1
002D0C  21F120     MOV #0x1F12, W0
002D0E  108F90     SUBR W1, [W0], [W15]
002D10  320006     BRA Z, 0x2D1E
002D12  418FE1     ADD W3, #0x1, [W15]
002D14  3A0006     BRA NZ, 0x2D22
002D16  21F120     MOV #0x1F12, W0
002D18  EB8080     SETM W1
002D1A  108F90     SUBR W1, [W0], [W15]
002D1C  3A0002     BRA NZ, 0x2D22
3214:                                 (usbTPL[i].device.idProduct == pDesc->idProduct)) ||
3215:                                ((usbTPL[i].device.idVendor  == 0xFFFF) &&
3216:                                 (usbTPL[i].device.idProduct == 0xFFFF)))
3217:                            #else
3218:                            if ((usbTPL[i].device.idVendor  == pDesc->idVendor ) &&
3219:                                (usbTPL[i].device.idProduct == pDesc->idProduct)   )
3220:                            #endif
3221:                            {
3222:                                #ifdef DEBUG_MODE
3223:                                    UART2PrintString( "HOST: Device validated by VID/PID\r\n" );
3224:                                #endif
3225:                                usbDeviceInfo.flags.bfUseDeviceClientDriver = 1;
002D1E  21ECC0     MOV #0x1ECC, W0
002D20  A06410     BSET.B [W0], #6
3226:                            }
3227:                        }
3228:              
3229:                        if (usbDeviceInfo.flags.bfUseDeviceClientDriver)
002D22  21ECC0     MOV #0x1ECC, W0
002D24  B3C401     MOV #0x40, W1
002D26  60C010     AND.B W1, [W0], W0
002D28  32000C     BRA Z, 0x2D42
3230:                        {
3231:                            // Save client driver info
3232:                            usbDeviceInfo.deviceClientDriver = usbTPL[i].ClientDriver;
002D2A  21F150     MOV #0x1F15, W0
002D2C  21EC11     MOV #0x1EC1, W1
002D2E  784890     MOV.B [W0], [W1]
3233:              
3234:                            // Select configuration if it is given in the TPL
3235:                            if (usbTPL[i].flags.bfSetConfiguration)
002D30  200011     MOV #0x1, W1
002D32  80F8B0     MOV 0x1F16, W0
002D34  A32800     BTST.Z W0, #2
002D36  320006     BRA Z, 0x2D44
3236:                            {
3237:                                usbDeviceInfo.currentConfiguration = usbTPL[i].bConfiguration;
002D38  21F141     MOV #0x1F14, W1
002D3A  21EBC0     MOV #0x1EBC, W0
002D3C  784811     MOV.B [W1], [W0]
002D3E  200011     MOV #0x1, W1
002D40  370001     BRA 0x2D44
002D42  EB0080     CLR W1
3238:                            }
3239:              
3240:                            return TRUE;
3241:                        }
3242:                      }
3243:              
3244:                      i++;
3245:                  }
3246:              
3247:                  #ifdef DEBUG_MODE
3248:                      UART2PrintString( "HOST: Device not yet validated\r\n" );
3249:                  #endif
3250:              
3251:                  return FALSE;
3252:              }
3253:              
3254:              /****************************************************************************
3255:                Function:
3256:                  USB_ENDPOINT_INFO * _USB_FindEndpoint( BYTE endpoint )
3257:              
3258:                Description:
3259:                  This function searches the list of interfaces to try to find the specified
3260:                  endpoint.
3261:              
3262:                Precondition:
3263:                  None
3264:              
3265:                Parameters:
3266:                  BYTE endpoint   - The endpoint to find.
3267:              
3268:                Returns:
3269:                  Returns a pointer to the USB_ENDPOINT_INFO structure for the endpoint.
3270:              
3271:                Remarks:
3272:                  None
3273:                ***************************************************************************/
3274:              
3275:              USB_ENDPOINT_INFO * _USB_FindEndpoint( BYTE endpoint )
3276:              {
3277:                  USB_ENDPOINT_INFO           *pEndpoint;
3278:                  USB_INTERFACE_INFO          *pInterface;
3279:              
3280:                  if (endpoint == 0)
0036A6  E00400     CP0.B W0
0036A8  3A0002     BRA NZ, 0x36AE
3281:                  {
3282:                      return usbDeviceInfo.pEndpoint0;
0036AA  80F651     MOV 0x1ECA, W1
0036AC  370011     BRA 0x36D0
3283:                  }
3284:              
3285:                  pInterface = usbDeviceInfo.pInterfaceList;
0036AE  80F642     MOV 0x1EC8, W2
0036B0  37000C     BRA 0x36CA
3286:                  while (pInterface)
0036CA  E00002     CP0 W2
0036CC  3AFFF2     BRA NZ, 0x36B2
0036CE  780082     MOV W2, W1
3287:                  {
3288:                      // Look for the endpoint in the currently active setting.
3289:                      if (pInterface->pCurrentSetting)
0036B2  900022     MOV [W2+4], W0
0036B4  E00000     CP0 W0
0036B6  320008     BRA Z, 0x36C8
3290:                      {
3291:                          pEndpoint = pInterface->pCurrentSetting->pEndpointList;
0036B8  9000A0     MOV [W0+4], W1
0036BA  370004     BRA 0x36C4
3292:                          while (pEndpoint)
0036C4  E00001     CP0 W1
0036C6  3AFFFA     BRA NZ, 0x36BC
3293:                          {
3294:                              if (pEndpoint->bEndpointAddress == endpoint)
0036BC  905821     MOV.B [W1+26], W0
0036BE  504F83     SUB.B W0, W3, [W15]
0036C0  320007     BRA Z, 0x36D0
3295:                              {
3296:                                  // We have found the endpoint.
3297:                                  return pEndpoint;
3298:                              }
3299:                              pEndpoint = pEndpoint->next;
0036C2  780091     MOV [W1], W1
3300:                          }
3301:                      }
3302:                      
3303:                      // Go to the next interface.
3304:                      pInterface = pInterface->next;
0036C8  780112     MOV [W2], W2
3305:                  }
3306:              
3307:                  return NULL;
3308:              }
3309:              
3310:              
3311:              /****************************************************************************
3312:                Function:
3313:                  USB_INTERFACE_INFO * _USB_FindInterface ( BYTE bInterface, BYTE bAltSetting )
3314:              
3315:                Description:
3316:                  This routine scans the interface linked list and returns a pointer to the
3317:                  node identified by the interface and alternate setting.
3318:              
3319:                Precondition:
3320:                  None
3321:              
3322:                Parameters:
3323:                  bInterface  - Interface number
3324:                  bAltSetting - Interface alternate setting number
3325:              
3326:                Returns:
3327:                  USB_INTERFACE_INFO *  - Pointer to the interface linked list node.
3328:              
3329:                Remarks:
3330:                  None
3331:                ***************************************************************************/
3332:              /*
3333:              USB_INTERFACE_INFO * _USB_FindInterface ( BYTE bInterface, BYTE bAltSetting )
3334:              {
3335:                  USB_INTERFACE_INFO *pCurIntf = usbDeviceInfo.pInterfaceList;
3336:              
3337:                  while (pCurIntf)
3338:                  {
3339:                      if (pCurIntf->interface           == bInterface &&
3340:                          pCurIntf->interfaceAltSetting == bAltSetting  )
3341:                      {
3342:                          return pCurIntf;
3343:                      }
3344:                  }
3345:              
3346:                  return NULL;
3347:              
3348:              } // _USB_FindInterface
3349:              */
3350:              
3351:              /****************************************************************************
3352:                Function:
3353:                  void _USB_FindNextToken( void )
3354:              
3355:                Description:
3356:                  This function determines the next token to send of all current pending
3357:                  transfers.
3358:              
3359:                Precondition:
3360:                  None
3361:              
3362:                Parameters:
3363:                  None - None
3364:              
3365:                Return Values:
3366:                  TRUE    - A token was sent
3367:                  FALSE   - No token was found to send, so the routine can be called again.
3368:              
3369:                Remarks:
3370:                  This routine is only called from an interrupt handler, either SOFIF or
3371:                  TRNIF.
3372:                ***************************************************************************/
3373:              
3374:              void _USB_FindNextToken( void )
3375:              {
3376:                  BOOL    illegalState = FALSE;
3377:              
3378:                  // If the device is suspended or resuming, do not send any tokens.  We will
3379:                  // send the next token on an SOF interrupt after the resume recovery time
3380:                  // has expired.
3381:                  if ((usbHostState & (SUBSTATE_MASK | SUBSUBSTATE_MASK)) == (STATE_RUNNING | SUBSTATE_SUSPEND_AND_RESUME))
001F14  80F690     MOV usbHostState, W0
3382:                  {
3383:                      return;
3384:                  }
3385:              
3386:                  // If we are currently sending a token, we cannot do anything.  We will come
3387:                  // back in here when we get either the Token Done or the Start of Frame interrupt.
3388:                  if (usbBusInfo.flags.bfTokenAlreadyWritten) //(U1CONbits.TOKBUSY)
001F16  21ECEA     MOV #0x1ECE, W10
001F18  78409A     MOV.B [W10], W1
001F1A  60C070     AND.B W1, #0x10, W0
001F1C  3A0107     BRA NZ, 0x212C
3389:                  {
3390:                      return;
3391:                  }
3392:              
3393:                  // We will handle control transfers first.  We only allow one control
3394:                  // transfer per frame.
3395:                  if (!usbBusInfo.flags.bfControlTransfersDone)
001F1E  78401A     MOV.B [W10], W0
001F20  6044E1     AND.B W0, #0x1, W9
001F22  EB0580     CLR W11
001F24  3A0073     BRA NZ, 0x200C
3396:                  {
3397:                      // Look for any control transfers.
3398:                      if (_USB_FindServiceEndpoint( USB_TRANSFER_TYPE_CONTROL ))
001F26  784009     MOV.B W9, W0
001F28  022C40     CALL _USB_FindServiceEndpoint
001F2A  000000     NOP
001F2C  E00000     CP0 W0
001F2E  3A0002     BRA NZ, 0x1F34
001F30  780580     MOV W0, W11
001F32  37006A     BRA 0x2008
3399:                      {
3400:                          switch (pCurrentEndpoint->transferState & TSTATE_MASK)
001F34  80F6A2     MOV pCurrentEndpoint, W2
001F36  905802     MOV.B [W2+24], W0
001F38  780080     MOV W0, W1
001F3A  B20F01     AND #0xF0, W1
001F3C  200200     MOV #0x20, W0
001F3E  508F80     SUB W1, W0, [W15]
001F40  320021     BRA Z, 0x1F84
001F42  400070     ADD W0, #0x10, W0
001F44  508F80     SUB W1, W0, [W15]
001F46  32003B     BRA Z, 0x1FBE
001F48  508FF0     SUB W1, #0x10, [W15]
001F4A  3A00E9     BRA NZ, 0x211E
3401:                          {
3402:                              case TSTATE_CONTROL_NO_DATA:
3403:                                  switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
001F4C  905802     MOV.B [W2+24], W0
001F4E  60006F     AND W0, #0xF, W0
001F50  500FE1     SUB W0, #0x1, [W15]
001F52  320007     BRA Z, 0x1F62
001F54  3C0003     BRA GT, 0x1F5C
001F56  E00000     CP0 W0
001F58  320041     BRA Z, 0x1FDC
001F5A  3700E1     BRA 0x211E
001F5C  500FE2     SUB W0, #0x2, [W15]
001F5E  32004F     BRA Z, 0x1FFE
001F60  37001D     BRA 0x1F9C
3404:                                  {
3405:                                      case TSUBSTATE_CONTROL_NO_DATA_SETUP:
3406:                                          _USB_SetDATA01( DTS_DATA0 );
3407:                                          _USB_SetBDT( USB_TOKEN_SETUP );
3408:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_SETUP );
3409:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3410:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
3411:                                          #endif
3412:                                          return;
3413:                                          break;
3414:              
3415:                                      case TSUBSTATE_CONTROL_NO_DATA_ACK:
3416:                                          pCurrentEndpoint->dataCountMax = pCurrentEndpoint->dataCount;
001F62  900802     MOV [W2+16], W0
001F64  900892     MOV [W2+18], W1
001F66  980150     MOV W0, [W2+10]
001F68  980161     MOV W1, [W2+12]
3417:                                          _USB_SetDATA01( DTS_DATA1 );
001F6A  904032     MOV.B [W2+3], W0
001F6C  A03400     BSET.B W0, #3
001F6E  984130     MOV.B W0, [W2+3]
3418:                                          _USB_SetBDT( USB_TOKEN_IN );
001F70  B3C090     MOV #0x9, W0
001F72  02292A     CALL _USB_SetBDT
001F74  000000     NOP
3419:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN );
001F76  80F6A0     MOV pCurrentEndpoint, W0
001F78  905820     MOV.B [W0+26], W0
001F7A  B3C091     MOV #0x9, W1
001F7C  02336C     CALL _USB_SendToken
001F7E  000000     NOP
3420:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3421:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
001F80  A0041A     BSET.B [W10], #0
001F82  3700D4     BRA 0x212C
3422:                                          #endif
3423:                                          return;
3424:                                          break;
3425:              
3426:                                      case TSUBSTATE_CONTROL_NO_DATA_COMPLETE:
3427:                                          pCurrentEndpoint->transferState               = TSTATE_IDLE;
3428:                                          pCurrentEndpoint->status.bfTransferComplete   = 1;
3429:                                          #if defined( USB_ENABLE_TRANSFER_EVENT )
3430:                                              if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3431:                                              {
3432:                                                  USB_EVENT_DATA *data;
3433:              
3434:                                                  data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3435:                                                  data->event = EVENT_TRANSFER;
3436:                                                  data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
3437:                                                  data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
3438:                                                  data->TransferData.bErrorCode       = USB_SUCCESS;
3439:                                                  data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3440:                                                  data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3441:                                                  data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3442:                                              }
3443:                                              else
3444:                                              {
3445:                                                  pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3446:                                              }
3447:                                          #endif
3448:                                  break;
3449:              
3450:                                      case TSUBSTATE_ERROR:
3451:                                          pCurrentEndpoint->transferState               = TSTATE_IDLE;
3452:                                          pCurrentEndpoint->status.bfTransferComplete   = 1;
3453:                                          #if defined( USB_ENABLE_TRANSFER_EVENT )
3454:                                              if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3455:                                              {
3456:                                                  USB_EVENT_DATA *data;
3457:              
3458:                                                  data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3459:                                                  data->event = EVENT_BUS_ERROR;
3460:                                                  data->TransferData.dataCount        = 0;
3461:                                                  data->TransferData.pUserData        = NULL;
3462:                                                  data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
3463:                                                  data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3464:                                                  data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3465:                                                  data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3466:                                              }
3467:                                              else
3468:                                              {
3469:                                                  pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3470:                                              }
3471:                                          #endif
3472:                                          break;
3473:              
3474:                                      default:
3475:                                          illegalState = TRUE;
3476:                                          break;
3477:                                  }
3478:                                  break;
3479:              
3480:                              case TSTATE_CONTROL_READ:
3481:                                  switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
001F84  905802     MOV.B [W2+24], W0
001F86  60006F     AND W0, #0xF, W0
001F88  500FE2     SUB W0, #0x2, [W15]
001F8A  32000B     BRA Z, 0x1FA2
001F8C  3C0005     BRA GT, 0x1F98
001F8E  E00000     CP0 W0
001F90  320025     BRA Z, 0x1FDC
001F92  500FE1     SUB W0, #0x1, [W15]
001F94  3A00C4     BRA NZ, 0x211E
001F96  37FFEC     BRA 0x1F70
001F98  500FE3     SUB W0, #0x3, [W15]
001F9A  320031     BRA Z, 0x1FFE
001F9C  500FEF     SUB W0, #0xF, [W15]
001F9E  3A00BF     BRA NZ, 0x211E
001FA0  37002E     BRA 0x1FFE
3482:                                  {
3483:                                      case TSUBSTATE_CONTROL_READ_SETUP:
3484:                                          _USB_SetDATA01( DTS_DATA0 );
3485:                                          _USB_SetBDT( USB_TOKEN_SETUP );
3486:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_SETUP );
3487:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3488:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
3489:                                          #endif
3490:                                          return;
3491:                                          break;
3492:              
3493:                                      case TSUBSTATE_CONTROL_READ_DATA:
3494:                                          _USB_SetBDT( USB_TOKEN_IN );
3495:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN );
3496:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3497:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
3498:                                          #endif
3499:                                          return;
3500:                                          break;
3501:              
3502:                                      case TSUBSTATE_CONTROL_READ_ACK:
3503:                                          pCurrentEndpoint->dataCountMax = pCurrentEndpoint->dataCount;
001FA2  900802     MOV [W2+16], W0
001FA4  900892     MOV [W2+18], W1
001FA6  980150     MOV W0, [W2+10]
001FA8  980161     MOV W1, [W2+12]
3504:                                          _USB_SetDATA01( DTS_DATA1 );
001FAA  904032     MOV.B [W2+3], W0
001FAC  A03400     BSET.B W0, #3
001FAE  984130     MOV.B W0, [W2+3]
3505:                                          _USB_SetBDT( USB_TOKEN_OUT );
001FB0  B3C010     MOV #0x1, W0
001FB2  02292A     CALL _USB_SetBDT
001FB4  000000     NOP
3506:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT );
001FB6  80F6A0     MOV pCurrentEndpoint, W0
001FB8  905820     MOV.B [W0+26], W0
001FBA  B3C011     MOV #0x1, W1
001FBC  37FFDF     BRA 0x1F7C
3507:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3508:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
3509:                                          #endif
3510:                                          return;
3511:                                          break;
3512:              
3513:                                      case TSUBSTATE_CONTROL_READ_COMPLETE:
3514:                                          pCurrentEndpoint->transferState               = TSTATE_IDLE;
3515:                                          pCurrentEndpoint->status.bfTransferComplete   = 1;
3516:                                          #if defined( USB_ENABLE_TRANSFER_EVENT )
3517:                                              if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3518:                                              {
3519:                                                  USB_EVENT_DATA *data;
3520:              
3521:                                                  data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3522:                                                  data->event = EVENT_TRANSFER;
3523:                                                  data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
3524:                                                  data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
3525:                                                  data->TransferData.bErrorCode       = USB_SUCCESS;
3526:                                                  data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3527:                                                  data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3528:                                                  data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3529:                                              }
3530:                                              else
3531:                                              {
3532:                                                  pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3533:                                              }
3534:                                          #endif
3535:                                          break;
3536:              
3537:                                      case TSUBSTATE_ERROR:
3538:                                          pCurrentEndpoint->transferState               = TSTATE_IDLE;
3539:                                          pCurrentEndpoint->status.bfTransferComplete   = 1;
3540:                                          #if defined( USB_ENABLE_TRANSFER_EVENT )
3541:                                              if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3542:                                              {
3543:                                                  USB_EVENT_DATA *data;
3544:              
3545:                                                  data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3546:                                                  data->event = EVENT_BUS_ERROR;
3547:                                                  data->TransferData.dataCount        = 0;
3548:                                                  data->TransferData.pUserData        = NULL;
3549:                                                  data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
3550:                                                  data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3551:                                                  data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3552:                                                  data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3553:                                              }
3554:                                              else
3555:                                              {
3556:                                                  pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3557:                                              }
3558:                                          #endif
3559:                                          break;
3560:              
3561:                                      default:
3562:                                          illegalState = TRUE;
3563:                                          break;
3564:                                  }
3565:                                  break;
3566:              
3567:                              case TSTATE_CONTROL_WRITE:
3568:                                  switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
001FBE  905802     MOV.B [W2+24], W0
001FC0  60046F     AND W0, #0xF, W8
001FC2  540FE2     SUB W8, #0x2, [W15]
001FC4  32FFCE     BRA Z, 0x1F62
001FC6  3C0005     BRA GT, 0x1FD2
001FC8  E00008     CP0 W8
001FCA  320008     BRA Z, 0x1FDC
001FCC  540FE1     SUB W8, #0x1, [W15]
001FCE  3A00A7     BRA NZ, 0x211E
001FD0  37000F     BRA 0x1FF0
001FD2  540FE3     SUB W8, #0x3, [W15]
001FD4  320014     BRA Z, 0x1FFE
001FD6  540FEF     SUB W8, #0xF, [W15]
001FD8  3A00A2     BRA NZ, 0x211E
001FDA  370011     BRA 0x1FFE
3569:                                  {
3570:                                      case TSUBSTATE_CONTROL_WRITE_SETUP:
3571:                                          _USB_SetDATA01( DTS_DATA0 );
001FDC  904032     MOV.B [W2+3], W0
001FDE  A13400     BCLR.B W0, #3
001FE0  984130     MOV.B W0, [W2+3]
3572:                                          _USB_SetBDT( USB_TOKEN_SETUP );
001FE2  B3C0D0     MOV #0xD, W0
001FE4  02292A     CALL _USB_SetBDT
001FE6  000000     NOP
3573:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_SETUP );
001FE8  80F6A0     MOV pCurrentEndpoint, W0
001FEA  905820     MOV.B [W0+26], W0
001FEC  B3C0D1     MOV #0xD, W1
001FEE  37FFC6     BRA 0x1F7C
3574:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3575:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
3576:                                          #endif
3577:                                          return;
3578:                                          break;
3579:              
3580:                                      case TSUBSTATE_CONTROL_WRITE_DATA:
3581:                                          _USB_SetBDT( USB_TOKEN_OUT );
001FF0  784008     MOV.B W8, W0
001FF2  02292A     CALL _USB_SetBDT
001FF4  000000     NOP
3582:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT );
001FF6  80F6A0     MOV pCurrentEndpoint, W0
001FF8  905820     MOV.B [W0+26], W0
001FFA  784088     MOV.B W8, W1
001FFC  37FFBF     BRA 0x1F7C
3583:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3584:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
3585:                                          #endif
3586:                                          return;
3587:                                          break;
3588:              
3589:                                      case TSUBSTATE_CONTROL_WRITE_ACK:
3590:                                          pCurrentEndpoint->dataCountMax = pCurrentEndpoint->dataCount;
3591:                                          _USB_SetDATA01( DTS_DATA1 );
3592:                                          _USB_SetBDT( USB_TOKEN_IN );
3593:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN );
3594:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3595:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
3596:                                          #endif
3597:                                          return;
3598:                                          break;
3599:              
3600:                                      case TSUBSTATE_CONTROL_WRITE_COMPLETE:
3601:                                          pCurrentEndpoint->transferState               = TSTATE_IDLE;
3602:                                          pCurrentEndpoint->status.bfTransferComplete   = 1;
3603:                                          #if defined( USB_ENABLE_TRANSFER_EVENT )
3604:                                              if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3605:                                              {
3606:                                                  USB_EVENT_DATA *data;
3607:              
3608:                                                  data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3609:                                                  data->event = EVENT_TRANSFER;
3610:                                                  data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
3611:                                                  data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
3612:                                                  data->TransferData.bErrorCode       = USB_SUCCESS;
3613:                                                  data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3614:                                                  data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3615:                                                  data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3616:                                              }
3617:                                              else
3618:                                              {
3619:                                                  pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3620:                                              }
3621:                                          #endif
3622:                                          break;
3623:              
3624:                                      case TSUBSTATE_ERROR:
3625:                                          pCurrentEndpoint->transferState               = TSTATE_IDLE;
001FFE  985909     MOV.B W9, [W2+24]
3626:                                          pCurrentEndpoint->status.bfTransferComplete   = 1;
002000  904032     MOV.B [W2+3], W0
002002  A01400     BSET.B W0, #1
002004  984130     MOV.B W0, [W2+3]
002006  EB0580     CLR W11
3627:                                          #if defined( USB_ENABLE_TRANSFER_EVENT )
3628:                                              if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3629:                                              {
3630:                                                  USB_EVENT_DATA *data;
3631:              
3632:                                                  data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3633:                                                  data->event = EVENT_BUS_ERROR;
3634:                                                  data->TransferData.dataCount        = 0;
3635:                                                  data->TransferData.pUserData        = NULL;
3636:                                                  data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
3637:                                                  data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3638:                                                  data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3639:                                                  data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3640:                                              }
3641:                                              else
3642:                                              {
3643:                                                  pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3644:                                              }
3645:                                          #endif
3646:                                          break;
3647:              
3648:                                      default:
3649:                                          illegalState = TRUE;
3650:                                          break;
3651:                                  }
3652:                                  break;
3653:              
3654:                              default:
3655:                                  illegalState = TRUE;
3656:                          }
3657:              
3658:                          if (illegalState)
3659:                          {
3660:                              // We should never use this, but in case we do, put the endpoint
3661:                              // in a recoverable state.
3662:                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
00211E  EB4000     CLR.B W0
002120  985900     MOV.B W0, [W2+24]
3663:                              pCurrentEndpoint->status.bfTransferComplete   = 1;
002122  904032     MOV.B [W2+3], W0
002124  A01400     BSET.B W0, #1
002126  984130     MOV.B W0, [W2+3]
002128  20001B     MOV #0x1, W11
00212A  37FF6E     BRA 0x2008
3664:                          }
3665:                      }
3666:              
3667:                      // If we've gone through all the endpoints, we do not have any more control transfers.
3668:                      usbBusInfo.flags.bfControlTransfersDone = 1;
002008  21ECE0     MOV #0x1ECE, W0
00200A  A00410     BSET.B [W0], #0
3669:                  }
3670:              
3671:                  #ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
3672:                      // Next, we will handle isochronous transfers.  We must be careful with
3673:                      // these.  The maximum packet size for an isochronous transfer is 1023
3674:                      // bytes, so we cannot use the threshold register (U1SOF) to ensure that
3675:                      // we do not write too many tokens during a frame.  Instead, we must count
3676:                      // the number of bytes we are sending and stop sending isochronous
3677:                      // transfers when we reach that limit.
3678:              
3679:                      // TODO: Implement scheduling by using usbBusInfo.dBytesSentInFrame
3680:              
3681:                      // Current Limitation:  The stack currently supports only one attached
3682:                      // device.  We will make the assumption that the control, isochronous, and
3683:                      // interrupt transfers requested by a single device will not exceed one
3684:                      // frame, and defer the scheduler.
3685:              
3686:                      // Due to the nature of isochronous transfers, transfer events must be used.
3687:                      #if !defined( USB_ENABLE_TRANSFER_EVENT )
3688:                          #error Transfer events are required for isochronous transfers
3689:                      #endif
3690:              
3691:                      if (!usbBusInfo.flags.bfIsochronousTransfersDone)
3692:                      {
3693:                          // Look for any isochronous operations.
3694:                          if (_USB_FindServiceEndpoint( USB_TRANSFER_TYPE_ISOCHRONOUS ))
3695:                          {
3696:                              switch (pCurrentEndpoint->transferState & TSTATE_MASK)
3697:                              {
3698:                                  case TSTATE_ISOCHRONOUS_READ:
3699:                                      switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
3700:                                      {
3701:                                          case TSUBSTATE_ISOCHRONOUS_READ_DATA:
3702:                                              if (pCurrentEndpoint->wIntervalCount == 0)
3703:                                              {
3704:                                                  // Reset the interval count for the next packet.
3705:                                                  pCurrentEndpoint->wIntervalCount  = pCurrentEndpoint->wInterval;
3706:              
3707:                                                  // Don't overwrite data the user has not yet processed.  We will skip this interval.    
3708:                                                  if (((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid)
3709:                                                  {
3710:                                                      // We have buffer overflow.
3711:                                                  }
3712:                                                  else
3713:                                                  {
3714:                                                      // Initialize the data buffer.
3715:                                                      ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid = 0;
3716:                                                      pCurrentEndpoint->dataCount = 0;
3717:                  
3718:                                                      _USB_SetDATA01( DTS_DATA0 );    // Always DATA0 for isochronous
3719:                                                      _USB_SetBDT( USB_TOKEN_IN );
3720:                                                      _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN );
3721:                                                      return;
3722:                                                  }    
3723:                                              }
3724:                                              break;
3725:              
3726:                                          case TSUBSTATE_ISOCHRONOUS_READ_COMPLETE:
3727:                                              // Isochronous transfers are continuous until the user stops them.
3728:                                              // Send an event that there is new data, and reset for the next
3729:                                              // interval.
3730:                                              pCurrentEndpoint->transferState = TSTATE_ISOCHRONOUS_READ | TSUBSTATE_ISOCHRONOUS_READ_DATA;
3731:              
3732:                                              // Update the valid data length for this buffer.
3733:                                              ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].dataLength = pCurrentEndpoint->dataCount;
3734:                                              ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid = 1;
3735:                                              #if defined( USB_ENABLE_ISOC_TRANSFER_EVENT )
3736:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3737:                                                  {
3738:                                                      USB_EVENT_DATA *data;
3739:              
3740:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3741:                                                      data->event = EVENT_TRANSFER;
3742:                                                      data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
3743:                                                      data->TransferData.pUserData        = ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer;
3744:                                                      data->TransferData.bErrorCode       = USB_SUCCESS;
3745:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3746:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3747:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3748:                                                  }
3749:                                                  else
3750:                                                  {
3751:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3752:                                                  }
3753:                                              #endif
3754:                                              
3755:                                              // If the user wants an event from the interrupt handler to handle the data as quickly as
3756:                                              // possible, send up the event.  Then mark the packet as used.
3757:                                              #ifdef USB_HOST_APP_DATA_EVENT_HANDLER
3758:                                                  usbClientDrvTable[pCurrentEndpoint->clientDriver].DataEventHandler( usbDeviceInfo.deviceAddress, EVENT_DATA_ISOC_READ, ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer, pCurrentEndpoint->dataCount );
3759:                                                  ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid = 0;
3760:                                              #endif
3761:                                              
3762:                                              // Move to the next data buffer.
3763:                                              ((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->currentBufferUSB++;
3764:                                              if (((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->currentBufferUSB >= ((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->totalBuffers)
3765:                                              {
3766:                                                  ((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->currentBufferUSB = 0;
3767:                                              }
3768:                                              break;
3769:              
3770:                                          case TSUBSTATE_ERROR:
3771:                                              // Isochronous transfers are continuous until the user stops them.
3772:                                              // Send an event that there is an error, and reset for the next
3773:                                              // interval.
3774:                                              pCurrentEndpoint->transferState = TSTATE_ISOCHRONOUS_READ | TSUBSTATE_ISOCHRONOUS_READ_DATA;
3775:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
3776:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3777:                                                  {
3778:                                                      USB_EVENT_DATA *data;
3779:              
3780:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3781:                                                      data->event = EVENT_BUS_ERROR;
3782:                                                      data->TransferData.dataCount        = 0;
3783:                                                      data->TransferData.pUserData        = NULL;
3784:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3785:                                                      data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
3786:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3787:                                                  }
3788:                                                  else
3789:                                                  {
3790:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3791:                                                  }
3792:                                              #endif
3793:                                              break;
3794:              
3795:                                          default:
3796:                                              illegalState = TRUE;
3797:                                              break;
3798:                                      }
3799:                                      break;
3800:              
3801:                                  case TSTATE_ISOCHRONOUS_WRITE:
3802:                                      switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
3803:                                      {
3804:                                          case TSUBSTATE_ISOCHRONOUS_WRITE_DATA:
3805:                                              if (pCurrentEndpoint->wIntervalCount == 0)
3806:                                              {
3807:                                                  // Reset the interval count for the next packet.
3808:                                                  pCurrentEndpoint->wIntervalCount  = pCurrentEndpoint->wInterval;
3809:              
3810:                                                  if (!((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid)
3811:                                                  {
3812:                                                      // We have buffer underrun.
3813:                                                  }
3814:                                                  else
3815:                                                  {
3816:                                                      pCurrentEndpoint->dataCount = ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].dataLength;
3817:                  
3818:                                                      _USB_SetDATA01( DTS_DATA0 );    // Always DATA0 for isochronous
3819:                                                      _USB_SetBDT( USB_TOKEN_OUT );
3820:                                                      _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT );
3821:                                                      return;
3822:                                                  }    
3823:                                              }
3824:                                              break;
3825:              
3826:                                          case TSUBSTATE_ISOCHRONOUS_WRITE_COMPLETE:
3827:                                              // Isochronous transfers are continuous until the user stops them.
3828:                                              // Send an event that data has been sent, and reset for the next
3829:                                              // interval.
3830:                                              pCurrentEndpoint->transferState = TSTATE_ISOCHRONOUS_WRITE | TSUBSTATE_ISOCHRONOUS_WRITE_DATA;
3831:              
3832:                                              // Update the valid data length for this buffer.
3833:                                              ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid = 0;
3834:                                              #if defined( USB_ENABLE_ISOC_TRANSFER_EVENT )
3835:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3836:                                                  {
3837:                                                      USB_EVENT_DATA *data;
3838:              
3839:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3840:                                                      data->event = EVENT_TRANSFER;
3841:                                                      data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
3842:                                                      data->TransferData.pUserData        = ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer;
3843:                                                      data->TransferData.bErrorCode       = USB_SUCCESS;
3844:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3845:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3846:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3847:                                                  }
3848:                                                  else
3849:                                                  {
3850:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3851:                                                  }
3852:                                              #endif
3853:              
3854:                                              // If the user wants an event from the interrupt handler to handle the data as quickly as
3855:                                              // possible, send up the event.
3856:                                              #ifdef USB_HOST_APP_DATA_EVENT_HANDLER
3857:                                                  usbClientDrvTable[pCurrentEndpoint->clientDriver].DataEventHandler( usbDeviceInfo.deviceAddress, EVENT_DATA_ISOC_WRITE, ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer, pCurrentEndpoint->dataCount );
3858:                                              #endif
3859:                                                                              
3860:                                              // Move to the next data buffer.
3861:                                              ((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->currentBufferUSB++;
3862:                                              if (((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->currentBufferUSB >= ((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->totalBuffers)
3863:                                              {
3864:                                                  ((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->currentBufferUSB = 0;
3865:                                              }
3866:                                              break;
3867:              
3868:                                          case TSUBSTATE_ERROR:
3869:                                              // Isochronous transfers are continuous until the user stops them.
3870:                                              // Send an event that there is an error, and reset for the next
3871:                                              // interval.
3872:                                              pCurrentEndpoint->transferState = TSTATE_ISOCHRONOUS_WRITE | TSUBSTATE_ISOCHRONOUS_WRITE_DATA;
3873:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
3874:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3875:                                                  {
3876:                                                      USB_EVENT_DATA *data;
3877:              
3878:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3879:                                                      data->event = EVENT_BUS_ERROR;
3880:                                                      data->TransferData.dataCount        = 0;
3881:                                                      data->TransferData.pUserData        = NULL;
3882:                                                      data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
3883:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3884:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3885:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3886:                                                  }
3887:                                                  else
3888:                                                  {
3889:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3890:                                                  }
3891:                                              #endif
3892:                                              break;
3893:              
3894:                                          default:
3895:                                              illegalState = TRUE;
3896:                                              break;
3897:                                      }
3898:                                      break;
3899:              
3900:                                  default:
3901:                                      illegalState = TRUE;
3902:                                      break;
3903:                              }
3904:              
3905:                              if (illegalState)
3906:                              {
3907:                                  // We should never use this, but in case we do, put the endpoint
3908:                                  // in a recoverable state.
3909:                                  pCurrentEndpoint->transferState               = TSTATE_IDLE;
3910:                                  pCurrentEndpoint->status.bfTransferComplete   = 1;
3911:                              }
3912:                          }
3913:              
3914:                          // If we've gone through all the endpoints, we do not have any more isochronous transfers.
3915:                          usbBusInfo.flags.bfIsochronousTransfersDone = 1;
3916:                      }
3917:                  #endif
3918:              
3919:                  #ifdef USB_SUPPORT_INTERRUPT_TRANSFERS
3920:                      if (!usbBusInfo.flags.bfInterruptTransfersDone)
00200C  21ECE0     MOV #0x1ECE, W0
00200E  784010     MOV.B [W0], W0
002010  604462     AND.B W0, #0x2, W8
002012  3A003B     BRA NZ, 0x208A
3921:                      {
3922:                          // Look for any interrupt operations.
3923:                          if (_USB_FindServiceEndpoint( USB_TRANSFER_TYPE_INTERRUPT ))
002014  B3C030     MOV #0x3, W0
002016  022C40     CALL _USB_FindServiceEndpoint
002018  000000     NOP
00201A  E00000     CP0 W0
00201C  320034     BRA Z, 0x2086
3924:                          {
3925:                              switch (pCurrentEndpoint->transferState & TSTATE_MASK)
00201E  80F6A1     MOV pCurrentEndpoint, W1
002020  905801     MOV.B [W1+24], W0
002022  780100     MOV W0, W2
002024  B20F02     AND #0xF0, W2
002026  200400     MOV #0x40, W0
002028  510F80     SUB W2, W0, [W15]
00202A  320004     BRA Z, 0x2034
00202C  400070     ADD W0, #0x10, W0
00202E  510F80     SUB W2, W0, [W15]
002030  3A0024     BRA NZ, 0x207A
002032  37000E     BRA 0x2050
3926:                              {
3927:                                  case TSTATE_INTERRUPT_READ:
3928:                                      switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
002034  905801     MOV.B [W1+24], W0
002036  60006F     AND W0, #0xF, W0
002038  500FE1     SUB W0, #0x1, [W15]
00203A  320018     BRA Z, 0x206C
00203C  500FEF     SUB W0, #0xF, [W15]
00203E  320016     BRA Z, 0x206C
002040  E00000     CP0 W0
002042  3A001B     BRA NZ, 0x207A
3929:                                      {
3930:                                          case TSUBSTATE_INTERRUPT_READ_DATA:
3931:                                              if (pCurrentEndpoint->wIntervalCount == 0)
002044  900031     MOV [W1+6], W0
002046  E00000     CP0 W0
002048  3A0015     BRA NZ, 0x2074
3932:                                              {
3933:                                                  // Reset the interval count for the next packet.
3934:                                                  pCurrentEndpoint->wIntervalCount = pCurrentEndpoint->wInterval;
00204A  900021     MOV [W1+4], W0
00204C  9800B0     MOV W0, [W1+6]
00204E  370039     BRA 0x20C2
3935:              
3936:                                                  _USB_SetBDT( USB_TOKEN_IN );
3937:                                                  _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN );
3938:                                                  return;
3939:                                              }
3940:                                              break;
3941:              
3942:                                          case TSUBSTATE_INTERRUPT_READ_COMPLETE:
3943:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
3944:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
3945:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
3946:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3947:                                                  {
3948:                                                      USB_EVENT_DATA *data;
3949:              
3950:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3951:                                                      data->event = EVENT_TRANSFER;
3952:                                                      data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
3953:                                                      data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
3954:                                                      data->TransferData.bErrorCode       = USB_SUCCESS;
3955:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3956:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3957:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3958:                                                  }
3959:                                                  else
3960:                                                  {
3961:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3962:                                                  }
3963:                                              #endif
3964:                                              break;
3965:              
3966:                                          case TSUBSTATE_ERROR:
3967:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
3968:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
3969:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
3970:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3971:                                                  {
3972:                                                      USB_EVENT_DATA *data;
3973:              
3974:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3975:                                                      data->event = EVENT_BUS_ERROR;
3976:                                                      data->TransferData.dataCount        = 0;
3977:                                                      data->TransferData.pUserData        = NULL;
3978:                                                      data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
3979:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3980:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3981:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3982:                                                  }
3983:                                                  else
3984:                                                  {
3985:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3986:                                                  }
3987:                                              #endif
3988:                                              break;
3989:              
3990:                                          default:
3991:                                              illegalState = TRUE;
3992:                                              break;
3993:                                      }
3994:                                      break;
3995:              
3996:                                  case TSTATE_INTERRUPT_WRITE:
3997:                                      switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
002050  905801     MOV.B [W1+24], W0
002052  60006F     AND W0, #0xF, W0
002054  500FE1     SUB W0, #0x1, [W15]
002056  32000A     BRA Z, 0x206C
002058  500FEF     SUB W0, #0xF, [W15]
00205A  320008     BRA Z, 0x206C
00205C  E00000     CP0 W0
00205E  3A000D     BRA NZ, 0x207A
3998:                                      {
3999:                                          case TSUBSTATE_INTERRUPT_WRITE_DATA:
4000:                                              if (pCurrentEndpoint->wIntervalCount == 0)
002060  900031     MOV [W1+6], W0
002062  E00000     CP0 W0
002064  3A0007     BRA NZ, 0x2074
4001:                                              {
4002:                                                  // Reset the interval count for the next packet.
4003:                                                  pCurrentEndpoint->wIntervalCount = pCurrentEndpoint->wInterval;
002066  900021     MOV [W1+4], W0
002068  9800B0     MOV W0, [W1+6]
00206A  37003A     BRA 0x20E0
4004:              
4005:                                                  _USB_SetBDT( USB_TOKEN_OUT );
4006:                                                  _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT );
4007:                                                  return;
4008:                                              }
4009:                                              break;
4010:              
4011:                                          case TSUBSTATE_INTERRUPT_WRITE_COMPLETE:
4012:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
4013:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
4014:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
4015:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
4016:                                                  {
4017:                                                      USB_EVENT_DATA *data;
4018:              
4019:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
4020:                                                      data->event = EVENT_TRANSFER;
4021:                                                      data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
4022:                                                      data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
4023:                                                      data->TransferData.bErrorCode       = USB_SUCCESS;
4024:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
4025:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
4026:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
4027:                                                  }
4028:                                                  else
4029:                                                  {
4030:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
4031:                                                  }
4032:                                              #endif
4033:                                              break;
4034:              
4035:                                          case TSUBSTATE_ERROR:
4036:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
00206C  985888     MOV.B W8, [W1+24]
4037:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
00206E  904031     MOV.B [W1+3], W0
002070  A01400     BSET.B W0, #1
002072  9840B0     MOV.B W0, [W1+3]
4038:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
4039:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
4040:                                                  {
4041:                                                      USB_EVENT_DATA *data;
4042:              
4043:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
4044:                                                      data->event = EVENT_BUS_ERROR;
4045:                                                      data->TransferData.dataCount        = 0;
4046:                                                      data->TransferData.pUserData        = NULL;
4047:                                                      data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
4048:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
4049:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
4050:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
4051:                                                  }
4052:                                                  else
4053:                                                  {
4054:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
4055:                                                  }
4056:                                              #endif
4057:                                              break;
4058:              
4059:                                          default:
4060:                                              illegalState = TRUE;
4061:                                              break;
4062:                                      }
4063:                                      break;
4064:              
4065:                                  default:
4066:                                      illegalState = TRUE;
4067:                                      break;
4068:                              }
4069:              
4070:                              if (illegalState)
002074  E0000B     CP0 W11
002076  3A0002     BRA NZ, 0x207C
002078  370006     BRA 0x2086
00207A  20001B     MOV #0x1, W11
4071:                              {
4072:                                  // We should never use this, but in case we do, put the endpoint
4073:                                  // in a recoverable state.
4074:                                  pCurrentEndpoint->status.bfTransferComplete   = 1;
00207C  904031     MOV.B [W1+3], W0
00207E  A01400     BSET.B W0, #1
002080  9840B0     MOV.B W0, [W1+3]
4075:                                  pCurrentEndpoint->transferState               = TSTATE_IDLE;
002082  EB4000     CLR.B W0
002084  985880     MOV.B W0, [W1+24]
4076:                              }
4077:                          }
4078:              
4079:                          // If we've gone through all the endpoints, we do not have any more interrupt transfers.
4080:                          usbBusInfo.flags.bfInterruptTransfersDone = 1;
002086  21ECE0     MOV #0x1ECE, W0
002088  A01410     BSET.B [W0], #1
4081:                      }
4082:                  #endif
4083:              
4084:                  #ifdef USB_SUPPORT_BULK_TRANSFERS
4085:              #ifdef ALLOW_MULTIPLE_BULK_TRANSACTIONS_PER_FRAME
4086:              TryBulk:
4087:              #endif
4088:              
4089:                      if (!usbBusInfo.flags.bfBulkTransfersDone)
00208A  21ECE0     MOV #0x1ECE, W0
00208C  784010     MOV.B [W0], W0
00208E  604468     AND.B W0, #0x8, W8
002090  3A004D     BRA NZ, 0x212C
4090:                      {
4091:                          #ifndef ALLOW_MULTIPLE_BULK_TRANSACTIONS_PER_FRAME
4092:                              // Only go through this section once if we are not allowing multiple transactions
4093:                              // per frame.
4094:                              usbBusInfo.flags.bfBulkTransfersDone = 1;
4095:                          #endif
4096:              
4097:                          // Look for any bulk operations.  Try to service all pending requests within the frame.
4098:                          if (_USB_FindServiceEndpoint( USB_TRANSFER_TYPE_BULK ))
002092  B3C020     MOV #0x2, W0
002094  022C40     CALL _USB_FindServiceEndpoint
002096  000000     NOP
002098  E00000     CP0 W0
00209A  320038     BRA Z, 0x210C
4099:                          {
4100:                              switch (pCurrentEndpoint->transferState & TSTATE_MASK)
00209C  80F6A1     MOV pCurrentEndpoint, W1
00209E  905801     MOV.B [W1+24], W0
0020A0  780100     MOV W0, W2
0020A2  B20F02     AND #0xF0, W2
0020A4  200800     MOV #0x80, W0
0020A6  510F80     SUB W2, W0, [W15]
0020A8  320004     BRA Z, 0x20B2
0020AA  400070     ADD W0, #0x10, W0
0020AC  510F80     SUB W2, W0, [W15]
0020AE  3A0028     BRA NZ, 0x2100
0020B0  37000F     BRA 0x20D0
4101:                              {
4102:                                  case TSTATE_BULK_READ:
4103:                                      switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
0020B2  905801     MOV.B [W1+24], W0
0020B4  60006F     AND W0, #0xF, W0
0020B6  500FE1     SUB W0, #0x1, [W15]
0020B8  32001C     BRA Z, 0x20F2
0020BA  500FEF     SUB W0, #0xF, [W15]
0020BC  32001A     BRA Z, 0x20F2
0020BE  E00000     CP0 W0
0020C0  3A001F     BRA NZ, 0x2100
4104:                                      {
4105:                                          case TSUBSTATE_BULK_READ_DATA:
4106:                                              _USB_SetBDT( USB_TOKEN_IN );
0020C2  B3C090     MOV #0x9, W0
0020C4  02292A     CALL _USB_SetBDT
0020C6  000000     NOP
4107:                                              _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN );
0020C8  80F6A0     MOV pCurrentEndpoint, W0
0020CA  905820     MOV.B [W0+26], W0
0020CC  B3C091     MOV #0x9, W1
0020CE  37000E     BRA 0x20EC
4108:                                              return;
4109:                                              break;
4110:              
4111:                                          case TSUBSTATE_BULK_READ_COMPLETE:
4112:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
4113:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
4114:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
4115:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
4116:                                                  {
4117:                                                      USB_EVENT_DATA *data;
4118:              
4119:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
4120:                                                      data->event = EVENT_TRANSFER;
4121:                                                      data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
4122:                                                      data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
4123:                                                      data->TransferData.bErrorCode       = USB_SUCCESS;
4124:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
4125:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
4126:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
4127:                                                  }
4128:                                                  else
4129:                                                  {
4130:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
4131:                                                  }
4132:                                              #endif
4133:                                              break;
4134:              
4135:                                          case TSUBSTATE_ERROR:
4136:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
4137:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
4138:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
4139:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
4140:                                                  {
4141:                                                      USB_EVENT_DATA *data;
4142:              
4143:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
4144:                                                      data->event = EVENT_BUS_ERROR;
4145:                                                      data->TransferData.dataCount        = 0;
4146:                                                      data->TransferData.pUserData        = NULL;
4147:                                                      data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
4148:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
4149:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
4150:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
4151:                                                  }
4152:                                                  else
4153:                                                  {
4154:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
4155:                                                  }
4156:                                              #endif
4157:                                              break;
4158:              
4159:                                          default:
4160:                                              illegalState = TRUE;
4161:                                              break;
4162:                                      }
4163:                                      break;
4164:              
4165:                                  case TSTATE_BULK_WRITE:
4166:                                      switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
0020D0  905801     MOV.B [W1+24], W0
0020D2  60006F     AND W0, #0xF, W0
0020D4  500FE1     SUB W0, #0x1, [W15]
0020D6  32000D     BRA Z, 0x20F2
0020D8  500FEF     SUB W0, #0xF, [W15]
0020DA  32000B     BRA Z, 0x20F2
0020DC  E00000     CP0 W0
0020DE  3A0010     BRA NZ, 0x2100
4167:                                      {
4168:                                          case TSUBSTATE_BULK_WRITE_DATA:
4169:                                              _USB_SetBDT( USB_TOKEN_OUT );
0020E0  B3C010     MOV #0x1, W0
0020E2  02292A     CALL _USB_SetBDT
0020E4  000000     NOP
4170:                                              _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT );
0020E6  80F6A0     MOV pCurrentEndpoint, W0
0020E8  905820     MOV.B [W0+26], W0
0020EA  B3C011     MOV #0x1, W1
0020EC  02336C     CALL _USB_SendToken
0020EE  000000     NOP
0020F0  37001D     BRA 0x212C
4171:                                              return;
4172:                                              break;
4173:              
4174:                                          case TSUBSTATE_BULK_WRITE_COMPLETE:
4175:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
4176:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
4177:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
4178:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
4179:                                                  {
4180:                                                      USB_EVENT_DATA *data;
4181:              
4182:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
4183:                                                      data->event = EVENT_TRANSFER;
4184:                                                      data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
4185:                                                      data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
4186:                                                      data->TransferData.bErrorCode       = USB_SUCCESS;
4187:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
4188:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
4189:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
4190:                                                  }
4191:                                                  else
4192:                                                  {
4193:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
4194:                                                  }
4195:                                              #endif
4196:                                              break;
4197:              
4198:                                          case TSUBSTATE_ERROR:
4199:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
0020F2  985888     MOV.B W8, [W1+24]
4200:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
0020F4  904031     MOV.B [W1+3], W0
0020F6  A01400     BSET.B W0, #1
0020F8  9840B0     MOV.B W0, [W1+3]
4201:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
4202:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
4203:                                                  {
4204:                                                      USB_EVENT_DATA *data;
4205:              
4206:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
4207:                                                      data->event = EVENT_BUS_ERROR;
4208:                                                      data->TransferData.dataCount        = 0;
4209:                                                      data->TransferData.pUserData        = NULL;
4210:                                                      data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
4211:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
4212:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
4213:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
4214:                                                  }
4215:                                                  else
4216:                                                  {
4217:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
4218:                                                  }
4219:                                              #endif
4220:                                              break;
4221:              
4222:                                          default:
4223:                                              illegalState = TRUE;
4224:                                              break;
4225:                                      }
4226:                                      break;
4227:              
4228:                                  default:
4229:                                      illegalState = TRUE;
4230:                                      break;
4231:                              }
4232:              
4233:                              if (illegalState)
0020FA  E0000B     CP0 W11
0020FC  3A0002     BRA NZ, 0x2102
0020FE  370006     BRA 0x210C
002100  20001B     MOV #0x1, W11
4234:                              {
4235:                                  // We should never use this, but in case we do, put the endpoint
4236:                                  // in a recoverable state.
4237:                                  pCurrentEndpoint->transferState               = TSTATE_IDLE;
002102  EB4000     CLR.B W0
002104  985880     MOV.B W0, [W1+24]
4238:                                  pCurrentEndpoint->status.bfTransferComplete   = 1;
002106  904031     MOV.B [W1+3], W0
002108  A01400     BSET.B W0, #1
00210A  9840B0     MOV.B W0, [W1+3]
4239:                              }
4240:                          }
4241:              
4242:                          // We've gone through all the bulk transactions, but we have time for more.
4243:                          // If we have any bulk transactions, go back to the beginning of the list
4244:                          // and start over.
4245:                          #ifdef ALLOW_MULTIPLE_BULK_TRANSACTIONS_PER_FRAME
4246:                              if (usbBusInfo.countBulkTransactions)
00210C  21ED10     MOV #0x1ED1, W0
00210E  E00410     CP0.B [W0]
002110  320003     BRA Z, 0x2118
4247:                              {
4248:                                  usbBusInfo.lastBulkTransaction = 0;
002112  21ED00     MOV #0x1ED0, W0
002114  EB4800     CLR.B [W0]
002116  37FFB9     BRA 0x208A
4249:                                  goto TryBulk;
4250:              
4251:                              }
4252:                          #endif
4253:              
4254:                          // If we've gone through all the endpoints, we do not have any more bulk transfers.
4255:                          usbBusInfo.flags.bfBulkTransfersDone = 1;
002118  21ECE0     MOV #0x1ECE, W0
00211A  A03410     BSET.B [W0], #3
00211C  370007     BRA 0x212C
4256:                      }
4257:                  #endif
4258:              
4259:                  return;
4260:              }
4261:              
4262:              
4263:              /****************************************************************************
4264:                Function:
4265:                  BOOL _USB_FindServiceEndpoint( BYTE transferType )
4266:              
4267:                Description:
4268:                  This function finds an endpoint of the specified transfer type that is
4269:                  ready for servicing.  If it finds one, usbDeviceInfo.pCurrentEndpoint is
4270:                  updated to point to the endpoint information structure.
4271:              
4272:                Precondition:
4273:                  None
4274:              
4275:                Parameters:
4276:                  BYTE transferType - Endpoint transfer type.  Valid values are:
4277:                                          * USB_TRANSFER_TYPE_CONTROL
4278:                                          * USB_TRANSFER_TYPE_ISOCHRONOUS
4279:                                          * USB_TRANSFER_TYPE_INTERRUPT
4280:                                          * USB_TRANSFER_TYPE_BULK
4281:              
4282:                Return Values:
4283:                  TRUE    - An endpoint of the indicated transfer type needs to be serviced,
4284:                              and pCurrentEndpoint has been updated to point to the endpoint.
4285:                  FALSE   - No endpoints of the indicated transfer type need to be serviced.
4286:              
4287:                Remarks:
4288:                  The EP 0 block is retained.
4289:                ***************************************************************************/
4290:              BOOL _USB_FindServiceEndpoint( BYTE transferType )
4291:              {
4292:                  USB_ENDPOINT_INFO           *pEndpoint;
4293:                  USB_INTERFACE_INFO          *pInterface;
4294:              
4295:                  // Check endpoint 0.
4296:                  if ((usbDeviceInfo.pEndpoint0->bmAttributes.bfTransferType == transferType) &&
002C42  80F651     MOV 0x1ECA, W1
002C44  FB8280     ZE W0, W5
002C46  900851     MOV [W1+26], W0
002C48  DE0048     LSR W0, #8, W0
002C4A  600063     AND W0, #0x3, W0
002C4C  500F85     SUB W0, W5, [W15]
002C4E  3A0003     BRA NZ, 0x2C56
002C50  904031     MOV.B [W1+3], W0
002C52  A31800     BTST.Z W0, #1
002C54  320035     BRA Z, 0x2CC0
4297:                      !usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
4298:                  {
4299:                      pCurrentEndpoint = usbDeviceInfo.pEndpoint0;
4300:                      return TRUE;
4301:                  }
4302:              
4303:                  usbBusInfo.countBulkTransactions = 0;
002C56  21ED10     MOV #0x1ED1, W0
002C58  EB4800     CLR.B [W0]
4304:                  pEndpoint = NULL;
4305:                  pInterface = usbDeviceInfo.pInterfaceList;
002C5A  80F643     MOV 0x1EC8, W3
002C5C  370027     BRA 0x2CAC
4306:                  if (pInterface && pInterface->pCurrentSetting)
4307:                  {
4308:                      pEndpoint = pInterface->pCurrentSetting->pEndpointList;
4309:                  }
4310:              
4311:                  while (pInterface)
4312:                  {
4313:                      if (pEndpoint != NULL)
002CB8  E00001     CP0 W1
002CBA  3AFFD1     BRA NZ, 0x2C5E
002CBC  37FFF6     BRA 0x2CAA
4314:                      {
4315:              			if (pEndpoint->bmAttributes.bfTransferType == transferType)
002C5E  900851     MOV [W1+26], W0
002C60  DE0048     LSR W0, #8, W0
002C62  600063     AND W0, #0x3, W0
002C64  500F85     SUB W0, W5, [W15]
002C66  3A001F     BRA NZ, 0x2CA6
4316:              			{
4317:              				switch (transferType)
002C68  524FE2     SUB.B W4, #0x2, [W15]
002C6A  320011     BRA Z, 0x2C8E
002C6C  524FE3     SUB.B W4, #0x3, [W15]
002C6E  320006     BRA Z, 0x2C7C
002C70  E00404     CP0.B W4
002C72  3A0019     BRA NZ, 0x2CA6
4318:              				{
4319:              					case USB_TRANSFER_TYPE_CONTROL:
4320:              						if (!pEndpoint->status.bfTransferComplete)
002C74  904031     MOV.B [W1+3], W0
002C76  A31800     BTST.Z W0, #1
002C78  3A0016     BRA NZ, 0x2CA6
002C7A  370022     BRA 0x2CC0
4321:              						{
4322:              							pCurrentEndpoint = pEndpoint;
4323:              							return TRUE;
4324:              						}
4325:              						break;
4326:              
4327:              					#ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
4328:              					case USB_TRANSFER_TYPE_ISOCHRONOUS:
4329:              					#endif
4330:              					#ifdef USB_SUPPORT_INTERRUPT_TRANSFERS
4331:              					case USB_TRANSFER_TYPE_INTERRUPT:
4332:              					#endif
4333:              					#if defined( USB_SUPPORT_ISOCHRONOUS_TRANSFERS ) || defined( USB_SUPPORT_INTERRUPT_TRANSFERS )
4334:              						if (pEndpoint->status.bfTransferComplete)
002C7C  904031     MOV.B [W1+3], W0
002C7E  A31800     BTST.Z W0, #1
002C80  32001F     BRA Z, 0x2CC0
4335:              						{
4336:              							// The endpoint doesn't need servicing.  If the interval count
4337:              							// has reached 0 and the user has not initiated another transaction,
4338:              							// reset the interval count for the next interval.
4339:              							if (pEndpoint->wIntervalCount == 0)
002C82  900031     MOV [W1+6], W0
002C84  E00000     CP0 W0
002C86  3A000F     BRA NZ, 0x2CA6
4340:              							{
4341:              								// Reset the interval count for the next packet.
4342:              								pEndpoint->wIntervalCount = pEndpoint->wInterval;
002C88  900021     MOV [W1+4], W0
002C8A  9800B0     MOV W0, [W1+6]
002C8C  37000C     BRA 0x2CA6
4343:              							}
4344:              						}
4345:              						else
4346:              						{
4347:              							pCurrentEndpoint = pEndpoint;
4348:              							return TRUE;
4349:              						}
4350:              						break;
4351:              					#endif
4352:              
4353:              					#ifdef USB_SUPPORT_BULK_TRANSFERS
4354:              					case USB_TRANSFER_TYPE_BULK:
4355:              						#ifdef ALLOW_MULTIPLE_NAKS_PER_FRAME
4356:              						if (!pEndpoint->status.bfTransferComplete)
4357:              						#else
4358:              						if (!pEndpoint->status.bfTransferComplete &&
002C8E  904031     MOV.B [W1+3], W0
002C90  A31800     BTST.Z W0, #1
002C92  3A0009     BRA NZ, 0x2CA6
002C94  904031     MOV.B [W1+3], W0
002C96  A34800     BTST.Z W0, #4
002C98  3A0006     BRA NZ, 0x2CA6
4359:              							!pEndpoint->status.bfLastTransferNAKd)
4360:              						#endif
4361:              						{
4362:              							usbBusInfo.countBulkTransactions ++;
002C9A  21ED10     MOV #0x1ED1, W0
002C9C  E84810     INC.B [W0], [W0]
4363:              							if (usbBusInfo.countBulkTransactions > usbBusInfo.lastBulkTransaction)
002C9E  21ED02     MOV #0x1ED0, W2
002CA0  784310     MOV.B [W0], W6
002CA2  534F92     SUB.B W6, [W2], [W15]
002CA4  3E000C     BRA GTU, 0x2CBE
4364:              							{
4365:              								usbBusInfo.lastBulkTransaction  = usbBusInfo.countBulkTransactions;
002CBE  784910     MOV.B [W0], [W2]
4366:              								pCurrentEndpoint                = pEndpoint;
002CC0  88F6A1     MOV W1, pCurrentEndpoint
002CC2  050010     RETLW #0x1, W0
4367:              								return TRUE;
4368:              							}
4369:              						}
4370:              						break;
4371:              					#endif
4372:              				}
4373:              			}
4374:              
4375:              	        // Go to the next endpoint.
4376:                          pEndpoint = pEndpoint->next;
002CA6  780091     MOV [W1], W1
002CA8  370007     BRA 0x2CB8
4377:                      }
4378:              
4379:                      if (pEndpoint == NULL)
4380:                      {
4381:                          // Go to the next interface.
4382:                          pInterface = pInterface->next;
002CAA  780193     MOV [W3], W3
4383:                          if (pInterface && pInterface->pCurrentSetting)
002CAC  E00003     CP0 W3
002CAE  32000A     BRA Z, 0x2CC4
002CB0  900023     MOV [W3+4], W0
002CB2  E00000     CP0 W0
002CB4  32FFFA     BRA Z, 0x2CAA
4384:                          {
4385:                              pEndpoint = pInterface->pCurrentSetting->pEndpointList;
002CB6  9000A0     MOV [W0+4], W1
4386:                          }
4387:                      }
4388:                  }
4389:              
4390:                  // No endpoints with the desired description are ready for servicing.
4391:                  return FALSE;
4392:              }
4393:              
4394:              
4395:              /****************************************************************************
4396:                Function:
4397:                  void _USB_FreeConfigMemory( void )
4398:              
4399:                Description:
4400:                  This function frees the interface and endpoint lists associated
4401:                              with a configuration.
4402:              
4403:                Precondition:
4404:                  None
4405:              
4406:                Parameters:
4407:                  None - None
4408:              
4409:                Returns:
4410:                  None
4411:              
4412:                Remarks:
4413:                  The EP 0 block is retained.
4414:                ***************************************************************************/
4415:              
4416:              void _USB_FreeConfigMemory( void )
4417:              {
4418:                  USB_INTERFACE_INFO          *pTempInterface;
4419:                  USB_INTERFACE_SETTING_INFO  *pTempSetting;
4420:                  USB_ENDPOINT_INFO           *pTempEndpoint;
4421:              
4422:                  while (usbDeviceInfo.pInterfaceList != NULL)
0032D4  80F640     MOV 0x1EC8, W0
0032D6  E00000     CP0 W0
0032D8  3AFFE2     BRA NZ, 0x329E
4423:                  {
4424:                      pTempInterface = usbDeviceInfo.pInterfaceList->next;
00329E  780510     MOV [W0], W10
0032A0  370012     BRA 0x32C6
4425:              
4426:                      while (usbDeviceInfo.pInterfaceList->pInterfaceSettings != NULL)
0032C6  80F640     MOV 0x1EC8, W0
0032C8  900090     MOV [W0+2], W1
0032CA  E00001     CP0 W1
0032CC  3AFFEA     BRA NZ, 0x32A2
4427:                      {
4428:                          pTempSetting = usbDeviceInfo.pInterfaceList->pInterfaceSettings->next;
0032A2  780491     MOV [W1], W9
0032A4  370006     BRA 0x32B2
4429:              
4430:                          while (usbDeviceInfo.pInterfaceList->pInterfaceSettings->pEndpointList != NULL)
0032B2  80F640     MOV 0x1EC8, W0
0032B4  900090     MOV [W0+2], W1
0032B6  900021     MOV [W1+4], W0
0032B8  E00000     CP0 W0
0032BA  3AFFF5     BRA NZ, 0x32A6
4431:                          {
4432:                              pTempEndpoint = usbDeviceInfo.pInterfaceList->pInterfaceSettings->pEndpointList->next;
0032A6  780410     MOV [W0], W8
4433:                              USB_FREE_AND_CLEAR( usbDeviceInfo.pInterfaceList->pInterfaceSettings->pEndpointList );
0032A8  0204B0     CALL free
0032AA  000000     NOP
0032AC  80F640     MOV 0x1EC8, W0
0032AE  900010     MOV [W0+2], W0
4434:                              usbDeviceInfo.pInterfaceList->pInterfaceSettings->pEndpointList = pTempEndpoint;
0032B0  980028     MOV W8, [W0+4]
4435:                          }
4436:                          USB_FREE_AND_CLEAR( usbDeviceInfo.pInterfaceList->pInterfaceSettings );
0032BC  780001     MOV W1, W0
0032BE  0204B0     CALL free
0032C0  000000     NOP
4437:                          usbDeviceInfo.pInterfaceList->pInterfaceSettings = pTempSetting;
0032C2  80F640     MOV 0x1EC8, W0
0032C4  980019     MOV W9, [W0+2]
4438:                      }
4439:                      USB_FREE_AND_CLEAR( usbDeviceInfo.pInterfaceList );
0032CE  0204B0     CALL free
0032D0  000000     NOP
4440:                      usbDeviceInfo.pInterfaceList = pTempInterface;
0032D2  88F64A     MOV W10, 0x1EC8
4441:                  }
4442:              
4443:                  pCurrentEndpoint = usbDeviceInfo.pEndpoint0;
0032DA  80F650     MOV 0x1ECA, W0
0032DC  88F6A0     MOV W0, pCurrentEndpoint
4444:              
4445:              } // _USB_FreeConfigMemory
4446:              
4447:              
4448:              /****************************************************************************
4449:                Function:
4450:                  void _USB_FreeMemory( void )
4451:              
4452:                Description:
4453:                  This function frees all memory that can be freed.  Only the EP0
4454:                  information block is retained.
4455:              
4456:                Precondition:
4457:                  None
4458:              
4459:                Parameters:
4460:                  None - None
4461:              
4462:                Returns:
4463:                  None
4464:              
4465:                Remarks:
4466:                  None
4467:                ***************************************************************************/
4468:              
4469:              void _USB_FreeMemory( void )
4470:              {
4471:                  BYTE    *pTemp;
4472:              
4473:                  while (usbDeviceInfo.pConfigurationDescriptorList != NULL)
003438  80F639     MOV 0x1EC6, W9
00343A  E00009     CP0 W9
00343C  3AFFF4     BRA NZ, 0x3426
4474:                  {
4475:                      pTemp = (BYTE *)usbDeviceInfo.pConfigurationDescriptorList->next;
003426  900419     MOV [W9+2], W8
4476:                      USB_FREE_AND_CLEAR( usbDeviceInfo.pConfigurationDescriptorList->descriptor );
003428  780019     MOV [W9], W0
00342A  0204B0     CALL free
00342C  000000     NOP
00342E  80F630     MOV 0x1EC6, W0
003430  EB0800     CLR [W0]
4477:                      USB_FREE_AND_CLEAR( usbDeviceInfo.pConfigurationDescriptorList );
003432  0204B0     CALL free
003434  000000     NOP
4478:                      usbDeviceInfo.pConfigurationDescriptorList = (USB_CONFIGURATION *)pTemp;
003436  88F638     MOV W8, 0x1EC6
4479:                  }
4480:                  if (pDeviceDescriptor != NULL)
00343E  80FA70     MOV pDeviceDescriptor, W0
003440  E00000     CP0 W0
003442  320003     BRA Z, 0x344A
4481:                  {
4482:                      USB_FREE_AND_CLEAR( pDeviceDescriptor );
003444  0204B0     CALL free
003446  000000     NOP
003448  88FA79     MOV W9, pDeviceDescriptor
4483:                  }
4484:                  if (pEP0Data != NULL)
00344A  80F590     MOV pEP0Data, W0
00344C  E00000     CP0 W0
00344E  320003     BRA Z, 0x3456
4485:                  {
4486:                      USB_FREE_AND_CLEAR( pEP0Data );
003450  0204B0     CALL free
003452  000000     NOP
003454  88F599     MOV W9, pEP0Data
4487:                  }
4488:              
4489:                  _USB_FreeConfigMemory();
003456  023298     CALL _USB_FreeConfigMemory
003458  000000     NOP
4490:              
4491:              }
4492:              
4493:              
4494:              /****************************************************************************
4495:                Function:
4496:                  void _USB_InitControlRead( USB_ENDPOINT_INFO *pEndpoint,
4497:                                      BYTE *pControlData, WORD controlSize, BYTE *pData,
4498:                                      WORD size )
4499:              
4500:                Description:
4501:                  This function sets up the endpoint information for a control (SETUP)
4502:                  transfer that will read information.
4503:              
4504:                Precondition:
4505:                  All error checking must be done prior to calling this function.
4506:              
4507:                Parameters:
4508:                  USB_ENDPOINT_INFO *pEndpoint    - Points to the desired endpoint
4509:                                                      in the endpoint information list.
4510:                  BYTE *pControlData              - Points to the SETUP message.
4511:                  WORD controlSize                - Size of the SETUP message.
4512:                  BYTE *pData                     - Points to where the read data
4513:                                                      is to be stored.
4514:                  WORD size                       - Number of data bytes to read.
4515:              
4516:                Returns:
4517:                  None
4518:              
4519:                Remarks:
4520:                  Since endpoint servicing is interrupt driven, the bfTransferComplete
4521:                  flag must be set last.
4522:                ***************************************************************************/
4523:              
4524:              void _USB_InitControlRead( USB_ENDPOINT_INFO *pEndpoint, BYTE *pControlData, WORD controlSize,
4525:                                          BYTE *pData, WORD size )
4526:              {
4527:                  pEndpoint->status.bfStalled             = 0;
0032E4  9042A0     MOV.B [W0+2], W5
0032E6  A15405     BCLR.B W5, #5
0032E8  984025     MOV.B W5, [W0+2]
4528:                  pEndpoint->status.bfError               = 0;
0032EA  9042A0     MOV.B [W0+2], W5
0032EC  A16405     BCLR.B W5, #6
0032EE  984025     MOV.B W5, [W0+2]
4529:                  pEndpoint->status.bfUserAbort           = 0;
0032F0  9042A0     MOV.B [W0+2], W5
0032F2  A17405     BCLR.B W5, #7
0032F4  984025     MOV.B W5, [W0+2]
4530:                  pEndpoint->status.bfTransferSuccessful  = 0;
0032F6  9042B0     MOV.B [W0+3], W5
0032F8  A10405     BCLR.B W5, #0
0032FA  984035     MOV.B W5, [W0+3]
4531:                  pEndpoint->status.bfErrorCount          = 0;
0032FC  9042A0     MOV.B [W0+2], W5
0032FE  B3CE06     MOV #0xE0, W6
003300  62C286     AND.B W5, W6, W5
003302  984025     MOV.B W5, [W0+2]
4532:                  pEndpoint->status.bfLastTransferNAKd    = 0;
003304  9042B0     MOV.B [W0+3], W5
003306  A14405     BCLR.B W5, #4
003308  984035     MOV.B W5, [W0+3]
4533:                  pEndpoint->pUserData                    = pData;
00330A  980833     MOV W3, [W0+22]
4534:                  pEndpoint->dataCount                    = 0;
00330C  B83360     MUL.UU W6, #0, W6
00330E  980806     MOV W6, [W0+16]
003310  980817     MOV W7, [W0+18]
4535:                  pEndpoint->dataCountMax                 = size;
003312  200005     MOV #0x0, W5
003314  980054     MOV W4, [W0+10]
003316  980065     MOV W5, [W0+12]
4536:                  pEndpoint->countNAKs                    = 0;
003318  EB0180     CLR W3
00331A  980873     MOV W3, [W0+30]
4537:              
4538:                  pEndpoint->pUserDataSETUP               = pControlData;
00331C  980821     MOV W1, [W0+20]
4539:                  pEndpoint->dataCountMaxSETUP            = controlSize;
00331E  980072     MOV W2, [W0+14]
4540:                  pEndpoint->transferState                = TSTATE_CONTROL_READ;
003320  B3C201     MOV #0x20, W1
003322  985801     MOV.B W1, [W0+24]
4541:              
4542:                  // Set the flag last so all the parameters are set for an interrupt.
4543:                  pEndpoint->status.bfTransferComplete    = 0;
003324  9040B0     MOV.B [W0+3], W1
003326  A11401     BCLR.B W1, #1
003328  984031     MOV.B W1, [W0+3]
4544:              }
4545:              
4546:              
4547:              /****************************************************************************
4548:                Function:
4549:                  void _USB_InitControlWrite( USB_ENDPOINT_INFO *pEndpoint,
4550:                                      BYTE *pControlData, WORD controlSize, BYTE *pData,
4551:                                      WORD size )
4552:              
4553:                Description:
4554:                  This function sets up the endpoint information for a control (SETUP)
4555:                  transfer that will write information.
4556:              
4557:                Precondition:
4558:                  All error checking must be done prior to calling this function.
4559:              
4560:                Parameters:
4561:                  USB_ENDPOINT_INFO *pEndpoint    - Points to the desired endpoint
4562:                                                                    in the endpoint information list.
4563:                  BYTE *pControlData              - Points to the SETUP message.
4564:                  WORD controlSize                - Size of the SETUP message.
4565:                  BYTE *pData                     - Points to where the write data
4566:                                                                    is to be stored.
4567:                  WORD size                       - Number of data bytes to write.
4568:              
4569:                Returns:
4570:                  None
4571:              
4572:                Remarks:
4573:                  Since endpoint servicing is interrupt driven, the bfTransferComplete
4574:                  flag must be set last.
4575:                ***************************************************************************/
4576:              
4577:              void _USB_InitControlWrite( USB_ENDPOINT_INFO *pEndpoint, BYTE *pControlData,
4578:                              WORD controlSize, BYTE *pData, WORD size )
4579:              {
4580:                  pEndpoint->status.bfStalled             = 0;
0031F8  904020     MOV.B [W0+2], W0
0031FA  A15400     BCLR.B W0, #5
0031FC  984420     MOV.B W0, [W8+2]
4581:                  pEndpoint->status.bfError               = 0;
0031FE  904028     MOV.B [W8+2], W0
003200  A16400     BCLR.B W0, #6
003202  984420     MOV.B W0, [W8+2]
4582:                  pEndpoint->status.bfUserAbort           = 0;
003204  904028     MOV.B [W8+2], W0
003206  A17400     BCLR.B W0, #7
003208  984420     MOV.B W0, [W8+2]
4583:                  pEndpoint->status.bfTransferSuccessful  = 0;
00320A  904038     MOV.B [W8+3], W0
00320C  A10400     BCLR.B W0, #0
00320E  984430     MOV.B W0, [W8+3]
4584:                  pEndpoint->status.bfErrorCount          = 0;
003210  904028     MOV.B [W8+2], W0
003212  B3CE05     MOV #0xE0, W5
003214  604005     AND.B W0, W5, W0
003216  984420     MOV.B W0, [W8+2]
4585:                  pEndpoint->status.bfLastTransferNAKd    = 0;
003218  904038     MOV.B [W8+3], W0
00321A  A14400     BCLR.B W0, #4
00321C  984430     MOV.B W0, [W8+3]
4586:                  pEndpoint->pUserData                    = pData;
00321E  980C33     MOV W3, [W8+22]
4587:                  pEndpoint->dataCount                    = 0;
003220  B83360     MUL.UU W6, #0, W6
003222  980C06     MOV W6, [W8+16]
003224  980C17     MOV W7, [W8+18]
4588:                  pEndpoint->dataCountMax                 = size;
003226  B82361     MUL.UU W4, #1, W6
003228  980456     MOV W6, [W8+10]
00322A  980467     MOV W7, [W8+12]
4589:                  pEndpoint->countNAKs                    = 0;
00322C  EB0000     CLR W0
00322E  980C70     MOV W0, [W8+30]
4590:              
4591:                  pEndpoint->pUserDataSETUP               = pControlData;
003230  980C21     MOV W1, [W8+20]
4592:                  pEndpoint->dataCountMaxSETUP            = controlSize;
003232  980472     MOV W2, [W8+14]
4593:              
4594:                  if (size == 0)
003236  E00004     CP0 W4
003238  320001     BRA Z, 0x323C
4595:                  {
4596:                      pEndpoint->transferState    = TSTATE_CONTROL_NO_DATA;
003234  B3C100     MOV #0x10, W0
4597:                  }
4598:                  else
4599:                  {
4600:                      pEndpoint->transferState    = TSTATE_CONTROL_WRITE;
00323A  B3C300     MOV #0x30, W0
00323C  985C00     MOV.B W0, [W8+24]
4601:                  }
4602:              
4603:                  // Set the flag last so all the parameters are set for an interrupt.
4604:                  pEndpoint->status.bfTransferComplete    = 0;
00323E  904038     MOV.B [W8+3], W0
003240  A11400     BCLR.B W0, #1
003242  984430     MOV.B W0, [W8+3]
4605:              }
4606:              
4607:              
4608:              /****************************************************************************
4609:                Function:
4610:                  void _USB_InitRead( USB_ENDPOINT_INFO *pEndpoint, BYTE *pData,
4611:                                      WORD size )
4612:              
4613:                Description:
4614:                  This function sets up the endpoint information for an interrupt,
4615:                  isochronous, or bulk read.  If the transfer is isochronous, the pData
4616:                  and size parameters have different meaning.
4617:              
4618:                Precondition:
4619:                  All error checking must be done prior to calling this function.
4620:              
4621:                Parameters:
4622:                  USB_ENDPOINT_INFO *pEndpoint  - Points to the desired endpoint in the
4623:                                                  endpoint information list.
4624:                  BYTE *pData                   - Points to where the data is to be
4625:                                                  stored.  If the endpoint is isochronous,
4626:                                                  this points to an ISOCHRONOUS_DATA_BUFFERS
4627:                                                  structure.
4628:                  WORD size                     - Number of data bytes to read. If the
4629:                                                  endpoint is isochronous, this is the number
4630:                                                  of data buffer pointers pointed to by
4631:                                                  pData.
4632:              
4633:                Returns:
4634:                  None
4635:              
4636:                Remarks:
4637:                  * Control reads should use the routine _USB_InitControlRead().  Since
4638:                      endpoint servicing is interrupt driven, the bfTransferComplete flag
4639:                      must be set last.
4640:              
4641:                  * For interrupt and isochronous endpoints, we let the interval count
4642:                      free run.  The transaction will begin when the interval count
4643:                      reaches 0.
4644:                ***************************************************************************/
4645:              
4646:              void _USB_InitRead( USB_ENDPOINT_INFO *pEndpoint, BYTE *pData, WORD size )
4647:              {
4648:                  pEndpoint->status.bfUserAbort           = 0;
0030F0  904020     MOV.B [W0+2], W0
0030F2  A17400     BCLR.B W0, #7
0030F4  9841A0     MOV.B W0, [W3+2]
4649:                  pEndpoint->status.bfTransferSuccessful  = 0;
0030F6  904033     MOV.B [W3+3], W0
0030F8  A10400     BCLR.B W0, #0
0030FA  9841B0     MOV.B W0, [W3+3]
4650:                  pEndpoint->status.bfErrorCount          = 0;
0030FC  904023     MOV.B [W3+2], W0
0030FE  B3CE01     MOV #0xE0, W1
003100  604001     AND.B W0, W1, W0
003102  9841A0     MOV.B W0, [W3+2]
4651:                  pEndpoint->status.bfLastTransferNAKd    = 0;
003104  904033     MOV.B [W3+3], W0
003106  A14400     BCLR.B W0, #4
003108  9841B0     MOV.B W0, [W3+3]
4652:                  pEndpoint->pUserData                    = pData;
00310A  9809B4     MOV W4, [W3+22]
4653:                  pEndpoint->dataCount                    = 0;
00310C  B80060     MUL.UU W0, #0, W0
00310E  980980     MOV W0, [W3+16]
003110  980991     MOV W1, [W3+18]
4654:                  pEndpoint->dataCountMax                 = size; // Not used for isochronous.
003112  B81061     MUL.UU W2, #1, W0
003114  9801D0     MOV W0, [W3+10]
003116  9801E1     MOV W1, [W3+12]
4655:                  pEndpoint->countNAKs                    = 0;
003118  EB0100     CLR W2
00311A  9809F2     MOV W2, [W3+30]
4656:              
4657:                  if (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_INTERRUPT)
00311C  9008D3     MOV [W3+26], W1
00311E  B23001     AND #0x300, W1
003120  203000     MOV #0x300, W0
003122  508F80     SUB W1, W0, [W15]
003124  3A0002     BRA NZ, 0x312A
4658:                  {
4659:                      pEndpoint->transferState            = TSTATE_INTERRUPT_READ;
003126  B3C400     MOV #0x40, W0
003128  370008     BRA 0x313A
4660:                  }
4661:                  else if (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
00312A  201000     MOV #0x100, W0
00312C  508F80     SUB W1, W0, [W15]
00312E  3A0004     BRA NZ, 0x3138
4662:                  {
4663:                      pEndpoint->transferState                                        = TSTATE_ISOCHRONOUS_READ;
003130  B3C600     MOV #0x60, W0
003132  985980     MOV.B W0, [W3+24]
4664:                      ((ISOCHRONOUS_DATA *)pEndpoint->pUserData)->currentBufferUSB    = 0;
003134  984212     MOV.B W2, [W4+1]
003136  370002     BRA 0x313C
4665:                  }
4666:                  else // Bulk
4667:                  {
4668:                      pEndpoint->transferState            = TSTATE_BULK_READ;
003138  B3C800     MOV #0x80, W0
00313A  985980     MOV.B W0, [W3+24]
4669:                  }
4670:              
4671:                  // Set the flag last so all the parameters are set for an interrupt.
4672:                  pEndpoint->status.bfTransferComplete    = 0;
00313C  904033     MOV.B [W3+3], W0
00313E  A11400     BCLR.B W0, #1
003140  9841B0     MOV.B W0, [W3+3]
4673:              }
4674:              
4675:              /****************************************************************************
4676:                Function:
4677:                  void _USB_InitWrite( USB_ENDPOINT_INFO *pEndpoint, BYTE *pData,
4678:                                          WORD size )
4679:              
4680:                Description:
4681:                  This function sets up the endpoint information for an interrupt,
4682:                  isochronous, or bulk  write.  If the transfer is isochronous, the pData
4683:                  and size parameters have different meaning.
4684:              
4685:                Precondition:
4686:                  All error checking must be done prior to calling this function.
4687:              
4688:                Parameters:
4689:                  USB_ENDPOINT_INFO *pEndpoint  - Points to the desired endpoint in the
4690:                                                  endpoint information list.
4691:                  BYTE *pData                   - Points to where the data to send is
4692:                                                  stored.  If the endpoint is isochronous,
4693:                                                  this points to an ISOCHRONOUS_DATA_BUFFERS
4694:                                                  structure.
4695:                  WORD size                     - Number of data bytes to write.  If the
4696:                                                  endpoint is isochronous, this is the number
4697:                                                  of data buffer pointers pointed to by
4698:                                                  pData.
4699:              
4700:                Returns:
4701:                  None
4702:              
4703:                Remarks:
4704:                  * Control writes should use the routine _USB_InitControlWrite().  Since
4705:                      endpoint servicing is interrupt driven, the bfTransferComplete flag
4706:                      must be set last.
4707:              
4708:                  * For interrupt and isochronous endpoints, we let the interval count
4709:                      free run.  The transaction will begin when the interval count
4710:                      reaches 0.
4711:                ***************************************************************************/
4712:              
4713:              void _USB_InitWrite( USB_ENDPOINT_INFO *pEndpoint, BYTE *pData, WORD size )
4714:              {
4715:                  pEndpoint->status.bfUserAbort           = 0;
003148  904020     MOV.B [W0+2], W0
00314A  A17400     BCLR.B W0, #7
00314C  9841A0     MOV.B W0, [W3+2]
4716:                  pEndpoint->status.bfTransferSuccessful  = 0;
00314E  904033     MOV.B [W3+3], W0
003150  A10400     BCLR.B W0, #0
003152  9841B0     MOV.B W0, [W3+3]
4717:                  pEndpoint->status.bfErrorCount          = 0;
003154  904023     MOV.B [W3+2], W0
003156  B3CE01     MOV #0xE0, W1
003158  604001     AND.B W0, W1, W0
00315A  9841A0     MOV.B W0, [W3+2]
4718:                  pEndpoint->status.bfLastTransferNAKd    = 0;
00315C  904033     MOV.B [W3+3], W0
00315E  A14400     BCLR.B W0, #4
003160  9841B0     MOV.B W0, [W3+3]
4719:                  pEndpoint->pUserData                    = pData;
003162  9809B4     MOV W4, [W3+22]
4720:                  pEndpoint->dataCount                    = 0;
003164  B80060     MUL.UU W0, #0, W0
003166  980980     MOV W0, [W3+16]
003168  980991     MOV W1, [W3+18]
4721:                  pEndpoint->dataCountMax                 = size; // Not used for isochronous.
00316A  B81061     MUL.UU W2, #1, W0
00316C  9801D0     MOV W0, [W3+10]
00316E  9801E1     MOV W1, [W3+12]
4722:                  pEndpoint->countNAKs                    = 0;
003170  EB0100     CLR W2
003172  9809F2     MOV W2, [W3+30]
4723:              
4724:                  if (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_INTERRUPT)
003174  9008D3     MOV [W3+26], W1
003176  B23001     AND #0x300, W1
003178  203000     MOV #0x300, W0
00317A  508F80     SUB W1, W0, [W15]
00317C  3A0002     BRA NZ, 0x3182
4725:                  {
4726:                      pEndpoint->transferState            = TSTATE_INTERRUPT_WRITE;
00317E  B3C500     MOV #0x50, W0
003180  370008     BRA 0x3192
4727:                  }
4728:                  else if (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
003182  201000     MOV #0x100, W0
003184  508F80     SUB W1, W0, [W15]
003186  3A0004     BRA NZ, 0x3190
4729:                  {
4730:                      pEndpoint->transferState                                        = TSTATE_ISOCHRONOUS_WRITE;
003188  B3C700     MOV #0x70, W0
00318A  985980     MOV.B W0, [W3+24]
4731:                      ((ISOCHRONOUS_DATA *)pEndpoint->pUserData)->currentBufferUSB    = 0;
00318C  984212     MOV.B W2, [W4+1]
00318E  370002     BRA 0x3194
4732:                  }
4733:                  else // Bulk
4734:                  {
4735:                      pEndpoint->transferState            = TSTATE_BULK_WRITE;
003190  B3C900     MOV #0x90, W0
003192  985980     MOV.B W0, [W3+24]
4736:                  }
4737:              
4738:                  // Set the flag last so all the parameters are set for an interrupt.
4739:                  pEndpoint->status.bfTransferComplete    = 0;
003194  904033     MOV.B [W3+3], W0
003196  A11400     BCLR.B W0, #1
003198  9841B0     MOV.B W0, [W3+3]
4740:              }
4741:              
4742:              
4743:              /****************************************************************************
4744:                Function:
4745:                  void _USB_NotifyClients( BYTE address, USB_EVENT event, void *data,
4746:                              unsigned int size )
4747:              
4748:                Description:
4749:                  This routine notifies all active client drivers for the given device of
4750:                  the given event.
4751:              
4752:                Precondition:
4753:                  None
4754:              
4755:                Parameters:
4756:                  BYTE address        - Address of the device generating the event
4757:                  USB_EVENT event     - Event ID
4758:                  void *data          - Pointer to event data
4759:                  unsigned int size   - Size of data pointed to by data
4760:              
4761:                Returns:
4762:                  None
4763:              
4764:                Remarks:
4765:                  When this driver is modified to support multiple devices, this function
4766:                  will require modification.
4767:                ***************************************************************************/
4768:              
4769:              void _USB_NotifyClients( BYTE address, USB_EVENT event, void *data, unsigned int size )
4770:              {
4771:                  USB_INTERFACE_INFO  *pInterface;
4772:              
4773:                  // Some events go to all drivers, some only to specific drivers.
4774:                  switch(event)
00309C  200720     MOV #0x72, W0
00309E  508F80     SUB W1, W0, [W15]
0030A0  320003     BRA Z, 0x30A8
0030A2  27FFF0     MOV #0x7FFF, W0
0030A4  508F80     SUB W1, W0, [W15]
0030A6  3A000E     BRA NZ, 0x30C4
4775:                  {
4776:                      case EVENT_TRANSFER:
4777:                      case EVENT_BUS_ERROR:
4778:                          if (((HOST_TRANSFER_DATA *)data)->clientDriver != CLIENT_DRIVER_HOST)
0030A8  90481A     MOV.B [W10+9], W0
0030AA  404FE1     ADD.B W0, #0x1, [W15]
0030AC  32001B     BRA Z, 0x30E4
4779:                          {
4780:                              usbClientDrvTable[((HOST_TRANSFER_DATA *)data)->clientDriver].EventHandler(address, event, data, size);
0030AE  FB8000     ZE W0, W0
0030B0  DD0043     SL W0, #3, W0
0030B2  E88000     INC2 W0, W0
0030B4  21F181     MOV #0x1F18, W1
0030B6  7801E1     MOV [W1+W0], W3
0030B8  B85A61     MUL.UU W11, #1, W4
0030BA  78010A     MOV W10, W2
0030BC  780089     MOV W9, W1
0030BE  78400C     MOV.B W12, W0
0030C0  010003     CALL W3
0030C2  370010     BRA 0x30E4
4781:                          }
4782:                          break;
4783:                      default:
4784:                          pInterface = usbDeviceInfo.pInterfaceList;
0030C4  80F648     MOV 0x1EC8, W8
0030C6  37000C     BRA 0x30E0
4785:                          while (pInterface != NULL)  // Scan the interface list for all active drivers.
0030E0  E00008     CP0 W8
0030E2  3AFFF2     BRA NZ, 0x30C8
4786:                          {
4787:                              usbClientDrvTable[pInterface->clientDriver].EventHandler(address, event, data, size);
0030C8  904078     MOV.B [W8+7], W0
0030CA  FB8000     ZE W0, W0
0030CC  DD0043     SL W0, #3, W0
0030CE  E88000     INC2 W0, W0
0030D0  21F181     MOV #0x1F18, W1
0030D2  7801E1     MOV [W1+W0], W3
0030D4  B85A61     MUL.UU W11, #1, W4
0030D6  78010A     MOV W10, W2
0030D8  780089     MOV W9, W1
0030DA  78400C     MOV.B W12, W0
0030DC  010003     CALL W3
4788:                              pInterface = pInterface->next;
0030DE  780418     MOV [W8], W8
4789:                          }
4790:                          break;
4791:                  }
4792:              } // _USB_NotifyClients
4793:              
4794:              /****************************************************************************
4795:                Function:
4796:                  void _USB_NotifyClients( BYTE address, USB_EVENT event, void *data,
4797:                              unsigned int size )
4798:              
4799:                Description:
4800:                  This routine notifies all active client drivers for the given device of
4801:                  the given event.
4802:              
4803:                Precondition:
4804:                  None
4805:              
4806:                Parameters:
4807:                  BYTE address        - Address of the device generating the event
4808:                  USB_EVENT event     - Event ID
4809:                  void *data          - Pointer to event data
4810:                  unsigned int size   - Size of data pointed to by data
4811:              
4812:                Returns:
4813:                  None
4814:              
4815:                Remarks:
4816:                  When this driver is modified to support multiple devices, this function
4817:                  will require modification.
4818:                ***************************************************************************/
4819:              #ifdef USB_HOST_APP_DATA_EVENT_HANDLER
4820:              void _USB_NotifyDataClients( BYTE address, USB_EVENT event, void *data, unsigned int size )
4821:              {
4822:                  USB_INTERFACE_INFO  *pInterface;
4823:              
4824:                  // Some events go to all drivers, some only to specific drivers.
4825:                  switch(event)
4826:                  {
4827:                      default:
4828:                          pInterface = usbDeviceInfo.pInterfaceList;
4829:                          while (pInterface != NULL)  // Scan the interface list for all active drivers.
4830:                          {
4831:                              usbClientDrvTable[pInterface->clientDriver].DataEventHandler(address, event, data, size);
4832:                              pInterface = pInterface->next;
4833:                          }
4834:                          break;
4835:                  }
4836:              } // _USB_NotifyClients
4837:              #endif
4838:              
4839:              /****************************************************************************
4840:                Function:
4841:                  void _USB_NotifyAllDataClients( BYTE address, USB_EVENT event, void *data,
4842:                              unsigned int size )
4843:              
4844:                Description:
4845:                  This routine notifies all client drivers (active or not) for the given device of
4846:                  the given event.
4847:              
4848:                Precondition:
4849:                  None
4850:              
4851:                Parameters:
4852:                  BYTE address        - Address of the device generating the event
4853:                  USB_EVENT event     - Event ID
4854:                  void *data          - Pointer to event data
4855:                  unsigned int size   - Size of data pointed to by data
4856:              
4857:                Returns:
4858:                  None
4859:              
4860:                Remarks:
4861:                  When this driver is modified to support multiple devices, this function
4862:                  will require modification.
4863:                ***************************************************************************/
4864:              #if defined(USB_ENABLE_1MS_EVENT) && defined(USB_HOST_APP_DATA_EVENT_HANDLER)
4865:              void _USB_NotifyAllDataClients( BYTE address, USB_EVENT event, void *data, unsigned int size )
4866:              {
4867:                  WORD i;
4868:              
4869:                  // Some events go to all drivers, some only to specific drivers.
4870:                  switch(event)
4871:                  {
4872:                      default:
4873:                          for(i=0;i<NUM_CLIENT_DRIVER_ENTRIES;i++)
4874:                          {
4875:                              usbClientDrvTable[i].DataEventHandler(address, event, data, size);
4876:                          }
4877:                          break;
4878:                  }
4879:              } // _USB_NotifyClients
4880:              #endif
4881:              
4882:              /****************************************************************************
4883:                Function:
4884:                  BOOL _USB_ParseConfigurationDescriptor( void )
4885:              
4886:                Description:
4887:                  This function parses all the endpoint descriptors for the required
4888:                  setting of the required interface and sets up the internal endpoint
4889:                  information.
4890:              
4891:                Precondition:
4892:                  pCurrentConfigurationDescriptor points to a valid Configuration
4893:                  Descriptor, which contains the endpoint descriptors.  The current
4894:                  interface and the current interface settings must be set up in
4895:                  usbDeviceInfo.
4896:              
4897:                Parameters:
4898:                  None - None
4899:              
4900:                Returns:
4901:                  TRUE    - Successful
4902:                  FALSE   - Configuration not supported.
4903:              
4904:                Remarks:
4905:                  * This function also automatically resets all endpoints (except
4906:                      endpoint 0) to DATA0, so _USB_ResetDATA0 does not have to be
4907:                      called.
4908:              
4909:                  * If the configuration is not supported, the caller will need to clean
4910:                      up, freeing memory by calling _USB_FreeConfigMemory.
4911:              
4912:                  * We do not currently implement checks for descriptors that are shorter
4913:                      than the expected length, in the case of invalid USB Peripherals.
4914:              
4915:                  * If there is not enough available heap space for storing the
4916:                      interface or endpoint information, this function will return FALSE.
4917:                      Currently, there is no other mechanism for informing the user of
4918:                      an out of dynamic memory condition.
4919:              
4920:                  * We are assuming that we can support a single interface on a single
4921:                      device.  When the driver is modified to support multiple devices,
4922:                      each endpoint should be checked to ensure that we have enough
4923:                      bandwidth to support it.
4924:                ***************************************************************************/
4925:              
4926:              BOOL _USB_ParseConfigurationDescriptor( void )
4927:              {
4928:                  BYTE                        bAlternateSetting;
4929:                  BYTE                        bDescriptorType;
4930:                  BYTE                        bInterfaceNumber;
4931:                  BYTE                        bLength;
4932:                  BYTE                        bNumEndpoints;
4933:                  BYTE                        bNumInterfaces;
4934:                  BYTE                        bMaxPower;
4935:                  BOOL                        error;
4936:                  BYTE                        Class;
4937:                  BYTE                        SubClass;
4938:                  BYTE                        Protocol;
4939:                  BYTE                        ClientDriver;
4940:                  WORD                        wTotalLength;
4941:              
4942:                  BYTE                        currentAlternateSetting;
4943:                  BYTE                        currentConfiguration;
4944:                  BYTE                        currentEndpoint;
4945:                  BYTE                        currentInterface;
4946:                  WORD                        index;
4947:                  USB_ENDPOINT_INFO           *newEndpointInfo;
4948:                  USB_INTERFACE_INFO          *newInterfaceInfo;
4949:                  USB_INTERFACE_SETTING_INFO  *newSettingInfo;
4950:                  USB_VBUS_POWER_EVENT_DATA   powerRequest;
4951:                  USB_INTERFACE_INFO          *pTempInterfaceList;
4952:                  BYTE                        *ptr;
4953:              
4954:                  // Prime the loops.
4955:                  currentEndpoint         = 0;
4956:                  error                   = FALSE;
4957:                  index                   = 0;
4958:                  ptr                     = pCurrentConfigurationDescriptor;
001A80  80FA82     MOV pCurrentConfigurationDescriptor, W2
4959:                  currentInterface        = 0;
4960:                  currentAlternateSetting = 0;
4961:                  pTempInterfaceList      = usbDeviceInfo.pInterfaceList; // Don't set until everything is in place.
001A82  80F64C     MOV 0x1EC8, W12
4962:              
4963:                  // Assume no OTG support (determine otherwise, below).
4964:                  usbDeviceInfo.flags.bfSupportsOTG   = 0;
001A84  21ECC0     MOV #0x1ECC, W0
001A86  A11410     BCLR.B [W0], #1
4965:                  usbDeviceInfo.flags.bfConfiguredOTG = 1;
001A88  A02410     BSET.B [W0], #2
4966:              
4967:                  #ifdef USB_SUPPORT_OTG
4968:                      usbDeviceInfo.flags.bfAllowHNP = 1;  //Allow HNP From Host
4969:                  #endif
4970:              
4971:                  // Load up the values from the Configuration Descriptor
4972:                  bLength              = *ptr++;
001A8A  784412     MOV.B [W2], W8
4973:                  bDescriptorType      = *ptr++;
4974:                  wTotalLength         = *ptr++;           // In case these are not word aligned
001A8C  9040A2     MOV.B [W2+2], W1
001A8E  FB8081     ZE W1, W1
4975:                  wTotalLength        += (*ptr++) << 8;
001A90  904032     MOV.B [W2+3], W0
001A92  DD0048     SL W0, #8, W0
001A94  408080     ADD W1, W0, W1
001A96  9FB7C1     MOV W1, [W15-24]
4976:                  bNumInterfaces       = *ptr++;
4977:                  currentConfiguration = *ptr++;  // bConfigurationValue
001A98  904052     MOV.B [W2+5], W0
001A9A  9FEFB0     MOV.B W0, [W15-21]
4978:                                          ptr++;  // iConfiguration
4979:                                          ptr++;  // bmAttributes
4980:                  bMaxPower            = *ptr;
001A9C  904902     MOV.B [W2+8], W2
001A9E  9FEFE2     MOV.B W2, [W15-18]
4981:              
4982:                  // Check Max Power to see if we can support this configuration.
4983:                  powerRequest.current = bMaxPower;
001AA0  57817B     SUB W15, #0x1B, W2
001AA2  97E8EF     MOV.B [W15-18], W1
001AA4  984111     MOV.B W1, [W2+1]
4984:                  powerRequest.port    = 0;        // Port 0
001AA6  EB4900     CLR.B [W2]
4985:                  if (!USB_HOST_APP_EVENT_HANDLER( USB_ROOT_HUB, EVENT_VBUS_REQUEST_POWER,
001AA8  200024     MOV #0x2, W4
001AAA  200005     MOV #0x0, W5
001AAC  200691     MOV #0x69, W1
001AAE  EBC000     SETM.B W0
001AB0  022C18     CALL USB_ApplicationEventHandler
001AB2  000000     NOP
001AB4  EB0100     CLR W2
001AB6  E00000     CP0 W0
001AB8  3A0004     BRA NZ, 0x1AC2
4986:                          &powerRequest, sizeof(USB_VBUS_POWER_EVENT_DATA) ))
4987:                  {
4988:                      usbDeviceInfo.errorCode = USB_ERROR_INSUFFICIENT_POWER;
001ABA  B3C281     MOV #0x28, W1
001ABC  21EC00     MOV #0x1EC0, W0
001ABE  784801     MOV.B W1, [W0]
001AC0  200012     MOV #0x1, W2
4989:                      error = TRUE;
4990:                  }
4991:              
4992:                  // Skip over the rest of the Configuration Descriptor
4993:                  index += bLength;
001AC2  FB8088     ZE W8, W1
4994:                  ptr    = &pCurrentConfigurationDescriptor[index];
001AC4  80FA80     MOV pCurrentConfigurationDescriptor, W0
001AC6  408480     ADD W1, W0, W9
001AC8  780501     MOV W1, W10
001ACA  EB4000     CLR.B W0
001ACC  9FEFA0     MOV.B W0, [W15-22]
001ACE  3700BA     BRA 0x1C44
4995:              
4996:                  while (!error && (index < wTotalLength))
001C44  E00002     CP0 W2
001C46  320006     BRA Z, 0x1C54
001C48  37000A     BRA 0x1C5E
001C52  EB0100     CLR W2
001C54  97B04F     MOV [W15-24], W0
001C56  550F80     SUB W10, W0, [W15]
001C58  39FF3B     BRA NC, 0x1AD0
001C5A  370001     BRA 0x1C5E
001C5C  200012     MOV #0x1, W2
4997:                  {
4998:                      // Check the descriptor length and type
4999:                      bLength         = *ptr++;
001AD0  784699     MOV.B [W9], W13
5000:                      bDescriptorType = *ptr++;
001AD2  904019     MOV.B [W9+1], W0
001AD4  E88089     INC2 W9, W1
5001:              
5002:              
5003:                      // Find the OTG discriptor (if present)
5004:                      if (bDescriptorType == USB_DESCRIPTOR_OTG)
001AD6  504FE9     SUB.B W0, #0x9, [W15]
001AD8  3A000F     BRA NZ, 0x1AF8
5005:                      {
5006:                          // We found an OTG Descriptor, so the device supports OTG.
5007:                          usbDeviceInfo.flags.bfSupportsOTG = 1;
001ADA  21ECC2     MOV #0x1ECC, W2
001ADC  A01412     BSET.B [W2], #1
5008:                          usbDeviceInfo.attributesOTG       = *ptr;
001ADE  784091     MOV.B [W1], W1
001AE0  21EBD0     MOV #0x1EBD, W0
001AE2  784801     MOV.B W1, [W0]
5009:              
5010:                          // See if we need to send the SET FEATURE command.  If we do,
5011:                          // clear the bConfiguredOTG flag.
5012:                          if ( (usbDeviceInfo.attributesOTG & OTG_HNP_SUPPORT) && (usbDeviceInfo.flags.bfAllowHNP))
001AE4  A31801     BTST.Z W1, #1
001AE6  320005     BRA Z, 0x1AF2
001AE8  784092     MOV.B [W2], W1
001AEA  60C068     AND.B W1, #0x8, W0
001AEC  320002     BRA Z, 0x1AF2
5013:                          {
5014:                              usbDeviceInfo.flags.bfConfiguredOTG = 0;
001AEE  A12412     BCLR.B [W2], #2
001AF0  3700AC     BRA 0x1C4A
5015:                          }
5016:                          else
5017:                          {
5018:                              usbDeviceInfo.flags.bfAllowHNP = 0;
001AF2  21ECC0     MOV #0x1ECC, W0
001AF4  A13410     BCLR.B [W0], #3
001AF6  3700A9     BRA 0x1C4A
5019:                          }
5020:                      }
5021:              
5022:                      // Find an interface descriptor
5023:                      if (bDescriptorType != USB_DESCRIPTOR_INTERFACE)
001AF8  504FE4     SUB.B W0, #0x4, [W15]
001AFA  3A00A7     BRA NZ, 0x1C4A
5024:                      {
5025:                          // Skip over the rest of the Descriptor
5026:                          index += bLength;
5027:                          ptr = &pCurrentConfigurationDescriptor[index];
5028:                      }
5029:                      else
5030:                      {
5031:                          // Read some data from the interface descriptor
5032:                          bInterfaceNumber  = *ptr++;
001AFC  784591     MOV.B [W1], W11
5033:                          bAlternateSetting = *ptr++;
001AFE  904039     MOV.B [W9+3], W0
001B00  9FF780     MOV.B W0, [W15-16]
5034:                          bNumEndpoints     = *ptr++;
001B02  9040C9     MOV.B [W9+4], W1
001B04  9FEFF1     MOV.B W1, [W15-17]
5035:                          Class             = *ptr++;
001B06  904059     MOV.B [W9+5], W0
001B08  9FEFD0     MOV.B W0, [W15-19]
5036:                          SubClass          = *ptr++;
001B0A  9040E9     MOV.B [W9+6], W1
001B0C  9FEFC1     MOV.B W1, [W15-20]
5037:                          Protocol          = *ptr++;
001B0E  904779     MOV.B [W9+7], W14
001B10  4484E8     ADD W9, #0x8, W9
5038:              
5039:                          // Get client driver index
5040:                          if (usbDeviceInfo.flags.bfUseDeviceClientDriver)
001B12  21ECC0     MOV #0x1ECC, W0
001B14  B3C401     MOV #0x40, W1
001B16  60C010     AND.B W1, [W0], W0
001B18  320004     BRA Z, 0x1B22
5041:                          {
5042:                              ClientDriver = usbDeviceInfo.deviceClientDriver;
001B1A  21EC10     MOV #0x1EC1, W0
001B1C  784010     MOV.B [W0], W0
001B1E  9FE7C0     MOV.B W0, [W15-28]
001B20  370008     BRA 0x1B32
5043:                          }
5044:                          else
5045:                          {
5046:                              if (!_USB_FindClassDriver(Class, SubClass, Protocol, &ClientDriver))
001B22  5781FC     SUB W15, #0x1C, W3
001B24  78410E     MOV.B W14, W2
001B26  97E8CF     MOV.B [W15-20], W1
001B28  97E85F     MOV.B [W15-19], W0
001B2A  022E2C     CALL _USB_FindClassDriver
001B2C  000000     NOP
001B2E  E00000     CP0 W0
001B30  32008C     BRA Z, 0x1C4A
5047:                              {
5048:                                  // If we cannot support this interface, skip it.
5049:                                  index += bLength;
001C4A  FB800D     ZE W13, W0
001C4C  450500     ADD W10, W0, W10
5050:                                  ptr = &pCurrentConfigurationDescriptor[index];
001C4E  80FA80     MOV pCurrentConfigurationDescriptor, W0
001C50  450480     ADD W10, W0, W9
5051:                                  continue;
001B32  78040C     MOV W12, W8
001B34  370001     BRA 0x1B38
5052:                              }
5053:                          }
5054:              
5055:                          // We can support this interface.  See if we already have a USB_INTERFACE_INFO node for it.
5056:                          newInterfaceInfo = pTempInterfaceList;
5057:                          while ((newInterfaceInfo != NULL) && (newInterfaceInfo->interface != bInterfaceNumber))
001B38  E00008     CP0 W8
001B3A  320004     BRA Z, 0x1B44
001B3C  904068     MOV.B [W8+6], W0
001B3E  504F8B     SUB.B W0, W11, [W15]
001B40  3AFFFA     BRA NZ, 0x1B36
001B42  37001B     BRA 0x1B7A
5058:                          {
5059:                              newInterfaceInfo = newInterfaceInfo->next;
001B36  780418     MOV [W8], W8
5060:                          }
5061:                          if (newInterfaceInfo == NULL)
5062:                          {
5063:                              // This is the first instance of this interface, so create a new node for it.
5064:                              if ((newInterfaceInfo = (USB_INTERFACE_INFO *)USB_MALLOC( sizeof(USB_INTERFACE_INFO) )) == NULL)
001B44  2000C0     MOV #0xC, W0
001B46  02038C     CALL malloc
001B48  000000     NOP
001B4A  780400     MOV W0, W8
001B4C  EA0080     NEG W0, W1
001B4E  708080     IOR W1, W0, W1
001B50  DE08CF     LSR W1, #15, W1
001B52  B3C010     MOV #0x1, W0
001B54  504081     SUB.B W0, W1, W1
001B56  FB8101     ZE W1, W2
5065:                              {
5066:                                  // Out of memory
5067:                                  error = TRUE;   
5068:                              }
5069:              
5070:                              // Initialize the interface node
5071:                              newInterfaceInfo->interface             = bInterfaceNumber;
001B58  98446B     MOV.B W11, [W8+6]
5072:                              newInterfaceInfo->clientDriver          = ClientDriver;
001B5A  97E04F     MOV.B [W15-28], W0
001B5C  984470     MOV.B W0, [W8+7]
5073:                              newInterfaceInfo->pInterfaceSettings    = NULL;
001B5E  EB0000     CLR W0
001B60  980410     MOV W0, [W8+2]
5074:                              newInterfaceInfo->pCurrentSetting       = NULL;
001B62  980420     MOV W0, [W8+4]
5075:                              newInterfaceInfo->type.cls              = Class;
001B64  97E85F     MOV.B [W15-19], W0
001B66  984C00     MOV.B W0, [W8+8]
5076:                              newInterfaceInfo->type.subcls           = SubClass;
001B68  97E84F     MOV.B [W15-20], W0
001B6A  984C10     MOV.B W0, [W8+9]
5077:                              newInterfaceInfo->type.proto            = Protocol;
001B6C  984C2E     MOV.B W14, [W8+10]
5078:              
5079:                              // Insert it into the list.
5080:                              newInterfaceInfo->next                  = pTempInterfaceList;
001B6E  780C0C     MOV W12, [W8]
5081:                              pTempInterfaceList                      = newInterfaceInfo;
5082:                          }
5083:              
5084:                          if (!error)
001B70  E00401     CP0.B W1
001B72  320002     BRA Z, 0x1B78
001B74  780608     MOV W8, W12
001B76  370062     BRA 0x1C3C
001B78  780608     MOV W8, W12
5085:                          {
5086:                              // Create a new setting for this interface, and add it to the list.
5087:                              if ((newSettingInfo = (USB_INTERFACE_SETTING_INFO *)USB_MALLOC( sizeof(USB_INTERFACE_SETTING_INFO) )) == NULL)
001B7A  200060     MOV #0x6, W0
001B7C  02038C     CALL malloc
001B7E  000000     NOP
001B80  780580     MOV W0, W11
001B82  200012     MOV #0x1, W2
001B84  E00000     CP0 W0
001B86  32005A     BRA Z, 0x1C3C
001B88  370092     BRA 0x1CAE
5088:                              {
5089:                                  // Out of memory
5090:                                  error = TRUE;   
5091:                              }
5092:                          }    
5093:                           
5094:                          if (!error)   
5095:                          {
5096:                              newSettingInfo->next                    = newInterfaceInfo->pInterfaceSettings;
001CAE  900018     MOV [W8+2], W0
001CB0  780D80     MOV W0, [W11]
5097:                              newSettingInfo->interfaceAltSetting     = bAlternateSetting;
001CB2  97F08F     MOV.B [W15-16], W1
001CB4  9845A1     MOV.B W1, [W11+2]
5098:                              newSettingInfo->pEndpointList           = NULL;
001CB6  EB0000     CLR W0
001CB8  9805A0     MOV W0, [W11+4]
5099:                              newInterfaceInfo->pInterfaceSettings    = newSettingInfo;
001CBA  98041B     MOV W11, [W8+2]
5100:                              if (bAlternateSetting == 0)
001CBC  E00401     CP0.B W1
001CBE  32FF65     BRA Z, 0x1B8A
001CC0  37FF65     BRA 0x1B8C
5101:                              {
5102:                                  newInterfaceInfo->pCurrentSetting   = newSettingInfo;
001B8A  98042B     MOV W11, [W8+4]
5103:                              }
5104:              
5105:                              // Skip over the rest of the Interface Descriptor
5106:                              index += bLength;
001B8C  FB800D     ZE W13, W0
001B8E  450500     ADD W10, W0, W10
5107:                              ptr = &pCurrentConfigurationDescriptor[index];
001B90  80FA80     MOV pCurrentConfigurationDescriptor, W0
001B92  450480     ADD W10, W0, W9
001B94  EB4080     CLR.B W1
001B96  9FEFA1     MOV.B W1, [W15-22]
001B98  370049     BRA 0x1C2C
5108:              
5109:                              // Find the Endpoint Descriptors.  There might be Class and Vendor descriptors in here
5110:                              currentEndpoint = 0;
5111:                              while (!error && (index < wTotalLength) && (currentEndpoint < bNumEndpoints))
001C2C  97B0CF     MOV [W15-24], W1
001C2E  550F81     SUB W10, W1, [W15]
001C30  310004     BRA C, 0x1C3A
001C32  97E82F     MOV.B [W15-22], W0
001C34  97E8FF     MOV.B [W15-17], W1
001C36  504F81     SUB.B W0, W1, [W15]
001C38  39FFB0     BRA NC, 0x1B9A
001C3A  EB0100     CLR W2
5112:                              {
5113:                                  bLength = *ptr++;
001B9A  784699     MOV.B [W9], W13
5114:                                  bDescriptorType = *ptr++;
001B9C  E88409     INC2 W9, W8
5115:              
5116:                                  if (bDescriptorType != USB_DESCRIPTOR_ENDPOINT)
001B9E  904019     MOV.B [W9+1], W0
001BA0  504FE5     SUB.B W0, #0x5, [W15]
001BA2  3A0040     BRA NZ, 0x1C24
5117:                                  {
5118:                                      // Skip over the rest of the Descriptor
5119:                                      index += bLength;
5120:                                      ptr = &pCurrentConfigurationDescriptor[index];
5121:                                  }
5122:                                  else
5123:                                  {
5124:                                      // Create an entry for the new endpoint.
5125:                                      if ((newEndpointInfo = (USB_ENDPOINT_INFO *)USB_MALLOC( sizeof(USB_ENDPOINT_INFO) )) == NULL)
001BA4  200220     MOV #0x22, W0
001BA6  02038C     CALL malloc
001BA8  000000     NOP
001BAA  780180     MOV W0, W3
001BAC  E00000     CP0 W0
001BAE  320056     BRA Z, 0x1C5C
5126:                                      {
5127:                                          // Out of memory
5128:                                          error = TRUE;
5129:                                          break;
5130:                                      }
5131:                                      newEndpointInfo->bEndpointAddress           = *ptr++;
001BB0  784418     MOV.B [W8], W8
001BB2  985828     MOV.B W8, [W0+26]
5132:                                      newEndpointInfo->bmAttributes.val           = *ptr++;
001BB4  904039     MOV.B [W9+3], W0
001BB6  9859B0     MOV.B W0, [W3+27]
5133:                                      newEndpointInfo->wMaxPacketSize             = *ptr++;
001BB8  9040C9     MOV.B [W9+4], W1
001BBA  FB8081     ZE W1, W1
001BBC  9801C1     MOV W1, [W3+8]
5134:                                      newEndpointInfo->wMaxPacketSize            += (*ptr++) << 8;
001BBE  904059     MOV.B [W9+5], W0
001BC0  DD0048     SL W0, #8, W0
001BC2  408080     ADD W1, W0, W1
001BC4  9801C1     MOV W1, [W3+8]
5135:                                      newEndpointInfo->wInterval                  = *ptr++;
001BC6  904069     MOV.B [W9+6], W0
001BC8  FB8200     ZE W0, W4
001BCA  9801A4     MOV W4, [W3+4]
5136:                                      newEndpointInfo->status.val                 = 0x00;
001BCC  EB0100     CLR W2
001BCE  980192     MOV W2, [W3+2]
5137:                                      newEndpointInfo->status.bfUseDTS            = 1;
001BD0  904033     MOV.B [W3+3], W0
001BD2  A02400     BSET.B W0, #2
001BD4  9841B0     MOV.B W0, [W3+3]
5138:                                      newEndpointInfo->status.bfTransferComplete  = 1;  // Initialize to success to allow preprocessing loops.
001BD6  904033     MOV.B [W3+3], W0
001BD8  A01400     BSET.B W0, #1
001BDA  9841B0     MOV.B W0, [W3+3]
5139:                                      newEndpointInfo->dataCount                  = 0;  // Initialize to 0 since we set bfTransferComplete.
001BDC  B80060     MUL.UU W0, #0, W0
001BDE  980980     MOV W0, [W3+16]
001BE0  980991     MOV W1, [W3+18]
5140:                                      newEndpointInfo->transferState              = TSTATE_IDLE;
001BE2  985982     MOV.B W2, [W3+24]
5141:                                      newEndpointInfo->clientDriver               = ClientDriver;
001BE4  97E0CF     MOV.B [W15-28], W1
001BE6  985991     MOV.B W1, [W3+25]
5142:              
5143:                                      // Special setup for isochronous endpoints.
5144:                                      if (newEndpointInfo->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
001BE8  900853     MOV [W3+26], W0
001BEA  B23000     AND #0x300, W0
001BEC  201001     MOV #0x100, W1
001BEE  500F81     SUB W0, W1, [W15]
001BF0  3A0011     BRA NZ, 0x1C14
5145:                                      {
5146:                                          // Validate and convert the interval to the number of frames.  The value must
5147:                                          // be between 1 and 16, and the frames is 2^(bInterval-1).
5148:                                          if (newEndpointInfo->wInterval == 0) newEndpointInfo->wInterval = 1;
001BF2  E00004     CP0 W4
001BF4  3A0002     BRA NZ, 0x1BFA
001BF6  200010     MOV #0x1, W0
001BF8  9801A0     MOV W0, [W3+4]
5149:                                          if (newEndpointInfo->wInterval > 16) newEndpointInfo->wInterval = 16;
001BFA  900023     MOV [W3+4], W0
001BFC  500FF0     SUB W0, #0x10, [W15]
001BFE  360002     BRA LEU, 0x1C04
001C00  200100     MOV #0x10, W0
001C02  9801A0     MOV W0, [W3+4]
5150:                                          newEndpointInfo->wInterval = 1 << (newEndpointInfo->wInterval-1);
001C04  900023     MOV [W3+4], W0
001C06  E90000     DEC W0, W0
001C08  200011     MOV #0x1, W1
001C0A  DD0880     SL W1, W0, W1
001C0C  9801A1     MOV W1, [W3+4]
5151:              
5152:                                          // Disable DTS
5153:                                          newEndpointInfo->status.bfUseDTS = 0;
001C0E  904033     MOV.B [W3+3], W0
001C10  A12400     BCLR.B W0, #2
001C12  9841B0     MOV.B W0, [W3+3]
5154:                                      }
5155:              
5156:                                      // Initialize interval count
5157:                                      newEndpointInfo->wIntervalCount = newEndpointInfo->wInterval;
001C14  900023     MOV [W3+4], W0
001C16  9801B0     MOV W0, [W3+6]
5158:              
5159:                                      // Put the new endpoint in the list.
5160:                                      newEndpointInfo->next           = newSettingInfo->pEndpointList;
001C18  9000AB     MOV [W11+4], W1
001C1A  780981     MOV W1, [W3]
5161:                                      newSettingInfo->pEndpointList   = newEndpointInfo;
001C1C  9805A3     MOV W3, [W11+4]
5162:              
5163:                                      // When multiple devices are supported, check the available
5164:                                      // bandwidth here to make sure that we can support this
5165:                                      // endpoint.
5166:              
5167:                                      // Get ready for the next endpoint.
5168:                                      currentEndpoint++;
001C1E  97E82F     MOV.B [W15-22], W0
001C20  E84000     INC.B W0, W0
001C22  9FEFA0     MOV.B W0, [W15-22]
5169:                                      index += bLength;
001C24  FB800D     ZE W13, W0
001C26  450500     ADD W10, W0, W10
5170:                                      ptr = &pCurrentConfigurationDescriptor[index];
001C28  80FA80     MOV pCurrentConfigurationDescriptor, W0
001C2A  450480     ADD W10, W0, W9
5171:                                  }
5172:                              }
5173:                          }    
5174:              
5175:                          // Ensure that we found all the endpoints for this interface.
5176:                          if (currentEndpoint != bNumEndpoints)
001C3C  97E82F     MOV.B [W15-22], W0
001C3E  97E8FF     MOV.B [W15-17], W1
001C40  504F81     SUB.B W0, W1, [W15]
001C42  3A000C     BRA NZ, 0x1C5C
5177:                          {
5178:                              error = TRUE;
5179:                          }
5180:                      }
5181:                  }
5182:              
5183:                  // Ensure that we found all the interfaces in this configuration.
5184:                  // This is a nice check, but some devices have errors where they have a
5185:                  // different number of interfaces than they report they have!
5186:              //    if (currentInterface != bNumInterfaces)
5187:              //    {
5188:              //        error = TRUE;
5189:              //    }
5190:              
5191:                  if (pTempInterfaceList == NULL)
001C5E  E0000C     CP0 W12
001C60  320024     BRA Z, 0x1CAA
5192:                  {
5193:                      // We could find no supported interfaces.
5194:                      #ifdef DEBUG_MODE
5195:                          UART2PrintString( "HOST: No supported interfaces.\r\n" );
5196:                      #endif
5197:              
5198:                      error = TRUE;
5199:                  }
5200:              
5201:                  if (error)
001C62  E00002     CP0 W2
001C64  320019     BRA Z, 0x1C98
5202:                  {
5203:                      // Destroy whatever list of interfaces, settings, and endpoints we created.
5204:                      // The "new" variables point to the current node we are trying to remove.
5205:                      while (pTempInterfaceList != NULL)
001C90  E00009     CP0 W9
001C92  32000B     BRA Z, 0x1CAA
001C94  780609     MOV W9, W12
001C96  37FFE7     BRA 0x1C66
5206:                      {
5207:                          newInterfaceInfo = pTempInterfaceList;
5208:                          pTempInterfaceList = pTempInterfaceList->next;
001C66  78049C     MOV [W12], W9
001C68  37000D     BRA 0x1C84
5209:                          
5210:                          while (newInterfaceInfo->pInterfaceSettings != NULL)
001C84  90041C     MOV [W12+2], W8
001C86  E00008     CP0 W8
001C88  3AFFF0     BRA NZ, 0x1C6A
5211:                          {
5212:                              newSettingInfo = newInterfaceInfo->pInterfaceSettings;
5213:                              newInterfaceInfo->pInterfaceSettings = newInterfaceInfo->pInterfaceSettings->next;
001C6A  780098     MOV [W8], W1
001C6C  980611     MOV W1, [W12+2]
001C6E  370004     BRA 0x1C78
5214:                              
5215:                              while (newSettingInfo->pEndpointList != NULL)
001C78  900028     MOV [W8+4], W0
001C7A  E00000     CP0 W0
001C7C  3AFFF9     BRA NZ, 0x1C70
5216:                              {
5217:                                  newEndpointInfo = newSettingInfo->pEndpointList;
5218:                                  newSettingInfo->pEndpointList = newSettingInfo->pEndpointList->next;
001C70  780090     MOV [W0], W1
001C72  980421     MOV W1, [W8+4]
5219:                                  
5220:                                  USB_FREE_AND_CLEAR( newEndpointInfo );
001C74  0204B0     CALL free
001C76  000000     NOP
5221:                              }    
5222:                  
5223:                              USB_FREE_AND_CLEAR( newSettingInfo );
001C7E  780008     MOV W8, W0
001C80  0204B0     CALL free
001C82  000000     NOP
5224:                          }
5225:                  
5226:                          USB_FREE_AND_CLEAR( newInterfaceInfo );
001C8A  78000C     MOV W12, W0
001C8C  0204B0     CALL free
001C8E  000000     NOP
5227:                      }    
5228:                      return FALSE;
5229:                  }
5230:                  else
5231:                  {    
5232:                      // Set configuration.
5233:                      usbDeviceInfo.currentConfiguration      = currentConfiguration;
001C98  21EBC0     MOV #0x1EBC, W0
001C9A  97E8BF     MOV.B [W15-21], W1
001C9C  784801     MOV.B W1, [W0]
5234:                      usbDeviceInfo.currentConfigurationPower = bMaxPower;
001C9E  97E8EF     MOV.B [W15-18], W1
001CA0  FB8001     ZE W1, W0
001CA2  88F610     MOV W0, 0x1EC2
5235:                  
5236:                      // Success!
5237:                      #ifdef DEBUG_MODE
5238:                          UART2PrintString( "HOST: Parse Descriptor success\r\n" );
5239:                      #endif
5240:                      usbDeviceInfo.pInterfaceList = pTempInterfaceList;
001CA4  88F64C     MOV W12, 0x1EC8
001CA6  200010     MOV #0x1, W0
001CA8  37000C     BRA 0x1CC2
5241:                      return TRUE;
001CAA  EB0000     CLR W0
001CAC  37000A     BRA 0x1CC2
5242:                  }    
5243:              }
5244:              
5245:              
5246:              /****************************************************************************
5247:                Function:
5248:                  void _USB_ResetDATA0( BYTE endpoint )
5249:              
5250:                Description:
5251:                  This function resets DATA0 for the specified endpoint.  If the
5252:                  specified endpoint is 0, it resets DATA0 for all endpoints.
5253:              
5254:                Precondition:
5255:                  None
5256:              
5257:                Parameters:
5258:                  BYTE endpoint   - Endpoint number to reset.
5259:              
5260:              
5261:                Returns:
5262:                  None
5263:              
5264:                Remarks:
5265:                  None
5266:                ***************************************************************************/
5267:              
5268:              void _USB_ResetDATA0( BYTE endpoint )
5269:              {
5270:                  USB_ENDPOINT_INFO   *pEndpoint;
5271:              
5272:                  if (endpoint == 0)
0033AA  E00400     CP0.B W0
0033AC  3A0013     BRA NZ, 0x33D4
5273:                  {
5274:                      // Reset DATA0 for all endpoints.
5275:                      USB_INTERFACE_INFO          *pInterface;
5276:                      USB_INTERFACE_SETTING_INFO  *pSetting;
5277:              
5278:                      pInterface = usbDeviceInfo.pInterfaceList;
0033AE  80F643     MOV 0x1EC8, W3
0033B0  37000E     BRA 0x33CE
5279:                      while (pInterface)
0033CE  E00003     CP0 W3
0033D0  3AFFF0     BRA NZ, 0x33B2
0033D2  060000     RETURN
5280:                      {
5281:                          pSetting = pInterface->pInterfaceSettings;
0033B2  900113     MOV [W3+2], W2
0033B4  370009     BRA 0x33C8
5282:                          while (pSetting)
0033C8  E00002     CP0 W2
0033CA  3AFFF5     BRA NZ, 0x33B6
5283:                          {
5284:                              pEndpoint = pSetting->pEndpointList;
0033B6  9000A2     MOV [W2+4], W1
0033B8  370004     BRA 0x33C2
5285:                              while (pEndpoint)
0033C2  E00001     CP0 W1
0033C4  3AFFFA     BRA NZ, 0x33BA
5286:                              {
5287:                                  pEndpoint->status.bfNextDATA01 = 0;
0033BA  904031     MOV.B [W1+3], W0
0033BC  A13400     BCLR.B W0, #3
0033BE  9840B0     MOV.B W0, [W1+3]
5288:                                  pEndpoint = pEndpoint->next;
0033C0  780091     MOV [W1], W1
5289:                              }
5290:                              pSetting = pSetting->next;
0033C6  780112     MOV [W2], W2
5291:                          }
5292:                          pInterface = pInterface->next;
0033CC  780193     MOV [W3], W3
5293:                      }
5294:                  }
5295:                  else
5296:                  {
5297:                      pEndpoint = _USB_FindEndpoint( endpoint );
0033D4  0236A4     CALL _USB_FindEndpoint
0033D6  000000     NOP
0033D8  780080     MOV W0, W1
5298:                      if (pEndpoint != NULL)
0033DA  E00000     CP0 W0
0033DC  320003     BRA Z, 0x33E4
5299:                      {
5300:                          pEndpoint->status.bfNextDATA01 = 0;
5301:                      }
5302:                  }
5303:              }
5304:              
5305:              
5306:              /****************************************************************************
5307:                Function:
5308:                  void _USB_SendToken( BYTE endpoint, BYTE tokenType )
5309:              
5310:                Description:
5311:                  This function sets up the endpoint control register and sends the token.
5312:              
5313:                Precondition:
5314:                  None
5315:              
5316:                Parameters:
5317:                  BYTE endpoint   - Endpoint number
5318:                  BYTE tokenType  - Token to send
5319:              
5320:                Returns:
5321:                  None
5322:              
5323:                Remarks:
5324:                  If the device is low speed, the transfer must be set to low speed.  If
5325:                  the endpoint is isochronous, handshaking must be disabled.
5326:                ***************************************************************************/
5327:              
5328:              void _USB_SendToken( BYTE endpoint, BYTE tokenType )
5329:              {
5330:                  BYTE    temp;
5331:              
5332:                  // Disable retries, disable control transfers, enable Rx and Tx and handshaking.
5333:                  temp = 0x5D;
5334:              
5335:                  // Enable low speed transfer if the device is low speed.
5336:                  if (usbDeviceInfo.flags.bfIsLowSpeed)
00336E  21ECC0     MOV #0x1ECC, W0
003370  784010     MOV.B [W0], W0
003372  604061     AND.B W0, #0x1, W0
003374  B3CDD3     MOV #0xDD, W3
003376  3A0001     BRA NZ, 0x337A
003378  B3C5D3     MOV #0x5D, W3
5337:                  {
5338:                      temp |= 0x80;   // Set LSPD
5339:                  }
5340:              
5341:                  // Enable control transfers if necessary.
5342:                  if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_CONTROL)
00337A  80F6A2     MOV pCurrentEndpoint, W2
00337C  905832     MOV.B [W2+27], W0
00337E  604063     AND.B W0, #0x3, W0
003380  3A0001     BRA NZ, 0x3384
5343:                  {
5344:                      temp &= 0xEF;   // Clear EPCONDIS
003382  A14403     BCLR.B W3, #4
5345:                  }
5346:              
5347:                  // Disable handshaking for isochronous endpoints.
5348:                  if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
003384  905832     MOV.B [W2+27], W0
003386  604063     AND.B W0, #0x3, W0
003388  504FE1     SUB.B W0, #0x1, [W15]
00338A  3A0001     BRA NZ, 0x338E
5349:                  {
5350:                      temp &= 0xFE;   // Clear EPHSHK
00338C  A10403     BCLR.B W3, #0
5351:                  }
5352:              
5353:                  U1EP0 = temp;
00338E  FB8003     ZE W3, W0
003390  882550     MOV W0, U1EP0
5354:              
5355:                  #ifdef DEBUG_MODE
5356:                      if (usbBusInfo.flags.bfTokenAlreadyWritten) UART2PutChar( '+' );
5357:              //        if (U1CONbits.TOKBUSY) UART2PutChar( '+' );
5358:                  #endif
5359:              
5360:                  U1ADDR = usbDeviceInfo.deviceAddressAndSpeed;
003392  21EBE0     MOV #0x1EBE, W0
003394  FB8010     ZE [W0], W0
003396  8824B0     MOV W0, U1ADDR
5361:                  U1TOK = (tokenType << 4) | (endpoint & 0x7F);
003398  FB8001     ZE W1, W0
00339A  DD0044     SL W0, #4, W0
00339C  780084     MOV W4, W1
00339E  B207F1     AND #0x7F, W1
0033A0  700001     IOR W0, W1, W0
0033A2  8824F0     MOV W0, U1TOK
5362:              
5363:                  // Lock out anyone from writing another token until this one has finished.
5364:              //    U1CONbits.TOKBUSY = 1;
5365:                  usbBusInfo.flags.bfTokenAlreadyWritten = 1;
0033A4  21ECE0     MOV #0x1ECE, W0
0033A6  A04410     BSET.B [W0], #4
5366:              
5367:                  #ifdef DEBUG_MODE
5368:                      //UART2PutChar('(');
5369:                      //UART2PutHex(U1ADDR);
5370:                      //UART2PutHex(U1EP0);
5371:                      //UART2PutHex(U1TOK);
5372:                      //UART2PutChar(')');
5373:                  #endif
5374:              }
5375:              
5376:              
5377:              /****************************************************************************
5378:                Function:
5379:                  void _USB_SetBDT( BYTE token )
5380:              
5381:                Description:
5382:                  This function sets up the BDT for the transfer.  The function handles the
5383:                  different ping-pong modes.
5384:              
5385:                Precondition:
5386:                  pCurrentEndpoint must point to the current endpoint being serviced.
5387:              
5388:                Parameters:
5389:                  BYTE token  - Token for the transfer.  That way we can tell which
5390:                                  ping-pong buffer and which data pointer to use.  Valid
5391:                                  values are:
5392:                                      * USB_TOKEN_SETUP
5393:                                      * USB_TOKEN_IN
5394:                                      * USB_TOKEN_OUT
5395:              
5396:                Returns:
5397:                  None
5398:              
5399:                Remarks:
5400:                  None
5401:                ***************************************************************************/
5402:              
5403:              void _USB_SetBDT( BYTE token )
5404:              {
5405:                  WORD                currentPacketSize;
5406:                  BDT_ENTRY           *pBDT;
5407:              
5408:                  if (token == USB_TOKEN_IN)
00292E  51CFE9     SUB.B W3, #0x9, [W15]
002930  3A000F     BRA NZ, 0x2950
5409:                  {
5410:                      // Find the BDT we need to use.
5411:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
5412:                          pBDT = BDT_IN;
5413:                          if (usbDeviceInfo.flags.bfPingPongIn)
002932  784010     MOV.B [W0], W0
002934  604070     AND.B W0, #0x10, W0
002936  21E047     MOV #0x1E04, W7
002938  3A0001     BRA NZ, 0x293C
00293A  21E007     MOV #0x1E00, W7
5414:                          {
5415:                              pBDT = BDT_IN_ODD;
5416:                          }
5417:                      #else
5418:                          pBDT = BDT_IN;
5419:                      #endif
5420:              
5421:                      // Set up ping-pong for the next transfer
5422:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
5423:                          usbDeviceInfo.flags.bfPingPongIn = ~usbDeviceInfo.flags.bfPingPongIn;
00293C  21ECC0     MOV #0x1ECC, W0
00293E  FB8090     ZE [W0], W1
002940  DE08C4     LSR W1, #4, W1
002942  60C0E1     AND.B W1, #0x1, W1
002944  A20401     BTG.B W1, #0
002946  DD08C4     SL W1, #4, W1
002948  784110     MOV.B [W0], W2
00294A  A14402     BCLR.B W2, #4
00294C  714801     IOR.B W2, W1, [W0]
00294E  370023     BRA 0x2996
5424:                      #endif
5425:                  }
5426:                  else  // USB_TOKEN_OUT or USB_TOKEN_SETUP
5427:                  {
5428:                      // Find the BDT we need to use.
5429:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
5430:                          pBDT = BDT_OUT;
5431:                          if (usbDeviceInfo.flags.bfPingPongOut)
002950  B3C201     MOV #0x20, W1
002952  60C010     AND.B W1, [W0], W0
002954  21E0C7     MOV #0x1E0C, W7
002956  3A0001     BRA NZ, 0x295A
002958  21E087     MOV #0x1E08, W7
5432:                          {
5433:                              pBDT = BDT_OUT_ODD;
5434:                          }
5435:                      #else
5436:                          pBDT = BDT_OUT;
5437:                      #endif
5438:              
5439:                      // Set up ping-pong for the next transfer
5440:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
5441:                          usbDeviceInfo.flags.bfPingPongOut = ~usbDeviceInfo.flags.bfPingPongOut;
00295A  21ECC0     MOV #0x1ECC, W0
00295C  FB8090     ZE [W0], W1
00295E  DE08C5     LSR W1, #5, W1
002960  60C0E1     AND.B W1, #0x1, W1
002962  A20401     BTG.B W1, #0
002964  DD08C5     SL W1, #5, W1
002966  784110     MOV.B [W0], W2
002968  A15402     BCLR.B W2, #5
00296A  714801     IOR.B W2, W1, [W0]
5442:                      #endif
5443:                  }
5444:              
5445:                  // Determine how much data we'll transfer in this packet.
5446:                  if (token == USB_TOKEN_SETUP)
00296C  51CFED     SUB.B W3, #0xD, [W15]
00296E  3A0013     BRA NZ, 0x2996
5447:                  {
5448:                      if ((pCurrentEndpoint->dataCountMaxSETUP - pCurrentEndpoint->dataCount) > pCurrentEndpoint->wMaxPacketSize)
002970  80F6A6     MOV pCurrentEndpoint, W6
002972  900076     MOV [W6+14], W0
002974  900A06     MOV [W6+16], W4
002976  900A96     MOV [W6+18], W5
002978  900146     MOV [W6+8], W2
00297A  200001     MOV #0x0, W1
00297C  500004     SUB W0, W4, W0
00297E  588085     SUBB W1, W5, W1
002980  200003     MOV #0x0, W3
002982  500F82     SUB W0, W2, [W15]
002984  588F83     SUBB W1, W3, [W15]
002986  360002     BRA LEU, 0x298C
5449:                      {
5450:                          currentPacketSize = pCurrentEndpoint->wMaxPacketSize;
002988  9001C6     MOV [W6+8], W3
00298A  37001D     BRA 0x29C6
5451:                      }
5452:                      else
5453:                      {
5454:                          currentPacketSize = pCurrentEndpoint->dataCountMaxSETUP - pCurrentEndpoint->dataCount;
00298C  900176     MOV [W6+14], W2
00298E  900806     MOV [W6+16], W0
002990  900896     MOV [W6+18], W1
002992  510180     SUB W2, W0, W3
002994  370018     BRA 0x29C6
5455:                      }
5456:                  }
5457:                  else
5458:                  {
5459:                      if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
002996  80F6A6     MOV pCurrentEndpoint, W6
002998  905836     MOV.B [W6+27], W0
00299A  604063     AND.B W0, #0x3, W0
00299C  504FE1     SUB.B W0, #0x1, [W15]
00299E  32000B     BRA Z, 0x29B6
5460:                      {
5461:                          // Isochronous transfers are always the same size, though the device may choose to send less.
5462:                          currentPacketSize = pCurrentEndpoint->wMaxPacketSize;
5463:                      }
5464:                      else
5465:                      {
5466:                          if ((pCurrentEndpoint->dataCountMax - pCurrentEndpoint->dataCount) > pCurrentEndpoint->wMaxPacketSize)
0029A0  900056     MOV [W6+10], W0
0029A2  9000E6     MOV [W6+12], W1
0029A4  900A06     MOV [W6+16], W4
0029A6  900A96     MOV [W6+18], W5
0029A8  900146     MOV [W6+8], W2
0029AA  500004     SUB W0, W4, W0
0029AC  588085     SUBB W1, W5, W1
0029AE  200003     MOV #0x0, W3
0029B0  500F82     SUB W0, W2, [W15]
0029B2  588F83     SUBB W1, W3, [W15]
0029B4  360002     BRA LEU, 0x29BA
5467:                          {
5468:                              currentPacketSize = pCurrentEndpoint->wMaxPacketSize;
0029B6  9001C6     MOV [W6+8], W3
0029B8  37002D     BRA 0x2A14
5469:                          }
5470:                          else
5471:                          {
5472:                              currentPacketSize = pCurrentEndpoint->dataCountMax - pCurrentEndpoint->dataCount;
0029BA  900156     MOV [W6+10], W2
0029BC  9001E6     MOV [W6+12], W3
0029BE  900806     MOV [W6+16], W0
0029C0  900896     MOV [W6+18], W1
0029C2  510180     SUB W2, W0, W3
0029C4  370027     BRA 0x2A14
5473:                          }
5474:                      }
5475:                  }
5476:              
5477:                  // Load up the BDT address.
5478:                  if (token == USB_TOKEN_SETUP)
5479:                  {
5480:                      #if defined(__C30__) || defined(__PIC32MX__)
5481:                          pBDT->ADR  = ConvertToPhysicalAddress(pCurrentEndpoint->pUserDataSETUP);
0029C6  900B26     MOV [W6+20], W6
0029C8  980396     MOV W6, [W7+2]
0029CA  37000E     BRA 0x29E8
5482:                      #else
5483:                          #error Cannot set BDT address.
5484:                      #endif
5485:                  }
5486:                  else
5487:                  {
5488:                      #if defined(__C30__)
5489:                          if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
5490:                          {
5491:                              pBDT->ADR  = ConvertToPhysicalAddress(((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer);
0029CC  9008B6     MOV [W6+22], W1
0029CE  900836     MOV [W6+22], W0
0029D0  904010     MOV.B [W0+1], W0
0029D2  B3C062     MOV #0x6, W2
0029D4  BC4004     MUL.B WREG2
0029D6  410166     ADD W2, #0x6, W2
0029D8  7900E1     MOV [W1+W2], W1
0029DA  980391     MOV W1, [W7+2]
0029DC  370005     BRA 0x29E8
5492:                          }
5493:                          else
5494:                          {
5495:                              pBDT->ADR  = ConvertToPhysicalAddress((WORD)pCurrentEndpoint->pUserData + (WORD)pCurrentEndpoint->dataCount);
0029DE  900936     MOV [W6+22], W2
0029E0  900806     MOV [W6+16], W0
0029E2  900896     MOV [W6+18], W1
0029E4  410100     ADD W2, W0, W2
0029E6  980392     MOV W2, [W7+2]
5496:                          }
5497:                      #elif defined(__PIC32MX__)
5498:                          if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
5499:                          {
5500:                              pBDT->ADR  = ConvertToPhysicalAddress(((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer);
5501:                          }
5502:                          else
5503:                          {
5504:                              pBDT->ADR  = ConvertToPhysicalAddress((DWORD)pCurrentEndpoint->pUserData + (DWORD)pCurrentEndpoint->dataCount);
5505:                          }
5506:                      #else
5507:                          #error Cannot set BDT address.
5508:                      #endif
5509:                  }
5510:              
5511:                  // Load up the BDT status register.
5512:                  pBDT->STAT.Val      = 0;
0029E8  EB4000     CLR.B W0
0029EA  984390     MOV.B W0, [W7+1]
5513:                  pBDT->count         = currentPacketSize;
0029EC  B23FF3     AND #0x3FF, W3
0029EE  2FC000     MOV #0xFC00, W0
0029F0  600B97     AND W0, [W7], [W7]
0029F2  718B97     IOR W3, [W7], [W7]
5514:                  pBDT->STAT.DTS      = pCurrentEndpoint->status.bfNextDATA01;
0029F4  80F6A1     MOV pCurrentEndpoint, W1
0029F6  904031     MOV.B [W1+3], W0
0029F8  DE0043     LSR W0, #3, W0
0029FA  600061     AND W0, #0x1, W0
0029FC  DD004E     SL W0, #14, W0
0029FE  A1E017     BCLR [W7], #14
002A00  700B97     IOR W0, [W7], [W7]
5515:                  pBDT->STAT.DTSEN    = pCurrentEndpoint->status.bfUseDTS;
002A02  904031     MOV.B [W1+3], W0
002A04  DE0042     LSR W0, #2, W0
002A06  600061     AND W0, #0x1, W0
002A08  DD004B     SL W0, #11, W0
002A0A  A1B017     BCLR [W7], #11
002A0C  700B97     IOR W0, [W7], [W7]
5516:              
5517:                  // Transfer the BD to the USB OTG module.
5518:                  pBDT->STAT.UOWN     = 1;
002A0E  280000     MOV #0x8000, W0
002A10  700B97     IOR W0, [W7], [W7]
5519:              
5520:                  #ifdef DEBUG_MODE
5521:              //        UART2PutChar('{');
5522:              //        UART2PutHex((pBDT->v[0] >> 24) & 0xff);
5523:              //        UART2PutHex((pBDT->v[0] >> 16) & 0xff);
5524:              //        UART2PutHex((pBDT->v[0] >> 8) & 0xff);
5525:              //        UART2PutHex((pBDT->v[0]) & 0xff);
5526:              //        UART2PutChar('-');
5527:              //        UART2PutHex((currentPacketSize >> 24) & 0xff);
5528:              //        UART2PutHex((pBDT->v[1] >> 16) & 0xff);
5529:              //        UART2PutHex((currentPacketSize >> 8) & 0xff);
5530:              //        UART2PutHex(currentPacketSize & 0xff);
5531:              //        UART2PutChar('}');
5532:                  #endif
5533:              
5534:              }
002A12  060000     RETURN
5535:              
5536:              
5537:              /****************************************************************************
5538:                Function:
5539:                  BOOL _USB_TransferInProgress( void )
5540:              
5541:                Description:
5542:                  This function checks to see if any read or write transfers are in
5543:                  progress.
5544:              
5545:                Precondition:
5546:                  None
5547:              
5548:                Parameters:
5549:                  None - None
5550:              
5551:                Returns:
5552:                  TRUE    - At least one read or write transfer is occurring.
5553:                  FALSE   - No read or write transfers are occurring.
5554:              
5555:                Remarks:
5556:                  None
5557:                ***************************************************************************/
5558:              
5559:              BOOL _USB_TransferInProgress( void )
5560:              {
5561:                  USB_ENDPOINT_INFO           *pEndpoint;
5562:                  USB_INTERFACE_INFO          *pInterface;
5563:                  USB_INTERFACE_SETTING_INFO  *pSetting;
5564:              
5565:                  // Check EP0.
5566:                  if (!usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
00360E  80F650     MOV 0x1ECA, W0
003610  904030     MOV.B [W0+3], W0
003612  A31800     BTST.Z W0, #1
003614  320014     BRA Z, 0x363E
5567:                  {
5568:                      return TRUE;
5569:                  }
5570:              
5571:                  // Check all of the other endpoints.
5572:                  pInterface = usbDeviceInfo.pInterfaceList;
003616  80F643     MOV 0x1EC8, W3
003618  37000E     BRA 0x3636
5573:                  while (pInterface)
5574:                  {
5575:                      pSetting = pInterface->pInterfaceSettings;
00361A  900113     MOV [W3+2], W2
00361C  370009     BRA 0x3630
5576:                      while (pSetting)
003630  E00002     CP0 W2
003632  3AFFF5     BRA NZ, 0x361E
5577:                      {
5578:                          pEndpoint = pSetting->pEndpointList;
00361E  9000A2     MOV [W2+4], W1
003620  370004     BRA 0x362A
5579:                          while (pEndpoint)
00362A  E00001     CP0 W1
00362C  3AFFFA     BRA NZ, 0x3622
5580:                          {
5581:                              if (!pEndpoint->status.bfTransferComplete)
003622  904031     MOV.B [W1+3], W0
003624  A31800     BTST.Z W0, #1
003626  32000B     BRA Z, 0x363E
5582:                              {
5583:                                  return TRUE;
5584:                              }
5585:                              pEndpoint = pEndpoint->next;
003628  780091     MOV [W1], W1
5586:                          }
5587:                          pSetting = pSetting->next;
00362E  780112     MOV [W2], W2
5588:                      }
5589:                      pInterface = pInterface->next;
003634  780193     MOV [W3], W3
5590:                  }
5591:              
5592:                  return FALSE;
5593:              }
5594:              
5595:              
5596:              // *****************************************************************************
5597:              // *****************************************************************************
5598:              // Section: Interrupt Handlers
5599:              // *****************************************************************************
5600:              // *****************************************************************************
5601:              
5602:              /****************************************************************************
5603:                Function:
5604:                  void _USB1Interrupt( void )
5605:              
5606:                Summary:
5607:                  This is the interrupt service routine for the USB interrupt.
5608:              
5609:                Description:
5610:                  This is the interrupt service routine for the USB interrupt.  The
5611:                  following cases are serviced:
5612:                       * Device Attach
5613:                       * Device Detach
5614:                       * One millisecond Timer
5615:                       * Start of Frame
5616:                       * Transfer Done
5617:                       * USB Error
5618:              
5619:                Precondition:
5620:                  In TRNIF handling, pCurrentEndpoint is still pointing to the last
5621:                  endpoint to which a token was sent.
5622:              
5623:                Parameters:
5624:                  None - None
5625:              
5626:                Returns:
5627:                  None
5628:              
5629:                Remarks:
5630:                  None
5631:                ***************************************************************************/
5632:              #define U1STAT_TX_MASK                      0x08    // U1STAT bit mask for Tx/Rx indication
5633:              #define U1STAT_ODD_MASK                     0x04    // U1STAT bit mask for even/odd buffer bank
5634:              
5635:              #if defined(__C30__)
5636:              void __attribute__((__interrupt__, no_auto_psv)) _USB1Interrupt( void )
5637:              #elif defined(__PIC32MX__)
5638:              #pragma interrupt _USB1Interrupt ipl4 vector 45
5639:              void _USB1Interrupt( void )
5640:              #else
5641:                  #error Cannot define timer interrupt vector.
5642:              #endif
5643:              {
5644:              
5645:                  #if defined( __C30__)
5646:                      IFS5 &= 0xFFBF;
000570  A9C08E     BCLR IFS5, #6
5647:                  #elif defined( __PIC32MX__)
5648:                      IFS1CLR = 0x02000000;
5649:                  #else
5650:                      #error Cannot clear USB interrupt.
5651:                  #endif
5652:              
5653:                  // -------------------------------------------------------------------------
5654:                  // One Millisecond Timer ISR
5655:              
5656:                  if (U1OTGIEbits.T1MSECIE && U1OTGIRbits.T1MSECIF)
000572  BFC482     MOV.B U1OTGIE, WREG
000574  A36800     BTST.Z W0, #6
000576  320012     BRA Z, 0x59C
000578  BFC480     MOV.B U1OTGIR, WREG
00057A  A36800     BTST.Z W0, #6
00057C  32000F     BRA Z, 0x59C
5657:                  {
5658:                      // The interrupt is cleared by writing a '1' to it.
5659:                      U1OTGIR = USB_INTERRUPT_T1MSECIF;
00057E  200400     MOV #0x40, W0
000580  882400     MOV W0, U1OTGIR
5660:              
5661:                      #if defined(USB_ENABLE_1MS_EVENT) && defined(USB_HOST_APP_DATA_EVENT_HANDLER)
5662:                          msec_count++;
5663:              
5664:                          //Notify ping all client drivers of 1MSEC event (address, event, data, sizeof_data)
5665:                          _USB_NotifyAllDataClients(0, EVENT_1MS, (void*)&msec_count, 0);
5666:                      #endif
5667:              
5668:                      #ifdef DEBUG_MODE
5669:                          UART2PutChar('~');
5670:                      #endif
5671:              
5672:                      #ifdef  USB_SUPPORT_OTG
5673:                          if (USBOTGGetSRPTimeOutFlag())
5674:                          {
5675:                              if (USBOTGIsSRPTimeOutExpired())
5676:                              {
5677:                                  USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
5678:                              }
5679:              
5680:                          }
5681:              
5682:                          else if (USBOTGGetHNPTimeOutFlag())
5683:                          {
5684:                              if (USBOTGIsHNPTimeOutExpired())
5685:                              {
5686:                                  USB_OTGEventHandler(0,OTG_EVENT_HNP_FAILED,0,0);
5687:                              }
5688:              
5689:                          }
5690:              
5691:                          else
5692:                          {
5693:                              if(numTimerInterrupts != 0)
5694:                              {
5695:                                  numTimerInterrupts--;
5696:              
5697:                                  if (numTimerInterrupts == 0)
5698:                                  {
5699:                                      //If we aren't using the 1ms events, then turn of the interrupt to
5700:                                      // save CPU time
5701:                                      #if !defined(USB_ENABLE_1MS_EVENT)
5702:                                          // Turn off the timer interrupt.
5703:                                          U1OTGIEbits.T1MSECIE = 0;
5704:                                      #endif
5705:                  
5706:                                      // Advance to the next state.  We can do this here, because the only time
5707:                                      // we'll get a timer interrupt is while we are in one of the holding states.
5708:                                      _USB_SetNextSubSubState();
5709:                                  }
5710:                              }
5711:                          }
5712:                       #else
5713:              
5714:                          if(numTimerInterrupts != 0)
000582  80F6B0     MOV numTimerInterrupts, W0
000584  E00000     CP0 W0
000586  32000A     BRA Z, 0x59C
5715:                          {
5716:                              numTimerInterrupts--;
000588  80F6B0     MOV numTimerInterrupts, W0
00058A  E90000     DEC W0, W0
00058C  88F6B0     MOV W0, numTimerInterrupts
5717:              
5718:                              if (numTimerInterrupts == 0)
00058E  80F6B0     MOV numTimerInterrupts, W0
000590  E00000     CP0 W0
000592  3A0004     BRA NZ, 0x59C
5719:                              {
5720:                                  //If we aren't using the 1ms events, then turn of the interrupt to
5721:                                  // save CPU time
5722:                                  #if !defined(USB_ENABLE_1MS_EVENT)
5723:                                      // Turn off the timer interrupt.
5724:                                      U1OTGIEbits.T1MSECIE = 0;
000594  A9C482     BCLR U1OTGIE, #6
5725:                                  #endif
5726:              
5727:                                  // Advance to the next state.  We can do this here, because the only time
5728:                                  // we'll get a timer interrupt is while we are in one of the holding states.
5729:                                  _USB_SetNextSubSubState();
000596  80F690     MOV usbHostState, W0
000598  E80000     INC W0, W0
00059A  88F690     MOV W0, usbHostState
5730:                              }
5731:                          }
5732:                       #endif
5733:                  }
5734:              
5735:                  // -------------------------------------------------------------------------
5736:                  // Attach ISR
5737:              
5738:                  // The attach interrupt is level, not edge, triggered.  So make sure we have it enabled.
5739:                  if (U1IEbits.ATTACHIE && U1IRbits.ATTACHIF)
00059C  BFC48C     MOV.B U1IE, WREG
00059E  A36800     BTST.Z W0, #6
0005A0  32000C     BRA Z, 0x5BA
0005A2  BFC48A     MOV.B U1IR, WREG
0005A4  A36800     BTST.Z W0, #6
0005A6  320009     BRA Z, 0x5BA
5740:                  {
5741:                      #ifdef DEBUG_MODE
5742:                          UART2PutChar( '[' );
5743:                      #endif
5744:              
5745:                      // The attach interrupt is level, not edge, triggered.  If we clear it, it just
5746:                      // comes right back.  So clear the enable instead
5747:                      U1IEbits.ATTACHIE   = 0;
0005A8  A9C48C     BCLR U1IE, #6
5748:                      U1IR                = USB_INTERRUPT_ATTACH;
0005AA  200400     MOV #0x40, W0
0005AC  882450     MOV W0, U1IR
5749:              
5750:                      if (usbHostState == (STATE_DETACHED | SUBSTATE_WAIT_FOR_DEVICE))
0005AE  80F691     MOV usbHostState, W1
0005B0  500070     SUB W0, #0x10, W0
0005B2  508F80     SUB W1, W0, [W15]
0005B4  3A0002     BRA NZ, 0x5BA
5751:                      {
5752:                          usbOverrideHostState = STATE_ATTACHED;
0005B6  201000     MOV #0x100, W0
0005B8  88F5B0     MOV W0, usbOverrideHostState
5753:                      }
5754:              
5755:                      #ifdef  USB_SUPPORT_OTG
5756:                          //If HNP Related Attach, Process Connect Event
5757:                          USB_OTGEventHandler(0, OTG_EVENT_CONNECT, 0, 0 );
5758:              
5759:                          //If SRP Related A side D+ High, Process D+ High Event
5760:                          USB_OTGEventHandler (0, OTG_EVENT_SRP_DPLUS_HIGH, 0, 0 );
5761:              
5762:                          //If SRP Related B side Attach
5763:                          USB_OTGEventHandler (0, OTG_EVENT_SRP_CONNECT, 0, 0 );
5764:                      #endif
5765:                  }
5766:              
5767:                  // -------------------------------------------------------------------------
5768:                  // Detach ISR
5769:              
5770:                  if (U1IEbits.DETACHIE && U1IRbits.DETACHIF)
0005BA  BFC48C     MOV.B U1IE, WREG
0005BC  A30800     BTST.Z W0, #0
0005BE  320008     BRA Z, 0x5D0
0005C0  BFC48A     MOV.B U1IR, WREG
0005C2  A30800     BTST.Z W0, #0
0005C4  320005     BRA Z, 0x5D0
5771:                  {
5772:                      #ifdef DEBUG_MODE
5773:                          UART2PutChar( ']' );
5774:                      #endif
5775:              
5776:                      U1IR                    = USB_INTERRUPT_DETACH;
0005C6  200010     MOV #0x1, W0
0005C8  882450     MOV W0, U1IR
5777:                      U1IEbits.DETACHIE       = 0;
0005CA  A9048C     BCLR U1IE, #0
5778:                      usbOverrideHostState    = STATE_DETACHED;
0005CC  EB0000     CLR W0
0005CE  88F5B0     MOV W0, usbOverrideHostState
5779:              
5780:                      #ifdef  USB_SUPPORT_OTG
5781:                          //If HNP Related Detach Detected, Process Disconnect Event
5782:                          USB_OTGEventHandler (0, OTG_EVENT_DISCONNECT, 0, 0 );
5783:              
5784:                          //If SRP Related D+ Low and SRP Is Active, Process D+ Low Event
5785:                          USB_OTGEventHandler (0, OTG_EVENT_SRP_DPLUS_LOW, 0, 0 );
5786:              
5787:                          //Disable HNP, Detach Interrupt Could've Triggered From Cable Being Unplugged
5788:                          USBOTGDisableHnp();
5789:                      #endif
5790:                  }
5791:              
5792:                  #ifdef USB_SUPPORT_OTG
5793:              
5794:                      // -------------------------------------------------------------------------
5795:                      //ID Pin Change ISR
5796:                      if (U1OTGIRbits.IDIF && U1OTGIEbits.IDIE)
5797:                      {
5798:                           USBOTGInitialize();
5799:              
5800:                           //Clear Interrupt Flag
5801:                           U1OTGIR = 0x80;
5802:                      }
5803:              
5804:                      // -------------------------------------------------------------------------
5805:                      //VB_SESS_END ISR
5806:                      if (U1OTGIRbits.SESENDIF && U1OTGIEbits.SESENDIE)
5807:                      {
5808:                          //If B side Host And Cable Was Detached Then
5809:                          if (U1OTGSTATbits.ID == CABLE_B_SIDE && USBOTGCurrentRoleIs() == ROLE_HOST)
5810:                          {
5811:                              //Reinitialize
5812:                              USBOTGInitialize();
5813:                          }
5814:              
5815:                          //Clear Interrupt Flag
5816:                          U1OTGIR = 0x04;
5817:                      }
5818:              
5819:                      // -------------------------------------------------------------------------
5820:                      //VA_SESS_VLD ISR
5821:                      if (U1OTGIRbits.SESVDIF && U1OTGIEbits.SESVDIE)
5822:                      {
5823:                          //If A side Host and SRP Is Active Then
5824:                          if (USBOTGDefaultRoleIs() == ROLE_HOST && USBOTGSrpIsActive())
5825:                          {
5826:                              //If VBUS > VA_SESS_VLD Then
5827:                              if (U1OTGSTATbits.SESVD == 1)
5828:                              {
5829:                                  //Process SRP VBUS High Event
5830:                                  USB_OTGEventHandler (0, OTG_EVENT_SRP_VBUS_HIGH, 0, 0 );
5831:                              }
5832:              
5833:                              //If VBUS < VA_SESS_VLD Then
5834:                              else
5835:                              {
5836:                                   //Process SRP Low Event
5837:                                  USB_OTGEventHandler (0, OTG_EVENT_SRP_VBUS_LOW, 0, 0 );
5838:                              }
5839:                          }
5840:              
5841:                          U1OTGIR = 0x08;
5842:                      }
5843:              
5844:                      // -------------------------------------------------------------------------
5845:                      //Resume Signaling for Remote Wakeup
5846:                      if (U1IRbits.RESUMEIF && U1IEbits.RESUMEIE)
5847:                      {
5848:                          //Process SRP VBUS High Event
5849:                          USB_OTGEventHandler (0, OTG_EVENT_RESUME_SIGNALING,0, 0 );
5850:              
5851:                          //Clear Resume Interrupt Flag
5852:                          U1IR = 0x20;
5853:                      }
5854:                  #endif
5855:              
5856:              
5857:                  // -------------------------------------------------------------------------
5858:                  // Transfer Done ISR - only process if there was no error
5859:              
5860:                  if ((U1IEbits.TRNIE && U1IRbits.TRNIF) &&
0005D0  BFC48C     MOV.B U1IE, WREG
0005D2  A33800     BTST.Z W0, #3
0005D4  3200D0     BRA Z, 0x776
0005D6  BFC48A     MOV.B U1IR, WREG
0005D8  A33800     BTST.Z W0, #3
0005DA  3200CD     BRA Z, 0x776
0005DC  BFC48C     MOV.B U1IE, WREG
0005DE  A31800     BTST.Z W0, #1
0005E0  320008     BRA Z, 0x5F2
0005E2  BFC48A     MOV.B U1IR, WREG
0005E4  A31800     BTST.Z W0, #1
0005E6  320005     BRA Z, 0x5F2
0005E8  80F6A0     MOV pCurrentEndpoint, W0
0005EA  905830     MOV.B [W0+27], W0
0005EC  604063     AND.B W0, #0x3, W0
0005EE  504FE1     SUB.B W0, #0x1, [W15]
0005F0  3A00C2     BRA NZ, 0x776
5861:                      (!(U1IEbits.UERRIE && U1IRbits.UERRIF) || (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)))
5862:                  {
5863:                      #if defined(__C30__)
5864:                          U1STATBITS          copyU1STATbits;
5865:                      #elif defined(__PIC32MX__)
5866:                          __U1STATbits_t      copyU1STATbits;
5867:                      #else
5868:                          #error Need structure name for copyU1STATbits.
5869:                      #endif
5870:                      WORD                    packetSize;
5871:                      BDT_ENTRY               *pBDT;
5872:              
5873:                      #ifdef DEBUG_MODE
5874:              //            UART2PutChar( '!' );
5875:                      #endif
5876:              
5877:                      // The previous token has finished, so clear the way for writing a new one.
5878:                      usbBusInfo.flags.bfTokenAlreadyWritten = 0;
0005F2  21ECE0     MOV #0x1ECE, W0
0005F4  A14410     BCLR.B [W0], #4
5879:              
5880:                      copyU1STATbits = U1STATbits;    // Read the status register before clearing the flag.
0005F6  802492     MOV U1STAT, W2
5881:              
5882:                      U1IR = USB_INTERRUPT_TRANSFER;  // Clear the interrupt by writing a '1' to the flag.
0005F8  200080     MOV #0x8, W0
0005FA  882450     MOV W0, U1IR
5883:              
5884:                      // In host mode, U1STAT does NOT reflect the endpoint.  It is really the last updated
5885:                      // BDT, which, in host mode, is always 0.  To get the endpoint, we either need to look
5886:                      // at U1TOK, or trust that pCurrentEndpoint is still accurate.
5887:                      if ((pCurrentEndpoint->bEndpointAddress & 0x0F) == (U1TOK & 0x0F))
0005FC  80F6A4     MOV pCurrentEndpoint, W4
0005FE  9058A4     MOV.B [W4+26], W1
000600  8024F0     MOV U1TOK, W0
000602  6080EF     AND W1, #0xF, W1
000604  60006F     AND W0, #0xF, W0
000606  508F80     SUB W1, W0, [W15]
000608  3A00B4     BRA NZ, 0x772
00060A  610064     AND W2, #0x4, W0
5888:                      {
5889:                          if (copyU1STATbits.DIR)     // TX
00060C  A33802     BTST.Z W2, #3
00060E  320005     BRA Z, 0x61A
5890:                          {
5891:                              // We are processing OUT or SETUP packets.
5892:                              // Set up the BDT pointer for the transaction we just received.
5893:                              #if (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
5894:                                  pBDT = BDT_OUT;
5895:                                  if (copyU1STATbits.PPBI) // Odd
000610  21E0C2     MOV #0x1E0C, W2
000612  E00000     CP0 W0
000614  3A0006     BRA NZ, 0x622
000616  21E082     MOV #0x1E08, W2
000618  370004     BRA 0x622
5896:                                  {
5897:                                      pBDT = BDT_OUT_ODD;
5898:                                  }
5899:                              #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
5900:                                  pBDT = BDT_OUT;
5901:                              #endif
5902:                          }
5903:                          else
5904:                          {
5905:                              // We are processing IN packets.
5906:                              // Set up the BDT pointer for the transaction we just received.
5907:                              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
5908:                                  pBDT = BDT_IN;
5909:                                  if (copyU1STATbits.PPBI) // Odd
00061A  21E042     MOV #0x1E04, W2
00061C  E00000     CP0 W0
00061E  3A0001     BRA NZ, 0x622
000620  21E002     MOV #0x1E00, W2
5910:                                  {
5911:                                      pBDT = BDT_IN_ODD;
5912:                                  }
5913:                              #else
5914:                                  pBDT = BDT_IN;
5915:                              #endif
5916:                          }
5917:              
5918:                          if (pBDT->STAT.PID == PID_ACK)
000622  23C000     MOV #0x3C00, W0
000624  600092     AND W0, [W2], W1
000626  208000     MOV #0x800, W0
000628  508F80     SUB W1, W0, [W15]
00062A  3A0037     BRA NZ, 0x69A
5919:                          {
5920:                              // We will only get this PID from an OUT or SETUP packet.
5921:              
5922:                              // Update the count of bytes tranferred.  (If there was an error, this count will be 0.)
5923:                              // The Byte Count is NOT 0 if a NAK occurs.  Therefore, we can only update the
5924:                              // count when an ACK, DATA0, or DATA1 is received.
5925:                              packetSize                  = pBDT->count;
00062C  203FF0     MOV #0x3FF, W0
00062E  600112     AND W0, [W2], W2
5926:                              pCurrentEndpoint->dataCount += packetSize;
000630  900804     MOV [W4+16], W0
000632  900894     MOV [W4+18], W1
000634  400002     ADD W0, W2, W0
000636  4880E0     ADDC W1, #0x0, W1
000638  980A00     MOV W0, [W4+16]
00063A  980A11     MOV W1, [W4+18]
5927:              
5928:                              // Set the NAK retries for the next transaction;
5929:                              pCurrentEndpoint->countNAKs = 0;
00063C  EB0000     CLR W0
00063E  980A70     MOV W0, [W4+30]
5930:              
5931:                              // Toggle DTS for the next transfer.
5932:                              pCurrentEndpoint->status.bfNextDATA01 ^= 0x01;
000640  904034     MOV.B [W4+3], W0
000642  DE0043     LSR W0, #3, W0
000644  600061     AND W0, #0x1, W0
000646  A20400     BTG.B W0, #0
000648  DD0043     SL W0, #3, W0
00064A  9040B4     MOV.B [W4+3], W1
00064C  A13401     BCLR.B W1, #3
00064E  70C080     IOR.B W1, W0, W1
000650  984231     MOV.B W1, [W4+3]
5933:              
5934:                              if ((pCurrentEndpoint->transferState == (TSTATE_CONTROL_NO_DATA | TSUBSTATE_CONTROL_NO_DATA_SETUP)) ||
000652  905804     MOV.B [W4+24], W0
000654  504FF0     SUB.B W0, #0x10, [W15]
000656  320008     BRA Z, 0x668
000658  905884     MOV.B [W4+24], W1
00065A  B3C200     MOV #0x20, W0
00065C  50CF80     SUB.B W1, W0, [W15]
00065E  320004     BRA Z, 0x668
000660  905884     MOV.B [W4+24], W1
000662  404070     ADD.B W0, #0x10, W0
000664  50CF80     SUB.B W1, W0, [W15]
000666  3A0032     BRA NZ, 0x6CC
5935:                                  (pCurrentEndpoint->transferState == (TSTATE_CONTROL_READ    | TSUBSTATE_CONTROL_READ_SETUP)) ||
5936:                                  (pCurrentEndpoint->transferState == (TSTATE_CONTROL_WRITE   | TSUBSTATE_CONTROL_WRITE_SETUP)))
5937:                              {
5938:                                  // We are doing SETUP transfers. See if we are done with the SETUP portion.
5939:                                  if (pCurrentEndpoint->dataCount >= pCurrentEndpoint->dataCountMaxSETUP)
000668  900904     MOV [W4+16], W2
00066A  900994     MOV [W4+18], W3
00066C  900074     MOV [W4+14], W0
00066E  200001     MOV #0x0, W1
000670  510F80     SUB W2, W0, [W15]
000672  598F81     SUBB W3, W1, [W15]
000674  39007E     BRA NC, 0x772
5940:                                  {
5941:                                      // We are done with the SETUP.  Reset the byte count and
5942:                                      // proceed to the next token.
5943:                                      pCurrentEndpoint->dataCount = 0;
000676  B80060     MUL.UU W0, #0, W0
000678  980A00     MOV W0, [W4+16]
00067A  980A11     MOV W1, [W4+18]
00067C  37000A     BRA 0x692
5944:                                      _USB_SetNextTransferState();
5945:                                  }
5946:                              }
5947:                              else
5948:                              {
5949:                                  // We are doing OUT transfers.  See if we've written all the data.
5950:                                  // We've written all the data when we send a short packet or we have
5951:                                  // transferred all the data.  If it's an isochronous transfer, this
5952:                                  // portion is complete, so go to the next state, so we can tell the
5953:                                  // next higher layer that a batch of data has been transferred.
5954:                                  if ((pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS) ||
00067E  900904     MOV [W4+16], W2
000680  900994     MOV [W4+18], W3
000682  900054     MOV [W4+10], W0
000684  9000E4     MOV [W4+12], W1
000686  510F80     SUB W2, W0, [W15]
000688  598F81     SUBB W3, W1, [W15]
00068A  390073     BRA NC, 0x772
5955:                                      (packetSize < pCurrentEndpoint->wMaxPacketSize) ||
5956:                                      (pCurrentEndpoint->dataCount >= pCurrentEndpoint->dataCountMax))
5957:                                  {
5958:                                      // We've written all the data. Proceed to the next step.
5959:                                      pCurrentEndpoint->status.bfTransferSuccessful = 1;
00068C  904034     MOV.B [W4+3], W0
00068E  A00400     BSET.B W0, #0
000690  984230     MOV.B W0, [W4+3]
5960:                                      _USB_SetNextTransferState();
000692  905804     MOV.B [W4+24], W0
000694  E84000     INC.B W0, W0
000696  985A00     MOV.B W0, [W4+24]
000698  37006C     BRA 0x772
5961:                                  }
5962:                                  else
5963:                                  {
5964:                                      // We need to process more data.  Keep this endpoint in its current
5965:                                      // transfer state.
5966:                                  }
5967:                              }
5968:                          }
5969:                          else if ((pBDT->STAT.PID == PID_DATA0) || (pBDT->STAT.PID == PID_DATA1))
00069A  20C000     MOV #0xC00, W0
00069C  508F80     SUB W1, W0, [W15]
00069E  320003     BRA Z, 0x6A6
0006A0  22C000     MOV #0x2C00, W0
0006A2  508F80     SUB W1, W0, [W15]
0006A4  3A001B     BRA NZ, 0x6DC
5970:                          {
5971:                              // We will only get these PID's from an IN packet.
5972:                              
5973:                              // Update the count of bytes tranferred.  (If there was an error, this count will be 0.)
5974:                              // The Byte Count is NOT 0 if a NAK occurs.  Therefore, we can only update the
5975:                              // count when an ACK, DATA0, or DATA1 is received.
5976:                              packetSize                  = pBDT->count;
0006A6  203FF0     MOV #0x3FF, W0
0006A8  600112     AND W0, [W2], W2
5977:                              pCurrentEndpoint->dataCount += packetSize;
0006AA  900804     MOV [W4+16], W0
0006AC  900894     MOV [W4+18], W1
0006AE  400002     ADD W0, W2, W0
0006B0  4880E0     ADDC W1, #0x0, W1
0006B2  980A00     MOV W0, [W4+16]
0006B4  980A11     MOV W1, [W4+18]
5978:              
5979:                              // Set the NAK retries for the next transaction;
5980:                              pCurrentEndpoint->countNAKs = 0;
0006B6  EB0000     CLR W0
0006B8  980A70     MOV W0, [W4+30]
5981:              
5982:                              // Toggle DTS for the next transfer.
5983:                              pCurrentEndpoint->status.bfNextDATA01 ^= 0x01;
0006BA  904034     MOV.B [W4+3], W0
0006BC  DE0043     LSR W0, #3, W0
0006BE  600061     AND W0, #0x1, W0
0006C0  A20400     BTG.B W0, #0
0006C2  DD0043     SL W0, #3, W0
0006C4  9040B4     MOV.B [W4+3], W1
0006C6  A13401     BCLR.B W1, #3
0006C8  70C080     IOR.B W1, W0, W1
0006CA  984231     MOV.B W1, [W4+3]
5984:              
5985:                              // We are doing IN transfers.  See if we've received all the data.
5986:                              // We've received all the data if it's an isochronous transfer, or when we receive a
5987:                              // short packet or we have transferred all the data.
5988:                              if ((pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS) ||
0006CC  905834     MOV.B [W4+27], W0
0006CE  604063     AND.B W0, #0x3, W0
0006D0  504FE1     SUB.B W0, #0x1, [W15]
0006D2  32FFDC     BRA Z, 0x68C
0006D4  900044     MOV [W4+8], W0
0006D6  510F80     SUB W2, W0, [W15]
0006D8  39FFD9     BRA NC, 0x68C
0006DA  37FFD1     BRA 0x67E
5989:                                  (packetSize < pCurrentEndpoint->wMaxPacketSize) ||
5990:                                  (pCurrentEndpoint->dataCount >= pCurrentEndpoint->dataCountMax))
5991:                              {
5992:                                  // If we've received all the data, stop the transfer.  We've received all the
5993:                                  // data when we receive a short or zero-length packet.  If the data length is a
5994:                                  // multiple of wMaxPacketSize, we will get a 0-length packet.
5995:                                  pCurrentEndpoint->status.bfTransferSuccessful = 1;
5996:                                  _USB_SetNextTransferState();
5997:                              }
5998:                              else
5999:                              {
6000:                                  // We need to process more data.  Keep this endpoint in its current
6001:                                  // transfer state.
6002:                              }
6003:                          }
6004:                          else if (pBDT->STAT.PID == PID_NAK)
0006DC  228000     MOV #0x2800, W0
0006DE  508F80     SUB W1, W0, [W15]
0006E0  3A0021     BRA NZ, 0x724
6005:                          {
6006:                              #ifndef ALLOW_MULTIPLE_NAKS_PER_FRAME
6007:                                  pCurrentEndpoint->status.bfLastTransferNAKd = 1;
0006E2  904034     MOV.B [W4+3], W0
0006E4  A04400     BSET.B W0, #4
0006E6  984230     MOV.B W0, [W4+3]
6008:                              #endif
6009:              
6010:                              pCurrentEndpoint->countNAKs ++;
0006E8  900874     MOV [W4+30], W0
0006EA  E80000     INC W0, W0
0006EC  980A70     MOV W0, [W4+30]
6011:              
6012:                              switch( pCurrentEndpoint->bmAttributes.bfTransferType )
0006EE  905834     MOV.B [W4+27], W0
0006F0  600063     AND W0, #0x3, W0
0006F2  500FE1     SUB W0, #0x1, [W15]
0006F4  32FFCB     BRA Z, 0x68C
0006F6  3C0003     BRA GT, 0x6FE
0006F8  E00000     CP0 W0
0006FA  320008     BRA Z, 0x70C
0006FC  37003A     BRA 0x772
0006FE  500FE2     SUB W0, #0x2, [W15]
000700  320005     BRA Z, 0x70C
000702  500FE3     SUB W0, #0x3, [W15]
000704  3A0036     BRA NZ, 0x772
6013:                              {
6014:                                  case USB_TRANSFER_TYPE_BULK:
6015:                                      // Bulk IN and OUT transfers are allowed to retry NAK'd
6016:                                      // transactions until a timeout (if enabled) or indefinitely
6017:                                          // (if NAK timeouts disabled).
6018:                                      if (pCurrentEndpoint->status.bfNAKTimeoutEnabled &&
6019:                                          (pCurrentEndpoint->countNAKs > pCurrentEndpoint->timeoutNAKs))
6020:                                      {
6021:                                          pCurrentEndpoint->status.bfError    = 1;
6022:                                          pCurrentEndpoint->bErrorCode        = USB_ENDPOINT_NAK_TIMEOUT;
6023:                                          _USB_SetTransferErrorState( pCurrentEndpoint );
6024:                                      }
6025:                                      break;
6026:              
6027:                                  case USB_TRANSFER_TYPE_CONTROL:
6028:                                      // Devices should not NAK the SETUP portion.  If they NAK
6029:                                      // the DATA portion, they are allowed to retry a fixed
6030:                                      // number of times.
6031:                                      if (pCurrentEndpoint->status.bfNAKTimeoutEnabled &&
6032:                                          (pCurrentEndpoint->countNAKs > pCurrentEndpoint->timeoutNAKs))
6033:                                      {
6034:                                          pCurrentEndpoint->status.bfError    = 1;
6035:                                          pCurrentEndpoint->bErrorCode        = USB_ENDPOINT_NAK_TIMEOUT;
6036:                                          _USB_SetTransferErrorState( pCurrentEndpoint );
6037:                                      }
6038:                                      break;
6039:              
6040:                                  case USB_TRANSFER_TYPE_INTERRUPT:
6041:                                      if ((pCurrentEndpoint->bEndpointAddress & 0x80) == 0x00)
000706  905824     MOV.B [W4+26], W0
000708  E00400     CP0.B W0
00070A  35FFC0     BRA LT, 0x68C
6042:                                      {
6043:                                          // Interrupt OUT transfers are allowed to retry NAK'd
6044:                                          // transactions until a timeout (if enabled) or indefinitely
6045:                                          // (if NAK timeouts disabled).
6046:                                          if (pCurrentEndpoint->status.bfNAKTimeoutEnabled &&
00070C  904034     MOV.B [W4+3], W0
00070E  A35800     BTST.Z W0, #5
000710  320030     BRA Z, 0x772
000712  9008F4     MOV [W4+30], W1
000714  901004     MOV [W4+32], W0
000716  508F80     SUB W1, W0, [W15]
000718  36002C     BRA LEU, 0x772
6047:                                              (pCurrentEndpoint->countNAKs > pCurrentEndpoint->timeoutNAKs))
6048:                                          {
6049:                                              pCurrentEndpoint->status.bfError    = 1;
00071A  904024     MOV.B [W4+2], W0
00071C  A06400     BSET.B W0, #6
00071E  984220     MOV.B W0, [W4+2]
6050:                                              pCurrentEndpoint->bErrorCode        = USB_ENDPOINT_NAK_TIMEOUT;
000720  B3C170     MOV #0x17, W0
000722  370007     BRA 0x732
6051:                                              _USB_SetTransferErrorState( pCurrentEndpoint );
6052:                                          }
6053:                                      }
6054:                                      else
6055:                                      {
6056:                                          // Interrupt IN transfers terminate with no error.
6057:                                          pCurrentEndpoint->status.bfTransferSuccessful = 1;
6058:                                          _USB_SetNextTransferState();
6059:                                      }
6060:                                      break;
6061:              
6062:                                  case USB_TRANSFER_TYPE_ISOCHRONOUS:
6063:                                      // Isochronous transfers terminate with no error.
6064:                                      pCurrentEndpoint->status.bfTransferSuccessful = 1;
6065:                                      _USB_SetNextTransferState();
6066:                                      break;
6067:                              }
6068:                          }
6069:                          else if (pBDT->STAT.PID == PID_STALL)
000724  238000     MOV #0x3800, W0
000726  508F80     SUB W1, W0, [W15]
000728  3A000A     BRA NZ, 0x73E
6070:                          {
6071:                              // Device is stalled.  Stop the transfer, and indicate the stall.
6072:                              // The application must clear this if not a control endpoint.
6073:                              // A stall on a control endpoint does not indicate that the
6074:                              // endpoint is halted.
6075:                              #ifdef DEBUG_MODE
6076:                                  UART2PutChar( '^' );
6077:                              #endif
6078:                              pCurrentEndpoint->status.bfStalled = 1;
00072A  904024     MOV.B [W4+2], W0
00072C  A05400     BSET.B W0, #5
00072E  984220     MOV.B W0, [W4+2]
6079:                              pCurrentEndpoint->bErrorCode       = USB_ENDPOINT_STALLED;
000730  B3C110     MOV #0x11, W0
000732  985A40     MOV.B W0, [W4+28]
6080:                              _USB_SetTransferErrorState( pCurrentEndpoint );
000734  905804     MOV.B [W4+24], W0
000736  B3CF01     MOV #0xF0, W1
000738  604001     AND.B W0, W1, W0
00073A  B340F0     IOR.B #0xF, W0
00073C  37FFAC     BRA 0x696
6081:                          }
6082:                          else
6083:                          {
6084:                              // Module-defined PID - Bus Timeout (0x0) or Data Error (0x0F).  Increment the error count.
6085:                              // NOTE: If DTS is enabled and the packet has the wrong DTS value, a PID of 0x0F is
6086:                              // returned.  The hardware, however, acknowledges the packet, so the device thinks
6087:                              // that the host has received it.  But the data is not actually received, and the application
6088:                              // layer is not informed of the packet.
6089:                              pCurrentEndpoint->status.bfErrorCount++;
00073E  9040A4     MOV.B [W4+2], W1
000740  E84081     INC.B W1, W1
000742  60C0FF     AND.B W1, #0x1F, W1
000744  904024     MOV.B [W4+2], W0
000746  B3CE02     MOV #0xE0, W2
000748  604002     AND.B W0, W2, W0
00074A  704001     IOR.B W0, W1, W0
00074C  984220     MOV.B W0, [W4+2]
6090:              
6091:                              if (pCurrentEndpoint->status.bfErrorCount >= USB_TRANSACTION_RETRY_ATTEMPTS)
00074E  904024     MOV.B [W4+2], W0
000750  60007F     AND W0, #0x1F, W0
000752  500FF3     SUB W0, #0x13, [W15]
000754  34000E     BRA LE, 0x772
6092:                              {
6093:                                  // We have too many errors.
6094:              
6095:                                  // Stop the transfer and indicate an error.
6096:                                  // The application must clear this.
6097:                                  pCurrentEndpoint->status.bfError    = 1;
000756  904024     MOV.B [W4+2], W0
000758  A06400     BSET.B W0, #6
00075A  984220     MOV.B W0, [W4+2]
6098:                                  pCurrentEndpoint->bErrorCode        = USB_ENDPOINT_ERROR_ILLEGAL_PID;
00075C  B3C130     MOV #0x13, W0
00075E  985A40     MOV.B W0, [W4+28]
6099:                                  _USB_SetTransferErrorState( pCurrentEndpoint );
000760  905804     MOV.B [W4+24], W0
000762  B3CF01     MOV #0xF0, W1
000764  604001     AND.B W0, W1, W0
000766  B340F0     IOR.B #0xF, W0
000768  985A00     MOV.B W0, [W4+24]
6100:              
6101:                                  // Avoid the error interrupt code, because we are going to
6102:                                  // find another token to send.
6103:                                  U1EIR = 0xFF;
00076A  200FF0     MOV #0xFF, W0
00076C  882470     MOV W0, U1EIR
6104:                                  U1IR  = USB_INTERRUPT_ERROR;
00076E  200020     MOV #0x2, W0
000770  882450     MOV W0, U1IR
6105:                              }
6106:                              else
6107:                              {
6108:                                  // Fall through.  This will automatically cause the transfer
6109:                                  // to be retried.
6110:                              }
6111:                          }
6112:                      }
6113:                      else
6114:                      {
6115:                          // We have a mismatch between the endpoint we were expecting and the one that we got.
6116:                          // The user may be trying to select a new configuration.  Discard the transaction.
6117:                      }
6118:              
6119:                      _USB_FindNextToken();
000772  021F10     CALL _USB_FindNextToken
000774  000000     NOP
6120:                  } // U1IRbits.TRNIF
6121:              
6122:              
6123:                  // -------------------------------------------------------------------------
6124:                  // Start-of-Frame ISR
6125:              
6126:                  if (U1IEbits.SOFIE && U1IRbits.SOFIF)
000776  BFC48C     MOV.B U1IE, WREG
000778  A32800     BTST.Z W0, #2
00077A  32002C     BRA Z, 0x7D4
00077C  BFC48A     MOV.B U1IR, WREG
00077E  A32800     BTST.Z W0, #2
000780  320029     BRA Z, 0x7D4
6127:                  {
6128:                      USB_ENDPOINT_INFO           *pEndpoint;
6129:                      USB_INTERFACE_INFO          *pInterface;
6130:              
6131:                      #if defined(USB_ENABLE_SOF_EVENT) && defined(USB_HOST_APP_DATA_EVENT_HANDLER)
6132:                          //Notify ping all client drivers of SOF event (address, event, data, sizeof_data)
6133:                          _USB_NotifyDataClients(0, EVENT_SOF, NULL, 0);
6134:                      #endif
6135:              
6136:                      #ifdef DEBUG_MODE
6137:              //            UART2PutChar( '$' );
6138:                      #endif
6139:                      U1IR = USB_INTERRUPT_SOF; // Clear the interrupt by writing a '1' to the flag.
000782  200040     MOV #0x4, W0
000784  882450     MOV W0, U1IR
6140:              
6141:                      pInterface = usbDeviceInfo.pInterfaceList;
000786  80F642     MOV 0x1EC8, W2
000788  37001A     BRA 0x7BE
6142:                      while (pInterface)
0007BE  E00002     CP0 W2
0007C0  3AFFE4     BRA NZ, 0x78A
6143:                      {
6144:                          if (pInterface->pCurrentSetting)
00078A  900022     MOV [W2+4], W0
00078C  E00000     CP0 W0
00078E  320016     BRA Z, 0x7BC
6145:                          {
6146:                              pEndpoint = pInterface->pCurrentSetting->pEndpointList;
000790  9000A0     MOV [W0+4], W1
000792  203004     MOV #0x300, W4
000794  201003     MOV #0x100, W3
000796  370010     BRA 0x7B8
6147:                              while (pEndpoint)
0007B8  E00001     CP0 W1
0007BA  3AFFEE     BRA NZ, 0x798
6148:                              {
6149:                                  // Decrement the interval count of all active interrupt and isochronous endpoints.
6150:                                  if ((pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_INTERRUPT) ||
000798  900851     MOV [W1+26], W0
00079A  B23000     AND #0x300, W0
00079C  500F84     SUB W0, W4, [W15]
00079E  320002     BRA Z, 0x7A4
0007A0  500F83     SUB W0, W3, [W15]
0007A2  3A0006     BRA NZ, 0x7B0
6151:                                      (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS))
6152:                                  {
6153:                                      if (pEndpoint->wIntervalCount != 0)
0007A4  900031     MOV [W1+6], W0
0007A6  E00000     CP0 W0
0007A8  320003     BRA Z, 0x7B0
6154:                                      {
6155:                                          pEndpoint->wIntervalCount--;
0007AA  900031     MOV [W1+6], W0
0007AC  E90000     DEC W0, W0
0007AE  9800B0     MOV W0, [W1+6]
6156:                                      }
6157:                                  }
6158:                  
6159:                                  #ifndef ALLOW_MULTIPLE_NAKS_PER_FRAME
6160:                                      pEndpoint->status.bfLastTransferNAKd = 0;
0007B0  904031     MOV.B [W1+3], W0
0007B2  A14400     BCLR.B W0, #4
0007B4  9840B0     MOV.B W0, [W1+3]
6161:                                  #endif
6162:                  
6163:                                  pEndpoint = pEndpoint->next;
0007B6  780091     MOV [W1], W1
6164:                              }
6165:                          }
6166:                          
6167:                          pInterface = pInterface->next;
0007BC  780112     MOV [W2], W2
6168:                      }
6169:              
6170:                      usbBusInfo.flags.bfControlTransfersDone     = 0;
0007C2  21ECE0     MOV #0x1ECE, W0
0007C4  A10410     BCLR.B [W0], #0
6171:                      usbBusInfo.flags.bfInterruptTransfersDone   = 0;
0007C6  A11410     BCLR.B [W0], #1
6172:                      usbBusInfo.flags.bfIsochronousTransfersDone = 0;
0007C8  A12410     BCLR.B [W0], #2
6173:                      usbBusInfo.flags.bfBulkTransfersDone        = 0;
0007CA  A13410     BCLR.B [W0], #3
6174:                      //usbBusInfo.dBytesSentInFrame                = 0;
6175:                      usbBusInfo.lastBulkTransaction              = 0;
0007CC  21ED00     MOV #0x1ED0, W0
0007CE  784802     MOV.B W2, [W0]
6176:              
6177:                      _USB_FindNextToken();
0007D0  021F10     CALL _USB_FindNextToken
0007D2  000000     NOP
6178:                  }
6179:              
6180:                  // -------------------------------------------------------------------------
6181:                  // USB Error ISR
6182:              
6183:                  if (U1IEbits.UERRIE && U1IRbits.UERRIF)
0007D4  BFC48C     MOV.B U1IE, WREG
0007D6  A31800     BTST.Z W0, #1
0007D8  320044     BRA Z, 0x862
0007DA  BFC48A     MOV.B U1IR, WREG
0007DC  A31800     BTST.Z W0, #1
0007DE  320041     BRA Z, 0x862
6184:                  {
6185:                      #ifdef DEBUG_MODE
6186:                          UART2PutChar('#');
6187:                          UART2PutHex( U1EIR );
6188:                      #endif
6189:              
6190:                      // The previous token has finished, so clear the way for writing a new one.
6191:                      usbBusInfo.flags.bfTokenAlreadyWritten = 0;
0007E0  21ECE0     MOV #0x1ECE, W0
0007E2  A14410     BCLR.B [W0], #4
6192:              
6193:                      // If we are doing isochronous transfers, ignore the error.
6194:                      if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
0007E4  80F6A3     MOV pCurrentEndpoint, W3
0007E6  905833     MOV.B [W3+27], W0
0007E8  604063     AND.B W0, #0x3, W0
0007EA  504FE1     SUB.B W0, #0x1, [W15]
0007EC  320036     BRA Z, 0x85A
6195:                      {
6196:              //            pCurrentEndpoint->status.bfTransferSuccessful = 1;
6197:              //            _USB_SetNextTransferState();
6198:                      }
6199:                      else
6200:                      {
6201:                          // Increment the error count.
6202:                          pCurrentEndpoint->status.bfErrorCount++;
0007EE  9040A3     MOV.B [W3+2], W1
0007F0  E84081     INC.B W1, W1
0007F2  60C0FF     AND.B W1, #0x1F, W1
0007F4  904023     MOV.B [W3+2], W0
0007F6  B3CE02     MOV #0xE0, W2
0007F8  604002     AND.B W0, W2, W0
0007FA  704001     IOR.B W0, W1, W0
0007FC  9841A0     MOV.B W0, [W3+2]
6203:              
6204:                          if (pCurrentEndpoint->status.bfErrorCount >= USB_TRANSACTION_RETRY_ATTEMPTS)
0007FE  904023     MOV.B [W3+2], W0
000800  60007F     AND W0, #0x1F, W0
000802  500FF3     SUB W0, #0x13, [W15]
000804  34002A     BRA LE, 0x85A
6205:                          {
6206:                              // We have too many errors.
6207:              
6208:                              // Check U1EIR for the appropriate error codes to return
6209:                              if (U1EIRbits.BTSEF)
000806  E2448E     CP0.B U1EIR
000808  3D0002     BRA GE, 0x80E
6210:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_BIT_STUFF;
00080A  B3C200     MOV #0x20, W0
00080C  9859C0     MOV.B W0, [W3+28]
6211:                              if (U1EIRbits.DMAEF)
00080E  BFC48E     MOV.B U1EIR, WREG
000810  A35800     BTST.Z W0, #5
000812  320002     BRA Z, 0x818
6212:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_DMA;
000814  B3C210     MOV #0x21, W0
000816  9859C0     MOV.B W0, [W3+28]
6213:                              if (U1EIRbits.BTOEF)
000818  BFC48E     MOV.B U1EIR, WREG
00081A  A34800     BTST.Z W0, #4
00081C  320002     BRA Z, 0x822
6214:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_TIMEOUT;
00081E  B3C220     MOV #0x22, W0
000820  9859C0     MOV.B W0, [W3+28]
6215:                              if (U1EIRbits.DFN8EF)
000822  BFC48E     MOV.B U1EIR, WREG
000824  A33800     BTST.Z W0, #3
000826  320002     BRA Z, 0x82C
6216:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_DATA_FIELD;
000828  B3C230     MOV #0x23, W0
00082A  9859C0     MOV.B W0, [W3+28]
6217:                              if (U1EIRbits.CRC16EF)
00082C  BFC48E     MOV.B U1EIR, WREG
00082E  A32800     BTST.Z W0, #2
000830  320002     BRA Z, 0x836
6218:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_CRC16;
000832  B3C240     MOV #0x24, W0
000834  9859C0     MOV.B W0, [W3+28]
6219:                              if (U1EIRbits.EOFEF)
000836  BFC48E     MOV.B U1EIR, WREG
000838  A31800     BTST.Z W0, #1
00083A  320002     BRA Z, 0x840
6220:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_END_OF_FRAME;
00083C  B3C250     MOV #0x25, W0
00083E  9859C0     MOV.B W0, [W3+28]
6221:                              if (U1EIRbits.PIDEF)
000840  BFC48E     MOV.B U1EIR, WREG
000842  A30800     BTST.Z W0, #0
000844  320002     BRA Z, 0x84A
6222:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_PID_CHECK;
000846  B3C260     MOV #0x26, W0
000848  9859C0     MOV.B W0, [W3+28]
6223:                              #if defined(__PIC32MX__)
6224:                              if (U1EIRbits.BMXEF)
6225:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_BMX;
6226:                              #endif
6227:              
6228:                              pCurrentEndpoint->status.bfError    = 1;
00084A  904023     MOV.B [W3+2], W0
00084C  A06400     BSET.B W0, #6
00084E  9841A0     MOV.B W0, [W3+2]
6229:              
6230:                              _USB_SetTransferErrorState( pCurrentEndpoint );
000850  905803     MOV.B [W3+24], W0
000852  B3CF01     MOV #0xF0, W1
000854  604001     AND.B W0, W1, W0
000856  B340F0     IOR.B #0xF, W0
000858  985980     MOV.B W0, [W3+24]
6231:                          }
6232:                      }
6233:              
6234:                      U1EIR = 0xFF;   // Clear the interrupts by writing '1' to the flags.
00085A  200FF0     MOV #0xFF, W0
00085C  882470     MOV W0, U1EIR
6235:                      U1IR = USB_INTERRUPT_ERROR; // Clear the interrupt by writing a '1' to the flag.
00085E  200020     MOV #0x2, W0
000860  882450     MOV W0, U1IR
6236:                  }
6237:              }
6238:              
6239:              
6240:              /*************************************************************************
6241:               * EOF usb_host.c
6242:               */
6243:              
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/microchip/common/uart2.c  
1:                 /*
2:                 
3:                 UART2 Driver File for PIC24.
4:                 
5:                 ********************************************************************************
6:                  FileName:        uart2.c
7:                  Dependencies:    HardwareProfile.h
8:                  Processor:       PIC24
9:                  Compiler:        MPLAB C30
10:                 Linker:          MPLAB LINK30
11:                 Company:         Microchip Technology Incorporated
12:                
13:                Author                Date      Comment
14:                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
15:                KO                 12-Feb-2008  Modified to use HardwareProfile.h
16:                KO                 11-Oct-2006  v1.0
17:                Anton Alkhimenok   18-Oct-2005
18:                Anton Alkhimenok   17-Feb-2009  Added UART2Char2Hex(), UART2Hex2Char(), 
19:                									  UART2ClearError(), UART2DataReceived()
20:                PAT				   27-Jan-2010  Added UART2GetBaudError() for dynamic checking
21:                								of baud rate percentage error.
22:                
23:                ********************************************************************************
24:                Software License Agreement
25:                
26:                Microchip Technology Inc. ("Microchip") licenses to you the right to use, copy,
27:                modify and distribute the software - including source code - only for use with
28:                Microchip microcontrollers or Microchip digital signal controllers; provided
29:                that no open source or free software is incorporated into the Source Code
30:                without Microchip?s prior written consent in each instance.
31:                
32:                The software is owned by Microchip and its licensors, and is protected under
33:                applicable copyright laws.  All rights reserved.
34:                
35:                SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT OR
42:                CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING
44:                BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                
46:                ********************************************************************************
47:                */
48:                
49:                #include "Compiler.h"
50:                #include "HardwareProfile.h"
51:                #include "uart2.h"
52:                
53:                //******************************************************************************
54:                // Constants
55:                //******************************************************************************
56:                
57:                //U2BRG register value and baudrate mistake calculation
58:                
59:                #if defined (__C30__)
60:                    #if defined (__dsPIC33E__) || defined (__PIC24E__)
61:                    #define BAUDRATEREG2        (((GetSystemClock())/(BRG_DIV2 * BAUDRATE2)) - 1)
62:                    #else
63:                    #define BAUDRATEREG2        (((GetSystemClock()/2)+(BRG_DIV2/2*BAUDRATE2))/BRG_DIV2/BAUDRATE2-1)
64:                    #endif
65:                #elif defined (__PIC32MX__)
66:                    #define BAUDRATEREG2        ((GetPeripheralClock()+(BRG_DIV2/2*BAUDRATE2))/BRG_DIV2/BAUDRATE2-1)
67:                #else
68:                    #error Cannot calculate BRG value
69:                #endif    
70:                
71:                #if defined (__C30__)
72:                    #if defined (__dsPIC33EP512MU810__)|| defined (__PIC24EP512GU810__)
73:                    #define BAUD_ACTUAL         ((GetSystemClock())/(BRG_DIV2 * (BAUDRATEREG2+1)))
74:                    #else
75:                    #define BAUD_ACTUAL         ((GetSystemClock()/2)/BRG_DIV2/(BAUDRATEREG2+1))
76:                    #endif
77:                #elif defined (__PIC32MX__)
78:                    #define BAUD_ACTUAL         (GetPeripheralClock()/BRG_DIV2/(BAUDRATEREG2+1))
79:                #else
80:                    #error Cannot calculate actual baud rate
81:                #endif    
82:                
83:                
84:                	#define BAUD_ERROR              ((BAUD_ACTUAL > BAUDRATE2) ? BAUD_ACTUAL-BAUDRATE2 : BAUDRATE2-BAUD_ACTUAL)
85:                	#define BAUD_ERROR_PERCENT      ((BAUD_ERROR*100+BAUDRATE2/2)/BAUDRATE2)
86:                	
87:                #if defined (__C30__)
88:                
89:                	#if (BAUD_ERROR_PERCENT > 3)
90:                	    #error UART frequency error is worse than 3%
91:                	#elif (BAUD_ERROR_PERCENT > 2)
92:                	    #warning UART frequency error is worse than 2%
93:                	#endif
94:                
95:                #endif // #if defined (__C30__)
96:                
97:                /*******************************************************************************
98:                Function: UART2GetBaudError()
99:                
100:               Precondition:
101:                   None.
102:               
103:               Overview:
104:                   This routine checks the UART baud rate error percentage and returns it.
105:               
106:               Input: None.
107:               
108:               Output: Returns the baud rate error in percent.
109:               
110:               *******************************************************************************/
111:               char UART2GetBaudError()
112:               {
113:                   unsigned int errorPercent = 0;
114:               
115:               	errorPercent = ((BAUD_ERROR*100+BAUDRATE2/2)/BAUDRATE2);
116:                   return (char)errorPercent;
117:               }
118:               
119:               
120:               /*******************************************************************************
121:               Function: UART2GetChar()
122:               
123:               Precondition:
124:                   UART2Init must be called prior to calling this routine.
125:               
126:               Overview:
127:                   This routine waits for a byte to be received.  It then returns that byte.
128:               
129:               Input: None.
130:               
131:               Output: Byte received.
132:               
133:               *******************************************************************************/
134:               char UART2GetChar()
135:               {
136:                   char Temp;
137:               
138:                   while(IFS1bits.U2RXIF == 0);
00230E  BFC087     MOV.B 0x87, WREG
002310  A36800     BTST.Z W0, #6
002312  32FFFD     BRA Z, UART2GetChar
139:               
140:                   Temp = U2RXREG;
002314  8011B0     MOV U2RXREG, W0
141:                   IFS1bits.U2RXIF = 0;
002316  A9C087     BCLR 0x87, #6
002318  FB0000     SE W0, W0
142:                   return Temp;
143:               }
144:               
145:               /*******************************************************************************
146:               Function: UART2Init()
147:               
148:               Precondition: None.
149:               
150:               Overview:
151:                   This routine sets up the UART2 module.
152:               
153:               Input: None.
154:               
155:               Output: None.
156:               
157:               Notes:
158:                   Allow the peripheral to set the I/O pin directions.  If we set the TRIS
159:                   bits manually, then when we disable the UART, the shape of the stop bit
160:                   changes, and some terminal programs have problems.
161:               *******************************************************************************/
162:               void UART2Init()
163:               {
164:                   U2BRG = BAUDRATEREG2;
00231C  200220     MOV #0x22, W0
00231E  8811C0     MOV W0, U2BRG
165:                   U2MODE = 0;
002320  EB0000     CLR W0
002322  881180     MOV W0, U2MODE
166:                   U2MODEbits.BRGH = BRGH2;
002324  A86230     BSET U2MODE, #3
167:                   U2STA = 0;
002326  881190     MOV W0, U2STA
168:                   U2MODEbits.UARTEN = 1;
002328  A8E231     BSET 0x231, #7
169:                   U2STAbits.UTXEN = 1;
00232A  A84233     BSET 0x233, #2
170:                   IFS1bits.U2RXIF = 0;
00232C  A9C087     BCLR 0x87, #6
171:                   
172:                   #if defined (__PIC32MX__)
173:                       U2STAbits.URXEN = 1;
174:                   #endif
175:               }
176:               
177:               /*******************************************************************************
178:               Function: UART2IsPressed()
179:               
180:               Precondition:
181:                   UART2Init must be called prior to calling this routine.
182:               
183:               Overview:
184:                   This routine checks to see if there is a new byte in UART reception buffer.
185:               
186:               Input: None.
187:               
188:               Output:
189:                   0 : No new data received.
190:                   1 : Data is in the receive buffer
191:               
192:               *******************************************************************************/
193:               char UART2IsPressed()
194:               {
195:                   if(IFS1bits.U2RXIF == 1)
002330  BFC087     MOV.B 0x87, WREG
002332  DE0046     LSR W0, #6, W0
002334  600061     AND W0, #0x1, W0
196:                       return 1;
197:                   return 0;
198:               }
199:               
200:               /*******************************************************************************
201:               Function: UART2PrintString( char *str )
202:               
203:               Precondition:
204:                   UART2Init must be called prior to calling this routine.
205:               
206:               Overview:
207:                   This function prints a string of characters to the UART.
208:               
209:               Input: Pointer to a null terminated character string.
210:               
211:               Output: None.
212:               
213:               *******************************************************************************/
214:               void UART2PrintString( char *str )
215:               {
216:                   unsigned char c;
217:               
218:                   while( (c = *str++) )
00234E  784038     MOV.B [W8++], W0
002350  E00400     CP0.B W0
002352  3AFFFC     BRA NZ, 0x234C
219:                       UART2PutChar(c);
00234C  07FFF5     RCALL UART2PutChar
220:               }
002358  781F88     MOV W8, [W15++]
00235A  784400     MOV.B W0, W8
221:               
222:               /*******************************************************************************
223:               Function: UART2PutChar( char ch )
224:               
225:               Precondition:
226:                   UART2Init must be called prior to calling this routine.
227:               
228:               Overview:
229:                   This routine writes a character to the transmit FIFO, and then waits for the
230:                   transmit FIFO to be empty.
231:               
232:               Input: Byte to be sent.
233:               
234:               Output: None.
235:               
236:               *******************************************************************************/
237:               void UART2PutChar( char ch )
238:               {
239:                   U2TXREG = ch;
002338  FB0000     SE W0, W0
00233A  8811A0     MOV W0, U2TXREG
240:                   #if !defined(__PIC32MX__)
241:                       Nop();
00233C  000000     NOP
242:                   #endif
243:                   while(U2STAbits.TRMT == 0);
00233E  BFC233     MOV.B 0x233, WREG
002340  A30800     BTST.Z W0, #0
002342  32FFFD     BRA Z, 0x233E
244:               }
002346  781F88     MOV W8, [W15++]
002348  780400     MOV W0, W8
00234A  370001     BRA 0x234E
245:               
246:               /*******************************************************************************
247:               Function: UART2PutDec(unsigned char dec)
248:               
249:               Precondition:
250:                   UART2Init must be called prior to calling this routine.
251:               
252:               Overview:
253:                   This function converts decimal data into a string and outputs it to UART.
254:               
255:               Input: Binary data.
256:               
257:               Output: None.
258:               
259:               *******************************************************************************/
260:               void  UART2PutDec(unsigned char dec)
261:               {
262:                   unsigned char res;
263:                   unsigned char printed_already = 0;
264:               
265:                   res = dec;
266:               
267:                   if (res/100)
00235C  EB4200     CLR.B W4
00235E  B3C630     MOV #0x63, W0
002360  544F80     SUB.B W8, W0, [W15]
002362  360007     BRA LEU, 0x2372
268:                   {
269:                       UART2PutChar( res/100 + '0' );
002364  FB8008     ZE W8, W0
002366  200642     MOV #0x64, W2
002368  090011     REPEAT #0x11
00236A  D88002     DIV.UW W0, W2
00236C  B04300     ADD.B #0x30, W0
00236E  07FFE4     RCALL UART2PutChar
002370  B3C014     MOV #0x1, W4
270:                       printed_already = 1;
271:                   }
272:                   res = res - (res/100)*100;
002372  FB8008     ZE W8, W0
002374  200642     MOV #0x64, W2
002376  090011     REPEAT #0x11
002378  D88002     DIV.UW W0, W2
00237A  B98002     MUL.SS W0, W2, W0
00237C  544400     SUB.B W8, W0, W8
273:               
274:                   if ((res/10) || (printed_already == 1))
00237E  544FE9     SUB.B W8, #0x9, [W15]
002380  3E0002     BRA GTU, 0x2386
002382  524FE1     SUB.B W4, #0x1, [W15]
002384  3A0006     BRA NZ, 0x2392
275:                   {
276:                       UART2PutChar( res/10 + '0' );
002386  FB8008     ZE W8, W0
002388  2000A2     MOV #0xA, W2
00238A  090011     REPEAT #0x11
00238C  D88002     DIV.UW W0, W2
00238E  B04300     ADD.B #0x30, W0
002390  07FFD3     RCALL UART2PutChar
277:                   }
278:                   res = res - (res/10)*10;
279:               
280:                   UART2PutChar( res + '0' );
002392  FB8008     ZE W8, W0
002394  2000A2     MOV #0xA, W2
002396  090011     REPEAT #0x11
002398  D88002     DIV.UW W0, W2
00239A  FD0080     EXCH W0, W1
00239C  B9086A     MUL.SU W1, #10, W0
00239E  544000     SUB.B W8, W0, W0
0023A0  B04300     ADD.B #0x30, W0
0023A2  07FFCA     RCALL UART2PutChar
281:               }
0023A8  BE9F88     MOV.D W8, [W15++]
0023AA  780480     MOV W0, W9
282:               
283:               /*******************************************************************************
284:               Function: UART2PutHex
285:               
286:               Precondition:
287:                   UART2Init must be called prior to calling this routine.
288:               
289:               Overview:
290:                   This function converts hex data into a string and outputs it to UART.
291:               
292:               Input: Binary data.
293:               
294:               Output: None.
295:               
296:               *******************************************************************************/
297:               
298:               const unsigned char CharacterArray[]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
299:               
300:               void UART2PutHex( int toPrint )
301:               {
302:                   int printVar;
303:               
304:                   printVar = toPrint;
305:                   toPrint = (toPrint>>4) & 0x0F;
306:                   UART2PutChar( CharacterArray[toPrint] );
0023AC  DE8044     ASR W0, #4, W0
0023AE  60006F     AND W0, #0xF, W0
0023B0  21F008     MOV #0x1F00, W8
0023B2  784068     MOV.B [W8+W0], W0
0023B4  07FFC1     RCALL UART2PutChar
307:               
308:                   toPrint = printVar & 0x0F;
309:                   UART2PutChar( CharacterArray[toPrint] );
0023B6  64806F     AND W9, #0xF, W0
0023B8  784068     MOV.B [W8+W0], W0
0023BA  07FFBE     RCALL UART2PutChar
310:               
311:                   return;
312:               }
0023C0  BE9F88     MOV.D W8, [W15++]
0023C2  780480     MOV W0, W9
313:               
314:               /*******************************************************************************
315:               Function: UART2PutHexWord(unsigned int toPrint)
316:               
317:               Precondition:
318:                   UART2Init must be called prior to calling this routine.
319:               
320:               Overview:
321:                   This function converts hex data into a string and outputs it to UART.
322:               
323:               Input: Binary data.
324:               
325:               Output: None.
326:               
327:               *******************************************************************************/
328:               #if defined( __C30__ ) || defined( __PIC32MX__ )
329:               void UART2PutHexWord( unsigned int toPrint )
330:               {
331:                   unsigned int printVar;
332:               
333:                   printVar = (toPrint>>12) & 0x0F;
334:                   UART2PutChar( CharacterArray[printVar] );
0023C4  DE004C     LSR W0, #12, W0
0023C6  21F008     MOV #0x1F00, W8
0023C8  784068     MOV.B [W8+W0], W0
0023CA  07FFB6     RCALL UART2PutChar
335:               
336:                   printVar = (toPrint>>8) & 0x0F;
337:                   UART2PutChar( CharacterArray[printVar] );
0023CC  DE4848     LSR W9, #8, W0
0023CE  60006F     AND W0, #0xF, W0
0023D0  784068     MOV.B [W8+W0], W0
0023D2  07FFB2     RCALL UART2PutChar
338:               
339:                   printVar = (toPrint>>4) & 0x0F;
340:                   UART2PutChar( CharacterArray[printVar] );
0023D4  DE4844     LSR W9, #4, W0
0023D6  60006F     AND W0, #0xF, W0
0023D8  784068     MOV.B [W8+W0], W0
0023DA  07FFAE     RCALL UART2PutChar
341:               
342:                   printVar = toPrint & 0x0F;
343:                   UART2PutChar( CharacterArray[printVar] );
0023DC  64806F     AND W9, #0xF, W0
0023DE  784068     MOV.B [W8+W0], W0
0023E0  07FFAB     RCALL UART2PutChar
344:               
345:                   return;
346:               }
0023E6  BE9F88     MOV.D W8, [W15++]
0023E8  781F8A     MOV W10, [W15++]
0023EA  BE0400     MOV.D W0, W8
347:               
348:               void UART2PutHexDWord( unsigned long toPrint )
349:               {
350:                   unsigned long printVar;
351:               
352:                   printVar = (toPrint>>28) & 0x0F;
353:                   UART2PutChar( CharacterArray[printVar] );
0023EC  DE084C     LSR W1, #12, W0
0023EE  60006F     AND W0, #0xF, W0
0023F0  21F00A     MOV #0x1F00, W10
0023F2  78406A     MOV.B [W10+W0], W0
0023F4  07FFA1     RCALL UART2PutChar
354:               
355:                   printVar = (toPrint>>24) & 0x0F;
356:                   UART2PutChar( CharacterArray[printVar] );
0023F6  DE4848     LSR W9, #8, W0
0023F8  200001     MOV #0x0, W1
0023FA  60006F     AND W0, #0xF, W0
0023FC  78406A     MOV.B [W10+W0], W0
0023FE  07FF9C     RCALL UART2PutChar
357:               
358:                   printVar = (toPrint>>20) & 0x0F;
359:                   UART2PutChar( CharacterArray[printVar] );
002400  DE4844     LSR W9, #4, W0
002402  200001     MOV #0x0, W1
002404  60006F     AND W0, #0xF, W0
002406  78406A     MOV.B [W10+W0], W0
002408  07FF97     RCALL UART2PutChar
360:               
361:                   printVar = (toPrint>>16) & 0x0F;
362:                   UART2PutChar( CharacterArray[printVar] );
00240A  DE4840     LSR W9, #0, W0
00240C  200001     MOV #0x0, W1
00240E  60006F     AND W0, #0xF, W0
002410  78406A     MOV.B [W10+W0], W0
002412  07FF92     RCALL UART2PutChar
363:               
364:                   printVar = (toPrint>>12) & 0x0F;
365:                   UART2PutChar( CharacterArray[printVar] );
002414  DD4944     SL W9, #4, W2
002416  DE404C     LSR W8, #12, W0
002418  710000     IOR W2, W0, W0
00241A  DE48CC     LSR W9, #12, W1
00241C  60006F     AND W0, #0xF, W0
00241E  78406A     MOV.B [W10+W0], W0
002420  07FF8B     RCALL UART2PutChar
366:               
367:                   printVar = (toPrint>>8) & 0x0F;
368:                   UART2PutChar( CharacterArray[printVar] );
002422  DD4948     SL W9, #8, W2
002424  DE4048     LSR W8, #8, W0
002426  710000     IOR W2, W0, W0
002428  DE48C8     LSR W9, #8, W1
00242A  60006F     AND W0, #0xF, W0
00242C  78406A     MOV.B [W10+W0], W0
00242E  07FF84     RCALL UART2PutChar
369:               
370:                   printVar = (toPrint>>4) & 0x0F;
371:                   UART2PutChar( CharacterArray[printVar] );
002430  DD494C     SL W9, #12, W2
002432  DE4044     LSR W8, #4, W0
002434  710000     IOR W2, W0, W0
002436  DE48C4     LSR W9, #4, W1
002438  60006F     AND W0, #0xF, W0
00243A  78406A     MOV.B [W10+W0], W0
00243C  07FF7D     RCALL UART2PutChar
372:               
373:                   printVar = toPrint & 0x0F;
374:                   UART2PutChar( CharacterArray[printVar] );
00243E  64046F     AND W8, #0xF, W8
002440  7C406A     MOV.B [W10+W8], W0
002442  07FF7A     RCALL UART2PutChar
375:               
376:                   return;
377:               }
00244A  784080     MOV.B W0, W1
378:               
379:               #endif
380:               
381:               /*********************************************************************
382:               Function: char UART2Char2Hex(char ch)
383:               
384:               PreCondition: none
385:               
386:               Input: ASCII to be converted
387:               
388:               Output: number
389:               
390:               Side Effects: none
391:               
392:               Overview: converts ASCII coded digit into number
393:               
394:               Note: none
395:               
396:               ********************************************************************/
397:               char UART2Char2Hex(char ch){
398:                 // Wrong char
399:                 if(ch > 102)
00244C  B3C660     MOV #0x66, W0
00244E  50CF80     SUB.B W1, W0, [W15]
002450  3C0017     BRA GT, 0x2480
400:                   return 0;  
401:                 
402:                 // From a to f     
403:                 if(ch > 96)
002452  504066     SUB.B W0, #0x6, W0
002454  50CF80     SUB.B W1, W0, [W15]
002456  340002     BRA LE, 0x245C
404:                   return (ch-87);
002458  B3CA90     MOV #0xA9, W0
00245A  37000F     BRA 0x247A
405:                   
406:                 // Wrong char    
407:                 if(ch > 70)
00245C  B3C460     MOV #0x46, W0
00245E  50CF80     SUB.B W1, W0, [W15]
002460  3C000F     BRA GT, 0x2480
408:                   return 0;
409:                 
410:                 // From A to F    
411:                 if(ch > 64)
002462  504066     SUB.B W0, #0x6, W0
002464  50CF80     SUB.B W1, W0, [W15]
002466  340002     BRA LE, 0x246C
412:                   return (ch-55);
002468  B3CC90     MOV #0xC9, W0
00246A  370007     BRA 0x247A
413:               
414:                 // Wrong char  
415:                 if(ch > 57)
00246C  B3C390     MOV #0x39, W0
00246E  50CF80     SUB.B W1, W0, [W15]
002470  3C0007     BRA GT, 0x2480
416:                   return 0;
417:                 
418:                 // From 0 - 9
419:                 if(ch > 47)
002472  50406A     SUB.B W0, #0xA, W0
002474  50CF80     SUB.B W1, W0, [W15]
002476  340004     BRA LE, 0x2480
420:                   return(ch-48);
421:                 else
422:                 // Wrong char
423:                   return 0;
424:               }
425:               
426:               /*********************************************************************
427:               Function: char UART2Hex2Char(char hex)
428:               
429:               PreCondition: none
430:               
431:               Input: number
432:               
433:               Output: ASCII code
434:               
435:               Side Effects: none
436:               
437:               Overview: converts low nibble into ASCII coded digit
438:               
439:               Note: none
440:               
441:               ********************************************************************/
442:               char UART2Hex2Char(char hex){
443:               char h;
444:                 h = hex&0x0f;
002482  60406F     AND.B W0, #0xF, W0
445:                 // From 0xa to 0xf
446:                 if(h>9)
002484  504FE9     SUB.B W0, #0x9, [W15]
002486  340003     BRA LE, 0x248E
447:                   return (h+55);
002488  B04370     ADD.B #0x37, W0
00248A  FB0000     SE W0, W0
00248C  060000     RETURN
448:                 else
449:                   return (h+48);
00248E  B04300     ADD.B #0x30, W0
002490  FB0000     SE W0, W0
450:               }
451:               
452:               /*********************************************************************
453:               Function: void UART2ClrError(void)
454:               
455:               PreCondition: none
456:               
457:               Input: none
458:               
459:               Output: character received
460:               
461:               Side Effects: none
462:               
463:               Overview: wait for character
464:               
465:               Note: none
466:               
467:               ********************************************************************/
468:               void UART2ClrError(void){
469:                   // Clear error flag
470:                   if(U2STAbits.OERR)
002494  BFC232     MOV.B U2STA, WREG
002496  A31800     BTST.Z W0, #1
002498  320001     BRA Z, 0x249C
471:               		U2STAbits.OERR = 0;
472:               }
473:               
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libusb/usb_host_android.c  
002F6C  FA0006     LNK #0x6
002F6E  BE9F88     MOV.D W8, [W15++]
003030  784380     MOV.B W0, W7
00345E  781F88     MOV W8, [W15++]
003460  780300     MOV W0, W6
00353A  BE9F88     MOV.D W8, [W15++]
00353C  781F8A     MOV W10, [W15++]
00353E  784500     MOV.B W0, W10
003540  780484     MOV W4, W9
003570  781F88     MOV W8, [W15++]
003572  780300     MOV W0, W6
00376C  780181     MOV W1, W3
00380C  780200     MOV W0, W4
003846  780200     MOV W0, W4
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include <stdlib.h>
31:                #include <string.h>
32:                #include <assert.h>
33:                #include "GenericTypeDefs.h"
34:                #include "USB/usb.h"
35:                #include "usb_host_android.h"
36:                
37:                #include "logging.h"
38:                
39:                #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
40:                
41:                ANDROID_DEVICE gc_DevData;
42:                
43:                BOOL USBHostAndroidInitInterface(BYTE address,
44:                                                 DWORD iid,
45:                                                 BYTE clientDriverID,
46:                                                 USB_DEVICE_INFO *pDevInfo,
47:                                                 USB_INTERFACE_INFO *pIntInfo) {
48:                  USB_DEVICE_DESCRIPTOR *pDev = (USB_DEVICE_DESCRIPTOR *) USBHostGetDeviceDescriptor(address);
003032  80FA76     MOV pDeviceDescriptor, W6
49:                  USB_ENDPOINT_INFO *pFirstEpInfo;
50:                  USB_ENDPOINT_INFO *pSecondEpInfo;
51:                  ANDROID_INTERFACE *pInterface;
52:                  log_printf("USBHostAndroidInitInterface(0x%x, 0x%lx, 0x%x)", address, iid, clientDriverID);
53:                  assert(iid < ANDROID_INTERFACE_MAX);
54:                
55:                  pInterface = &gc_DevData.interfaces[iid];
003034  B9116A     MUL.SU W2, #10, W2
003036  21C000     MOV #0x1C00, W0
003038  400182     ADD W0, W2, W3
56:                  pFirstEpInfo = pIntInfo->pCurrentSetting->pEndpointList;
00303A  900025     MOV [W5+4], W0
00303C  900120     MOV [W0+4], W2
57:                  if (!pFirstEpInfo) { log_printf("No end-points"); return FALSE; }
00303E  E00002     CP0 W2
003040  320026     BRA Z, 0x308E
58:                  pSecondEpInfo = pFirstEpInfo->next;
003042  780092     MOV [W2], W1
59:                  if (!pSecondEpInfo) { log_printf("Only one end-point"); return FALSE; }
003044  E00001     CP0 W1
003046  320023     BRA Z, 0x308E
60:                  if (pSecondEpInfo->next) { log_printf("Too many end-points"); return FALSE; }
003048  E00011     CP0 [W1]
00304A  3A0021     BRA NZ, 0x308E
00304C  905821     MOV.B [W1+26], W0
61:                
62:                  if (pFirstEpInfo->bEndpointAddress & 0x80) {
00304E  905A22     MOV.B [W2+26], W4
003050  E00404     CP0.B W4
003052  3D0006     BRA GE, 0x3060
63:                      if (pSecondEpInfo->bEndpointAddress & 0x80) {
003054  E00400     CP0.B W0
003056  35001B     BRA LT, 0x308E
64:                        log_printf("Need one input and one output end-point");
65:                        return FALSE;
66:                      }
67:                      pInterface->inEndpoint = pFirstEpInfo->bEndpointAddress;
003058  9841C4     MOV.B W4, [W3+4]
68:                      pInterface->outEndpoint = pSecondEpInfo->bEndpointAddress;
00305A  9058A1     MOV.B [W1+26], W1
00305C  9841D1     MOV.B W1, [W3+5]
00305E  370005     BRA 0x306A
69:                  } else {
70:                      if (!(pSecondEpInfo->bEndpointAddress & 0x80)) {
003060  E00400     CP0.B W0
003062  3D0015     BRA GE, 0x308E
71:                        log_printf("Need one input and one output end-point");
72:                        return FALSE;
73:                      }
74:                      pInterface->inEndpoint = pSecondEpInfo->bEndpointAddress;
003064  9841C0     MOV.B W0, [W3+4]
75:                      pInterface->outEndpoint = pFirstEpInfo->bEndpointAddress;
003066  905922     MOV.B [W2+26], W2
003068  9841D2     MOV.B W2, [W3+5]
76:                  }
77:                  pInterface->flags.initialized = 1;
00306A  900043     MOV [W3+8], W0
00306C  A00000     BSET W0, #0
00306E  9801C0     MOV W0, [W3+8]
78:                  log_printf("Successfully initialized Android inteface %ld. IN_EP=0x%x OUT_EP=0x%x",
79:                             iid, pInterface->inEndpoint, pInterface->outEndpoint);
80:                
81:                  // Save device the address, VID, & PID
82:                  gc_DevData.ID.deviceAddress = address;
003070  21BFE0     MOV #0x1BFE, W0
003072  784807     MOV.B W7, [W0]
83:                  gc_DevData.ID.vid  =  pDev->idVendor;
003074  904886     MOV.B [W6+8], W1
003076  FB8081     ZE W1, W1
003078  904816     MOV.B [W6+9], W0
00307A  DD0048     SL W0, #8, W0
00307C  700001     IOR W0, W1, W0
00307E  88DFD0     MOV W0, gc_DevData
84:                  gc_DevData.ID.pid  =  pDev->idProduct;
003080  9048A6     MOV.B [W6+10], W1
003082  FB8081     ZE W1, W1
003084  904836     MOV.B [W6+11], W0
003086  DD0048     SL W0, #8, W0
003088  700001     IOR W0, W1, W0
00308A  88DFE0     MOV W0, 0x1BFC
00308C  050010     RETLW #0x1, W0
85:                
86:                  return TRUE;
87:                }
88:                
89:                BOOL USBHostAndroidInitDevice(BYTE address,
90:                                              DWORD iid,
91:                                              BYTE clientDriverID,
92:                                              USB_DEVICE_INFO *pDevInfo,
93:                                              USB_INTERFACE_INFO *pIntInfo) {
94:                  log_printf("USBHostAndroidInitDevice(0x%x, 0x%lx, 0x%x)", address, iid, clientDriverID);
95:                
96:                  // Initialize state
97:                  memset(&gc_DevData, 0, sizeof gc_DevData);
003542  2001A2     MOV #0x1A, W2
003544  EB0080     CLR W1
003546  21BFA0     MOV #0x1BFA, W0
003548  020516     CALL memset
00354A  000000     NOP
98:                  
99:                  for (pIntInfo = pDevInfo->pInterfaceList; pIntInfo; pIntInfo = pIntInfo->next) {
00354C  900479     MOV [W9+14], W8
00354E  37000A     BRA 0x3564
003562  780418     MOV [W8], W8
003564  E00008     CP0 W8
003566  3AFFF4     BRA NZ, 0x3550
100:                   log_printf("Encoutered interface %d, class 0x%x, subclass 0x%x, protocol, 0x%x",
101:                       pIntInfo->interface, pIntInfo->type.cls, pIntInfo->type.subcls, pIntInfo->type.proto);
102:                   // initialize according to the interface number
103:                   USBHostAndroidInitInterface(address, pIntInfo->interface, 0, pDevInfo, pIntInfo);
003550  904168     MOV.B [W8+6], W2
003552  FB8102     ZE W2, W2
003554  200003     MOV #0x0, W3
003556  780288     MOV W8, W5
003558  780209     MOV W9, W4
00355A  EB4080     CLR.B W1
00355C  78400A     MOV.B W10, W0
00355E  023030     CALL USBHostAndroidInitInterface
003560  000000     NOP
104:                 }
105:               
106:                 log_printf("Android device initalized: address=%d VID=0x%x PID=0x%x",
107:                            address, gc_DevData.ID.vid, gc_DevData.ID.pid);
108:                 
109:                 return TRUE;
110:               } //  USBHostAndroidInit
111:                 
112:               
113:               BOOL USBHostAndroidEventHandler(BYTE address, USB_EVENT event, void *data, DWORD size) {
114:                 // Make sure it was for our device
115:                 if (address != gc_DevData.ID.deviceAddress) return FALSE;
00376E  EB0100     CLR W2
003770  21BFE1     MOV #0x1BFE, W1
003772  504F91     SUB.B W0, [W1], [W15]
003774  3A000A     BRA NZ, 0x378A
116:               
117:                 // Handle specific events.
118:                 switch (event) {
003776  200012     MOV #0x1, W2
003778  200710     MOV #0x71, W0
00377A  518F80     SUB W3, W0, [W15]
00377C  3A0006     BRA NZ, 0x378A
119:                  case EVENT_DETACH:
120:                   memset(&gc_DevData, 0, sizeof gc_DevData);
00377E  2001A2     MOV #0x1A, W2
003780  EB0080     CLR W1
003782  21BFA0     MOV #0x1BFA, W0
003784  020516     CALL memset
003786  000000     NOP
003788  EB0100     CLR W2
121:               
122:                   log_printf("Android Client Device Detached: address=0x%x", address);
123:                   break;
124:               
125:               #ifdef USB_ENABLE_TRANSFER_EVENT
126:                  case EVENT_BUS_ERROR:
127:                  case EVENT_TRANSFER:
128:                   if ((data != NULL) && (size == sizeof(HOST_TRANSFER_DATA))) {
129:                     int i;
130:                     DWORD dataCount = ((HOST_TRANSFER_DATA *)data)->dataCount;
131:               
132:                     for (i = 0; i < ANDROID_INTERFACE_MAX; ++i) {
133:                       ANDROID_INTERFACE *pInterface = &gc_DevData.interfaces[i];
134:                       if (((HOST_TRANSFER_DATA *)data)->bEndpointAddress == pInterface->inEndpoint) {
135:                         pInterface->flags.rxBusy = 0;
136:                         pInterface->rxLength = dataCount;
137:                         pInterface->rxErrorCode = ((HOST_TRANSFER_DATA *)data)->bErrorCode;
138:                         log_printf("Received message with %ld bytes: ", ((HOST_TRANSFER_DATA *)data)->dataCount);
139:                         log_print_buf(((HOST_TRANSFER_DATA *)data)->pUserData, ((HOST_TRANSFER_DATA *)data)->dataCount);
140:                         return TRUE;
141:                       }
142:                       if (((HOST_TRANSFER_DATA *)data)->bEndpointAddress == pInterface->outEndpoint) {
143:                         pInterface->flags.txBusy = 0;
144:                         pInterface->txErrorCode = ((HOST_TRANSFER_DATA *)data)->bErrorCode;
145:                         return TRUE;
146:                       }
147:                     }
148:                   }
149:                   return FALSE;
150:               #endif
151:               
152:                  case EVENT_SUSPEND:
153:                  case EVENT_RESUME:
154:                  default:
155:                   return TRUE;
156:                 }
157:                 return FALSE;
158:               }  // USBHostAndroidEventHandler
159:               
160:               
161:               //void USBHostAndroidGetDeviceId(USB_DEVICE_ID *pDevID) {
162:               //  assert(pDevID != NULL);
163:               //  *pDevID = gc_DevData.ID;
164:               //}  // USBHostAndroidGetDeviceId
165:               
166:               
167:               void USBHostAndroidReset() {
168:                 assert(gc_DevData.ID.deviceAddress != 0);
169:                 USBHostResetDevice(gc_DevData.ID.deviceAddress);
0038A6  21BFE0     MOV #0x1BFE, W0
0038A8  784010     MOV.B [W0], W0
0038AA  02382A     CALL USBHostResetDevice
0038AC  000000     NOP
170:                 memset(&gc_DevData, 0, sizeof gc_DevData);
0038AE  2001A2     MOV #0x1A, W2
0038B0  EB0080     CLR W1
0038B2  21BFA0     MOV #0x1BFA, W0
0038B4  040516     GOTO memset
0038B6  000000     NOP
171:               }
172:               
173:               BYTE USBHostAndroidRead(void *buffer, DWORD length, ANDROID_INTERFACE_ID iid) {
174:                 BYTE RetVal;
175:                 ANDROID_INTERFACE *pInterface = &gc_DevData.interfaces[iid];
003462  B90A6A     MUL.SU W1, #10, W4
003464  21C000     MOV #0x1C00, W0
003466  400404     ADD W0, W4, W8
176:               
177:                 // Validate the call
178:                 assert(pInterface->flags.initialized);
179:                 if (pInterface->flags.rxBusy) return USB_BUSY;
003468  9000C8     MOV [W8+8], W1
00346A  200020     MOV #0x2, W0
00346C  A32801     BTST.Z W1, #2
00346E  3A0012     BRA NZ, 0x3494
180:               
181:                 log_printf("Requested read of %u bytes", (unsigned) length);
182:               
183:                 // Set the busy flag, clear the count and start a new IN transfer.
184:                 pInterface->flags.rxBusy = 1;
003470  A02001     BSET W1, #2
003472  980441     MOV W1, [W8+8]
185:                 pInterface->rxLength = 0;
003474  EB0C00     CLR [W8]
003476  781438     MOV [W8++], [W8--]
186:                 RetVal = USBHostRead(gc_DevData.ID.deviceAddress, pInterface->inEndpoint, (BYTE *)buffer, length);
003478  9040C8     MOV.B [W8+4], W1
00347A  BE0202     MOV.D W2, W4
00347C  780106     MOV W6, W2
00347E  21BFE0     MOV #0x1BFE, W0
003480  784010     MOV.B [W0], W0
003482  022E98     CALL USBHostRead
003484  000000     NOP
003486  784080     MOV.B W0, W1
187:                 if (RetVal != USB_SUCCESS) {
003488  E00400     CP0.B W0
00348A  320003     BRA Z, 0x3492
188:                   pInterface->flags.rxBusy = 0;    // Clear flag to allow re-try
00348C  900048     MOV [W8+8], W0
00348E  A12000     BCLR W0, #2
003490  980440     MOV W0, [W8+8]
189:                 }
190:                 return RetVal;
003492  FB8001     ZE W1, W0
191:               }  // USBHostAndroidRead
192:               
193:               BOOL USBHostAndroidRxIsComplete(BYTE *errorCode, DWORD *byteCount, ANDROID_INTERFACE_ID iid) {
194:                 ANDROID_INTERFACE *pInterface = &gc_DevData.interfaces[iid];
00380E  B9116A     MUL.SU W2, #10, W2
003810  21C000     MOV #0x1C00, W0
003812  400102     ADD W0, W2, W2
195:               
196:                 if (pInterface->flags.rxBusy) {
003814  900042     MOV [W2+8], W0
003816  EB0180     CLR W3
003818  A32800     BTST.Z W0, #2
00381A  3A0005     BRA NZ, 0x3826
197:                   return FALSE;
198:                 } else {
199:                   *byteCount = pInterface->rxLength;
00381C  BE0312     MOV.D [W2], W6
00381E  BE8886     MOV.D W6, [W1]
200:                   *errorCode = pInterface->rxErrorCode;
003820  904162     MOV.B [W2+6], W2
003822  784A02     MOV.B W2, [W4]
003824  200013     MOV #0x1, W3
201:                   return TRUE;
202:                 }
203:               }  // USBHostAndroidRxIsComplete
204:               
205:               #ifndef USB_ENABLE_TRANSFER_EVENT
206:               void USBHostAndroidTasks(void) {
002F70  21C088     MOV #0x1C08, W8
002F72  780488     MOV W8, W9
207:                 DWORD   byteCount;
208:                 BYTE    errorCode;
209:                 int iid;
210:               
211:                 for (iid = 0; iid < ANDROID_INTERFACE_MAX; ++iid) {
002FC4  21C1C0     MOV #0x1C1C, W0
002FC6  540F80     SUB W8, W0, [W15]
002FC8  3AFFD5     BRA NZ, 0x2F74
212:                   ANDROID_INTERFACE *pInterface = &gc_DevData.interfaces[iid];
213:               
214:                   if (gc_DevData.ID.deviceAddress && pInterface->flags.initialized) {
002F74  21BFE0     MOV #0x1BFE, W0
002F76  784010     MOV.B [W0], W0
002F78  E00400     CP0.B W0
002F7A  320022     BRA Z, 0x2FC0
002F7C  780098     MOV [W8], W1
002F7E  A30801     BTST.Z W1, #0
002F80  32001F     BRA Z, 0x2FC0
215:                     if (pInterface->flags.rxBusy) {
002F82  A32801     BTST.Z W1, #2
002F84  32000E     BRA Z, 0x2FA2
216:                       if (USBHostTransferIsComplete(gc_DevData.ID.deviceAddress, pInterface->inEndpoint, &errorCode, &byteCount)) {
002F86  97F8C8     MOV.B [W8-4], W1
002F88  5781E8     SUB W15, #0x8, W3
002F8A  57816A     SUB W15, #0xA, W2
002F8C  022FD0     CALL USBHostTransferIsComplete
002F8E  000000     NOP
002F90  E00000     CP0 W0
002F92  320007     BRA Z, 0x2FA2
217:                         pInterface->flags.rxBusy = 0;
002F94  A12019     BCLR [W9], #2
218:                         pInterface->rxLength     = byteCount;
002F96  97B84F     MOV [W15-8], W0
002F98  97B8DF     MOV [W15-6], W1
002F9A  9FBC40     MOV W0, [W8-8]
002F9C  9FBC51     MOV W1, [W8-6]
219:                         pInterface->rxErrorCode  = errorCode;
002F9E  97F0EF     MOV.B [W15-10], W1
002FA0  9FFC61     MOV.B W1, [W8-2]
220:                         log_printf("Received message with %ld bytes on endpoint 0x%x", byteCount, pInterface->inEndpoint);
221:                       }
222:                     }
223:               
224:                     if (pInterface->flags.txBusy) {
002FA2  780098     MOV [W8], W1
002FA4  608062     AND W1, #0x2, W0
002FA6  32000C     BRA Z, 0x2FC0
225:                       if (USBHostTransferIsComplete(gc_DevData.ID.deviceAddress, pInterface->outEndpoint, &errorCode, &byteCount)) {
002FA8  97F8D8     MOV.B [W8-3], W1
002FAA  5781E8     SUB W15, #0x8, W3
002FAC  57816A     SUB W15, #0xA, W2
002FAE  21BFE0     MOV #0x1BFE, W0
002FB0  784010     MOV.B [W0], W0
002FB2  022FD0     CALL USBHostTransferIsComplete
002FB4  000000     NOP
002FB6  E00000     CP0 W0
002FB8  320003     BRA Z, 0x2FC0
226:                         pInterface->flags.txBusy = 0;
002FBA  A11019     BCLR [W9], #1
227:                         pInterface->txErrorCode  = errorCode;
002FBC  97F06F     MOV.B [W15-10], W0
002FBE  9FFC70     MOV.B W0, [W8-1]
002FC0  4484EA     ADD W9, #0xA, W9
002FC2  44046A     ADD W8, #0xA, W8
228:                       }
229:                     }
230:                   }
231:                 }
232:               }  // USBHostAndroidTasks
233:               #endif  // USB_ENABLE_TRANSFER_EVENT
234:               
235:               BOOL USBHostAndroidTxIsComplete(BYTE *errorCode, ANDROID_INTERFACE_ID iid) {
236:                 ANDROID_INTERFACE *pInterface = &gc_DevData.interfaces[iid];
003848  B9096A     MUL.SU W1, #10, W2
00384A  21C000     MOV #0x1C00, W0
00384C  400082     ADD W0, W2, W1
237:               
238:                 if ( pInterface->flags.txBusy) {
00384E  900041     MOV [W1+8], W0
003850  EB0100     CLR W2
003852  A31800     BTST.Z W0, #1
003854  3A0003     BRA NZ, 0x385C
239:                   return FALSE;
240:                 } else {
241:                   *errorCode =  pInterface->txErrorCode;
003856  9040F1     MOV.B [W1+7], W1
003858  784A01     MOV.B W1, [W4]
00385A  200012     MOV #0x1, W2
242:                   return TRUE;
243:                 }
244:               }  // USBHostAndroidTxIsComplete
245:               
246:               
247:               BYTE USBHostAndroidWrite(const void *buffer, DWORD length, ANDROID_INTERFACE_ID iid) {
248:                 BYTE RetVal;
249:                 ANDROID_INTERFACE *pInterface = &gc_DevData.interfaces[iid];
003574  B90A6A     MUL.SU W1, #10, W4
003576  21C000     MOV #0x1C00, W0
003578  400404     ADD W0, W4, W8
250:               
251:                 // Validate the call
252:                 assert(pInterface->flags.initialized);
253:                 if (pInterface->flags.txBusy) return USB_BUSY;
00357A  9000C8     MOV [W8+8], W1
00357C  200020     MOV #0x2, W0
00357E  A31801     BTST.Z W1, #1
003580  3A0010     BRA NZ, 0x35A2
254:               
255:                 log_printf("Sending message with %u bytes to endpoint 0x%x: ",
256:                            (unsigned) length,
257:                            pInterface->outEndpoint);
258:                 log_print_buf(buffer, length);
259:               
260:                 // Set the busy flag and start a new OUT transfer.
261:                 pInterface->flags.txBusy = 1;
003582  A01001     BSET W1, #1
003584  980441     MOV W1, [W8+8]
262:                 RetVal = USBHostWrite(gc_DevData.ID.deviceAddress, pInterface->outEndpoint, (BYTE *)buffer, length);
003586  9040D8     MOV.B [W8+5], W1
003588  BE0202     MOV.D W2, W4
00358A  780106     MOV W6, W2
00358C  21BFE0     MOV #0x1BFE, W0
00358E  784010     MOV.B [W0], W0
003590  022F02     CALL USBHostWrite
003592  000000     NOP
003594  784080     MOV.B W0, W1
263:                 if (RetVal != USB_SUCCESS) {
003596  E00400     CP0.B W0
003598  320003     BRA Z, 0x35A0
264:                   pInterface->flags.txBusy = 0;    // Clear flag to allow re-try
00359A  900048     MOV [W8+8], W0
00359C  A11000     BCLR W0, #1
00359E  980440     MOV W0, [W8+8]
265:                 }
266:                 return RetVal;
0035A0  FB8001     ZE W1, W0
267:               }  // USBHostAndroidWrite
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libadb/adb_packet.c  -----
002714  FA0006     LNK #0x6
002716  781F88     MOV W8, [W15++]
00332C  FA0000     LNK #0x0
00332E  BE9F88     MOV.D W8, [W15++]
003330  781F8A     MOV W10, [W15++]
003332  BE0400     MOV.D W0, W8
003334  BE0002     MOV.D W2, W0
003336  780506     MOV W6, W10
003338  97B90F     MOV [W15-16], W2
00333A  97B99F     MOV [W15-14], W3
0035DA  BE9F88     MOV.D W8, [W15++]
0035DC  780300     MOV W0, W6
003726  781F88     MOV W8, [W15++]
003728  780400     MOV W0, W8
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include <assert.h>
31:                
32:                #include "adb_packet.h"
33:                #include "usb_host_android.h"
34:                #include "logging.h"
35:                
36:                #define CHANGE_STATE(var,state)              \
37:                do {                                         \
38:                  log_printf("%s set to %s", #var, #state);  \
39:                  var = state;                               \
40:                } while (0)
41:                
42:                ////////////////////////////////////////////////////////////////////////////////
43:                // Types
44:                ////////////////////////////////////////////////////////////////////////////////
45:                
46:                typedef struct {
47:                  UINT32 command;       /* command identifier constant      */
48:                  UINT32 arg0;          /* first argument                   */
49:                  UINT32 arg1;          /* second argument                  */
50:                  UINT32 data_length;   /* length of payload (0 is allowed) */
51:                  UINT32 data_check;    /* checksum of data payload         */
52:                  UINT32 magic;         /* command ^ 0xffffffff             */
53:                } ADB_PACKET_HEADER;
54:                
55:                typedef enum {
56:                  ADB_PACKET_STATE_START,
57:                  ADB_PACKET_STATE_WAIT_HEADER,
58:                  ADB_PACKET_STATE_WAIT_DATA,
59:                  ADB_PACKET_STATE_IDLE,
60:                  ADB_PACKET_STATE_ERROR
61:                } ADB_PACKET_STATE;
62:                
63:                ////////////////////////////////////////////////////////////////////////////////
64:                // Globals
65:                ////////////////////////////////////////////////////////////////////////////////
66:                
67:                static ADB_PACKET_HEADER adb_packet_send_header;
68:                static ADB_PACKET_HEADER adb_packet_recv_header;
69:                static ADB_PACKET_STATE adb_packet_send_state;
70:                static ADB_PACKET_STATE adb_packet_recv_state;
71:                static const BYTE* adb_packet_send_data;
72:                static BYTE adb_packet_recv_data[ADB_PACKET_MAX_RECV_DATA_BYTES];
73:                
74:                ////////////////////////////////////////////////////////////////////////////////
75:                // Functions & Macros
76:                ////////////////////////////////////////////////////////////////////////////////
77:                
78:                #define ADB_PACKET_STATE_BUSY(state) ((state) < ADB_PACKET_STATE_IDLE)
79:                
80:                static UINT32 ADBChecksum(const BYTE* data, UINT32 len) {
00372A  B83360     MUL.UU W6, #0, W6
00372C  BE0206     MOV.D W6, W4
00372E  370007     BRA 0x373E
81:                  UINT32 sum = 0;
82:                  UINT32 i;
83:                  for (i = 0; i < len; ++i) {
00373A  420261     ADD W4, #0x1, W4
00373C  4A82E0     ADDC W5, #0x0, W5
00373E  520F82     SUB W4, W2, [W15]
003740  5A8F83     SUBB W5, W3, [W15]
003742  39FFF6     BRA NC, 0x3730
84:                    sum += *(data++);
003730  7A4068     MOV.B [W8+W4], W0
003732  FB8000     ZE W0, W0
003734  200001     MOV #0x0, W1
003736  400306     ADD W0, W6, W6
003738  488387     ADDC W1, W7, W7
85:                  }
86:                  return sum;
87:                }
88:                
89:                static void ADBPacketSendTasks() {
90:                  BYTE ret_val;
91:                  switch (adb_packet_send_state) {
002718  80C2A8     MOV adb_packet_send_state, W8
00271A  540FE1     SUB W8, #0x1, [W15]
00271C  32000E     BRA Z, 0x273A
00271E  390003     BRA NC, 0x2726
002720  540FE2     SUB W8, #0x2, [W15]
002722  3A002E     BRA NZ, 0x2780
002724  370020     BRA 0x2766
92:                   case ADB_PACKET_STATE_START:
93:                    if (USBHostAndroidWrite((BYTE*) &adb_packet_send_header,
002726  200011     MOV #0x1, W1
002728  200182     MOV #0x18, W2
00272A  200003     MOV #0x0, W3
00272C  2186E0     MOV #0x186E, W0
00272E  023570     CALL USBHostAndroidWrite
002730  000000     NOP
002732  E00400     CP0.B W0
002734  3A0021     BRA NZ, 0x2778
94:                                            sizeof(ADB_PACKET_HEADER),
95:                                            ANDROID_INTERFACE_ADB) != USB_SUCCESS) {
96:                      CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_ERROR);
97:                      break;
98:                    }
99:                    CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_WAIT_HEADER);
002736  200010     MOV #0x1, W0
002738  370022     BRA 0x277E
100:                   break;
101:               
102:                  case ADB_PACKET_STATE_WAIT_HEADER:
103:                   if (USBHostAndroidTxIsComplete(&ret_val, ANDROID_INTERFACE_ADB)) {
00273A  780088     MOV W8, W1
00273C  578068     SUB W15, #0x8, W0
00273E  023846     CALL USBHostAndroidTxIsComplete
002740  000000     NOP
002742  E00000     CP0 W0
002744  32001D     BRA Z, 0x2780
104:                     if (ret_val != USB_SUCCESS) {
002746  97F80F     MOV.B [W15-8], W0
002748  E00400     CP0.B W0
00274A  3A0016     BRA NZ, 0x2778
105:                       CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_ERROR);
106:                       break;
107:                     }
108:                     if (adb_packet_send_header.data_length == 0) {
00274C  80C3D2     MOV 0x187A, W2
00274E  80C3E3     MOV 0x187C, W3
002750  510FE0     SUB W2, #0x0, [W15]
002752  598FE0     SUBB W3, #0x0, [W15]
002754  320013     BRA Z, 0x277C
109:                       CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_IDLE);
110:                       break;
111:                     }
112:                     if (USBHostAndroidWrite(adb_packet_send_data,
002756  80C280     MOV adb_packet_send_data, W0
002758  780088     MOV W8, W1
00275A  023570     CALL USBHostAndroidWrite
00275C  000000     NOP
00275E  E00400     CP0.B W0
002760  3A000B     BRA NZ, 0x2778
113:                                             adb_packet_send_header.data_length,
114:                                             ANDROID_INTERFACE_ADB) != USB_SUCCESS) {
115:                       CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_ERROR);
116:                       break;
117:                     }
118:                     CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_WAIT_DATA);
002762  200020     MOV #0x2, W0
002764  37000C     BRA 0x277E
119:                   }
120:                   break;
121:               
122:                  case ADB_PACKET_STATE_WAIT_DATA:
123:                   if (USBHostAndroidTxIsComplete(&ret_val, ANDROID_INTERFACE_ADB)) {
002766  200011     MOV #0x1, W1
002768  578068     SUB W15, #0x8, W0
00276A  023846     CALL USBHostAndroidTxIsComplete
00276C  000000     NOP
00276E  E00000     CP0 W0
002770  320007     BRA Z, 0x2780
124:                     if (ret_val != USB_SUCCESS) {
002772  97F80F     MOV.B [W15-8], W0
002774  E00400     CP0.B W0
002776  320002     BRA Z, 0x277C
125:                       CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_ERROR);
002778  200040     MOV #0x4, W0
00277A  370001     BRA 0x277E
126:                       break;
127:                     }
128:                     CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_IDLE);
00277C  200030     MOV #0x3, W0
00277E  88C2A0     MOV W0, adb_packet_send_state
129:                   }
130:                   break;
131:               
132:                  case ADB_PACKET_STATE_IDLE:
133:                  case ADB_PACKET_STATE_ERROR:
134:                   break;
135:                 }
136:               }
137:               
138:               static void ADBPacketRecvTasks() {
139:                 BYTE ret_val;
140:                 DWORD bytes_received;
141:                 switch (adb_packet_recv_state) {
002780  80C298     MOV adb_packet_recv_state, W8
002782  540FE1     SUB W8, #0x1, [W15]
002784  32000E     BRA Z, 0x27A2
002786  390003     BRA NC, 0x278E
002788  540FE2     SUB W8, #0x2, [W15]
00278A  3A004E     BRA NZ, 0x2828
00278C  370032     BRA 0x27F2
142:                  case ADB_PACKET_STATE_START:
143:                   if (USBHostAndroidRead((BYTE*) &adb_packet_recv_header,
00278E  200011     MOV #0x1, W1
002790  200182     MOV #0x18, W2
002792  200003     MOV #0x0, W3
002794  218560     MOV #0x1856, W0
002796  02345E     CALL USBHostAndroidRead
002798  000000     NOP
00279A  E00400     CP0.B W0
00279C  3A0041     BRA NZ, 0x2820
144:                                          sizeof(ADB_PACKET_HEADER),
145:                                          ANDROID_INTERFACE_ADB) != USB_SUCCESS) {
146:                     CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_ERROR);
147:                     break;
148:                   }
149:                   CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_WAIT_HEADER);
00279E  200010     MOV #0x1, W0
0027A0  370042     BRA 0x2826
150:                   break;
151:               
152:                  case ADB_PACKET_STATE_WAIT_HEADER:
153:                   if (USBHostAndroidRxIsComplete(&ret_val, &bytes_received,
0027A2  780108     MOV W8, W2
0027A4  5780E6     SUB W15, #0x6, W1
0027A6  578068     SUB W15, #0x8, W0
0027A8  02380C     CALL USBHostAndroidRxIsComplete
0027AA  000000     NOP
0027AC  E00000     CP0 W0
0027AE  32003C     BRA Z, 0x2828
154:                                                  ANDROID_INTERFACE_ADB)) {
155:                     if (ret_val != USB_SUCCESS) {
0027B0  97F80F     MOV.B [W15-8], W0
0027B2  E00400     CP0.B W0
0027B4  3A0035     BRA NZ, 0x2820
156:                       CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_ERROR);
157:                       break;
158:                     }
159:               // TODO: probably not needed
160:               //      if (bytes_received == 0) {
161:               //        adb_packet_recv_header.command = 0;
162:               //        CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_IDLE);
163:               //        break;
164:               //      }
165:                     if (bytes_received != sizeof(ADB_PACKET_HEADER)
0027B6  97B85F     MOV [W15-6], W0
0027B8  97B8EF     MOV [W15-4], W1
0027BA  500FF8     SUB W0, #0x18, [W15]
0027BC  588FE0     SUBB W1, #0x0, [W15]
0027BE  3A0030     BRA NZ, 0x2820
0027C0  80C350     MOV 0x186A, W0
0027C2  80C361     MOV 0x186C, W1
0027C4  EA8000     COM W0, W0
0027C6  EA8081     COM W1, W1
0027C8  218562     MOV #0x1856, W2
0027CA  100FB2     SUBR W0, [W2++], [W15]
0027CC  188FA2     SUBBR W1, [W2--], [W15]
0027CE  3A0028     BRA NZ, 0x2820
0027D0  80C312     MOV 0x1862, W2
0027D2  80C323     MOV 0x1864, W3
0027D4  210000     MOV #0x1000, W0
0027D6  510F80     SUB W2, W0, [W15]
0027D8  598FE0     SUBB W3, #0x0, [W15]
0027DA  3E0022     BRA GTU, 0x2820
166:                         || adb_packet_recv_header.command != (~adb_packet_recv_header.magic)
167:                         || adb_packet_recv_header.data_length > ADB_PACKET_MAX_RECV_DATA_BYTES) {
168:                       CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_ERROR);
169:                       break;
170:                     }
171:                     if (adb_packet_recv_header.data_length == 0) {
0027DC  510FE0     SUB W2, #0x0, [W15]
0027DE  598FE0     SUBB W3, #0x0, [W15]
0027E0  320021     BRA Z, 0x2824
172:                       CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_IDLE);
173:                       break;
174:                     }
175:                     if (USBHostAndroidRead(adb_packet_recv_data,
0027E2  780088     MOV W8, W1
0027E4  208500     MOV #0x850, W0
0027E6  02345E     CALL USBHostAndroidRead
0027E8  000000     NOP
0027EA  E00400     CP0.B W0
0027EC  3A0019     BRA NZ, 0x2820
176:                                            adb_packet_recv_header.data_length,
177:                                            ANDROID_INTERFACE_ADB) != USB_SUCCESS) {
178:                       CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_ERROR);
179:                       break;
180:                     }
181:                     CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_WAIT_DATA);
0027EE  200020     MOV #0x2, W0
0027F0  37001A     BRA 0x2826
182:                   }
183:                   break;
184:               
185:                  case ADB_PACKET_STATE_WAIT_DATA:
186:                   if (USBHostAndroidRxIsComplete(&ret_val,
0027F2  200012     MOV #0x1, W2
0027F4  5780E6     SUB W15, #0x6, W1
0027F6  578068     SUB W15, #0x8, W0
0027F8  02380C     CALL USBHostAndroidRxIsComplete
0027FA  000000     NOP
0027FC  E00000     CP0 W0
0027FE  320014     BRA Z, 0x2828
187:                                                  &bytes_received,
188:                                                  ANDROID_INTERFACE_ADB)) {
189:                     if (ret_val != USB_SUCCESS || bytes_received != adb_packet_recv_header.data_length) {
002800  97F80F     MOV.B [W15-8], W0
002802  E00400     CP0.B W0
002804  3A000D     BRA NZ, 0x2820
002806  97B95F     MOV [W15-6], W2
002808  97B9EF     MOV [W15-4], W3
00280A  218620     MOV #0x1862, W0
00280C  510FB0     SUB W2, [W0++], [W15]
00280E  598FA0     SUBB W3, [W0--], [W15]
002810  3A0007     BRA NZ, 0x2820
190:                       CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_ERROR);
191:                       break;
192:                     }
193:               
194:                     if (ADBChecksum(adb_packet_recv_data, adb_packet_recv_header.data_length) != adb_packet_recv_header.data_check) {
002812  208500     MOV #0x850, W0
002814  023726     CALL ADBChecksum
002816  000000     NOP
002818  218662     MOV #0x1866, W2
00281A  500FB2     SUB W0, [W2++], [W15]
00281C  588FA2     SUBB W1, [W2--], [W15]
00281E  320002     BRA Z, 0x2824
195:                       CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_ERROR);
002820  200040     MOV #0x4, W0
002822  370001     BRA 0x2826
196:                       break;
197:                     }
198:               	    CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_IDLE);
002824  200030     MOV #0x3, W0
002826  88C290     MOV W0, adb_packet_recv_state
199:                   }
200:                   break;
201:                  case ADB_PACKET_STATE_IDLE:
202:                  case ADB_PACKET_STATE_ERROR:
203:                   break;
204:                 }
205:               }
206:               
207:               void ADBPacketSend(UINT32 cmd, UINT32 arg0, UINT32 arg1, const void* data, UINT32 data_len) {
208:                 assert(!ADB_PACKET_STATE_BUSY(adb_packet_send_state));
209:                 adb_packet_send_header.command = cmd;
00333C  88C378     MOV W8, adb_packet_send_header
00333E  88C389     MOV W9, 0x1870
210:                 adb_packet_send_header.arg0 = arg0;
003340  88C390     MOV W0, 0x1872
003342  88C3A1     MOV W1, 0x1874
211:                 adb_packet_send_header.arg1 = arg1;
003344  88C3B4     MOV W4, 0x1876
003346  88C3C5     MOV W5, 0x1878
212:                 adb_packet_send_header.data_length = data_len;
003348  88C3D2     MOV W2, 0x187A
00334A  88C3E3     MOV W3, 0x187C
213:                 adb_packet_send_header.data_check = ADBChecksum(data, data_len);
00334C  780006     MOV W6, W0
00334E  023726     CALL ADBChecksum
003350  000000     NOP
003352  88C3F0     MOV W0, 0x187E
003354  88C401     MOV W1, 0x1880
214:                 adb_packet_send_header.magic = ~cmd;
003356  EA8408     COM W8, W8
003358  EA8489     COM W9, W9
00335A  88C418     MOV W8, 0x1882
00335C  88C429     MOV W9, 0x1884
215:                 adb_packet_send_data = (const BYTE*) data;
00335E  88C28A     MOV W10, adb_packet_send_data
216:                 CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_START);
003360  EB0000     CLR W0
003362  88C2A0     MOV W0, adb_packet_send_state
217:               }
218:               
219:               ADB_RESULT ADBPacketSendStatus() {
220:                 if (ADB_PACKET_STATE_BUSY(adb_packet_send_state)) return ADB_RESULT_BUSY;
0038B8  80C2A1     MOV adb_packet_send_state, W1
0038BA  200020     MOV #0x2, W0
0038BC  508F80     SUB W1, W0, [W15]
0038BE  360004     BRA LEU, 0x38C8
221:                 return adb_packet_send_state == ADB_PACKET_STATE_IDLE ? ADB_RESULT_OK : ADB_RESULT_ERROR;
0038C0  6880E3     XOR W1, #0x3, W1
0038C2  EA0001     NEG W1, W0
0038C4  700001     IOR W0, W1, W0
0038C6  DE004F     LSR W0, #15, W0
222:               }
223:               
224:               void ADBPacketRecv() {
225:                 assert(!ADB_PACKET_STATE_BUSY(adb_packet_recv_state));
226:                 CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_START);
003918  EB0000     CLR W0
00391A  88C290     MOV W0, adb_packet_recv_state
227:               }
228:               
229:               ADB_RESULT ADBPacketRecvStatus(UINT32* cmd, UINT32* arg0, UINT32* arg1, void** data, UINT32* data_len) {
230:                 if (ADB_PACKET_STATE_BUSY(adb_packet_recv_state)) return ADB_RESULT_BUSY;
0035DE  80C295     MOV adb_packet_recv_state, W5
0035E0  200020     MOV #0x2, W0
0035E2  528F80     SUB W5, W0, [W15]
0035E4  360012     BRA LEU, 0x360A
231:                 if (adb_packet_recv_state == ADB_PACKET_STATE_ERROR) return ADB_RESULT_ERROR;
0035E6  200010     MOV #0x1, W0
0035E8  528FE4     SUB W5, #0x4, [W15]
0035EA  32000F     BRA Z, 0x360A
232:                 *cmd = adb_packet_recv_header.command;
0035EC  80C2B8     MOV adb_packet_recv_header, W8
0035EE  80C2C9     MOV 0x1858, W9
0035F0  BE8B08     MOV.D W8, [W6]
233:                 *arg0 = adb_packet_recv_header.arg0;
0035F2  80C2D6     MOV 0x185A, W6
0035F4  80C2E7     MOV 0x185C, W7
0035F6  BE8886     MOV.D W6, [W1]
234:                 *arg1 = adb_packet_recv_header.arg1;
0035F8  80C2F8     MOV 0x185E, W8
0035FA  80C309     MOV 0x1860, W9
0035FC  BE8908     MOV.D W8, [W2]
235:                 *data_len = adb_packet_recv_header.data_length;
0035FE  80C310     MOV 0x1862, W0
003600  80C321     MOV 0x1864, W1
003602  BE8A00     MOV.D W0, [W4]
236:                 *data = adb_packet_recv_data;
003604  208500     MOV #0x850, W0
003606  780980     MOV W0, [W3]
003608  EB0000     CLR W0
237:                 return ADB_RESULT_OK;
238:               }
239:               
240:               void ADBPacketReset() {
241:                 CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_IDLE);
00390A  200030     MOV #0x3, W0
00390C  88C2A0     MOV W0, adb_packet_send_state
242:                 CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_IDLE);
00390E  88C290     MOV W0, adb_packet_recv_state
243:               }
244:               
245:               void ADBPacketTasks() {
246:                 ADBPacketSendTasks();
247:                 ADBPacketRecvTasks();
248:               }
249:               
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libadb/adb_file.c  -------
00249E  BE9F88     MOV.D W8, [W15++]
0024A0  BE9F8A     MOV.D W10, [W15++]
0024A2  BE9F8C     MOV.D W12, [W15++]
0024A4  780601     MOV W1, W12
0024A6  BE0402     MOV.D W2, W8
00319C  BE9F88     MOV.D W8, [W15++]
00319E  BE9F8A     MOV.D W10, [W15++]
0031A0  781F8C     MOV W12, [W15++]
0031A2  780600     MOV W0, W12
0031A4  780581     MOV W1, W11
003248  BE9F88     MOV.D W8, [W15++]
00378E  BE9F88     MOV.D W8, [W15++]
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include <assert.h>
31:                #include <string.h>
32:                #include "logging.h"
33:                #include "adb_file.h"
34:                
35:                #define CHANGE_STATE(var,state)              \
36:                do {                                         \
37:                  log_printf("%s set to %s", #var, #state);  \
38:                  var = state;                               \
39:                } while (0)
40:                
41:                #define MKID(a,b,c,d) (((UINT32) (a)) | (((UINT32) (b)) << 8) | (((UINT32) (c)) << 16) | (((UINT32) (d)) << 24))
42:                
43:                #define ID_STAT MKID('S','T','A','T')
44:                #define ID_LIST MKID('L','I','S','T')
45:                #define ID_ULNK MKID('U','L','N','K')
46:                #define ID_SEND MKID('S','E','N','D')
47:                #define ID_RECV MKID('R','E','C','V')
48:                #define ID_DENT MKID('D','E','N','T')
49:                #define ID_DONE MKID('D','O','N','E')
50:                #define ID_DATA MKID('D','A','T','A')
51:                #define ID_OKAY MKID('O','K','A','Y')
52:                #define ID_FAIL MKID('F','A','I','L')
53:                #define ID_QUIT MKID('Q','U','I','T')
54:                
55:                typedef union {
56:                    UINT32 id;
57:                    struct {
58:                        UINT32 id;
59:                        UINT32 namelen;
60:                    } req;
61:                    struct {
62:                        UINT32 id;
63:                        UINT32 mode;
64:                        UINT32 size;
65:                        UINT32 time;
66:                    } stat;
67:                    struct {
68:                        UINT32 id;
69:                        UINT32 mode;
70:                        UINT32 size;
71:                        UINT32 time;
72:                        UINT32 namelen;
73:                    } dent;
74:                    struct {
75:                        UINT32 id;
76:                        UINT32 size;
77:                    } data;
78:                    struct {
79:                        UINT32 id;
80:                        UINT32 msglen;
81:                    } status;    
82:                } adb_syncmsg;
83:                
84:                typedef struct {
85:                  UINT32 id;
86:                  UINT32 namelen;
87:                } adb_req;
88:                
89:                typedef enum {
90:                  ADB_FILE_STATE_FREE = 0,
91:                  ADB_FILE_STATE_WAIT_OPEN,
92:                  ADB_FILE_STATE_WAIT_HEADER,
93:                  ADB_FILE_STATE_WAIT_DATA,
94:                  ADB_FILE_STATE_WAIT_FAIL_DATA
95:                } ADB_FILE_STATE;
96:                
97:                typedef struct {
98:                  ADB_FILE_STATE state;
99:                  ADBFileRecvFunc func;
100:                 ADB_CHANNEL_HANDLE handle;
101:                 UINT32 read_remain;
102:                 adb_syncmsg msg;
103:                 adb_req req;
104:                 char path[ADB_FILE_MAX_PATH_LENGTH];
105:               } ADB_FILE;
106:               
107:               static ADB_FILE adb_files[ADB_FILE_MAX_FILES];
108:               static int adb_file_buffer_refcount;
109:               
110:               static void ADBFileCallback(ADB_CHANNEL_HANDLE h, const void* data, UINT32 data_len) {
0024A8  EB0680     CLR W13
0024AA  21B321     MOV #0x1B32, W1
0024AC  370004     BRA 0x24B6
111:                 int i;
112:                 ADB_FILE* f;
113:                 for (i = 0; i < ADB_FILE_MAX_FILES && adb_files[i].handle != h; ++i);
0024AE  E8068D     INC W13, W13
0024B0  B00661     ADD #0x66, W1
0024B2  568FE2     SUB W13, #0x2, [W15]
0024B4  320002     BRA Z, 0x24BA
0024B6  100F91     SUBR W0, [W1], [W15]
0024B8  3AFFFA     BRA NZ, 0x24AE
114:                 assert(i < ADB_FILE_MAX_FILES);
115:                 f = &adb_files[i];
0024BA  200660     MOV #0x66, W0
0024BC  B9E800     MUL.SS W13, W0, W0
0024BE  21B2E2     MOV #0x1B2E, W2
0024C0  410500     ADD W2, W0, W10
116:               
117:                 // handle unexpected channel closure
118:                 if (!data) goto error;
0024C2  E0000C     CP0 W12
0024C4  32007B     BRA Z, error
119:               
120:                 // consume data
121:                 while (1) {
122:                   switch (f->state) {
0024C6  78001A     MOV [W10], W0
0024C8  500FE2     SUB W0, #0x2, [W15]
0024CA  320006     BRA Z, 0x24D8
0024CC  390074     BRA NC, close_and_error
0024CE  500FE3     SUB W0, #0x3, [W15]
0024D0  320032     BRA Z, 0x2536
0024D2  500FE4     SUB W0, #0x4, [W15]
0024D4  3AFFF8     BRA NZ, 0x24C6
0024D6  370065     BRA 0x25A2
123:                    case ADB_FILE_STATE_FREE:
124:                    case ADB_FILE_STATE_WAIT_OPEN:
125:                     goto close_and_error;
126:                 
127:                    case ADB_FILE_STATE_WAIT_HEADER:
128:                     if (data_len >= f->read_remain) {
0024D8  90013A     MOV [W10+6], W2
0024DA  9001CA     MOV [W10+8], W3
0024DC  4505EA     ADD W10, #0xA, W11
0024DE  540F82     SUB W8, W2, [W15]
0024E0  5C8F83     SUBB W9, W3, [W15]
0024E2  390022     BRA NC, 0x2528
129:                       memcpy(((BYTE*) &f->msg.data) + sizeof f->msg.data - f->read_remain, data, f->read_remain);
0024E4  558002     SUB W11, W2, W0
0024E6  400068     ADD W0, #0x8, W0
0024E8  78008C     MOV W12, W1
0024EA  020356     CALL memcpy
0024EC  000000     NOP
130:                       data = ((const BYTE*) data) + f->read_remain;
0024EE  90003A     MOV [W10+6], W0
0024F0  9000CA     MOV [W10+8], W1
0024F2  460600     ADD W12, W0, W12
131:                       data_len -= f->read_remain;
0024F4  540400     SUB W8, W0, W8
0024F6  5C8481     SUBB W9, W1, W9
132:                       f->read_remain = f->msg.data.size;
0024F8  90007A     MOV [W10+14], W0
0024FA  90088A     MOV [W10+16], W1
0024FC  980530     MOV W0, [W10+6]
0024FE  980541     MOV W1, [W10+8]
133:                       if (f->msg.data.id == ID_DATA || f->msg.data.id == ID_DONE) {
002500  BE011B     MOV.D [W11], W2
002502  241440     MOV #0x4144, W0
002504  241541     MOV #0x4154, W1
002506  510F80     SUB W2, W0, [W15]
002508  598F81     SUBB W3, W1, [W15]
00250A  320005     BRA Z, 0x2516
00250C  24F440     MOV #0x4F44, W0
00250E  2454E1     MOV #0x454E, W1
002510  510F80     SUB W2, W0, [W15]
002512  598F81     SUBB W3, W1, [W15]
002514  3A0002     BRA NZ, 0x251A
134:                         CHANGE_STATE(f->state, ADB_FILE_STATE_WAIT_DATA);
002516  200030     MOV #0x3, W0
002518  370037     BRA 0x2588
135:                       } else if (f->msg.data.id == ID_FAIL) {
00251A  241460     MOV #0x4146, W0
00251C  24C491     MOV #0x4C49, W1
00251E  510F80     SUB W2, W0, [W15]
002520  598F81     SUBB W3, W1, [W15]
002522  3A0049     BRA NZ, close_and_error
136:                         CHANGE_STATE(f->state, ADB_FILE_STATE_WAIT_FAIL_DATA);
002524  200040     MOV #0x4, W0
002526  370030     BRA 0x2588
137:                       } else {
138:                         goto close_and_error;
139:                       }
140:                     } else {
141:                       memcpy(((BYTE*) &f->msg.data) + sizeof f->msg.data - f->read_remain, data, data_len);
002528  558002     SUB W11, W2, W0
00252A  400068     ADD W0, #0x8, W0
00252C  780108     MOV W8, W2
00252E  78008C     MOV W12, W1
002530  020356     CALL memcpy
002532  000000     NOP
002534  370033     BRA 0x259C
142:                       f->read_remain -= data_len; 
143:                       return;
144:                     }
145:                     break;
146:                 
147:                    case ADB_FILE_STATE_WAIT_DATA:
148:                     if (data_len >= f->read_remain) {
002536  90013A     MOV [W10+6], W2
002538  9001CA     MOV [W10+8], W3
00253A  540F82     SUB W8, W2, [W15]
00253C  5C8F83     SUBB W9, W3, [W15]
00253E  390026     BRA NC, 0x258C
149:                       if (data_len > 0) {
002540  540FE0     SUB W8, #0x0, [W15]
002542  5C8FE0     SUBB W9, #0x0, [W15]
002544  320004     BRA Z, 0x254E
150:                         f->func(i, data, f->read_remain);
002546  90021A     MOV [W10+2], W4
002548  78008C     MOV W12, W1
00254A  78000D     MOV W13, W0
00254C  010004     CALL W4
151:                       }
152:                       if (f->msg.id == ID_DONE) {
00254E  90015A     MOV [W10+10], W2
002550  9001EA     MOV [W10+12], W3
002552  90023A     MOV [W10+6], W4
002554  9002CA     MOV [W10+8], W5
002556  24F440     MOV #0x4F44, W0
002558  2454E1     MOV #0x454E, W1
00255A  510F80     SUB W2, W0, [W15]
00255C  598F81     SUBB W3, W1, [W15]
00255E  3A000C     BRA NZ, 0x2578
153:                         if (data_len != f->read_remain) goto close_and_error;
002560  540F84     SUB W8, W4, [W15]
002562  5C8F85     SUBB W9, W5, [W15]
002564  3A0028     BRA NZ, close_and_error
154:                         // success - EOF
155:                         f->func(i, NULL, 0);
002566  90021A     MOV [W10+2], W4
002568  B81160     MUL.UU W2, #0, W2
00256A  EB0080     CLR W1
00256C  78000D     MOV W13, W0
00256E  010004     CALL W4
156:                         ADBClose(f->handle);
002570  90002A     MOV [W10+4], W0
002572  02387A     CALL ADBClose
002574  000000     NOP
002576  370028     BRA 0x25C8
157:                         memset(f, 0, sizeof(ADB_FILE));
158:                         return;
159:                       } else {
160:                         data = ((const BYTE*) data) + f->read_remain;
002578  460604     ADD W12, W4, W12
161:                         data_len -= f->read_remain;
00257A  540404     SUB W8, W4, W8
00257C  5C8485     SUBB W9, W5, W9
162:                         f->read_remain = sizeof f->msg.data;
00257E  200080     MOV #0x8, W0
002580  200001     MOV #0x0, W1
002582  980530     MOV W0, [W10+6]
002584  980541     MOV W1, [W10+8]
163:                         CHANGE_STATE(f->state, ADB_FILE_STATE_WAIT_HEADER);
002586  200020     MOV #0x2, W0
002588  780D00     MOV W0, [W10]
00258A  37FF9D     BRA 0x24C6
164:                       }
165:                     } else {
166:                       if (data_len > 0) {
00258C  540FE0     SUB W8, #0x0, [W15]
00258E  5C8FE0     SUBB W9, #0x0, [W15]
002590  320005     BRA Z, 0x259C
167:                         f->func(i, data, data_len);
002592  90021A     MOV [W10+2], W4
002594  BE0108     MOV.D W8, W2
002596  78008C     MOV W12, W1
002598  78000D     MOV W13, W0
00259A  010004     CALL W4
168:                       }
169:                       f->read_remain -= data_len;
00259C  90003A     MOV [W10+6], W0
00259E  9000CA     MOV [W10+8], W1
0025A0  370005     BRA 0x25AC
170:                       return;
171:                     }
172:                     break;
173:               
174:                    case ADB_FILE_STATE_WAIT_FAIL_DATA:
175:                     if (data_len >= f->read_remain) {
0025A2  90003A     MOV [W10+6], W0
0025A4  9000CA     MOV [W10+8], W1
0025A6  540F80     SUB W8, W0, [W15]
0025A8  5C8F81     SUBB W9, W1, [W15]
0025AA  310005     BRA C, close_and_error
176:                       goto close_and_error;
177:                     } else {
178:                       f->read_remain -= data_len;
0025AC  500008     SUB W0, W8, W0
0025AE  588089     SUBB W1, W9, W1
0025B0  980530     MOV W0, [W10+6]
0025B2  980541     MOV W1, [W10+8]
0025B4  37000E     BRA 0x25D2
179:                       return;
180:                     }
181:                     break;
182:                   }
183:                 }
184:                 return;
185:               
186:               close_and_error:
187:                 ADBClose(f->handle);
0025B6  90002A     MOV [W10+4], W0
0025B8  02387A     CALL ADBClose
0025BA  000000     NOP
188:               error:
189:                 log_printf("Failed to open or read file %s", f->path);
190:                 f->func(i, NULL, 1);
0025BC  90021A     MOV [W10+2], W4
0025BE  200012     MOV #0x1, W2
0025C0  200003     MOV #0x0, W3
0025C2  EB0080     CLR W1
0025C4  78000D     MOV W13, W0
0025C6  010004     CALL W4
191:                 memset(f, 0, sizeof(ADB_FILE));
0025C8  200662     MOV #0x66, W2
0025CA  EB0080     CLR W1
0025CC  78000A     MOV W10, W0
0025CE  020516     CALL memset
0025D0  000000     NOP
192:               }
193:               
194:               ADB_FILE_HANDLE ADBFileRead(const char* path, ADBChannelRecvFunc recv_func) {
0031A6  EB0500     CLR W10
0031A8  21B2E0     MOV #0x1B2E, W0
0031AA  370004     BRA 0x31B4
195:                 int i;
196:                 assert(path != NULL);
197:                 assert(strlen(path) < ADB_FILE_MAX_PATH_LENGTH);
198:                 for (i = 0; i < ADB_FILE_MAX_FILES && adb_files[i].state != ADB_FILE_STATE_FREE; ++i);
0031AC  E8050A     INC W10, W10
0031AE  B00660     ADD #0x66, W0
0031B0  550FE2     SUB W10, #0x2, [W15]
0031B2  32001A     BRA Z, 0x31E8
0031B4  E00010     CP0 [W0]
0031B6  3AFFFA     BRA NZ, 0x31AC
199:                 if (i == ADB_FILE_MAX_FILES) {
200:                   log_printf("Exceeded maximum number of open files: %d", ADB_FILE_MAX_FILES);
201:                   return ADB_FILE_INVALID_HANDLE;
202:                 }
203:                 if ((adb_files[i].handle = ADBOpen("sync:", &ADBFileCallback)) == ADB_INVALID_CHANNEL_HANDLE) {
0031B8  2249E1     MOV #0x249E, W1
0031BA  21F440     MOV #0x1F44, W0
0031BC  022DBE     CALL ADBOpen
0031BE  000000     NOP
0031C0  200662     MOV #0x66, W2
0031C2  B9D102     MUL.SS W10, W2, W2
0031C4  780402     MOV W2, W8
0031C6  4100E4     ADD W2, #0x4, W1
0031C8  21B2E9     MOV #0x1B2E, W9
0031CA  78B480     MOV W0, [W9+W1]
0031CC  400FE1     ADD W0, #0x1, [W15]
0031CE  32000C     BRA Z, 0x31E8
204:                   log_printf("Failed to open ADB channel to sync:");
205:                   return ADB_FILE_INVALID_HANDLE;
206:                 }
207:                 adb_files[i].func = recv_func;
0031D0  E88002     INC2 W2, W0
0031D2  78348B     MOV W11, [W9+W0]
208:                 strncpy(adb_files[i].path, path, ADB_FILE_MAX_PATH_LENGTH);
0031D4  200260     MOV #0x26, W0
0031D6  400002     ADD W0, W2, W0
0031D8  400009     ADD W0, W9, W0
0031DA  200402     MOV #0x40, W2
0031DC  78008C     MOV W12, W1
0031DE  020524     CALL strncpy
0031E0  000000     NOP
209:                 CHANGE_STATE(adb_files[i].state, ADB_FILE_STATE_WAIT_OPEN);
0031E2  200010     MOV #0x1, W0
0031E4  7C3480     MOV W0, [W9+W8]
0031E6  370001     BRA 0x31EA
210:                 log_printf("Success opening file %s. Handle is %d", path, i);
211:                 return i;
0031E8  EB8500     SETM W10
212:               }
213:               
214:               void ADBFileClose(ADB_FILE_HANDLE h) {
215:                 log_printf("Closing file %d", h);
216:                 assert(h >= 0 && h < ADB_FILE_MAX_FILES);
217:                 ADB_FILE* f = &adb_files[h];
003790  200669     MOV #0x66, W9
003792  B98109     MUL.SS W0, W9, W2
003794  21B2E0     MOV #0x1B2E, W0
003796  400402     ADD W0, W2, W8
218:                 if (f->state != ADB_FILE_STATE_FREE) {
003798  E00018     CP0 [W8]
00379A  320008     BRA Z, 0x37AC
219:                   ADBClose(f->handle);
00379C  900028     MOV [W8+4], W0
00379E  02387A     CALL ADBClose
0037A0  000000     NOP
220:                   memset(f, 0, sizeof(ADB_FILE));
0037A2  780109     MOV W9, W2
0037A4  EB0080     CLR W1
0037A6  780008     MOV W8, W0
0037A8  020516     CALL memset
0037AA  000000     NOP
221:                 }
222:               }
223:               
224:               void ADBFileInit() {
225:                 memset(adb_files, 0, sizeof adb_files);
0038DA  200CC2     MOV #0xCC, W2
0038DC  EB0080     CLR W1
0038DE  21B2E0     MOV #0x1B2E, W0
0038E0  020516     CALL memset
0038E2  000000     NOP
226:                 adb_file_buffer_refcount = 0;
0038E4  EB0000     CLR W0
0038E6  88D960     MOV W0, adb_file_buffer_refcount
227:               }
228:               
229:               void ADBFileTasks() {
00324A  21B2E8     MOV #0x1B2E, W8
003252  4404E4     ADD W8, #0x4, W9
230:                 int i;
231:                 for (i = 0; i < ADB_FILE_MAX_FILES; ++i) {
00328E  21BFA0     MOV #0x1BFA, W0
003290  540F80     SUB W8, W0, [W15]
003292  3AFFDC     BRA NZ, 0x324C
232:                   ADB_FILE* f = &adb_files[i];
233:                   if (f->state == ADB_FILE_STATE_WAIT_OPEN && ADBChannelReady(f->handle)) {
00324C  200010     MOV #0x1, W0
00324E  100F98     SUBR W0, [W8], [W15]
003250  3A001D     BRA NZ, 0x328C
003254  780019     MOV [W9], W0
003256  0237B0     CALL ADBChannelReady
003258  000000     NOP
00325A  E00000     CP0 W0
00325C  320017     BRA Z, 0x328C
234:                     f->req.id = ID_RECV;
00325E  245520     MOV #0x4552, W0
003260  256431     MOV #0x5643, W1
003262  980C70     MOV W0, [W8+30]
003264  981401     MOV W1, [W8+32]
235:                     f->req.namelen = strlen(f->path);
003266  200260     MOV #0x26, W0
003268  400008     ADD W0, W8, W0
00326A  020552     CALL strlen
00326C  000000     NOP
00326E  200001     MOV #0x0, W1
003270  981410     MOV W0, [W8+34]
003272  981421     MOV W1, [W8+36]
236:                     ADBWrite(f->handle, &f->req, sizeof f->req + f->req.namelen);
003274  400168     ADD W0, #0x8, W2
003276  4881E0     ADDC W1, #0x0, W3
003278  4400FE     ADD W8, #0x1E, W1
00327A  780019     MOV [W9], W0
00327C  023890     CALL ADBWrite
00327E  000000     NOP
237:                     f->read_remain = sizeof f->msg.data;
003280  200080     MOV #0x8, W0
003282  200001     MOV #0x0, W1
003284  980430     MOV W0, [W8+6]
003286  980441     MOV W1, [W8+8]
238:                     CHANGE_STATE(f->state, ADB_FILE_STATE_WAIT_HEADER);
003288  200020     MOV #0x2, W0
00328A  780C00     MOV W0, [W8]
00328C  B00668     ADD #0x66, W8
239:                   }
240:                 }
241:               }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libadb/adb.c  ------------
0017E4  FA0012     LNK #0x12
0017E6  BE9F88     MOV.D W8, [W15++]
0017E8  BE9F8A     MOV.D W10, [W15++]
002DBE  BE9F88     MOV.D W8, [W15++]
002DC0  BE9F8A     MOV.D W10, [W15++]
002DC2  BE9F8C     MOV.D W12, [W15++]
002DC4  780200     MOV W0, W4
002DC6  780681     MOV W1, W13
003672  BE9F88     MOV.D W8, [W15++]
0037B0  780080     MOV W0, W1
00387A  780080     MOV W0, W1
003890  780200     MOV W0, W4
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include <string.h>
31:                #include <assert.h>
32:                
33:                #include "adb_private.h"
34:                #include "adb_packet.h"
35:                #include "usb_host_android.h"
36:                #include "logging.h"
37:                
38:                #define CHANGE_CHANNEL_STATE(ch,st)                          \
39:                  do {                                                       \
40:                    log_printf("Channel %d state changed to %s", ch, #st);  \
41:                    adb_channels[ch].state = st;                             \
42:                  } while (0)
43:                
44:                #define CHANGE_STATE(var,state)              \
45:                do {                                         \
46:                  log_printf("%s set to %s", #var, #state);  \
47:                  var = state;                               \
48:                } while (0)
49:                
50:                
51:                ////////////////////////////////////////////////////////////////////////////////
52:                // Constants
53:                ////////////////////////////////////////////////////////////////////////////////
54:                
55:                // ADB protocol defines
56:                #define ADB_CNXN 0x4e584e43
57:                #define ADB_OPEN 0x4e45504f
58:                #define ADB_OKAY 0x59414b4f
59:                #define ADB_CLSE 0x45534c43
60:                #define ADB_WRTE 0x45545257
61:                
62:                #define ADB_VERSION 0x01000000        // ADB protocol version
63:                
64:                ////////////////////////////////////////////////////////////////////////////////
65:                // Types
66:                ////////////////////////////////////////////////////////////////////////////////
67:                
68:                typedef enum {
69:                  ADB_CONN_STATE_ERROR,
70:                  ADB_CONN_STATE_WAIT_ATTACH,
71:                  ADB_CONN_STATE_WAIT_CONNECT,
72:                  ADB_CONN_STATE_CONNECTED
73:                } ADB_CONN_STATE;
74:                
75:                typedef enum {
76:                  ADB_CHAN_STATE_FREE = 0,
77:                  ADB_CHAN_STATE_START,
78:                  ADB_CHAN_STATE_WAIT_OPEN,
79:                  ADB_CHAN_STATE_IDLE,
80:                  ADB_CHAN_STATE_WAIT_READY,
81:                  ADB_CHAN_STATE_CLOSE_REQUESTED,
82:                  ADB_CHAN_STATE_WAIT_CLOSE,
83:                } ADB_CHAN_STATE;
84:                
85:                typedef struct {
86:                  ADB_CHAN_STATE state;
87:                  const void* data;
88:                  UINT32 data_len;
89:                  char name[ADB_CHANNEL_NAME_MAX_LENGTH];
90:                  UINT32 local_id;
91:                  UINT32 remote_id;
92:                  BOOL pending_ack;
93:                  ADBChannelRecvFunc recv_func;
94:                } ADB_CHANNEL;
95:                
96:                ////////////////////////////////////////////////////////////////////////////////
97:                // Globals
98:                ////////////////////////////////////////////////////////////////////////////////
99:                static ADB_CONN_STATE adb_conn_state;
100:               static ADB_CHANNEL adb_channels[ADB_MAX_CHANNELS];
101:               static char ADB_HOSTNAME_STRING[] = "host::";  // Leave non-const. USB stack
102:                                                              // doesn't work from ROM.
103:               static unsigned int adb_buffer_refcount;
104:               static UINT32 local_id_counter = 1;  // used for allocating unique local ids.
105:               
106:               ////////////////////////////////////////////////////////////////////////////////
107:               // Functions & Macros
108:               ////////////////////////////////////////////////////////////////////////////////
109:               
110:               BOOL ADBAttached() {
003912  80E090     MOV 0x1C12, W0
003914  600061     AND W0, #0x1, W0
111:                 return USBHostAndroidIsInterfaceAttached(ANDROID_INTERFACE_ADB);
112:               }
113:               
114:               BOOL ADBConnected() {
0038EA  EB0080     CLR W1
0038EC  80D950     MOV adb_conn_state, W0
0038EE  500FE2     SUB W0, #0x2, [W15]
0038F0  360001     BRA LEU, 0x38F4
0038F2  200011     MOV #0x1, W1
115:                 return adb_conn_state > ADB_CONN_STATE_WAIT_CONNECT;
116:               }
117:               
118:               static void ADBReset() {
003674  EB0480     CLR W9
003676  2188A8     MOV #0x188A, W8
119:                 // close all open channels
120:                 ADB_CHANNEL_HANDLE h;
121:                 for (h = 0; h < ADB_MAX_CHANNELS; ++h) {
003686  E80489     INC W9, W9
003688  B00548     ADD #0x54, W8
00368A  548FE8     SUB W9, #0x8, [W15]
00368C  3AFFF5     BRA NZ, 0x3678
122:                   if (adb_channels[h].state != ADB_CHAN_STATE_FREE) {
003678  E00018     CP0 [W8]
00367A  320005     BRA Z, 0x3686
123:                     adb_channels[h].recv_func(h, NULL, 0);
00367C  902A18     MOV [W8+82], W4
00367E  B81160     MUL.UU W2, #0, W2
003680  EB0080     CLR W1
003682  780009     MOV W9, W0
003684  010004     CALL W4
124:                   }
125:                 }
126:                 memset(adb_channels, 0, sizeof adb_channels);
00368E  202A02     MOV #0x2A0, W2
003690  EB0080     CLR W1
003692  2188A0     MOV #0x188A, W0
003694  020516     CALL memset
003696  000000     NOP
127:                 adb_buffer_refcount = 0;
003698  EB0000     CLR W0
00369A  88C440     MOV W0, adb_buffer_refcount
128:                 CHANGE_STATE(adb_conn_state, ADB_CONN_STATE_WAIT_ATTACH);
00369C  200010     MOV #0x1, W0
00369E  88D950     MOV W0, adb_conn_state
129:               }
130:               
131:               void ADBBufferRef() {
132:                 ++adb_buffer_refcount;
003902  80C440     MOV adb_buffer_refcount, W0
003904  E80000     INC W0, W0
003906  88C440     MOV W0, adb_buffer_refcount
133:               }
134:               
135:               void ADBBufferUnref() {
136:                 assert(adb_buffer_refcount);
137:                 --adb_buffer_refcount;
003860  80C440     MOV adb_buffer_refcount, W0
003862  E90080     DEC W0, W1
003864  88C441     MOV W1, adb_buffer_refcount
138:                 if (adb_conn_state < ADB_CONN_STATE_WAIT_CONNECT) return;
003866  80D950     MOV adb_conn_state, W0
003868  500FE1     SUB W0, #0x1, [W15]
00386A  360006     BRA LEU, 0x3878
139:                 if (adb_buffer_refcount == 0) {
00386C  E00001     CP0 W1
00386E  3A0004     BRA NZ, 0x3878
140:                   adb_buffer_refcount = 1;
003870  200010     MOV #0x1, W0
003872  88C440     MOV W0, adb_buffer_refcount
141:                   ADBPacketRecv();
142:                 }
143:               }
144:               
145:               static void ADBChannelTasks() {
146:                 static ADB_CHANNEL_HANDLE current_channel = 0;
147:                 ADB_RESULT adb_res;
148:                 ADB_CHANNEL_HANDLE h;
149:                 if ((adb_res = ADBPacketSendStatus()) == ADB_RESULT_BUSY) return;
001974  0238B8     CALL ADBPacketSendStatus
001976  000000     NOP
001978  500FE2     SUB W0, #0x2, [W15]
00197A  320073     BRA Z, 0x1A62
150:                 if (adb_res == ADB_RESULT_ERROR) {
00197C  500FE1     SUB W0, #0x1, [W15]
00197E  3A0003     BRA NZ, 0x1986
151:                   CHANGE_STATE(adb_conn_state, ADB_CONN_STATE_ERROR);
001980  EB0000     CLR W0
001982  88D950     MOV W0, adb_conn_state
001984  37006E     BRA 0x1A62
001986  80C432     MOV 0x1886, W2
001988  200083     MOV #0x8, W3
152:                   return;
153:                 }
154:                 for (h = 0; h < ADB_MAX_CHANNELS; ++h) {
0019C0  3AFFE4     BRA NZ, 0x198A
0019C2  88C432     MOV W2, 0x1886
0019C4  37004E     BRA 0x1A62
155:                   if (++current_channel == ADB_MAX_CHANNELS) current_channel = 0;
00198A  E80102     INC W2, W2
00198C  510FE8     SUB W2, #0x8, [W15]
00198E  3A0001     BRA NZ, 0x1992
001990  EB0100     CLR W2
156:                   if (adb_channels[current_channel].state == ADB_CHAN_STATE_FREE) {
001992  20054B     MOV #0x54, W11
001994  B9900B     MUL.SS W2, W11, W0
001996  780480     MOV W0, W9
001998  2188AA     MOV #0x188A, W10
00199A  7800EA     MOV [W10+W0], W1
00199C  E00001     CP0 W1
00199E  32000F     BRA Z, 0x19BE
157:                     continue;
158:                   }
159:                   if (adb_channels[current_channel].state == ADB_CHAN_STATE_START) {
0019A0  508FE1     SUB W1, #0x1, [W15]
0019A2  320048     BRA Z, 0x1A34
001A34  88C432     MOV W2, 0x1886
160:                     ADBPacketSend(ADB_OPEN, adb_channels[current_channel].local_id, 0, adb_channels[current_channel].name, strlen(adb_channels[current_channel].name) + 1);
001A36  448468     ADD W9, #0x8, W8
001A38  44040A     ADD W8, W10, W8
001A3A  B00489     ADD #0x48, W9
001A3C  44848A     ADD W9, W10, W9
001A3E  780008     MOV W8, W0
001A40  020552     CALL strlen
001A42  000000     NOP
001A44  E80000     INC W0, W0
001A46  200001     MOV #0x0, W1
001A48  BE9F80     MOV.D W0, [W15++]
001A4A  780308     MOV W8, W6
001A4C  B82260     MUL.UU W4, #0, W4
001A4E  BE0119     MOV.D [W9], W2
001A50  2504F0     MOV #0x504F, W0
001A52  24E451     MOV #0x4E45, W1
001A54  02332C     CALL ADBPacketSend
001A56  000000     NOP
161:                     CHANGE_CHANNEL_STATE(current_channel, ADB_CHAN_STATE_WAIT_OPEN);
001A58  80C430     MOV 0x1886, W0
001A5A  B9800B     MUL.SS W0, W11, W0
001A5C  200022     MOV #0x2, W2
001A5E  783502     MOV W2, [W10+W0]
001A60  5787E4     SUB W15, #0x4, W15
162:                     return;
163:                   }
164:                   if (adb_channels[current_channel].pending_ack) {
0019A4  200500     MOV #0x50, W0
0019A6  400009     ADD W0, W9, W0
0019A8  78036A     MOV [W10+W0], W6
0019AA  E00006     CP0 W6
0019AC  3A0010     BRA NZ, 0x19CE
0019CE  88C432     MOV W2, 0x1886
165:                     ADBPacketSend(ADB_OKAY, adb_channels[current_channel].local_id, adb_channels[current_channel].remote_id, NULL, 0);
0019D0  44800A     ADD W9, W10, W0
0019D2  B81160     MUL.UU W2, #0, W2
0019D4  BE9F82     MOV.D W2, [W15++]
0019D6  EB0300     CLR W6
0019D8  902260     MOV [W0+76], W4
0019DA  9022F0     MOV [W0+78], W5
0019DC  902140     MOV [W0+72], W2
0019DE  9021D0     MOV [W0+74], W3
0019E0  24B4F0     MOV #0x4B4F, W0
0019E2  259411     MOV #0x5941, W1
0019E4  02332C     CALL ADBPacketSend
0019E6  000000     NOP
166:                     adb_channels[current_channel].pending_ack = FALSE;
0019E8  80C430     MOV 0x1886, W0
0019EA  B9800B     MUL.SS W0, W11, W0
0019EC  B00500     ADD #0x50, W0
0019EE  EB0100     CLR W2
0019F0  370036     BRA 0x1A5E
167:                     return;
168:                   }
169:                   if (adb_channels[current_channel].state == ADB_CHAN_STATE_CLOSE_REQUESTED) {
0019AE  508FE5     SUB W1, #0x5, [W15]
0019B0  320020     BRA Z, 0x19F2
0019F2  88C432     MOV W2, 0x1886
170:                     ADBPacketSend(ADB_CLSE, adb_channels[current_channel].local_id, adb_channels[current_channel].remote_id, NULL, 0);
0019F4  44800A     ADD W9, W10, W0
0019F6  B82260     MUL.UU W4, #0, W4
0019F8  BE9F84     MOV.D W4, [W15++]
0019FA  902260     MOV [W0+76], W4
0019FC  9022F0     MOV [W0+78], W5
0019FE  902140     MOV [W0+72], W2
001A00  9021D0     MOV [W0+74], W3
001A02  24C430     MOV #0x4C43, W0
001A04  245531     MOV #0x4553, W1
001A06  02332C     CALL ADBPacketSend
001A08  000000     NOP
171:                     CHANGE_CHANNEL_STATE(current_channel, ADB_CHAN_STATE_WAIT_CLOSE);
001A0A  80C430     MOV 0x1886, W0
001A0C  B9800B     MUL.SS W0, W11, W0
001A0E  200062     MOV #0x6, W2
001A10  370026     BRA 0x1A5E
172:                     return;
173:                   }
174:                   if (adb_channels[current_channel].state == ADB_CHAN_STATE_IDLE
0019B2  508FE3     SUB W1, #0x3, [W15]
0019B4  3A0004     BRA NZ, 0x19BE
0019B6  E88009     INC2 W9, W0
0019B8  78036A     MOV [W10+W0], W6
0019BA  E00006     CP0 W6
0019BC  3A002A     BRA NZ, 0x1A12
001A12  88C432     MOV W2, 0x1886
175:                       && adb_channels[current_channel].data != NULL) {
176:                     ADBPacketSend(ADB_WRTE, adb_channels[current_channel].local_id, adb_channels[current_channel].remote_id, adb_channels[current_channel].data, adb_channels[current_channel].data_len);
001A14  44808A     ADD W9, W10, W1
001A16  900221     MOV [W1+4], W4
001A18  9002B1     MOV [W1+6], W5
001A1A  BE9F84     MOV.D W4, [W15++]
001A1C  902261     MOV [W1+76], W4
001A1E  9022F1     MOV [W1+78], W5
001A20  902141     MOV [W1+72], W2
001A22  9021D1     MOV [W1+74], W3
001A24  252570     MOV #0x5257, W0
001A26  245541     MOV #0x4554, W1
001A28  02332C     CALL ADBPacketSend
001A2A  000000     NOP
177:                     CHANGE_CHANNEL_STATE(current_channel, ADB_CHAN_STATE_WAIT_READY);
0019BE  E90183     DEC W3, W3
001A2C  80C430     MOV 0x1886, W0
001A2E  B9800B     MUL.SS W0, W11, W0
001A30  200042     MOV #0x4, W2
001A32  370015     BRA 0x1A5E
178:                     return;
179:                   }
180:                 }
181:               }
182:               
183:               static void ADBHandlePacket(UINT32 cmd, UINT32 arg0, UINT32 arg1, const void* recv_data, UINT32 data_len) {
184:                 int h = arg1 & 0xFF;
001830  780486     MOV W6, W9
001832  B20FF9     AND #0xFF, W9
185:                 switch(cmd) {
001834  97B24F     MOV [W15-24], W4
001836  97B2DF     MOV [W15-22], W5
001838  252570     MOV #0x5257, W0
00183A  245541     MOV #0x4554, W1
00183C  520F80     SUB W4, W0, [W15]
00183E  5A8F81     SUBB W5, W1, [W15]
001840  320053     BRA Z, 0x18E8
001842  3E0006     BRA GTU, 0x1850
001844  24C430     MOV #0x4C43, W0
001846  245531     MOV #0x4553, W1
001848  520F80     SUB W4, W0, [W15]
00184A  5A8F81     SUBB W5, W1, [W15]
00184C  3A0070     BRA NZ, 0x192E
00184E  37002E     BRA 0x18AC
001850  24E430     MOV #0x4E43, W0
001852  24E581     MOV #0x4E58, W1
001854  520F80     SUB W4, W0, [W15]
001856  5A8F81     SUBB W5, W1, [W15]
001858  320006     BRA Z, 0x1866
00185A  24B4F0     MOV #0x4B4F, W0
00185C  259411     MOV #0x5941, W1
00185E  520F80     SUB W4, W0, [W15]
001860  5A8F81     SUBB W5, W1, [W15]
001862  3A0065     BRA NZ, 0x192E
001864  370003     BRA 0x186C
186:                  case ADB_CNXN:
187:                   log_printf("ADB established connection with [%s]", (const char*) recv_data);
188:                   // TODO: arg1 contains max_data - handle
189:                   CHANGE_STATE(adb_conn_state, ADB_CONN_STATE_CONNECTED);
001866  200030     MOV #0x3, W0
001868  88D950     MOV W0, adb_conn_state
00186A  370061     BRA 0x192E
190:                   break;
191:               
192:                  case ADB_OPEN:
193:                   // should not happen. ignored.
194:                   break;
195:               
196:                  case ADB_OKAY:
197:                   if (h >= 0 && h < ADB_MAX_CHANNELS && adb_channels[h].local_id == arg1) {
00186C  548FE7     SUB W9, #0x7, [W15]
00186E  3E005F     BRA GTU, 0x192E
001870  200540     MOV #0x54, W0
001872  B9C800     MUL.SS W9, W0, W0
001874  780100     MOV W0, W2
001876  B00480     ADD #0x48, W0
001878  2188A3     MOV #0x188A, W3
00187A  400003     ADD W0, W3, W0
00187C  130FB0     SUBR W6, [W0++], [W15]
00187E  1B8FA0     SUBBR W7, [W0--], [W15]
001880  3A0056     BRA NZ, 0x192E
198:                     if (adb_channels[h].state == ADB_CHAN_STATE_WAIT_OPEN) {
001882  790063     MOV [W3+W2], W0
001884  500FE2     SUB W0, #0x2, [W15]
001886  3A0004     BRA NZ, 0x1890
199:                       log_printf("Channel %d is open. Remote ID: 0x%lx. Name: %s", h, arg0, adb_channels[h].name);
200:                       adb_channels[h].remote_id = arg0;
001888  410003     ADD W2, W3, W0
00188A  98206A     MOV W10, [W0+76]
00188C  98207B     MOV W11, [W0+78]
00188E  37000B     BRA 0x18A6
201:                       CHANGE_CHANNEL_STATE(h, ADB_CHAN_STATE_IDLE);
202:                     } else if (adb_channels[h].state == ADB_CHAN_STATE_WAIT_READY
001890  500FE4     SUB W0, #0x4, [W15]
001892  3A004D     BRA NZ, 0x192E
001894  2004C0     MOV #0x4C, W0
001896  400002     ADD W0, W2, W0
001898  400003     ADD W0, W3, W0
00189A  150FB0     SUBR W10, [W0++], [W15]
00189C  1D8FA0     SUBBR W11, [W0--], [W15]
00189E  3A0047     BRA NZ, 0x192E
203:                       && adb_channels[h].remote_id == arg0) {
204:                       adb_channels[h].data = NULL;
0018A0  E88002     INC2 W2, W0
0018A2  EB0080     CLR W1
0018A4  783181     MOV W1, [W3+W0]
205:                       CHANGE_CHANNEL_STATE(h, ADB_CHAN_STATE_IDLE);
0018A6  200030     MOV #0x3, W0
0018A8  793180     MOV W0, [W3+W2]
0018AA  370041     BRA 0x192E
206:                     }
207:                   } else {
208:                     log_printf("Remote side sent an OK on an unexpected ID: 0x%lx", arg1);
209:                   }
210:                   break;
211:               
212:                  case ADB_CLSE:
213:                   if (h >= 0 && h < ADB_MAX_CHANNELS && adb_channels[h].local_id == arg1) {
0018AC  548FE7     SUB W9, #0x7, [W15]
0018AE  3E003F     BRA GTU, 0x192E
0018B0  200540     MOV #0x54, W0
0018B2  B9C800     MUL.SS W9, W0, W0
0018B4  780400     MOV W0, W8
0018B6  B00480     ADD #0x48, W0
0018B8  2188AA     MOV #0x188A, W10
0018BA  40000A     ADD W0, W10, W0
0018BC  130FB0     SUBR W6, [W0++], [W15]
0018BE  1B8FA0     SUBBR W7, [W0--], [W15]
0018C0  3A0036     BRA NZ, 0x192E
214:                     if (adb_channels[h].state == ADB_CHAN_STATE_WAIT_OPEN) {
0018C2  7C00EA     MOV [W10+W8], W1
0018C4  508FE2     SUB W1, #0x2, [W15]
0018C6  320006     BRA Z, 0x18D4
215:                       log_printf("Channel %d open failed. Name: %s", h, adb_channels[h].name);
216:                       adb_channels[h].recv_func(h, NULL, 0);
217:                       CHANGE_CHANNEL_STATE(h, ADB_CHAN_STATE_FREE);
218:                     } else if (adb_channels[h].state == ADB_CHAN_STATE_WAIT_CLOSE
0018C8  508065     SUB W1, #0x5, W0
0018CA  500FE1     SUB W0, #0x1, [W15]
0018CC  36000A     BRA LEU, 0x18E2
219:                         || adb_channels[h].state == ADB_CHAN_STATE_CLOSE_REQUESTED) {
220:                       log_printf("Channel %d closed. Name: %s", h, adb_channels[h].name);
221:                       CHANGE_CHANNEL_STATE(h, ADB_CHAN_STATE_FREE);
222:                     } else if ((adb_channels[h].state == ADB_CHAN_STATE_WAIT_READY
0018CE  508063     SUB W1, #0x3, W0
0018D0  500FE1     SUB W0, #0x1, [W15]
0018D2  3E002D     BRA GTU, 0x192E
223:                                 || adb_channels[h].state == ADB_CHAN_STATE_IDLE)
224:                       // in the ADB documentation it says that only failed attempts to open
225:                       // will result in CLSE with local-id (arg0) of 0, and that in any other
226:                       // case we should ignore the message if it is not equal to our remote
227:                       // ID. In practice, however, we do get CLSE(0, ...) as result of a
228:                       // legitimate closure on the server-side, so this check is disabled.
229:                                /*&& adb_channels[arg1].remote_id == arg0*/) {
230:                       log_printf("Channel %d closed by remote side. Name: %s", h, adb_channels[h].name);
231:                       adb_channels[h].recv_func(h, NULL, 0);
0018D4  200520     MOV #0x52, W0
0018D6  400008     ADD W0, W8, W0
0018D8  78026A     MOV [W10+W0], W4
0018DA  B81160     MUL.UU W2, #0, W2
0018DC  EB0080     CLR W1
0018DE  780009     MOV W9, W0
0018E0  010004     CALL W4
232:                       CHANGE_CHANNEL_STATE(h, ADB_CHAN_STATE_FREE);
0018E2  EB0000     CLR W0
0018E4  7C3500     MOV W0, [W10+W8]
0018E6  370023     BRA 0x192E
233:                     }
234:                   } else {
235:                     log_printf("Remote side sent a CLSE on an unexpected ID: 0x%lx", arg1);
236:                   }
237:                   break;
238:               
239:                  case ADB_WRTE:
240:                   if (h >= 0 && h < ADB_MAX_CHANNELS && adb_channels[h].local_id == arg1
0018E8  548FE7     SUB W9, #0x7, [W15]
0018EA  3E0021     BRA GTU, 0x192E
0018EC  200540     MOV #0x54, W0
0018EE  B9C800     MUL.SS W9, W0, W0
0018F0  780080     MOV W0, W1
0018F2  B00480     ADD #0x48, W0
0018F4  2188A4     MOV #0x188A, W4
0018F6  400004     ADD W0, W4, W0
0018F8  130FB0     SUBR W6, [W0++], [W15]
0018FA  1B8FA0     SUBBR W7, [W0--], [W15]
0018FC  3A0018     BRA NZ, 0x192E
0018FE  2004C0     MOV #0x4C, W0
001900  400001     ADD W0, W1, W0
001902  400004     ADD W0, W4, W0
001904  150FB0     SUBR W10, [W0++], [W15]
001906  1D8FA0     SUBBR W11, [W0--], [W15]
001908  3A0012     BRA NZ, 0x192E
241:                       && adb_channels[h].remote_id == arg0) {
242:                     if (adb_channels[h].state < ADB_CHAN_STATE_CLOSE_REQUESTED
00190A  788064     MOV [W4+W1], W0
00190C  500FE4     SUB W0, #0x4, [W15]
00190E  3E0009     BRA GTU, 0x1922
001910  510FE0     SUB W2, #0x0, [W15]
001912  598FE0     SUBB W3, #0x0, [W15]
001914  320006     BRA Z, 0x1922
243:                         && data_len > 0) {
244:                       adb_channels[h].recv_func(h, recv_data, data_len);
001916  200520     MOV #0x52, W0
001918  400001     ADD W0, W1, W0
00191A  780264     MOV [W4+W0], W4
00191C  780088     MOV W8, W1
00191E  780009     MOV W9, W0
001920  010004     CALL W4
245:                     }
246:                     adb_channels[h].pending_ack = TRUE;
001922  200540     MOV #0x54, W0
001924  B9C800     MUL.SS W9, W0, W0
001926  B00500     ADD #0x50, W0
001928  200013     MOV #0x1, W3
00192A  2188A2     MOV #0x188A, W2
00192C  783103     MOV W3, [W2+W0]
247:                   } else {
248:                     log_printf("Remote side sent a WRTE on an unexpected ID: 0x%lx", arg1);
249:                   }
250:                   break;
251:               
252:                  default:
253:                   log_printf("Unknown command 0x%lx. Ignoring.", cmd);
254:                 }
255:               }
256:               
257:               ADB_CHANNEL_HANDLE ADBOpen(const char* name, ADBChannelRecvFunc recv_func) {
002DC8  EB0580     CLR W11
002DCA  2188A0     MOV #0x188A, W0
002DCC  218D2C     MOV #0x18D2, W12
002DCE  218923     MOV #0x1892, W3
258:                 assert(name != NULL);
259:                 assert(strlen(name) < ADB_CHANNEL_NAME_MAX_LENGTH);
260:                 assert(recv_func != NULL);
261:                 // find a free channel
262:                 ADB_CHANNEL_HANDLE h;
263:                 for (h = 0; h < ADB_MAX_CHANNELS; ++h) {
002E14  E8058B     INC W11, W11
002E16  B00543     ADD #0x54, W3
002E18  B0054C     ADD #0x54, W12
002E1A  B00540     ADD #0x54, W0
002E1C  558FE8     SUB W11, #0x8, [W15]
002E1E  3AFFD8     BRA NZ, 0x2DD0
002E20  EB8580     SETM W11
264:                   if (adb_channels[h].state == ADB_CHAN_STATE_FREE) {
002DD0  E00010     CP0 [W0]
002DD2  3A0020     BRA NZ, 0x2E14
265:                     CHANGE_CHANNEL_STATE(h, ADB_CHAN_STATE_START);
002DD4  200548     MOV #0x54, W8
002DD6  B9DC08     MUL.SS W11, W8, W8
002DD8  2188AA     MOV #0x188A, W10
002DDA  200010     MOV #0x1, W0
002DDC  7C3500     MOV W0, [W10+W8]
266:                     strncpy(adb_channels[h].name, name, ADB_CHANNEL_NAME_MAX_LENGTH);
002DDE  200402     MOV #0x40, W2
002DE0  780084     MOV W4, W1
002DE2  780003     MOV W3, W0
002DE4  020524     CALL strncpy
002DE6  000000     NOP
267:                     adb_channels[h].pending_ack = FALSE;
002DE8  200500     MOV #0x50, W0
002DEA  400008     ADD W0, W8, W0
002DEC  EB0080     CLR W1
002DEE  783501     MOV W1, [W10+W0]
268:                     adb_channels[h].data = NULL;
002DF0  E88008     INC2 W8, W0
002DF2  783501     MOV W1, [W10+W0]
269:                     adb_channels[h].recv_func = recv_func;
002DF4  B00528     ADD #0x52, W8
002DF6  7C350D     MOV W13, [W10+W8]
270:                     adb_channels[h].local_id = (local_id_counter++) << 8 | h;
002DF8  80F9C0     MOV local_id_counter, W0
002DFA  80F9D1     MOV 0x1F3A, W1
002DFC  DD0A48     SL W1, #8, W4
002DFE  DE02C8     LSR W0, #8, W5
002E00  720285     IOR W4, W5, W5
002E02  DD0248     SL W0, #8, W4
002E04  B95961     MUL.SU W11, #1, W2
002E06  721E02     IOR W4, W2, [W12++]
002E08  729603     IOR W5, W3, [W12--]
002E0A  400061     ADD W0, #0x1, W0
002E0C  4880E0     ADDC W1, #0x0, W1
002E0E  88F9C0     MOV W0, local_id_counter
002E10  88F9D1     MOV W1, 0x1F3A
002E12  370007     BRA 0x2E22
271:                     log_printf("Trying to open channel %d with local ID 0x%lx, name: %s", h,
272:                                 adb_channels[h].local_id, name);
273:                     return h;
274:                   }
275:                 }
276:                 return ADB_INVALID_CHANNEL_HANDLE;
277:               }
278:               
279:               void ADBClose(ADB_CHANNEL_HANDLE handle) {
280:                 assert(handle >= 0 && handle < ADB_MAX_CHANNELS);
281:                 if (adb_channels[handle].state > ADB_CHAN_STATE_FREE) {
00387C  200540     MOV #0x54, W0
00387E  B98800     MUL.SS W1, W0, W0
003880  780080     MOV W0, W1
003882  2188A2     MOV #0x188A, W2
003884  780062     MOV [W2+W0], W0
003886  E00000     CP0 W0
003888  320002     BRA Z, 0x388E
282:                   CHANGE_CHANNEL_STATE(handle, ADB_CHAN_STATE_CLOSE_REQUESTED);
283:                 }
284:               }
285:               
286:               BOOL ADBChannelReady(ADB_CHANNEL_HANDLE handle) {
287:                 return adb_channels[handle].state == ADB_CHAN_STATE_IDLE && adb_channels[handle].data == NULL;
0037B2  200540     MOV #0x54, W0
0037B4  B98800     MUL.SS W1, W0, W0
0037B6  780080     MOV W0, W1
0037B8  2188A2     MOV #0x188A, W2
0037BA  780062     MOV [W2+W0], W0
0037BC  500FE3     SUB W0, #0x3, [W15]
0037BE  3A0005     BRA NZ, 0x37CA
0037C0  E88001     INC2 W1, W0
0037C2  780062     MOV [W2+W0], W0
0037C4  200011     MOV #0x1, W1
0037C6  E00000     CP0 W0
0037C8  320001     BRA Z, 0x37CC
0037CA  EB0080     CLR W1
288:               }
289:               
290:               void ADBWrite(ADB_CHANNEL_HANDLE handle, const void* data, UINT32 data_len) {
291:                 assert(handle >= 0 && handle < ADB_MAX_CHANNELS);
292:                 assert(adb_channels[handle].state == ADB_CHAN_STATE_IDLE);
293:                 adb_channels[handle].data = data;
003892  200540     MOV #0x54, W0
003894  B9A200     MUL.SS W4, W0, W4
003896  780284     MOV W4, W5
003898  E88204     INC2 W4, W4
00389A  2188A0     MOV #0x188A, W0
00389C  7A3001     MOV W1, [W0+W4]
294:                 adb_channels[handle].data_len = data_len;
00389E  428000     ADD W5, W0, W0
0038A0  980022     MOV W2, [W0+4]
0038A2  980033     MOV W3, [W0+6]
295:               }
296:               
297:               ADB_RESULT ADBWriteStatus();
298:               void ADBRead(ADB_CHANNEL_HANDLE handle);
299:               ADB_RESULT ADBReadStatus(ADB_CHANNEL_HANDLE handle, void** data, UINT32* data_len);
300:               
301:               void ADBInit() {
302:                 memset(adb_channels, 0, sizeof adb_channels);
0038CA  202A02     MOV #0x2A0, W2
0038CC  EB0080     CLR W1
0038CE  2188A0     MOV #0x188A, W0
0038D0  020516     CALL memset
0038D2  000000     NOP
303:                 CHANGE_STATE(adb_conn_state, ADB_CONN_STATE_WAIT_ATTACH);
0038D4  200010     MOV #0x1, W0
0038D6  88D950     MOV W0, adb_conn_state
304:               }
305:               
306:               int ADBTasks() {
307:                 ADB_RESULT adb_res;
308:                 UINT32 cmd, arg0, arg1, data_len;
309:                 void* recv_data;
310:               
311:               
312:                 if (adb_conn_state > ADB_CONN_STATE_WAIT_ATTACH) {
0017EA  80D950     MOV adb_conn_state, W0
0017EC  500FE1     SUB W0, #0x1, [W15]
0017EE  3600A1     BRA LEU, 0x1932
313:                   if (!ADBAttached()) {
0017F0  80E090     MOV 0x1C12, W0
0017F2  A30800     BTST.Z W0, #0
0017F4  3A0004     BRA NZ, 0x17FE
314:                     // detached
315:                     ADBReset();
0017F6  023672     CALL ADBReset
0017F8  000000     NOP
0017FA  EB0080     CLR W1
0017FC  370137     BRA 0x1A6C
316:                     return 0;
317:                   }
318:                   ADBPacketTasks();
0017FE  022714     CALL ADBPacketTasks
001800  000000     NOP
319:                   if (adb_buffer_refcount > 0) {
001802  80C440     MOV adb_buffer_refcount, W0
001804  E00000     CP0 W0
001806  320095     BRA Z, 0x1932
320:                     if ((adb_res = ADBPacketRecvStatus(&cmd, &arg0, &arg1, &recv_data, &data_len)) != ADB_RESULT_BUSY) {
001808  57826C     SUB W15, #0xC, W4
00180A  5781FA     SUB W15, #0x1A, W3
00180C  578170     SUB W15, #0x10, W2
00180E  5780F4     SUB W15, #0x14, W1
001810  578078     SUB W15, #0x18, W0
001812  0235DA     CALL ADBPacketRecvStatus
001814  000000     NOP
001816  500FE2     SUB W0, #0x2, [W15]
001818  32008C     BRA Z, 0x1932
321:                       if (adb_res == ADB_RESULT_ERROR) {
00181A  500FE1     SUB W0, #0x1, [W15]
00181C  3A0002     BRA NZ, 0x1822
322:                         CHANGE_STATE(adb_conn_state, ADB_CONN_STATE_ERROR);
00181E  EB0000     CLR W0
001820  370023     BRA 0x1868
323:                       } else {
324:                         ADBHandlePacket(cmd, arg0, arg1, recv_data, data_len);
001822  97B92F     MOV [W15-12], W2
001824  97B9BF     MOV [W15-10], W3
001826  97BB0F     MOV [W15-16], W6
001828  97BB9F     MOV [W15-14], W7
00182A  97B56F     MOV [W15-20], W10
00182C  97B5FF     MOV [W15-18], W11
00182E  97B43F     MOV [W15-26], W8
325:                       }
326:                       ADBBufferUnref();
00192E  023860     CALL ADBBufferUnref
001930  000000     NOP
327:                     }
328:                   }
329:                 }
330:               
331:                 switch (adb_conn_state) {
001932  80D958     MOV adb_conn_state, W8
001934  540FE1     SUB W8, #0x1, [W15]
001936  320004     BRA Z, 0x1940
001938  390046     BRA NC, 0x19C6
00193A  540FE3     SUB W8, #0x3, [W15]
00193C  3A0092     BRA NZ, 0x1A62
00193E  37001A     BRA 0x1974
332:                  case ADB_CONN_STATE_WAIT_ATTACH:
333:                   if (ADBAttached()) {
001940  80E090     MOV 0x1C12, W0
001942  A30800     BTST.Z W0, #0
001944  32008E     BRA Z, 0x1A62
334:                     log_printf("Device attached.");
335:                     ADBPacketReset();
001946  02390A     CALL ADBPacketReset
001948  000000     NOP
336:                     adb_buffer_refcount = 1;
00194A  88C448     MOV W8, adb_buffer_refcount
337:                     ADBPacketRecv();  // start receiving
00194C  023918     CALL ADBPacketRecv
00194E  000000     NOP
338:                     ADBPacketSend(ADB_CNXN, ADB_VERSION, ADB_PACKET_MAX_RECV_DATA_BYTES, ADB_HOSTNAME_STRING, strlen(ADB_HOSTNAME_STRING) + 1);
001950  21F300     MOV #0x1F30, W0
001952  020552     CALL strlen
001954  000000     NOP
001956  E80000     INC W0, W0
001958  200001     MOV #0x0, W1
00195A  BE9F80     MOV.D W0, [W15++]
00195C  21F306     MOV #0x1F30, W6
00195E  210004     MOV #0x1000, W4
001960  200005     MOV #0x0, W5
001962  200002     MOV #0x0, W2
001964  201003     MOV #0x100, W3
001966  24E430     MOV #0x4E43, W0
001968  24E581     MOV #0x4E58, W1
00196A  02332C     CALL ADBPacketSend
00196C  000000     NOP
339:                     CHANGE_STATE(adb_conn_state, ADB_CONN_STATE_WAIT_CONNECT);
00196E  200020     MOV #0x2, W0
001970  88D950     MOV W0, adb_conn_state
001972  370076     BRA 0x1A60
340:                   }
341:                   break;
342:               
343:                  case ADB_CONN_STATE_WAIT_CONNECT:
344:                   break;
345:               
346:                  case ADB_CONN_STATE_CONNECTED:
347:                   ADBChannelTasks();
348:                   break;
349:               
350:                  case ADB_CONN_STATE_ERROR:
351:                   log_printf("Error occured. Resetting.");
352:                   ADBReset();
0019C6  023672     CALL ADBReset
0019C8  000000     NOP
0019CA  EB8080     SETM W1
0019CC  37004F     BRA 0x1A6C
353:                   return -1;
354:                 }
355:               
356:                 return ADBConnected();
001A62  EB0080     CLR W1
001A64  80D950     MOV adb_conn_state, W0
001A66  500FE2     SUB W0, #0x2, [W15]
001A68  360001     BRA LEU, 0x1A6C
001A6A  200011     MOV #0x1, W1
357:               }
358:               
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/bootloader/xml.c  --------
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include "xml.h"
31:                
32:                #include <assert.h>
33:                
34:                void XMLInit(XML_CONTEXT* context) {
35:                  assert(context);
36:                  context->state = XML_STATE_CHARACTERS;
001538  EB0080     CLR W1
00153A  988031     MOV W1, [W0+134]
37:                  context->buf_pos = 0;
00153C  988001     MOV W1, [W0+128]
38:                }
001540  781F88     MOV W8, [W15++]
001542  780400     MOV W0, W8
001544  780101     MOV W1, W2
39:                
40:                static void FlushBuf(XML_CONTEXT* context, XML_CALLBACKS* callbacks) {
41:                  context->buf[context->buf_pos] = '\0';
001546  908080     MOV [W0+128], W1
001548  400001     ADD W0, W1, W0
00154A  EB4800     CLR.B [W0]
42:                  switch (context->state) {
00154C  908038     MOV [W8+134], W0
00154E  500FE3     SUB W0, #0x3, [W15]
001550  320020     BRA Z, 0x1592
001552  3E0005     BRA GTU, 0x155E
001554  E00000     CP0 W0
001556  32000A     BRA Z, 0x156C
001558  500FE1     SUB W0, #0x1, [W15]
00155A  3A0023     BRA NZ, 0x15A2
00155C  37000E     BRA 0x157A
00155E  500FE7     SUB W0, #0x7, [W15]
001560  320005     BRA Z, 0x156C
001562  500FE9     SUB W0, #0x9, [W15]
001564  32001B     BRA Z, 0x159C
001566  500FE4     SUB W0, #0x4, [W15]
001568  3A001C     BRA NZ, 0x15A2
00156A  370016     BRA 0x1598
43:                    case XML_STATE_CHARACTERS:
44:                    case XML_STATE_ATTRIBUTE_VALUE:
45:                      if (context->buf_pos) {
00156C  908088     MOV [W8+128], W1
00156E  E00001     CP0 W1
001570  320018     BRA Z, 0x15A2
46:                        callbacks->Characters(context->buf, context->buf_pos);
001572  900142     MOV [W2+8], W2
001574  780008     MOV W8, W0
001576  010002     CALL W2
001578  370014     BRA 0x15A2
47:                      }
48:                      break;
49:                
50:                    case XML_STATE_ELEMENT_NAME:
51:                      if (context->buf_pos) {
00157A  E00001     CP0 W1
00157C  320005     BRA Z, 0x1588
52:                        if (!context->is_proc_inst) {
00157E  908028     MOV [W8+132], W0
001580  E00000     CP0 W0
001582  3A000F     BRA NZ, 0x15A2
53:                          callbacks->StartElement(context->buf);
001584  780092     MOV [W2], W1
001586  37000B     BRA 0x159E
54:                        }
55:                      } else {
56:                        callbacks->Error();
001588  900052     MOV [W2+10], W0
00158A  010000     CALL W0
57:                        context->state = XML_STATE_ERROR;
00158C  2000B0     MOV #0xB, W0
00158E  988430     MOV W0, [W8+134]
001590  370008     BRA 0x15A2
58:                      }
59:                      break;
60:                
61:                    case XML_STATE_ELEMENT_OPEN_EMPTY:
62:                      callbacks->EndElement(0);
001592  900092     MOV [W2+2], W1
001594  EB0000     CLR W0
001596  370004     BRA 0x15A0
63:                      break;
64:                
65:                    case XML_STATE_ATTRIBUTE_NAME:
66:                      callbacks->StartAttribute(context->buf);
001598  9000A2     MOV [W2+4], W1
00159A  370001     BRA 0x159E
67:                      break;
68:                
69:                    case XML_STATE_ELEMENT_CLOSE_NAME:
70:                      callbacks->EndElement(context->buf);
00159C  900092     MOV [W2+2], W1
00159E  780008     MOV W8, W0
0015A0  010001     CALL W1
71:                      break;
72:                
73:                    default:
74:                      assert(0);
75:                  }
76:                  context->buf_pos = 0;
0015A2  EB0000     CLR W0
0015A4  988400     MOV W0, [W8+128]
77:                }
0015AA  BE9F88     MOV.D W8, [W15++]
0015AC  BE9F8A     MOV.D W10, [W15++]
0015AE  BE9F8C     MOV.D W12, [W15++]
0015B0  BE0600     MOV.D W0, W12
0015B2  780482     MOV W2, W9
0015B4  780503     MOV W3, W10
78:                
79:                void XMLProcess(const char* data, int size, XML_CONTEXT* context, XML_CALLBACKS* callbacks) {
0015B6  EB0580     CLR W11
0015B8  370104     BRA 0x17C2
80:                  assert(data);
81:                  assert(context);
82:                  assert(callbacks);
83:                
84:                  while (size-- && context->state != XML_STATE_ERROR) {
0017C2  558F8D     SUB W11, W13, [W15]
0017C4  320003     BRA Z, 0x17CC
0017C6  908139     MOV [W9+134], W2
0017C8  510FEB     SUB W2, #0xB, [W15]
0017CA  3AFEF7     BRA NZ, 0x15BA
85:                    char c = *data++;
0015BA  7E446B     MOV.B [W11+W12], W8
86:                    // make sure there are at least two characters remaining in the buffer
87:                    if (context->buf_pos > XML_BUF_SIZE - 2) {
0015BC  908089     MOV [W9+128], W1
0015BE  2007E0     MOV #0x7E, W0
0015C0  508F80     SUB W1, W0, [W15]
0015C2  34000D     BRA LE, 0x15DE
88:                      if (context->state == XML_STATE_CHARACTERS
0015C4  E00002     CP0 W2
0015C6  320002     BRA Z, 0x15CC
0015C8  510FE7     SUB W2, #0x7, [W15]
0015CA  3A0004     BRA NZ, 0x15D4
89:                          || context->state == XML_STATE_ATTRIBUTE_VALUE) {
90:                        FlushBuf(context, callbacks);
0015CC  78008A     MOV W10, W1
0015CE  780009     MOV W9, W0
0015D0  07FFB7     RCALL FlushBuf
0015D2  370005     BRA 0x15DE
91:                      } else {
92:                        callbacks->Error();
0015D4  90005A     MOV [W10+10], W0
0015D6  010000     CALL W0
93:                        context->state = XML_STATE_ERROR;
0015D8  2000B0     MOV #0xB, W0
0015DA  9884B0     MOV W0, [W9+134]
0015DC  3700FF     BRA 0x17DC
94:                        return;
95:                      }
96:                    }
97:                    switch (context->state) {
0015DE  908039     MOV [W9+134], W0
0015E0  200001     MOV #0x0, W1
0015E2  500FEA     SUB W0, #0xA, [W15]
0015E4  588FE0     SUBB W1, #0x0, [W15]
0015E6  3E00EC     BRA GTU, 0x17C0
0015E8  016000     BRA W0
0015EA  37000A     BRA 0x1600
0015EC  370013     BRA 0x1614
0015EE  37003A     BRA 0x1664
0015F0  37005F     BRA 0x16B0
0015F2  370068     BRA 0x16C4
0015F4  37007E     BRA 0x16F2
0015F6  370088     BRA 0x1708
0015F8  37009D     BRA 0x1734
0015FA  3700B1     BRA 0x175E
0015FC  3700BC     BRA 0x1776
0015FE  3700D7     BRA 0x17AE
98:                      case XML_STATE_CHARACTERS:
99:                        switch (c) {
001600  B3C3C0     MOV #0x3C, W0
001602  544F80     SUB.B W8, W0, [W15]
001604  3A00CF     BRA NZ, 0x17A4
100:                         case '<':
101:                           FlushBuf(context, callbacks);
001606  78008A     MOV W10, W1
001608  780009     MOV W9, W0
00160A  07FF9A     RCALL FlushBuf
102:                           context->state = XML_STATE_ELEMENT_NAME;
00160C  200010     MOV #0x1, W0
00160E  9884B0     MOV W0, [W9+134]
103:                           context->is_proc_inst = 0;
001610  EB0000     CLR W0
001612  370026     BRA 0x1660
104:                           break;
105:               
106:                         default:
107:                           context->buf[context->buf_pos++] = c;
108:                       }
109:                       break;
110:               
111:                     case XML_STATE_ELEMENT_NAME:
112:                       switch (c) {
001614  B3C200     MOV #0x20, W0
001616  544F80     SUB.B W8, W0, [W15]
001618  320012     BRA Z, 0x163E
00161A  3C0007     BRA GT, 0x162A
00161C  544FE9     SUB.B W8, #0x9, [W15]
00161E  3500C2     BRA LT, 0x17A4
001620  544FEA     SUB.B W8, #0xA, [W15]
001622  34000D     BRA LE, 0x163E
001624  544FED     SUB.B W8, #0xD, [W15]
001626  3A00BE     BRA NZ, 0x17A4
001628  37000A     BRA 0x163E
00162A  B3C3E0     MOV #0x3E, W0
00162C  544F80     SUB.B W8, W0, [W15]
00162E  3200B6     BRA Z, 0x179C
001630  E84000     INC.B W0, W0
001632  544F80     SUB.B W8, W0, [W15]
001634  320011     BRA Z, 0x1658
001636  504070     SUB.B W0, #0x10, W0
001638  544F80     SUB.B W8, W0, [W15]
00163A  3A00B4     BRA NZ, 0x17A4
00163C  370004     BRA 0x1646
113:                         case ' ':
114:                         case '\t':
115:                         case '\r':
116:                         case '\n':
117:                           FlushBuf(context, callbacks);
00163E  78008A     MOV W10, W1
001640  780009     MOV W9, W0
001642  07FF7E     RCALL FlushBuf
001644  37008A     BRA 0x175A
118:                           context->state = XML_STATE_ELEMENT_OPEN;
119:                           break;
120:               
121:                         case '>':
122:                           FlushBuf(context, callbacks);
123:                           context->state = XML_STATE_CHARACTERS;
124:                           break;
125:               
126:                         case '/':
127:                           if (context->buf_pos) {
001646  908009     MOV [W9+128], W0
001648  E00000     CP0 W0
00164A  320004     BRA Z, 0x1654
128:                             FlushBuf(context, callbacks);
00164C  78008A     MOV W10, W1
00164E  780009     MOV W9, W0
001650  07FF77     RCALL FlushBuf
001652  370026     BRA 0x16A0
129:                             context->state = XML_STATE_ELEMENT_OPEN_EMPTY;
130:                           } else {
131:                             context->state = XML_STATE_ELEMENT_CLOSE_NAME;
001654  200090     MOV #0x9, W0
001656  3700B3     BRA 0x17BE
132:                           }
133:                           break;
134:               
135:                         case '?':
136:                           if (context->buf_pos == 0) {
001658  908009     MOV [W9+128], W0
00165A  E00000     CP0 W0
00165C  3A00A3     BRA NZ, 0x17A4
137:                             context->is_proc_inst = 1;
00165E  200010     MOV #0x1, W0
001660  9884A0     MOV W0, [W9+132]
001662  3700AE     BRA 0x17C0
138:                             break;
139:                           }
140:                           // fall-through on purpose
141:               
142:                         default:
143:                           // TODO: validate name characters
144:                           context->buf[context->buf_pos++] = c;
145:                       }
146:                       break;
147:               
148:                     case XML_STATE_ELEMENT_OPEN:
149:                       assert(context->buf_pos == 0);
150:                       switch (c) {
001664  B3C200     MOV #0x20, W0
001666  544F80     SUB.B W8, W0, [W15]
001668  3200AB     BRA Z, 0x17C0
00166A  3C0007     BRA GT, 0x167A
00166C  544FE9     SUB.B W8, #0x9, [W15]
00166E  35001A     BRA LT, 0x16A4
001670  544FEA     SUB.B W8, #0xA, [W15]
001672  3400A6     BRA LE, 0x17C0
001674  544FED     SUB.B W8, #0xD, [W15]
001676  3A0016     BRA NZ, 0x16A4
001678  3700A3     BRA 0x17C0
00167A  B3C3E0     MOV #0x3E, W0
00167C  544F80     SUB.B W8, W0, [W15]
00167E  320007     BRA Z, 0x168E
001680  E84000     INC.B W0, W0
001682  544F80     SUB.B W8, W0, [W15]
001684  320008     BRA Z, 0x1696
001686  504070     SUB.B W0, #0x10, W0
001688  544F80     SUB.B W8, W0, [W15]
00168A  3A000C     BRA NZ, 0x16A4
00168C  370009     BRA 0x16A0
151:                         case ' ':
152:                         case '\t':
153:                         case '\r':
154:                         case '\n':
155:                           break;
156:               
157:                         case '>':
158:                           if (!context->is_proc_inst) {
00168E  908029     MOV [W9+132], W0
001690  E00000     CP0 W0
001692  320095     BRA Z, 0x17BE
001694  370091     BRA 0x17B8
159:                             context->state = XML_STATE_CHARACTERS;
160:                           } else {
161:                             callbacks->Error();
162:                             context->state = XML_STATE_ERROR;
163:                           }
164:                           break;
165:               
166:                         case '?':
167:                           if (context->is_proc_inst) {
001696  908029     MOV [W9+132], W0
001698  E00000     CP0 W0
00169A  32008E     BRA Z, 0x17B8
168:                             context->state = XML_STATE_PROC_INST_WAIT_CLOSE;
00169C  2000A0     MOV #0xA, W0
00169E  37008F     BRA 0x17BE
169:                           } else {
170:                             callbacks->Error();
171:                             context->state = XML_STATE_ERROR;
172:                           }
173:                           break;
174:               
175:                         case '/':
176:                           context->state = XML_STATE_ELEMENT_OPEN_EMPTY;
0016A0  200030     MOV #0x3, W0
0016A2  37008D     BRA 0x17BE
177:                           break;
178:               
179:                         default:
180:                           // TODO: validate name characters
181:                           context->buf[context->buf_pos++] = c;
0016A4  908009     MOV [W9+128], W0
0016A6  787488     MOV.B W8, [W9+W0]
0016A8  E80000     INC W0, W0
0016AA  988480     MOV W0, [W9+128]
182:                           context->state = XML_STATE_ATTRIBUTE_NAME;
0016AC  200040     MOV #0x4, W0
0016AE  370087     BRA 0x17BE
183:                       }
184:                       break;
185:               
186:                     case XML_STATE_ELEMENT_OPEN_EMPTY:
187:                       switch (c) {
0016B0  544FED     SUB.B W8, #0xD, [W15]
0016B2  320086     BRA Z, 0x17C0
0016B4  340057     BRA LE, 0x1764
0016B6  B3C200     MOV #0x20, W0
0016B8  544F80     SUB.B W8, W0, [W15]
0016BA  320082     BRA Z, 0x17C0
0016BC  40407E     ADD.B W0, #0x1E, W0
0016BE  544F80     SUB.B W8, W0, [W15]
0016C0  3A007B     BRA NZ, 0x17B8
0016C2  37006C     BRA 0x179C
188:                         case ' ':
189:                         case '\t':
190:                         case '\r':
191:                         case '\n':
192:                           break;
193:               
194:                         case '>':
195:                           FlushBuf(context, callbacks);
196:                           context->state = XML_STATE_CHARACTERS;
197:                           break;
198:               
199:                         default:
200:                           callbacks->Error();
201:                           context->state = XML_STATE_ERROR;
202:                       }
203:                       break;
204:               
205:                     case XML_STATE_ATTRIBUTE_NAME:
206:                       switch (c) {
0016C4  544FED     SUB.B W8, #0xD, [W15]
0016C6  32000C     BRA Z, 0x16E0
0016C8  3C0004     BRA GT, 0x16D2
0016CA  544069     SUB.B W8, #0x9, W0
0016CC  504FE1     SUB.B W0, #0x1, [W15]
0016CE  3E006A     BRA GTU, 0x17A4
0016D0  370007     BRA 0x16E0
0016D2  B3C200     MOV #0x20, W0
0016D4  544F80     SUB.B W8, W0, [W15]
0016D6  320004     BRA Z, 0x16E0
0016D8  40407D     ADD.B W0, #0x1D, W0
0016DA  544F80     SUB.B W8, W0, [W15]
0016DC  3A0063     BRA NZ, 0x17A4
0016DE  370005     BRA 0x16EA
207:                         case ' ':
208:                         case '\t':
209:                         case '\r':
210:                         case '\n':
211:                           FlushBuf(context, callbacks);
0016E0  78008A     MOV W10, W1
0016E2  780009     MOV W9, W0
0016E4  07FF2D     RCALL FlushBuf
212:                           context->state = XML_STATE_ATTRIBUTE_WAIT_EQ;
0016E6  200050     MOV #0x5, W0
0016E8  37006A     BRA 0x17BE
213:                           break;
214:               
215:                         case '=':
216:                           FlushBuf(context, callbacks);
0016EA  78008A     MOV W10, W1
0016EC  780009     MOV W9, W0
0016EE  07FF28     RCALL FlushBuf
0016F0  370009     BRA 0x1704
217:                           context->state = XML_STATE_ATTRIBUTE_WAIT_QUOT;
218:                           break;
219:               
220:                         default:
221:                           context->buf[context->buf_pos++] = c;
222:                       }
223:                       break;
224:               
225:                     case XML_STATE_ATTRIBUTE_WAIT_EQ:
226:                       switch (c) {
0016F2  544FED     SUB.B W8, #0xD, [W15]
0016F4  320065     BRA Z, 0x17C0
0016F6  340036     BRA LE, 0x1764
0016F8  B3C200     MOV #0x20, W0
0016FA  544F80     SUB.B W8, W0, [W15]
0016FC  320061     BRA Z, 0x17C0
0016FE  40407D     ADD.B W0, #0x1D, W0
001700  544F80     SUB.B W8, W0, [W15]
001702  3A005A     BRA NZ, 0x17B8
227:                         case ' ':
228:                         case '\t':
229:                         case '\r':
230:                         case '\n':
231:                           break;
232:               
233:                         case '=':
234:                           context->state = XML_STATE_ATTRIBUTE_WAIT_QUOT;
001704  200060     MOV #0x6, W0
001706  37005B     BRA 0x17BE
235:                           break;
236:               
237:                         default:
238:                           callbacks->Error();
239:                           context->state = XML_STATE_ERROR;
240:                       }
241:                       break;
242:               
243:                     case XML_STATE_ATTRIBUTE_WAIT_QUOT:
244:                       switch (c) {
001708  544FED     SUB.B W8, #0xD, [W15]
00170A  32005A     BRA Z, 0x17C0
00170C  34002B     BRA LE, 0x1764
00170E  B3C220     MOV #0x22, W0
001710  544F80     SUB.B W8, W0, [W15]
001712  320007     BRA Z, 0x1722
001714  404065     ADD.B W0, #0x5, W0
001716  544F80     SUB.B W8, W0, [W15]
001718  320008     BRA Z, 0x172A
00171A  504067     SUB.B W0, #0x7, W0
00171C  544F80     SUB.B W8, W0, [W15]
00171E  3A004C     BRA NZ, 0x17B8
001720  37004F     BRA 0x17C0
245:                         case ' ':
246:                         case '\t':
247:                         case '\r':
248:                         case '\n':
249:                           break;
250:               
251:                         case '"':
252:                           context->state = XML_STATE_ATTRIBUTE_VALUE;
001722  200070     MOV #0x7, W0
001724  9884B0     MOV W0, [W9+134]
253:                           context->attr_use_apos = 0;
001726  EB0000     CLR W0
001728  370003     BRA 0x1730
254:                           break;
255:               
256:                         case '\'':
257:                           context->state = XML_STATE_ATTRIBUTE_VALUE;
00172A  200070     MOV #0x7, W0
00172C  9884B0     MOV W0, [W9+134]
258:                           context->attr_use_apos = 1;
00172E  200010     MOV #0x1, W0
001730  988490     MOV W0, [W9+130]
001732  370046     BRA 0x17C0
259:                           break;
260:               
261:                         default:
262:                           callbacks->Error();
263:                           context->state = XML_STATE_ERROR;
264:                       }
265:                       break;
266:               
267:                     case XML_STATE_ATTRIBUTE_VALUE:
268:                       switch (c) {
001734  B3C220     MOV #0x22, W0
001736  544F80     SUB.B W8, W0, [W15]
001738  320004     BRA Z, 0x1742
00173A  404065     ADD.B W0, #0x5, W0
00173C  544F80     SUB.B W8, W0, [W15]
00173E  3A0032     BRA NZ, 0x17A4
001740  370004     BRA 0x174A
269:                         case '"':
270:                           if (!context->attr_use_apos) {
001742  908019     MOV [W9+130], W0
001744  E00000     CP0 W0
001746  3A002E     BRA NZ, 0x17A4
001748  370003     BRA 0x1750
271:                             FlushBuf(context, callbacks);
272:                             callbacks->EndAttribute();
273:                             context->state = XML_STATE_ELEMENT_OPEN;
274:                           } else {
275:                             context->buf[context->buf_pos++] = c;
276:                           }
277:                           break;
278:               
279:                         case '\'':
280:                           if (context->attr_use_apos) {
00174A  908019     MOV [W9+130], W0
00174C  E00000     CP0 W0
00174E  32002A     BRA Z, 0x17A4
281:                             FlushBuf(context, callbacks);
001750  78008A     MOV W10, W1
001752  780009     MOV W9, W0
001754  07FEF5     RCALL FlushBuf
282:                             callbacks->EndAttribute();
001756  90003A     MOV [W10+6], W0
001758  010000     CALL W0
283:                             context->state = XML_STATE_ELEMENT_OPEN;
00175A  200020     MOV #0x2, W0
00175C  370030     BRA 0x17BE
284:                           } else {
285:                             context->buf[context->buf_pos++] = c;
286:                           }
287:                           break;
288:               
289:                         default:
290:                           context->buf[context->buf_pos++] = c;
291:                       }
292:                       break;
293:               
294:                     case XML_STATE_ELEMENT_CLOSE:
295:                       switch (c) {
00175E  544FED     SUB.B W8, #0xD, [W15]
001760  32002F     BRA Z, 0x17C0
001762  3C0004     BRA GT, 0x176C
001764  544069     SUB.B W8, #0x9, W0
001766  504FE1     SUB.B W0, #0x1, [W15]
001768  3E0027     BRA GTU, 0x17B8
00176A  37002A     BRA 0x17C0
00176C  B3C200     MOV #0x20, W0
00176E  544F80     SUB.B W8, W0, [W15]
001770  320027     BRA Z, 0x17C0
001772  40407E     ADD.B W0, #0x1E, W0
001774  37001D     BRA 0x17B0
296:                         case ' ':
297:                         case '\t':
298:                         case '\r':
299:                         case '\n':
300:                           break;
301:               
302:                         case '>':
303:                           context->state = XML_STATE_CHARACTERS;
304:                           break;
305:               
306:                         default:
307:                           callbacks->Error();
308:                           context->state = XML_STATE_ERROR;
309:                       }
310:                       break;
311:               
312:                     case XML_STATE_ELEMENT_CLOSE_NAME:
313:                       switch (c) {
001776  544FED     SUB.B W8, #0xD, [W15]
001778  32000C     BRA Z, 0x1792
00177A  3C0004     BRA GT, 0x1784
00177C  544069     SUB.B W8, #0x9, W0
00177E  504FE1     SUB.B W0, #0x1, [W15]
001780  3E0011     BRA GTU, 0x17A4
001782  370007     BRA 0x1792
001784  B3C200     MOV #0x20, W0
001786  544F80     SUB.B W8, W0, [W15]
001788  320004     BRA Z, 0x1792
00178A  40407E     ADD.B W0, #0x1E, W0
00178C  544F80     SUB.B W8, W0, [W15]
00178E  3A000A     BRA NZ, 0x17A4
001790  370005     BRA 0x179C
314:                         case ' ':
315:                         case '\t':
316:                         case '\r':
317:                         case '\n':
318:                           FlushBuf(context, callbacks);
001792  78008A     MOV W10, W1
001794  780009     MOV W9, W0
001796  07FED4     RCALL FlushBuf
319:                           context->state = XML_STATE_ELEMENT_CLOSE;
001798  200080     MOV #0x8, W0
00179A  370011     BRA 0x17BE
320:                           break;
321:               
322:                         case '>':
323:                           FlushBuf(context, callbacks);
00179C  78008A     MOV W10, W1
00179E  780009     MOV W9, W0
0017A0  07FECF     RCALL FlushBuf
0017A2  370008     BRA 0x17B4
324:                           context->state = XML_STATE_CHARACTERS;
325:                           break;
326:               
327:                         default:
328:                           context->buf[context->buf_pos++] = c;
0017A4  908009     MOV [W9+128], W0
0017A6  787488     MOV.B W8, [W9+W0]
0017A8  E80000     INC W0, W0
0017AA  988480     MOV W0, [W9+128]
0017AC  370009     BRA 0x17C0
329:                       }
330:                       break;
331:               
332:                     case XML_STATE_PROC_INST_WAIT_CLOSE:
333:                       if (c == '>') {
0017AE  B3C3E0     MOV #0x3E, W0
0017B0  544F80     SUB.B W8, W0, [W15]
0017B2  3A0002     BRA NZ, 0x17B8
334:                         context->state = XML_STATE_CHARACTERS;
0017B4  EB0000     CLR W0
0017B6  370003     BRA 0x17BE
335:                       } else {
336:                         callbacks->Error();
0017B8  90005A     MOV [W10+10], W0
0017BA  010000     CALL W0
337:                         context->state = XML_STATE_ERROR;
0017BC  2000B0     MOV #0xB, W0
0017BE  9884B0     MOV W0, [W9+134]
0017C0  E8058B     INC W11, W11
338:                       }
339:                       break;
340:               
341:                     default:
342:                       assert(0);
343:                   }
344:                 }
345:                 if (context->state == XML_STATE_CHARACTERS || context->state == XML_STATE_ATTRIBUTE_VALUE) {
0017CC  908039     MOV [W9+134], W0
0017CE  E00000     CP0 W0
0017D0  320002     BRA Z, 0x17D6
0017D2  500FE7     SUB W0, #0x7, [W15]
0017D4  3A0003     BRA NZ, 0x17DC
346:                   FlushBuf(context, callbacks);
0017D6  78008A     MOV W10, W1
0017D8  780009     MOV W9, W0
0017DA  07FEB2     RCALL FlushBuf
347:                 }
348:               }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/bootloader/main.c  -------
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                // Bootloader main
31:                
32:                #include <string.h>
33:                #include "GenericTypeDefs.h"
34:                #include "HardwareProfile.h"
35:                #include "board.h"
36:                #include "bootloader_defs.h"
37:                #include "libadb/adb.h"
38:                #include "libadb/adb_file.h"
39:                #include "bootloader_conn.h"
40:                #include "flash.h"
41:                #include "logging.h"
42:                #include "ioio_file.h"
43:                #include "dumpsys.h"
44:                #include "auth.h"
45:                
46:                //
47:                // Desired behavior:
48:                // 1. Wait for ADB connection.
49:                // 2. Find directory of manager app. If not found, skip to step 8.
50:                // 3. Attempt to read fingerprint file.
51:                //    If read failed OR fingerprint is identical to the one we have, skip to
52:                //    step 8.
53:                // 4. Authenticate manager app. If failed, skip to step 8.
54:                // 5. Erase fingerprint. If failed, signal error.
55:                // 6. Read application image file and program Flash. If failed, signal error.
56:                // 7. Program new fingerprint. If failed, signal error.
57:                // 8. Run the application.
58:                //
59:                // When signaling error, only a reset gets us out of there.
60:                // A lost connection at any point gets us back to step 1.
61:                
62:                
63:                // *****************************************************************************
64:                // *****************************************************************************
65:                // Configuration Bits
66:                // *****************************************************************************
67:                // *****************************************************************************
68:                
69:                #if defined(__PIC24FJ256DA206__) || defined(__PIC24FJ128DA106__) || defined(__PIC24FJ128DA206__)
70:                  _CONFIG1(FWDTEN_OFF & ICS_PGx2 & GWRP_OFF & GCP_OFF & JTAGEN_OFF)
71:                  _CONFIG2(POSCMOD_NONE & IOL1WAY_ON & OSCIOFNC_ON & FCKSM_CSDCMD & FNOSC_FRCPLL & PLL96MHZ_ON & PLLDIV_NODIV & IESO_OFF)
72:                  _CONFIG3(WPDIS_WPDIS & WPFP_WPFP19 & WPCFG_WPCFGEN & WPEND_WPSTARTMEM & SOSCSEL_EC)
73:                #else
74:                  #error Unsupported target
75:                #endif
76:                
77:                // platform ID:
78:                // the platform ID is what maintains compatibility between the application
79:                // firmware image and the board / bootloader.
80:                // any application firmware image is given a platform ID for which it was built,
81:                // similarly, the bootloader holds a platform ID uniquely designating its own
82:                // binary interface and the underlying hardware.
83:                // the bootloader will only attempt to install a firmware image with a matching
84:                // platform ID.
85:                // boards that are completely electrically equivalent and have the same pin
86:                // numbering scheme and the same bootloader interface, will have identical
87:                // platform IDs.
88:                //
89:                // note that when BLAPI changes, this list will need to be completely rebuilt
90:                // with new numbers per hardware version.
91:                #if BOARD_VER == BOARD_SPRK0010
92:                  #define PLATFORM_ID "IOIO0020"
93:                #elif BOARD_VER >= BOARD_SPRK0011 && BOARD_VER <= BOARD_SPRK0012
94:                  #define PLATFORM_ID "IOIO0021"
95:                #elif BOARD_VER >= BOARD_SPRK0013 && BOARD_VER <= BOARD_SPRK0015
96:                  #define PLATFORM_ID "IOIO0022"
97:                #elif BOARD_VER == BOARD_SPRK0016
98:                  #define PLATFORM_ID "IOIO0023"
99:                #elif BOARD_VER == BOARD_MINT0010
100:                 #define PLATFORM_ID "IOIO0023"
101:               #else
102:                 #error Unknown board version - cannot determine platform ID
103:               #endif
104:               
105:               #define FINGERPRINT_SIZE 16
106:               #define MAX_PATH 64
107:               
108:               int pass_usb_to_app __attribute__ ((near, section("bootflag.sec"))) = 0;
109:               
110:               void InitializeSystem() {
111:                 mInitAllLEDs();
001CCE  A962E8     BCLR TRISF, #3
001CD0  A862EC     BSET LATF, #3
001E2C  A962E8     BCLR TRISF, #3
001E2E  A862EC     BSET LATF, #3
112:               }
001CD4  BE9F88     MOV.D W8, [W15++]
001CD6  781F8A     MOV W10, [W15++]
113:               
114:               typedef enum {
115:                 MAIN_STATE_WAIT_CONNECT,
116:                 MAIN_STATE_WAIT_ADB_READY,
117:                 MAIN_STATE_FIND_PATH,
118:                 MAIN_STATE_FIND_PATH_DONE,
119:                 MAIN_STATE_AUTH_MANAGER,
120:                 MAIN_STATE_AUTH_PASSED,
121:                 MAIN_STATE_WAIT_RECV_FP,
122:                 MAIN_STATE_FP_FAILED,
123:                 MAIN_STATE_WAIT_RECV_IMAGE,
124:                 MAIN_STATE_RECV_IMAGE_DONE,
125:                 MAIN_STATE_RUN_APP,
126:                 MAIN_STATE_ERROR
127:               } MAIN_STATE;
128:               
129:               static MAIN_STATE state = MAIN_STATE_WAIT_CONNECT;
130:               static int fingerprint_size;
131:               static BYTE fingerprint[FINGERPRINT_SIZE];
132:               static const char* manager_path;
133:               char filepath[MAX_PATH];
134:               static AUTH_RESULT auth_result;
135:               static int led_counter = 0;
136:               
137:               BOOL ValidateFingerprint() {
001CD8  2A7008     MOV #0xA700, W8
001CDA  200029     MOV #0x2, W9
001CDC  21E5AA     MOV #0x1E5A, W10
138:                 int i;
139:                 DWORD addr = BOOTLOADER_FINGERPRINT_ADDRESS;
140:                 BYTE* fp = fingerprint;
141:                 for (i = 0; i < FINGERPRINT_SIZE / 2; ++i) {
001CFA  2A7100     MOV #0xA710, W0
001CFC  200021     MOV #0x2, W1
001CFE  540F80     SUB W8, W0, [W15]
001D00  5C8F81     SUBB W9, W1, [W15]
001D02  3AFFED     BRA NZ, 0x1CDE
001D04  200010     MOV #0x1, W0
001D06  370001     BRA 0x1D0A
001D08  EB0000     CLR W0
142:                   DWORD_VAL dw = {FlashReadDWORD(addr)};
001CDE  BE0008     MOV.D W8, W0
001CE0  070764     RCALL FlashReadDWORD
001CE2  BE0100     MOV.D W0, W2
143:                   if (*fp++ != dw.byte.LB) return FALSE;
001CE4  104F9A     SUBR.B W0, [W10], [W15]
001CE6  3A0010     BRA NZ, 0x1D08
144:                   if (*fp++ != dw.byte.HB) return FALSE;
001CE8  90409A     MOV.B [W10+1], W1
001CEA  E8850A     INC2 W10, W10
001CEC  DE1048     LSR W2, #8, W0
001CEE  50CF80     SUB.B W1, W0, [W15]
001CF0  3A000B     BRA NZ, 0x1D08
145:                   if (dw.word.HW != 0) return FALSE;
001CF2  E00003     CP0 W3
001CF4  3A0009     BRA NZ, 0x1D08
146:                   addr += 2;
001CF6  440462     ADD W8, #0x2, W8
001CF8  4C84E0     ADDC W9, #0x0, W9
147:                 }
148:                 return TRUE;
149:               }
150:               
151:               BOOL EraseFingerprint() {
152:                 return FlashErasePage(BOOTLOADER_FINGERPRINT_PAGE);
001D10  2A4000     MOV #0xA400, W0
001D12  200021     MOV #0x2, W1
001D14  3706F2     BRA FlashErasePage
153:               }
001D16  BE9F88     MOV.D W8, [W15++]
001D18  781F8A     MOV W10, [W15++]
154:               
155:               BOOL WriteFingerprint() {
001D1A  2A7008     MOV #0xA700, W8
001D1C  200029     MOV #0x2, W9
001D1E  21E5AA     MOV #0x1E5A, W10
156:                 int i;
157:                 DWORD addr = BOOTLOADER_FINGERPRINT_ADDRESS;
158:                 BYTE* fp = fingerprint;
159:                 for (i = 0; i < FINGERPRINT_SIZE / 2; ++i) {
001D3A  2A7100     MOV #0xA710, W0
001D3C  200021     MOV #0x2, W1
001D3E  540F80     SUB W8, W0, [W15]
001D40  5C8F81     SUBB W9, W1, [W15]
001D42  3AFFEE     BRA NZ, 0x1D20
001D44  200010     MOV #0x1, W0
160:                   DWORD_VAL dw = {0};
161:                   dw.byte.LB = *fp++;
001D20  B81160     MUL.UU W2, #0, W2
001D22  FB811A     ZE [W10], W2
162:                   dw.byte.HB = *fp++;
001D24  90401A     MOV.B [W10+1], W0
001D26  DD0048     SL W0, #8, W0
001D28  B20FF2     AND #0xFF, W2
001D2A  710100     IOR W2, W0, W2
001D2C  E8850A     INC2 W10, W10
163:                   if (!FlashWriteDWORD(addr, dw.Val)) return FALSE;
001D2E  BE0008     MOV.D W8, W0
001D30  0706FB     RCALL FlashWriteDWORD
001D32  E00000     CP0 W0
001D34  320008     BRA Z, 0x1D46
164:                   addr += 2;
001D36  440462     ADD W8, #0x2, W8
001D38  4C84E0     ADDC W9, #0x0, W9
165:                 }
166:                 return TRUE;
167:               }
001D4C  781F88     MOV W8, [W15++]
001D4E  780281     MOV W1, W5
168:               
169:               void FileRecvFingerprint(ADB_FILE_HANDLE h, const void* data, UINT32 data_len) {
170:                 if (data) {
001D50  E00001     CP0 W1
001D52  320014     BRA Z, 0x1D7C
171:                   if (fingerprint_size != -1 && data_len <= FINGERPRINT_SIZE - fingerprint_size) {
001D54  80F354     MOV fingerprint_size, W4
001D56  420FE1     ADD W4, #0x1, [W15]
001D58  32000E     BRA Z, 0x1D76
001D5A  120070     SUBR W4, #0x10, W0
001D5C  DE80CF     ASR W0, #15, W1
001D5E  510F80     SUB W2, W0, [W15]
001D60  598F81     SUBB W3, W1, [W15]
001D62  3E0009     BRA GTU, 0x1D76
172:                     memcpy(fingerprint + fingerprint_size, data, data_len);
001D64  780402     MOV W2, W8
001D66  21E5A0     MOV #0x1E5A, W0
001D68  420000     ADD W4, W0, W0
001D6A  780085     MOV W5, W1
001D6C  07F2F4     RCALL memcpy
173:                     fingerprint_size += data_len;
001D6E  80F350     MOV fingerprint_size, W0
001D70  440400     ADD W8, W0, W8
001D72  88F358     MOV W8, fingerprint_size
001D74  370010     BRA 0x1D96
174:                   } else {
175:                     fingerprint_size = -1;
001D76  EB8000     SETM W0
001D78  88F350     MOV W0, fingerprint_size
001D7A  37000D     BRA 0x1D96
176:                   }
177:                 } else {
178:                   // EOF or error
179:                   if (data_len == 0 && fingerprint_size == FINGERPRINT_SIZE) {
001D7C  510FE0     SUB W2, #0x0, [W15]
001D7E  598FE0     SUBB W3, #0x0, [W15]
001D80  3A0008     BRA NZ, 0x1D92
001D82  80F350     MOV fingerprint_size, W0
001D84  500FF0     SUB W0, #0x10, [W15]
001D86  3A0005     BRA NZ, 0x1D92
180:                     if (ValidateFingerprint()) {
001D88  07FFA5     RCALL ValidateFingerprint
001D8A  E00000     CP0 W0
001D8C  3A0002     BRA NZ, 0x1D92
181:                       // if all went OK and the fingerprint matches, skip download and run app
182:                       log_printf("Fingerprint match - skipping download");
183:                       state = MAIN_STATE_RUN_APP;
184:                     } else {
185:                       // if anything went wrong or fingerprint is different, force download
186:                       log_printf("Fingerprint mismatch - downloading image");
187:                       state = MAIN_STATE_FP_FAILED;
001D8E  200070     MOV #0x7, W0
001D90  370001     BRA 0x1D94
188:                     }
189:                   } else {
190:                     // failed to read fingerprint file, probably doesn't exist, run whatever we have
191:                     // if all went OK and the fingerprint matches, skip download and run app
192:                     log_printf("Couldn't find firmware to install");
193:                     state = MAIN_STATE_RUN_APP;
001D92  2000A0     MOV #0xA, W0
001D94  88F0A0     MOV W0, state
194:                   }
195:                 }
196:               }
001D9A  780001     MOV W1, W0
197:               
198:               void FileRecvImage(ADB_FILE_HANDLE h, const void* data, UINT32 data_len) {
199:                 if (data) {
001D9C  E00001     CP0 W1
001D9E  320006     BRA Z, 0x1DAC
200:                   if (!IOIOFileHandleBuffer(data, data_len)) {
001DA0  780082     MOV W2, W1
001DA2  070551     RCALL IOIOFileHandleBuffer
001DA4  E00000     CP0 W0
001DA6  3A000D     BRA NZ, 0x1DC2
201:                     state = MAIN_STATE_ERROR;
001DA8  2000B0     MOV #0xB, W0
001DAA  370007     BRA 0x1DBA
202:                   }
203:                 } else {
204:                   if (data_len == 0 && IOIOFileDone()) {
001DAC  510FE0     SUB W2, #0x0, [W15]
001DAE  598FE0     SUBB W3, #0x0, [W15]
001DB0  3A0006     BRA NZ, 0x1DBE
001DB2  0705B1     RCALL IOIOFileDone
001DB4  E00000     CP0 W0
001DB6  320003     BRA Z, 0x1DBE
205:                     log_printf("Successfully wrote application firmware image!");
206:                     state = MAIN_STATE_RECV_IMAGE_DONE;
001DB8  200090     MOV #0x9, W0
001DBA  88F0A0     MOV W0, state
001DBC  060000     RETURN
207:                   } else {
208:                     state = MAIN_STATE_ERROR;
001DC4  781F88     MOV W8, [W15++]
001DC6  780400     MOV W0, W8
001DC8  780201     MOV W1, W4
209:                   }
210:                 }
211:               }
212:               
213:               void FileRecvPackages(ADB_FILE_HANDLE h, const void* data, UINT32 data_len) {
214:                 if (data) {
001DCA  E00001     CP0 W1
001DCC  32000B     BRA Z, 0x1DE4
215:                   if (auth_result == AUTH_BUSY) {
001DCE  80F2B0     MOV auth_result, W0
001DD0  500FE3     SUB W0, #0x3, [W15]
001DD2  3A0008     BRA NZ, 0x1DE4
216:                     auth_result = AuthProcess(data, data_len);
001DD4  780082     MOV W2, W1
001DD6  780004     MOV W4, W0
001DD8  070289     RCALL AuthProcess
001DDA  88F2B0     MOV W0, auth_result
217:                     if (auth_result == AUTH_BUSY) {
001DDC  500FE3     SUB W0, #0x3, [W15]
001DDE  320009     BRA Z, 0x1DF2
218:                       return;
219:                     } else {
220:                       ADBFileClose(h);
001DE0  780008     MOV W8, W0
001DE2  070CD5     RCALL ADBFileClose
221:                     }
222:                   }
223:                 }
224:                 if (auth_result == AUTH_DONE_PASS) {
001DE4  80F2B0     MOV auth_result, W0
001DE6  E00000     CP0 W0
001DE8  3A0002     BRA NZ, 0x1DEE
225:                   log_printf("IOIO manager is authentic.");
226:                   state = MAIN_STATE_AUTH_PASSED;
001DEA  200050     MOV #0x5, W0
001DEC  370001     BRA 0x1DF0
227:                 } else {
228:                   log_printf("IOIO manager authentication failed. Skipping download.");
229:                   state = MAIN_STATE_RUN_APP;
001DEE  2000A0     MOV #0xA, W0
001DF0  88F0A0     MOV W0, state
230:                 }
231:               }
001DF6  781F88     MOV W8, [W15++]
001DF8  780400     MOV W0, W8
001DFA  780201     MOV W1, W4
232:               
233:               void RecvDumpsys(ADB_CHANNEL_HANDLE h, const void* data, UINT32 data_len) {
234:                 if (state != MAIN_STATE_FIND_PATH) return;
001DFC  80F0A0     MOV state, W0
001DFE  500FE2     SUB W0, #0x2, [W15]
001E00  3A0013     BRA NZ, 0x1E28
235:               
236:                 if (data) {
001E02  E00001     CP0 W1
001E04  32000F     BRA Z, 0x1E24
237:                   manager_path = DumpsysProcess(data, data_len);
001E06  780082     MOV W2, W1
001E08  780004     MOV W4, W0
001E0A  0707A2     RCALL DumpsysProcess
001E0C  88F2C0     MOV W0, manager_path
238:                   if (manager_path == DUMPSYS_BUSY) {
001E0E  80F081     MOV DUMPSYS_BUSY, W1
001E10  500F81     SUB W0, W1, [W15]
001E12  32000A     BRA Z, 0x1E28
239:                     // Not done yet.
240:                     return;
241:                   } else {
242:                     // Done.
243:                     ADBClose(h);
001E14  780008     MOV W8, W0
001E16  070D31     RCALL ADBClose
244:                     if (manager_path != DUMPSYS_ERROR) {
001E18  80F2C1     MOV manager_path, W1
001E1A  80FAA0     MOV DUMPSYS_ERROR, W0
001E1C  508F80     SUB W1, W0, [W15]
001E1E  320004     BRA Z, 0x1E28
245:                       log_printf("IOIO manager found with path %s", manager_path);
246:                       state = MAIN_STATE_FIND_PATH_DONE;
001E20  200030     MOV #0x3, W0
001E22  370001     BRA 0x1E26
247:                     }
248:                   }
249:                 } else {
250:                   log_printf("IOIO manager not found, skipping download");
251:                   state = MAIN_STATE_RUN_APP;
001E24  2000A0     MOV #0xA, W0
001E26  88F0A0     MOV W0, state
252:                 }
253:               }
254:               
255:               // When IOIO gets reset for an unexpected reason, its default behavior is to
256:               // restart normally. This is desired in most cases.
257:               // For debug purposes, however, we want to know what went wrong. With defining
258:               // SIGANAL_AFTER_BAD_RESET, on any reset other than power-on, IOIO will blink
259:               // a 16-bit code (long-1 short-0) to designtae the error.
260:               // One very useful case is catching failed asserts. Their blink code will start
261:               // with short-long-...
262:               #ifdef SIGNAL_AFTER_BAD_RESET
263:               static void Delay(unsigned long time) {
264:                 while (time-- > 0);
265:               }
266:               
267:               static void SignalBit(int bit) {
268:                 _LATF3 = 0;
269:                 Delay(bit ? 900000UL : 100000UL);
270:                 _LATF3 = 1;
271:                 Delay(bit ? 100000UL : 900000UL);
272:               }
273:               
274:               static void SignalWord(unsigned int word) {
275:                 int i;
276:                 for (i = 0; i < 16; ++i) {
277:                   SignalBit(word & 0x8000);
278:                   word <<= 1;
279:                 }
280:               }
281:               
282:               static void SignalRcon() {
283:                 _LATF3 = 1;
284:                 _TRISF3 = 0;
285:                 while (1) {
286:                  SignalWord(RCON);
287:                  Delay(8000000UL);
288:                 }
289:               }
290:               #endif
291:               
292:               int main() {
293:                 ADB_FILE_HANDLE f;
294:                 ADB_CHANNEL_HANDLE h;
295:               #ifdef SIGNAL_AFTER_BAD_RESET
296:                 if (RCON & 0b1100001001000000) {
297:                   SignalRcon();
298:                 }
299:               #endif
300:                 log_init();
301:                 log_printf("Hello from Bootloader!!!");
302:                 InitializeSystem();
303:                 BootloaderConnInit();
001E30  0706C1     RCALL BootloaderConnInit
304:               
305:                 while (1) {
306:                   BOOL connected = BootloaderConnTasks();
001E32  0706C6     RCALL BootloaderConnTasks
001E34  780100     MOV W0, W2
307:                   mLED_0 = (state == MAIN_STATE_ERROR) ? (led_counter++ >> 13) : !connected;
001E36  80F0A0     MOV state, W0
001E38  500FEB     SUB W0, #0xB, [W15]
001E3A  3A0006     BRA NZ, 0x1E48
001E3C  80F090     MOV led_counter, W0
001E3E  DE80CD     ASR W0, #13, W1
001E40  60C0E1     AND.B W1, #0x1, W1
001E42  E80000     INC W0, W0
001E44  88F090     MOV W0, led_counter
001E46  370006     BRA 0x1E54
001E48  EA0002     NEG W2, W0
001E4A  700002     IOR W0, W2, W0
001E4C  DE00CF     LSR W0, #15, W1
001E4E  B3C010     MOV #0x1, W0
001E50  504081     SUB.B W0, W1, W1
001E52  60C080     AND.B W1, W0, W1
001E54  60C0E1     AND.B W1, #0x1, W1
001E56  DD08C3     SL W1, #3, W1
001E58  BFC2EC     MOV.B LATF, WREG
001E5A  A13400     BCLR.B W0, #3
001E5C  704001     IOR.B W0, W1, W0
001E5E  B7E2EC     MOV.B WREG, LATF
308:                   if (!connected) {
001E60  E00002     CP0 W2
001E62  3A0001     BRA NZ, 0x1E66
309:                     state = MAIN_STATE_WAIT_CONNECT;
001E64  88F0A2     MOV W2, state
310:                   }
311:               
312:                   switch(state) {
001E66  80F0A0     MOV state, W0
001E68  500FE5     SUB W0, #0x5, [W15]
001E6A  320038     BRA Z, 0x1EDC
001E6C  3E0006     BRA GTU, 0x1E7A
001E6E  500FE1     SUB W0, #0x1, [W15]
001E70  320015     BRA Z, 0x1E9C
001E72  39000A     BRA NC, 0x1E88
001E74  500FE3     SUB W0, #0x3, [W15]
001E76  3AFFDD     BRA NZ, 0x1E32
001E78  37001C     BRA 0x1EB2
001E7A  500FE9     SUB W0, #0x9, [W15]
001E7C  32003E     BRA Z, 0x1EFA
001E7E  500FEA     SUB W0, #0xA, [W15]
001E80  320041     BRA Z, 0x1F04
001E82  500FE7     SUB W0, #0x7, [W15]
001E84  3AFFD6     BRA NZ, 0x1E32
001E86  370022     BRA 0x1ECC
313:                     case MAIN_STATE_WAIT_CONNECT:
314:                       if (connected) {
001E88  E00002     CP0 W2
001E8A  32FFD3     BRA Z, 0x1E32
315:                         log_printf("Device connected!");
316:                         if (ADBAttached()) {
001E8C  070D42     RCALL ADBAttached
001E8E  E00000     CP0 W0
001E90  320002     BRA Z, 0x1E96
317:                           log_printf("ADB attached - attempting firmware upgrade");
318:                           state = MAIN_STATE_WAIT_ADB_READY;
001E92  200010     MOV #0x1, W0
001E94  370001     BRA 0x1E98
319:                         } else {
320:                           log_printf("ADB not attached - skipping boot sequence");
321:                           state = MAIN_STATE_RUN_APP;
001E96  2000A0     MOV #0xA, W0
001E98  88F0A0     MOV W0, state
001E9A  37FFCB     BRA 0x1E32
322:                         }
323:                       }
324:                       break;
325:               
326:                     case MAIN_STATE_WAIT_ADB_READY:
327:                       if (ADBConnected()) {
001E9C  070D26     RCALL ADBConnected
001E9E  E00000     CP0 W0
001EA0  32FFC8     BRA Z, 0x1E32
328:                           log_printf("ADB connected - starting boot sequence");
329:                           manager_path = DUMPSYS_BUSY;
001EA2  80F080     MOV DUMPSYS_BUSY, W0
001EA4  88F2C0     MOV W0, manager_path
330:                           DumpsysInit();
001EA6  070750     RCALL DumpsysInit
331:                           h = ADBOpen("shell:dumpsys package ioio.manager", &RecvDumpsys);
001EA8  21DF61     MOV #0x1DF6, W1
001EAA  21D800     MOV #0x1D80, W0
001EAC  070788     RCALL ADBOpen
332:                           state = MAIN_STATE_FIND_PATH;
001EAE  200020     MOV #0x2, W0
001EB0  37FFF3     BRA 0x1E98
333:                       }
334:                       break;
335:               
336:                     case MAIN_STATE_FIND_PATH_DONE:
337:                       fingerprint_size = 0;
001EB2  EB0000     CLR W0
001EB4  88F350     MOV W0, fingerprint_size
338:                       strcpy(filepath, manager_path);
001EB6  80F2C1     MOV manager_path, W1
001EB8  21E160     MOV #0x1E16, W0
001EBA  07F254     RCALL strcpy
339:                       strcat(filepath, "/files/" PLATFORM_ID ".fp");
001EBC  21DA31     MOV #0x1DA3, W1
001EBE  21E160     MOV #0x1E16, W0
001EC0  07F259     RCALL strcat
340:                       f = ADBFileRead(filepath, &FileRecvFingerprint);
001EC2  21D4C1     MOV #0x1D4C, W1
001EC4  21E160     MOV #0x1E16, W0
001EC6  07096A     RCALL ADBFileRead
341:                       state = MAIN_STATE_WAIT_RECV_FP;
001EC8  200060     MOV #0x6, W0
001ECA  37FFE6     BRA 0x1E98
342:                       break;
343:               
344:                     case MAIN_STATE_FP_FAILED:
345:               #ifdef BYPASS_SECURITY
346:                       state = MAIN_STATE_AUTH_PASSED;
347:                       break;
348:               #endif
349:                       auth_result = AUTH_BUSY;
001ECC  200030     MOV #0x3, W0
001ECE  88F2B0     MOV W0, auth_result
350:                       AuthInit();
001ED0  070207     RCALL AuthInit
351:                       f = ADBFileRead("/data/system/packages.xml", &FileRecvPackages);
001ED2  21DC41     MOV #0x1DC4, W1
001ED4  21DB60     MOV #0x1DB6, W0
001ED6  070962     RCALL ADBFileRead
352:                       state = MAIN_STATE_AUTH_MANAGER;
001ED8  200040     MOV #0x4, W0
001EDA  37FFDE     BRA 0x1E98
353:                       break;
354:               
355:                     case MAIN_STATE_AUTH_PASSED:
356:                       if (!EraseFingerprint()) {
001EDC  07FF19     RCALL EraseFingerprint
001EDE  E00000     CP0 W0
001EE0  32000F     BRA Z, 0x1F00
357:                         state = MAIN_STATE_ERROR;
358:                       } else {
359:                         IOIOFileInit();
001EE2  0704A5     RCALL IOIOFileInit
360:                         strcpy(filepath, manager_path);
001EE4  80F2C1     MOV manager_path, W1
001EE6  21E160     MOV #0x1E16, W0
001EE8  07F23D     RCALL strcpy
361:                         strcat(filepath, "/files/" PLATFORM_ID ".ioio");
001EEA  21DD01     MOV #0x1DD0, W1
001EEC  21E160     MOV #0x1E16, W0
001EEE  07F242     RCALL strcat
362:                         f = ADBFileRead(filepath, &FileRecvImage);
001EF0  21D9A1     MOV #0x1D9A, W1
001EF2  21E160     MOV #0x1E16, W0
001EF4  070953     RCALL ADBFileRead
363:                         state = MAIN_STATE_WAIT_RECV_IMAGE;
001EF6  200080     MOV #0x8, W0
001EF8  37FFCF     BRA 0x1E98
364:                       }
365:                       break;
366:               
367:                     case MAIN_STATE_RECV_IMAGE_DONE:
368:                       if (WriteFingerprint()) {
001EFA  07FF0D     RCALL WriteFingerprint
001EFC  E00000     CP0 W0
001EFE  3AFFCB     BRA NZ, 0x1E96
369:                         state = MAIN_STATE_RUN_APP;
370:                       } else {
371:                         state = MAIN_STATE_ERROR;
001F00  2000B0     MOV #0xB, W0
001F02  37FFCA     BRA 0x1E98
372:                       }
373:                       break;
374:               
375:                     case MAIN_STATE_RUN_APP:
376:                       BootloaderConnResetUSB();
001F04  070688     RCALL BootloaderConnResetUSB
377:                       pass_usb_to_app = 1;
001F06  200010     MOV #0x1, W0
001F08  88FFF0     MOV W0, pass_usb_to_app
378:                       log_printf("Running app...");
379:                       __asm__("goto __APP_RESET");
380:               
381:                     default:
382:                       break;  // do nothing
383:                   }
384:                 }
385:                 return 0;
386:               }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/bootloader/ioio_file.c  --
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include <string.h>
31:                
32:                #include "logging.h"
33:                #include "flash.h"
34:                #include "ioio_file.h"
35:                #include "bootloader_defs.h"
36:                
37:                #define MIN(a,b) ((a) < (b) ? (a) : (b))
38:                
39:                typedef enum {
40:                  IOIO_FILE_STATE_WAIT_HEADER,
41:                  IOIO_FILE_STATE_WAIT_BLOCK
42:                } IOIO_FILE_STATE;
43:                
44:                static BYTE ioio_file_buf[196];
45:                static BYTE ioio_file_buf_pos;
46:                static BYTE ioio_file_field_remaining;
47:                static DWORD ioio_file_last_page;
48:                static IOIO_FILE_STATE ioio_file_state;
49:                static const BYTE IOIO_FILE_HEADER[8] = { 'I', 'O', 'I', 'O', '\1', '\0', '\0', '\0' };
50:                
51:                static BOOL IOIOFileBlockDone() {
52:                  DWORD address, page_address;
53:                  switch (ioio_file_state) {
002880  80E0A0     MOV ioio_file_state, W0
002882  E00000     CP0 W0
002884  320003     BRA Z, 0x288C
002886  500FE1     SUB W0, #0x1, [W15]
002888  3A003C     BRA NZ, 0x2902
00288A  37000D     BRA 0x28A6
54:                    case IOIO_FILE_STATE_WAIT_HEADER:
55:                      if (memcmp(ioio_file_buf, IOIO_FILE_HEADER, 8) != 0) {
00288C  200082     MOV #0x8, W2
00288E  21F3C1     MOV #0x1F3C, W1
002890  780009     MOV W9, W0
002892  07ED47     RCALL memcmp
002894  E00000     CP0 W0
002896  3A0039     BRA NZ, 0x290A
56:                        log_printf("Unexpected IOIO file header or version");
57:                        return FALSE;
58:                      }
59:                      ioio_file_buf_pos = 0;
002898  784F00     MOV.B W0, [W14]
60:                      ioio_file_field_remaining = 196;
00289A  B3CC40     MOV #0xC4, W0
00289C  21C1A1     MOV #0x1C1A, W1
00289E  784880     MOV.B W0, [W1]
61:                      ioio_file_state = IOIO_FILE_STATE_WAIT_BLOCK;
0028A0  200010     MOV #0x1, W0
0028A2  88E0A0     MOV W0, ioio_file_state
0028A4  37002E     BRA 0x2902
62:                      break;
63:                
64:                    case IOIO_FILE_STATE_WAIT_BLOCK:
65:                      address = *((const DWORD *) ioio_file_buf);
0028A6  80E0EA     MOV ioio_file_buf, W10
0028A8  80E0FB     MOV 0x1C1E, W11
66:                      if (address & 0x7F) {
0028AA  BE030A     MOV.D W10, W6
0028AC  78000A     MOV W10, W0
0028AE  B207F0     AND #0x7F, W0
0028B0  3A002C     BRA NZ, 0x290A
67:                        log_printf("Misaligned block: 0x%lx", address);
68:                        return FALSE;
69:                      }
70:                      if (address < BOOTLOADER_MIN_APP_ADDRESS || address >= BOOTLOADER_MAX_APP_ADDRESS) {
0028B2  2C0000     MOV #0xC000, W0
0028B4  2FFFF1     MOV #0xFFFF, W1
0028B6  40000A     ADD W0, W10, W0
0028B8  48808B     ADDC W1, W11, W1
0028BA  266FF2     MOV #0x66FF, W2
0028BC  200023     MOV #0x2, W3
0028BE  500F82     SUB W0, W2, [W15]
0028C0  588F83     SUBB W1, W3, [W15]
0028C2  3E0023     BRA GTU, 0x290A
71:                        log_printf("Adderess outside of permitted range: 0x%lx", address);
72:                        return FALSE;
73:                      }
74:                      if (ioio_file_last_page != BOOTLOADER_INVALID_ADDRESS && address < ioio_file_last_page) {
0028C4  80E0B4     MOV ioio_file_last_page, W4
0028C6  80E0C5     MOV 0x1C18, W5
0028C8  420FE1     ADD W4, #0x1, [W15]
0028CA  4A8FE0     ADDC W5, #0x0, [W15]
0028CC  320003     BRA Z, 0x28D4
0028CE  550F84     SUB W10, W4, [W15]
0028D0  5D8F85     SUBB W11, W5, [W15]
0028D2  39001B     BRA NC, 0x290A
75:                        log_printf("Out-of-order address: 0x%lx", address);
76:                        return FALSE;
77:                      }
78:                      page_address = address & 0xFFFFFFC00ull;
0028D4  2FC000     MOV #0xFC00, W0
0028D6  630000     AND W6, W0, W0
0028D8  780187     MOV W7, W3
0028DA  780100     MOV W0, W2
0028DC  BE0402     MOV.D W2, W8
79:                      if (page_address != ioio_file_last_page) {
0028DE  540F84     SUB W8, W4, [W15]
0028E0  5C8F85     SUBB W9, W5, [W15]
0028E2  320006     BRA Z, 0x28F0
80:                        log_printf("Erasing Flash page: 0x%lx", address);
81:                        if (!FlashErasePage(page_address)) return FALSE;
0028E4  BE0008     MOV.D W8, W0
0028E6  070109     RCALL FlashErasePage
0028E8  E00000     CP0 W0
0028EA  32000F     BRA Z, 0x290A
82:                        ioio_file_last_page = page_address;
0028EC  88E0B8     MOV W8, ioio_file_last_page
0028EE  88E0C9     MOV W9, 0x1C18
83:                      }
84:                      log_printf("Writing Flash block: 0x%lx", address);
85:                      if (!FlashWriteBlock(address, ioio_file_buf + 4)) return FALSE;
0028F0  21C202     MOV #0x1C20, W2
0028F2  BE000A     MOV.D W10, W0
0028F4  07012F     RCALL FlashWriteBlock
0028F6  E00000     CP0 W0
0028F8  320008     BRA Z, 0x290A
86:                      ioio_file_buf_pos = 0;
0028FA  EB4F00     CLR.B [W14]
87:                      ioio_file_field_remaining = 196;
0028FC  B3CC40     MOV #0xC4, W0
0028FE  21C1A2     MOV #0x1C1A, W2
002900  784900     MOV.B W0, [W2]
88:                      break;
89:                  }
90:                  return TRUE;
91:                }
92:                
93:                void IOIOFileInit() {
94:                  ioio_file_buf_pos = 0;
00282E  21C1B0     MOV #0x1C1B, W0
002830  EB4800     CLR.B [W0]
95:                  ioio_file_field_remaining = 8;
002832  B3C081     MOV #0x8, W1
002834  21C1A0     MOV #0x1C1A, W0
002836  784801     MOV.B W1, [W0]
96:                  ioio_file_last_page = BOOTLOADER_INVALID_ADDRESS;
002838  EB8000     SETM W0
00283A  EB8080     SETM W1
00283C  88E0B0     MOV W0, ioio_file_last_page
00283E  88E0C1     MOV W1, 0x1C18
97:                  ioio_file_state = IOIO_FILE_STATE_WAIT_HEADER;
002840  EB0000     CLR W0
002842  88E0A0     MOV W0, ioio_file_state
98:                }
002846  BE9F88     MOV.D W8, [W15++]
002848  BE9F8A     MOV.D W10, [W15++]
00284A  BE9F8C     MOV.D W12, [W15++]
00284C  781F8E     MOV W14, [W15++]
00284E  780680     MOV W0, W13
002850  780601     MOV W1, W12
002852  370057     BRA 0x2902
99:                
100:               BOOL IOIOFileHandleBuffer(const void * buffer, size_t size) {
101:                 while (size) {
002902  E0000C     CP0 W12
002904  3AFFA7     BRA NZ, 0x2854
002906  200010     MOV #0x1, W0
002908  370001     BRA 0x290C
00290A  EB0000     CLR W0
102:                   size_t bytes_to_copy = MIN(ioio_file_field_remaining, size);
002854  21C1A1     MOV #0x1C1A, W1
002856  FB8011     ZE [W1], W0
002858  78040C     MOV W12, W8
00285A  560F80     SUB W12, W0, [W15]
00285C  360001     BRA LEU, 0x2860
00285E  780400     MOV W0, W8
103:                   memcpy(ioio_file_buf + ioio_file_buf_pos, buffer, bytes_to_copy);
002860  21C1BE     MOV #0x1C1B, W14
002862  FB801E     ZE [W14], W0
002864  21C1C9     MOV #0x1C1C, W9
002866  400009     ADD W0, W9, W0
002868  780108     MOV W8, W2
00286A  78008D     MOV W13, W1
00286C  07ED74     RCALL memcpy
104:                   ioio_file_buf_pos += bytes_to_copy;
00286E  444F1E     ADD.B W8, [W14], [W14]
105:                   ioio_file_field_remaining -= bytes_to_copy;
002870  21C1A2     MOV #0x1C1A, W2
002872  784012     MOV.B [W2], W0
002874  504008     SUB.B W0, W8, W0
002876  784900     MOV.B W0, [W2]
106:                   buffer = ((const BYTE *) buffer) + bytes_to_copy;
002878  468688     ADD W13, W8, W13
107:                   size -= bytes_to_copy;
00287A  560608     SUB W12, W8, W12
108:                   if (ioio_file_field_remaining == 0) {
00287C  E00400     CP0.B W0
00287E  3A0041     BRA NZ, 0x2902
109:                     if (!IOIOFileBlockDone()) {
110:                       return FALSE;
111:                     }
112:                   }
113:                 }
114:                 return TRUE;
115:               }
116:               
117:               BOOL IOIOFileDone() {
118:                 if (ioio_file_state == IOIO_FILE_STATE_WAIT_BLOCK
119:                     && ioio_file_field_remaining == 196) return TRUE;
120:                 log_printf("Unexpected EOF");
121:                 return FALSE;
122:               }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/bootloader/flash.c  ------
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include <assert.h>
31:                #include "Compiler.h"
32:                #include "flash.h"
33:                
34:                BOOL FlashErasePage(DWORD address) {
35:                  assert((address & 0x3FF) == 0);
36:                  DWORD_VAL a = { address };
37:                
38:                  NVMCON = 0x4042;  // Erase page
002AFA  240422     MOV #0x4042, W2
002AFC  883B02     MOV W2, NVMCON
39:                
40:                  TBLPAG = a.byte.UB;
002AFE  FB8101     ZE W1, W2
002B00  8802A2     MOV W2, TBLPAG
41:                  __builtin_tblwtl(a.word.LW, 0xFFFF);
002B02  EB8100     SETM W2
002B04  BB0802     TBLWTL W2, [W0]
42:                
43:                  asm("DISI #5");
002B06  FC0005     DISI #0x5
44:                  __builtin_write_NVM();
002B08  200550     MOV #0x55, W0
002B0A  883B30     MOV W0, NVMKEY
002B0C  200AA0     MOV #0xAA, W0
002B0E  883B30     MOV W0, NVMKEY
002B10  A8E761     BSET 0x761, #7
002B12  000000     NOP
002B14  000000     NOP
45:                  while(NVMCONbits.WR);
002B16  E24761     CP0.B 0x761
002B18  35FFFE     BRA LT, 0x2B16
46:                  NVMCONbits.WREN = 0;
002B1A  A9C761     BCLR 0x761, #6
47:                  return NVMCONbits.WRERR == 0;
002B1C  BFC761     MOV.B 0x761, WREG
002B1E  FB8000     ZE W0, W0
002B20  DE0045     LSR W0, #5, W0
002B22  A20000     BTG W0, #0
002B24  600061     AND W0, #0x1, W0
48:                }	
49:                
50:                BOOL FlashWriteDWORD(DWORD address, DWORD value)	{
51:                  assert((address & 0x1) == 0);
52:                  DWORD_VAL a = { address };
53:                  DWORD_VAL v = { value };
54:                
55:                  NVMCON = 0x4003;  // Word write
002B28  240034     MOV #0x4003, W4
002B2A  883B04     MOV W4, NVMCON
56:                
57:                  TBLPAG = a.word.HW;
002B2C  8802A1     MOV W1, TBLPAG
58:                  __builtin_tblwtl(a.word.LW, v.word.LW);		//Write the low word to the latch
002B2E  BB0802     TBLWTL W2, [W0]
59:                  __builtin_tblwth(a.word.LW, v.word.HW); 	//Write the high word to the latch (8 bits of data + 8 bits of "phantom data")
002B30  BB8803     TBLWTH W3, [W0]
60:                
61:                  asm("DISI #5");
002B32  FC0005     DISI #0x5
62:                  __builtin_write_NVM();
002B34  200550     MOV #0x55, W0
002B36  883B30     MOV W0, NVMKEY
002B38  200AA0     MOV #0xAA, W0
002B3A  883B30     MOV W0, NVMKEY
002B3C  A8E761     BSET 0x761, #7
002B3E  000000     NOP
002B40  000000     NOP
63:                  while (NVMCONbits.WR);
002B42  E24761     CP0.B 0x761
002B44  35FFFE     BRA LT, 0x2B42
64:                  NVMCONbits.WREN = 0;
002B46  A9C761     BCLR 0x761, #6
65:                  return NVMCONbits.WRERR == 0;
002B48  BFC761     MOV.B 0x761, WREG
002B4A  FB8000     ZE W0, W0
002B4C  DE0045     LSR W0, #5, W0
002B4E  A20000     BTG W0, #0
002B50  600061     AND W0, #0x1, W0
66:                }
002B54  B82260     MUL.UU W4, #0, W4
67:                
68:                BOOL FlashWriteBlock(DWORD address, BYTE block[192]) {
69:                  assert((address & 0x7F) == 0);
70:                  unsigned int i = 0;
71:                  DWORD_VAL a = { address };
72:                  DWORD_VAL v;
73:                
74:                  NVMCON = 0x4001;  // Block write
002B56  240013     MOV #0x4001, W3
002B58  883B03     MOV W3, NVMCON
75:                
76:                  TBLPAG = a.word.HW;
002B5A  8802A1     MOV W1, TBLPAG
002B5C  780080     MOV W0, W1
002B5E  EB0180     CLR W3
002B60  2FF006     MOV #0xFF00, W6
002B62  200C07     MOV #0xC0, W7
77:                  while (i < 192) {
002B84  518F87     SUB W3, W7, [W15]
002B86  3AFFEE     BRA NZ, 0x2B64
78:                    v.byte.LB = block[i++];
002B64  FB8012     ZE [W2], W0
002B66  630204     AND W6, W4, W4
002B68  720200     IOR W4, W0, W4
79:                    v.byte.HB = block[i++];
002B6A  904012     MOV.B [W2+1], W0
002B6C  DD0048     SL W0, #8, W0
002B6E  B20FF4     AND #0xFF, W4
002B70  720200     IOR W4, W0, W4
80:                    v.byte.UB = block[i++];
002B72  904022     MOV.B [W2+2], W0
002B74  FB8000     ZE W0, W0
002B76  630285     AND W6, W5, W5
002B78  728280     IOR W5, W0, W5
002B7A  4181E3     ADD W3, #0x3, W3
81:                    __builtin_tblwtl(a.word.LW, v.word.LW);  // Write the low word to the latch
002B7C  BB0884     TBLWTL W4, [W1]
82:                    __builtin_tblwth(a.word.LW, v.word.HW);  // Write the high word to the latch (8 bits of data + 8 bits of "phantom data")
002B7E  BB8885     TBLWTH W5, [W1]
002B80  E88081     INC2 W1, W1
002B82  410163     ADD W2, #0x3, W2
83:                    a.word.LW += 2;
84:                  }
85:                
86:                  asm("DISI #5");
002B88  FC0005     DISI #0x5
87:                  __builtin_write_NVM();
002B8A  200550     MOV #0x55, W0
002B8C  883B30     MOV W0, NVMKEY
002B8E  200AA0     MOV #0xAA, W0
002B90  883B30     MOV W0, NVMKEY
002B92  A8E761     BSET 0x761, #7
002B94  000000     NOP
002B96  000000     NOP
88:                  while (NVMCONbits.WR);
002B98  E24761     CP0.B 0x761
002B9A  35FFFE     BRA LT, 0x2B98
89:                  NVMCONbits.WREN = 0;
002B9C  A9C761     BCLR 0x761, #6
90:                  return NVMCONbits.WRERR == 0;
002B9E  BFC761     MOV.B 0x761, WREG
002BA0  FB8000     ZE W0, W0
002BA2  DE0045     LSR W0, #5, W0
002BA4  A20000     BTG W0, #0
002BA6  600061     AND W0, #0x1, W0
91:                }
92:                
93:                DWORD FlashReadDWORD(DWORD address) {
94:                  DWORD_VAL a = { address };
95:                  DWORD_VAL res;
96:                  TBLPAG = a.word.HW;
002BAA  8802A1     MOV W1, TBLPAG
97:                  res.word.HW = __builtin_tblrdh(a.word.LW);
002BAC  BA8190     TBLRDH [W0], W3
98:                  res.word.LW = __builtin_tblrdl(a.word.LW);
002BAE  BA0110     TBLRDL [W0], W2
99:                  return res.Val;
100:               }
101:               
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/bootloader/fake  ---------
0002CC  80FAB0     MOV __curbrk, W0
0002CE  E00000     CP0 W0
0002D0  3A0003     BRA NZ, 0x2D8
0002D2  070010     RCALL brk
0002D4  E00000     CP0 W0
0002D6  35000A     BRA LT, 0x2EC
0002D8  80FAB0     MOV __curbrk, W0
0002F6  E00000     CP0 W0
0002F8  3A0004     BRA NZ, 0x302
0002FA  220000     MOV #0x2000, W0
0002FC  88FAB0     MOV W0, __curbrk
0002FE  780101     MOV W1, W2
000300  370006     BRA 0x30E
000302  EB8100     SETM W2
000304  226000     MOV #0x2600, W0
000306  508F80     SUB W1, W0, [W15]
000308  3E0002     BRA GTU, 0x30E
0002DA  E00009     CP0 W9
0002DC  3A0002     BRA NZ, 0x2E2
00030A  88FAB1     MOV W1, __curbrk
00030C  EB0100     CLR W2
0002DE  780400     MOV W0, W8
0002E0  370006     BRA 0x2EE
0002E2  780400     MOV W0, W8
0002E4  400009     ADD W0, W9, W0
0002E6  070006     RCALL brk
0002E8  E00000     CP0 W0
0002EA  3D0001     BRA GE, 0x2EE
0002EC  EB8400     SETM W8
0002F4  780080     MOV W0, W1
0002C8  BE9F88     MOV.D W8, [W15++]
0002CA  780480     MOV W0, W9
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/bootloader/dumpsys.c  ----
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include "dumpsys.h"
31:                
32:                #include <assert.h>
33:                
34:                #include "bootloader_defs.h"
35:                
36:                #define MAX_PATH 64
37:                
38:                typedef enum {
39:                  STATE_IN_PREFIX,
40:                  STATE_SKIP_LINE,
41:                  STATE_IN_PATH
42:                } STATE;
43:                
44:                static const char prefix[] FORCEROM = "    dataDir=";
45:                static int cursor;
46:                static char result[MAX_PATH];
47:                static STATE state;
48:                
49:                void DumpsysInit() {
50:                  cursor = 0;
002D48  EB0000     CLR W0
002D4A  88F580     MOV W0, cursor
51:                  state = STATE_IN_PREFIX;
002D4C  88F370     MOV W0, state
52:                }
002D50  780300     MOV W0, W6
53:                
54:                const char* DumpsysProcess(const char* data, int size) {
002D52  80F582     MOV cursor, W2
002D54  80F373     MOV state, W3
002D56  EB0280     CLR W5
002D58  21E707     MOV #0x1E70, W7
002D5A  37002B     BRA 0x2DB2
55:                  assert(data);
56:                
57:                  while (size--) {
002DB2  528F81     SUB W5, W1, [W15]
002DB4  3AFFD3     BRA NZ, 0x2D5C
002DB6  88F582     MOV W2, cursor
002DB8  88F373     MOV W3, state
58:                    char c = *data++;
002D5C  7B4265     MOV.B [W5+W6], W4
59:                    switch (state) {
002D5E  518FE1     SUB W3, #0x1, [W15]
002D60  32000F     BRA Z, 0x2D80
002D62  390003     BRA NC, 0x2D6A
002D64  518FE2     SUB W3, #0x2, [W15]
002D66  3A0024     BRA NZ, 0x2DB0
002D68  370010     BRA 0x2D8A
60:                      case STATE_IN_PREFIX:
61:                        if (c == prefix[cursor++]) {
002D6A  28EA20     MOV #0x8EA2, W0
002D6C  794060     MOV.B [W0+W2], W0
002D6E  E80102     INC W2, W2
002D70  524F80     SUB.B W4, W0, [W15]
002D72  3A001D     BRA NZ, 0x2DAE
62:                          if (cursor == sizeof(prefix) - 1) {
002D76  510FEC     SUB W2, #0xC, [W15]
002D78  3A001B     BRA NZ, 0x2DB0
002D7A  EB0100     CLR W2
002D7C  200023     MOV #0x2, W3
002D7E  370018     BRA 0x2DB0
63:                            state = STATE_IN_PATH;
64:                            cursor = 0;
65:                          }
66:                        } else {
67:                          state = STATE_SKIP_LINE;
68:                        }
69:                        break;
70:                
71:                      case STATE_SKIP_LINE:
72:                        if (c == '\n') {
002D80  524FEA     SUB.B W4, #0xA, [W15]
002D82  3A0015     BRA NZ, 0x2DAE
002D84  EB0100     CLR W2
002D86  780182     MOV W2, W3
002D88  370013     BRA 0x2DB0
73:                          state = STATE_IN_PREFIX;
74:                          cursor = 0;
75:                        }
76:                        break;
77:                
78:                      case STATE_IN_PATH:
79:                        if (c == '\r') {
002D8A  524FED     SUB.B W4, #0xD, [W15]
002D8C  3A0006     BRA NZ, 0x2D9A
002D8E  88F582     MOV W2, cursor
002D90  88F373     MOV W3, state
80:                          result[cursor] = '\0';
002D92  EB4000     CLR.B W0
002D94  797380     MOV.B W0, [W7+W2]
002D96  21E700     MOV #0x1E70, W0
002D98  060000     RETURN
81:                          return result;
82:                        } else {
83:                          if (cursor < MAX_PATH - 1) {
002D9A  2003E0     MOV #0x3E, W0
002D9C  510F80     SUB W2, W0, [W15]
002D9E  3C0003     BRA GT, 0x2DA6
84:                            result[cursor++] = c;
002DA0  797384     MOV.B W4, [W7+W2]
002DA2  E80102     INC W2, W2
002DA4  370005     BRA 0x2DB0
002DA6  88F582     MOV W2, cursor
002DA8  88F373     MOV W3, state
85:                          } else {
86:                            return DUMPSYS_ERROR;
002D74  EB0180     CLR W3
002DAA  80FA90     MOV DUMPSYS_ERROR, W0
002DAC  060000     RETURN
002DAE  200013     MOV #0x1, W3
002DB0  E80285     INC W5, W5
87:                          }
88:                        break;
89:                      }
90:                    }
91:                  }
92:                  return DUMPSYS_BUSY;
002DBA  80F360     MOV DUMPSYS_BUSY, W0
93:                }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/bootloader/bootloader_conn.c
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include "bootloader_conn.h"
31:                
32:                #include <string.h>
33:                #include <assert.h>
34:                
35:                #include "logging.h"
36:                #include "libusb/usb_config.h"
37:                #include "libusb/usb_host_android.h"
38:                #include "adb_private.h"
39:                #include "adb_file_private.h"
40:                
41:                typedef enum {
42:                  STATE_ADB_DISCONNECTED,
43:                  STATE_ADB_INITIALIZING,
44:                  STATE_ADB_INITIALIZED
45:                } ADB_STATE;
46:                
47:                static ADB_STATE adb_state;
48:                static BOOL unknown_device_attached;
49:                
50:                static void ConnADBTasks() {
51:                  int res;
52:                
53:                  if (!ADBAttached()) {
002BC4  0706A6     RCALL ADBAttached
002BC6  E00000     CP0 W0
002BC8  32001B     BRA Z, 0x2C00
54:                    adb_state = STATE_ADB_DISCONNECTED;
55:                    return;
56:                  }
57:                
58:                  switch (adb_state) {
002BCA  80FA60     MOV adb_state, W0
002BCC  E00000     CP0 W0
002BCE  320003     BRA Z, 0x2BD6
002BD0  500FE2     SUB W0, #0x2, [W15]
002BD2  3E0017     BRA GTU, 0x2C02
002BD4  370006     BRA 0x2BE2
59:                    case STATE_ADB_DISCONNECTED:
60:                      if (ADBAttached()) {
002BD6  07069D     RCALL ADBAttached
002BD8  E00000     CP0 W0
002BDA  320013     BRA Z, 0x2C02
61:                        ADBInit();
002BDC  070676     RCALL ADBInit
62:                        ADBFileInit();
002BDE  07067D     RCALL ADBFileInit
002BE0  37000A     BRA 0x2BF6
63:                        adb_state = STATE_ADB_INITIALIZED;
64:                      }
65:                      break;
66:                
67:                    case STATE_ADB_INITIALIZING:
68:                    case STATE_ADB_INITIALIZED:
69:                      res = ADBTasks();
002BE2  07F600     RCALL ADBTasks
002BE4  780400     MOV W0, W8
70:                      if (res == -1) {
002BE6  400FE1     ADD W0, #0x1, [W15]
002BE8  3A0002     BRA NZ, 0x2BEE
71:                        log_printf("Error occured. Resetting Android USB.");
72:                        USBHostAndroidReset();
002BEA  07065D     RCALL USBHostAndroidReset
002BEC  37000A     BRA 0x2C02
73:                        break;
74:                      }
75:                #ifndef USB_ENABLE_TRANSFER_EVENT
76:                      USBHostAndroidTasks();
002BEE  0701BE     RCALL USBHostAndroidTasks
77:                #endif
78:                      if (res == 1) {
002BF0  540FE1     SUB W8, #0x1, [W15]
002BF2  3A0003     BRA NZ, 0x2BFA
79:                        ADBFileTasks();
002BF4  070329     RCALL ADBFileTasks
80:                        adb_state = STATE_ADB_INITIALIZED;
002BF6  200020     MOV #0x2, W0
002BF8  370003     BRA 0x2C00
81:                      } else if (res == 0) {
002BFA  E00008     CP0 W8
002BFC  3A0002     BRA NZ, 0x2C02
82:                        adb_state = STATE_ADB_INITIALIZING;
002BFE  200010     MOV #0x1, W0
002C00  88FA60     MOV W0, adb_state
83:                      }
84:                      break;
85:                  }
86:                }
87:                
88:                void BootloaderConnInit() {
89:                  BOOL res = USBHostInit(0);
002BB4  B80060     MUL.UU W0, #0, W0
002BB6  07048B     RCALL USBHostInit
90:                  assert(res);
91:                  adb_state = STATE_ADB_DISCONNECTED;
002BB8  EB0000     CLR W0
002BBA  88FA60     MOV W0, adb_state
92:                  unknown_device_attached = FALSE;
002BBC  88FA50     MOV W0, unknown_device_attached
93:                }
002BC0  781F88     MOV W8, [W15++]
94:                
95:                BOOL BootloaderConnTasks() {
96:                  USBHostTasks();
002BC2  07F176     RCALL USBHostTasks
97:                  ConnADBTasks();
98:                
99:                  return USBHostAndroidIsInterfaceAttached(ANDROID_INTERFACE_ADB) || unknown_device_attached;
002C02  21C120     MOV #0x1C12, W0
002C04  780010     MOV [W0], W0
002C06  600061     AND W0, #0x1, W0
002C08  3A0003     BRA NZ, 0x2C10
002C0A  80FA50     MOV unknown_device_attached, W0
002C0C  E00000     CP0 W0
002C0E  320001     BRA Z, 0x2C12
002C10  200010     MOV #0x1, W0
100:               }
101:               
102:               void BootloaderConnResetUSB() {
103:                 USBHostShutdown();
002C16  370476     BRA USBHostShutdown
104:               }
105:               
106:               BOOL USB_ApplicationEventHandler(BYTE address, USB_EVENT event, void *data, DWORD size) {
107:                 // Handle specific events.
108:                 switch (event) {
002C18  2FF9B0     MOV #0xFF9B, W0
002C1A  408000     ADD W1, W0, W0
002C1C  500FEB     SUB W0, #0xB, [W15]
002C1E  3E0009     BRA GTU, 0x2C32
002C20  200012     MOV #0x1, W2
002C22  DD1080     SL W2, W0, W1
002C24  20F110     MOV #0xF11, W0
002C26  608000     AND W1, W0, W0
002C28  3A0006     BRA NZ, 0x2C36
002C2A  A35801     BTST.Z W1, #5
002C2C  3A0003     BRA NZ, 0x2C34
002C2E  A37801     BTST.Z W1, #7
002C30  3A0004     BRA NZ, 0x2C3A
002C32  050000     RETLW #0x0, W0
109:                  case EVENT_VBUS_REQUEST_POWER:
110:                   // We'll let anything attach.
111:                   return TRUE;
112:               
113:                  case EVENT_VBUS_RELEASE_POWER:
114:                   unknown_device_attached = FALSE;
002C34  88FA50     MOV W0, unknown_device_attached
002C36  780002     MOV W2, W0
002C38  060000     RETURN
115:                   return TRUE;
116:               
117:                  case EVENT_HUB_ATTACH:
118:                   log_printf("***** USB Error - hubs are not supported *****");
119:                   return TRUE;
120:               
121:                  case EVENT_UNSUPPORTED_DEVICE:
122:                   log_printf("***** USB Error - device is not supported *****");
123:                   unknown_device_attached = TRUE;
002C3A  88FA52     MOV W2, unknown_device_attached
002C3C  780002     MOV W2, W0
124:                   return TRUE;
125:               
126:                  case EVENT_CANNOT_ENUMERATE:
127:                   log_printf("***** USB Error - cannot enumerate device *****");
128:                   return TRUE;
129:               
130:                  case EVENT_CLIENT_INIT_ERROR:
131:                   log_printf("***** USB Error - client driver initialization error *****");
132:                   return TRUE;
133:               
134:                  case EVENT_OUT_OF_MEMORY:
135:                   log_printf("***** USB Error - out of heap memory *****");
136:                   return TRUE;
137:               
138:                  case EVENT_UNSPECIFIED_ERROR:   // This should never be generated.
139:                   log_printf("***** USB Error - unspecified *****");
140:                   return TRUE;
141:               
142:                  default:
143:                   return FALSE;
144:                 }
145:               }  // USB_ApplicationEventHandler
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/bootloader/auth.c  -------
002132  780100     MOV W0, W2
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include "auth.h"
31:                
32:                #include <string.h>
33:                
34:                #include "xml.h"
35:                #include "bootloader_defs.h"
36:                
37:                typedef enum {
38:                  AUTH_STATE_DONE_PASS = AUTH_DONE_PASS,
39:                  AUTH_STATE_DONE_FAIL = AUTH_DONE_FAIL,
40:                  AUTH_STATE_ERROR = AUTH_DONE_PARSE_ERROR,
41:                  AUTH_STATE_TOP = AUTH_BUSY,
42:                  AUTH_STATE_PACKAGES,
43:                  AUTH_STATE_PACKAGE,
44:                  AUTH_STATE_NAME_ATTR,
45:                  AUTH_STATE_SIGS,
46:                  AUTH_STATE_CERT,
47:                  AUTH_STATE_CERT_KEY,
48:                  AUTH_STATE_CERT_FAIL,
49:                } AUTH_STATE;
50:                
51:                static const char FORCEROM cert_key[] =
52:                  "30820312308202d0a00302010202044cdeff27300b06072a8648ce3804030500"
53:                  "306b310b300906035504061302494c3110300e06035504081307556e6b6e6f77"
54:                  "6e3111300f0603550407130854656c2d41766976310d300b060355040a130449"
55:                  "4f494f3110300e060355040b1307556e6b6e6f776e311630140603550403130d"
56:                  "597461692d42656e2d547376693020170d3130313131333231313230375a180f"
57:                  "32313130313032303231313230375a306b310b300906035504061302494c3110"
58:                  "300e06035504081307556e6b6e6f776e3111300f0603550407130854656c2d41"
59:                  "766976310d300b060355040a1304494f494f3110300e060355040b1307556e6b"
60:                  "6e6f776e311630140603550403130d597461692d42656e2d54737669308201b8"
61:                  "3082012c06072a8648ce3804013082011f02818100fd7f53811d75122952df4a"
62:                  "9c2eece4e7f611b7523cef4400c31e3f80b6512669455d402251fb593d8d58fa"
63:                  "bfc5f5ba30f6cb9b556cd7813b801d346ff26660b76b9950a5a49f9fe8047b10"
64:                  "22c24fbba9d7feb7c61bf83b57e7c6a8a6150f04fb83f6d3c51ec3023554135a"
65:                  "169132f675f3ae2b61d72aeff22203199dd14801c70215009760508f15230bcc"
66:                  "b292b982a2eb840bf0581cf502818100f7e1a085d69b3ddecbbcab5c36b857b9"
67:                  "7994afbbfa3aea82f9574c0b3d0782675159578ebad4594fe67107108180b449"
68:                  "167123e84c281613b7cf09328cc8a6e13c167a8b547c8d28e0a3ae1e2bb3a675"
69:                  "916ea37f0bfa213562f1fb627a01243bcca4f1bea8519089a883dfe15ae59f06"
70:                  "928b665e807b552564014c3bfecf492a038185000281810090e22346696394b3"
71:                  "9a0e31202f4232eba95e4e71c71c1a5b7b39042509df889f6c60f54198569ff3"
72:                  "15c06015e82a9286d2a1f628878422cb4ecf9db0173353dbf149424dfa934dcc"
73:                  "7e1845cd415ed8f066581aab8ee3141fa99449597b8ebde2ea8eee0a9ee65e25"
74:                  "877b36a00194b48b6dbac9324c33f2792ad22e6271584dc7300b06072a8648ce"
75:                  "3804030500032f00302c02145a05308f318f9bb7783b09352dbdcf218c6bd97a"
76:                  "02146464d844931dd0a4359f876305339f4ced0a4a35";
77:                
78:                static AUTH_STATE state;
79:                static int depth;
80:                static int name_matches;
81:                static char package_name[sizeof(manager_app_name)];
82:                static int package_name_cursor;
83:                static int package_key_cursor;
84:                
85:                static void StartElement(const char* name) {
86:                  switch (state) {
002134  80EBF0     MOV state, W0
002136  500FE4     SUB W0, #0x4, [W15]
002138  320013     BRA Z, 0x2160
00213A  3E0003     BRA GTU, 0x2142
00213C  500FE3     SUB W0, #0x3, [W15]
00213E  3A0037     BRA NZ, 0x21AE
002140  370005     BRA 0x214C
002142  500FE5     SUB W0, #0x5, [W15]
002144  32001A     BRA Z, 0x217A
002146  500FE7     SUB W0, #0x7, [W15]
002148  3A0032     BRA NZ, 0x21AE
00214A  370024     BRA 0x2194
87:                    case AUTH_STATE_TOP:
88:                      if (depth == 0 && strcmp(name, "packages") == 0) {
00214C  80EBE0     MOV depth, W0
00214E  E00000     CP0 W0
002150  3A002E     BRA NZ, 0x21AE
002152  21EDC1     MOV #0x1EDC, W1
002154  780002     MOV W2, W0
002156  07F0DD     RCALL strcmp
002158  E00000     CP0 W0
00215A  3A0029     BRA NZ, 0x21AE
89:                        state = AUTH_STATE_PACKAGES;
00215C  200040     MOV #0x4, W0
00215E  370026     BRA 0x21AC
90:                      }
91:                      break;
92:                
93:                    case AUTH_STATE_PACKAGES:
94:                      if (depth == 1 && strcmp(name, "package") == 0) {
002160  80EBE0     MOV depth, W0
002162  500FE1     SUB W0, #0x1, [W15]
002164  3A0024     BRA NZ, 0x21AE
002166  21EE51     MOV #0x1EE5, W1
002168  780002     MOV W2, W0
00216A  07F0D3     RCALL strcmp
00216C  780080     MOV W0, W1
00216E  E00000     CP0 W0
002170  3A001E     BRA NZ, 0x21AE
95:                        state = AUTH_STATE_PACKAGE;
002172  200050     MOV #0x5, W0
002174  88EBF0     MOV W0, state
96:                        name_matches = 0;
002176  88EBD1     MOV W1, name_matches
002178  37001A     BRA 0x21AE
97:                      }
98:                      break;
99:                
100:                   case AUTH_STATE_PACKAGE:
101:                     if (depth == 2 && name_matches && strcmp(name, "sigs") == 0) {
00217A  80EBE0     MOV depth, W0
00217C  500FE2     SUB W0, #0x2, [W15]
00217E  3A0017     BRA NZ, 0x21AE
002180  80EBD0     MOV name_matches, W0
002182  E00000     CP0 W0
002184  320014     BRA Z, 0x21AE
002186  21EED1     MOV #0x1EED, W1
002188  780002     MOV W2, W0
00218A  07F0C3     RCALL strcmp
00218C  E00000     CP0 W0
00218E  3A000F     BRA NZ, 0x21AE
102:                       state = AUTH_STATE_SIGS;
002190  200070     MOV #0x7, W0
002192  37000C     BRA 0x21AC
103:                     }
104:                     break;
105:               
106:                   case AUTH_STATE_SIGS:
107:                     if (depth == 3 && name_matches && strcmp(name, "cert") == 0) {
002194  80EBE0     MOV depth, W0
002196  500FE3     SUB W0, #0x3, [W15]
002198  3A000A     BRA NZ, 0x21AE
00219A  80EBD0     MOV name_matches, W0
00219C  E00000     CP0 W0
00219E  320007     BRA Z, 0x21AE
0021A0  21EF21     MOV #0x1EF2, W1
0021A2  780002     MOV W2, W0
0021A4  07F0B6     RCALL strcmp
0021A6  E00000     CP0 W0
0021A8  3A0002     BRA NZ, 0x21AE
108:                       state = AUTH_STATE_CERT;
0021AA  200080     MOV #0x8, W0
0021AC  88EBF0     MOV W0, state
109:                     }
110:                     break;
111:               
112:                   default:
113:                     break;  // nothing
114:                 }
115:                 ++depth;
0021AE  80EBE0     MOV depth, W0
0021B0  E80000     INC W0, W0
0021B2  88EBE0     MOV W0, depth
116:               }
117:               
118:               static void EndElement(const char* name) {
119:                 switch (state) {
0021B6  80EBF0     MOV state, W0
0021B8  500FE5     SUB W0, #0x5, [W15]
0021BA  32000E     BRA Z, 0x21D8
0021BC  3E0003     BRA GTU, 0x21C4
0021BE  500FE4     SUB W0, #0x4, [W15]
0021C0  3A001A     BRA NZ, 0x21F6
0021C2  370005     BRA 0x21CE
0021C4  500FE7     SUB W0, #0x7, [W15]
0021C6  32000D     BRA Z, 0x21E2
0021C8  500FE8     SUB W0, #0x8, [W15]
0021CA  3A0015     BRA NZ, 0x21F6
0021CC  37000F     BRA 0x21EC
120:                   case AUTH_STATE_PACKAGES:
121:                     if (depth == 1) {
0021CE  80EBE0     MOV depth, W0
0021D0  500FE1     SUB W0, #0x1, [W15]
0021D2  3A0011     BRA NZ, 0x21F6
122:                       state = AUTH_STATE_TOP;
0021D4  200030     MOV #0x3, W0
0021D6  37000E     BRA 0x21F4
123:                     }
124:                     break;
125:               
126:                   case AUTH_STATE_PACKAGE:
127:                     if (depth == 2) {
0021D8  80EBE0     MOV depth, W0
0021DA  500FE2     SUB W0, #0x2, [W15]
0021DC  3A000C     BRA NZ, 0x21F6
128:                       state = AUTH_STATE_PACKAGES;
0021DE  200040     MOV #0x4, W0
0021E0  370009     BRA 0x21F4
129:                     }
130:                     break;
131:               
132:                   case AUTH_STATE_SIGS:
133:                     if (depth == 3) {
0021E2  80EBE0     MOV depth, W0
0021E4  500FE3     SUB W0, #0x3, [W15]
0021E6  3A0007     BRA NZ, 0x21F6
134:                       state = AUTH_STATE_PACKAGE;
0021E8  200050     MOV #0x5, W0
0021EA  370004     BRA 0x21F4
135:                     }
136:                     break;
137:               
138:                   case AUTH_STATE_CERT:
139:                     if (depth == 4) {
0021EC  80EBE0     MOV depth, W0
0021EE  500FE4     SUB W0, #0x4, [W15]
0021F0  3A0002     BRA NZ, 0x21F6
140:                       state = AUTH_STATE_SIGS;
0021F2  200070     MOV #0x7, W0
0021F4  88EBF0     MOV W0, state
141:                     }
142:                     break;
143:               
144:                   default:
145:                     break;  // nothing
146:                 }
147:                 --depth;
0021F6  80EBE0     MOV depth, W0
0021F8  E90000     DEC W0, W0
0021FA  88EBE0     MOV W0, depth
148:               }
0021FE  780100     MOV W0, W2
149:               
150:               static void StartAttribute(const char* name) {
151:                 switch (state) {
002200  80EBF0     MOV state, W0
002202  500FE5     SUB W0, #0x5, [W15]
002204  320003     BRA Z, 0x220C
002206  500FE8     SUB W0, #0x8, [W15]
002208  3A0017     BRA NZ, 0x2238
00220A  37000B     BRA 0x2222
152:                   case AUTH_STATE_PACKAGE:
153:                     if (depth == 2 && strcmp(name, "name") == 0) {
00220C  80EBE0     MOV depth, W0
00220E  500FE2     SUB W0, #0x2, [W15]
002210  3A0013     BRA NZ, 0x2238
002212  21EF71     MOV #0x1EF7, W1
002214  780002     MOV W2, W0
002216  07F07D     RCALL strcmp
002218  E00000     CP0 W0
00221A  3A000E     BRA NZ, 0x2238
154:                       package_name_cursor = 0;
00221C  88EB50     MOV W0, package_name_cursor
155:                       state = AUTH_STATE_NAME_ATTR;
00221E  200060     MOV #0x6, W0
002220  37000A     BRA 0x2236
156:                     }
157:                     break;
158:               
159:                   case AUTH_STATE_CERT:
160:                     if (depth == 4 && strcmp(name, "key") == 0) {
002222  80EBE0     MOV depth, W0
002224  500FE4     SUB W0, #0x4, [W15]
002226  3A0008     BRA NZ, 0x2238
002228  21EFC1     MOV #0x1EFC, W1
00222A  780002     MOV W2, W0
00222C  07F072     RCALL strcmp
00222E  E00000     CP0 W0
002230  3A0003     BRA NZ, 0x2238
161:                       package_key_cursor = 0;
002232  88EB40     MOV W0, package_key_cursor
162:                       state = AUTH_STATE_CERT_KEY;
002234  200090     MOV #0x9, W0
002236  88EBF0     MOV W0, state
163:                     }
164:                     break;
165:               
166:                   default:
167:                     break;  // nothing
168:                 }
169:               
170:                 ++depth;
002238  80EBE0     MOV depth, W0
00223A  E80000     INC W0, W0
00223C  88EBE0     MOV W0, depth
171:               }
172:               
173:               static void EndAttribute() {
174:                 --depth;
002240  80EBE0     MOV depth, W0
002242  E90000     DEC W0, W0
002244  88EBE0     MOV W0, depth
175:                 switch (state) {
002246  80EBF1     MOV state, W1
002248  508FE6     SUB W1, #0x6, [W15]
00224A  320005     BRA Z, 0x2256
00224C  39001B     BRA NC, 0x2284
00224E  508069     SUB W1, #0x9, W0
002250  500FE1     SUB W0, #0x1, [W15]
002252  3E0018     BRA GTU, 0x2284
002254  37000C     BRA 0x226E
176:                   case AUTH_STATE_NAME_ATTR:
177:                     if (package_name_cursor == sizeof(manager_app_name) - 1
002256  80EB52     MOV package_name_cursor, W2
002258  510FEC     SUB W2, #0xC, [W15]
00225A  3A0007     BRA NZ, 0x226A
00225C  21DF21     MOV #0x1DF2, W1
00225E  21D6C0     MOV #0x1D6C, W0
002260  07F060     RCALL memcmp
002262  E00000     CP0 W0
002264  3A0002     BRA NZ, 0x226A
178:                         && memcmp(package_name, manager_app_name, package_name_cursor) == 0) {
179:                       name_matches = 1;
002266  200010     MOV #0x1, W0
002268  88EBD0     MOV W0, name_matches
180:                     }
181:                     state = AUTH_STATE_PACKAGE;
00226A  200050     MOV #0x5, W0
00226C  370007     BRA 0x227C
182:                     break;
183:               
184:                   case AUTH_STATE_CERT_KEY:
185:                   case AUTH_STATE_CERT_FAIL:
186:                     if (state == AUTH_STATE_CERT_KEY && package_key_cursor == sizeof(cert_key) - 1) {
00226E  508FE9     SUB W1, #0x9, [W15]
002270  3A0007     BRA NZ, 0x2280
002272  80EB41     MOV package_key_cursor, W1
002274  2062C0     MOV #0x62C, W0
002276  508F80     SUB W1, W0, [W15]
002278  3A0003     BRA NZ, 0x2280
187:                       state = AUTH_STATE_DONE_PASS;
00227A  EB0000     CLR W0
00227C  88EBF0     MOV W0, state
00227E  060000     RETURN
188:                     } else {
189:                       state = AUTH_STATE_DONE_FAIL;
002286  BE9F88     MOV.D W8, [W15++]
002288  780180     MOV W0, W3
00228A  780401     MOV W1, W8
190:                     }
191:                     break;
192:               
193:                   default:
194:                     break;  // nothing
195:                 }
196:               }
197:               
198:               static void Characters(const char* characters, int size) {
199:                 switch (state) {
00228C  80EBF0     MOV state, W0
00228E  500FE6     SUB W0, #0x6, [W15]
002290  320003     BRA Z, 0x2298
002292  500FE9     SUB W0, #0x9, [W15]
002294  3A0020     BRA NZ, 0x22D6
002296  37000F     BRA 0x22B6
200:                   case AUTH_STATE_NAME_ATTR:
201:                     if (package_name_cursor + size <= sizeof(package_name)) {
002298  80EB51     MOV package_name_cursor, W1
00229A  408008     ADD W1, W8, W0
00229C  500FED     SUB W0, #0xD, [W15]
00229E  3E0009     BRA GTU, 0x22B2
202:                       memcpy(package_name + package_name_cursor, characters, size);
0022A0  21D6C0     MOV #0x1D6C, W0
0022A2  408000     ADD W1, W0, W0
0022A4  780108     MOV W8, W2
0022A6  780083     MOV W3, W1
0022A8  07F056     RCALL memcpy
203:                       package_name_cursor += size;
0022AA  80EB50     MOV package_name_cursor, W0
0022AC  440000     ADD W8, W0, W0
0022AE  88EB50     MOV W0, package_name_cursor
0022B0  370012     BRA 0x22D6
204:                     } else {
205:                       state = AUTH_STATE_PACKAGE;
0022B2  200050     MOV #0x5, W0
0022B4  37000F     BRA 0x22D4
206:                     }
207:                     break;
208:               
209:                   case AUTH_STATE_CERT_KEY:
210:                     if (size + package_key_cursor < sizeof(cert_key)
0022B6  80EB41     MOV package_key_cursor, W1
0022B8  440481     ADD W8, W1, W9
0022BA  2062C0     MOV #0x62C, W0
0022BC  548F80     SUB W9, W0, [W15]
0022BE  3E0009     BRA GTU, 0x22D2
0022C0  288740     MOV #0x8874, W0
0022C2  408000     ADD W1, W0, W0
0022C4  780108     MOV W8, W2
0022C6  780083     MOV W3, W1
0022C8  07F02C     RCALL memcmp
0022CA  E00000     CP0 W0
0022CC  3A0002     BRA NZ, 0x22D2
211:                         && memcmp(cert_key + package_key_cursor, characters, size) == 0) {
212:                       package_key_cursor += size;
0022CE  88EB49     MOV W9, package_key_cursor
0022D0  370002     BRA 0x22D6
213:                     } else {
214:                       state = AUTH_STATE_CERT_FAIL;
0022D2  2000A0     MOV #0xA, W0
0022D4  88EBF0     MOV W0, state
215:                     }
216:                     break;
217:               
218:                   default:
219:                     break;  // nothing
220:                 }
221:               }
222:               
223:               static void Error() {
224:                 state = AUTH_STATE_ERROR;
0022DA  200020     MOV #0x2, W0
0022DC  88EBF0     MOV W0, state
225:               }
226:               
227:               static XML_CONTEXT context;
228:               static XML_CALLBACKS callbacks = {
229:                 &StartElement,
230:                 &EndElement,
231:                 &StartAttribute,
232:                 &EndAttribute,
233:                 &Characters,
234:                 &Error
235:               };
236:               
237:               void AuthInit() {
238:                 state = AUTH_STATE_TOP;
0022E0  200030     MOV #0x3, W0
0022E2  88EBF0     MOV W0, state
239:                 depth = 0;
0022E4  EB0000     CLR W0
0022E6  88EBE0     MOV W0, depth
240:                 XMLInit(&context);
0022E8  21CE00     MOV #0x1CE0, W0
0022EA  37F926     BRA XMLInit
241:               }
242:               
243:               AUTH_RESULT AuthProcess(const char* data, int size) {
244:                   XMLProcess(data, size, &context, &callbacks);
0022EC  21DE63     MOV #0x1DE6, W3
0022EE  21CE02     MOV #0x1CE0, W2
0022F0  07F95C     RCALL XMLProcess
245:                   if (context.state == XML_STATE_ERROR) state = AUTH_DONE_PARSE_ERROR;
0022F2  21D660     MOV #0x1D66, W0
0022F4  2000B1     MOV #0xB, W1
0022F6  108F90     SUBR W1, [W0], [W15]
0022F8  3A0002     BRA NZ, 0x22FE
0022FA  200020     MOV #0x2, W0
0022FC  88EBF0     MOV W0, state
246:                   if (state >= AUTH_BUSY) return AUTH_BUSY;
0022FE  80EBF0     MOV state, W0
002300  200031     MOV #0x3, W1
002302  500FE2     SUB W0, #0x2, [W15]
002304  3E0001     BRA GTU, 0x2308
002306  780080     MOV W0, W1
247:                   return (AUTH_STATE) state;
248:               }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/microchip/usb/usb_host.c  
005FE2  F80036     PUSH RCOUNT
005FE4  BE9F80     MOV.D W0, [W15++]
005FE6  BE9F82     MOV.D W2, [W15++]
005FE8  BE9F84     MOV.D W4, [W15++]
005FEA  BE9F86     MOV.D W6, [W15++]
00BF84  FA0002     LNK #0x2
00BF86  BE9F88     MOV.D W8, [W15++]
00BF88  BE9F8A     MOV.D W10, [W15++]
00BF8A  781F8C     MOV W12, [W15++]
010B1C  4787F0     ADD W15, #0x10, W15
010B1E  BE9F88     MOV.D W8, [W15++]
010B20  BE9F8A     MOV.D W10, [W15++]
010B22  BE9F8C     MOV.D W12, [W15++]
010B24  781F8E     MOV W14, [W15++]
01167E  BE9F88     MOV.D W8, [W15++]
011680  BE9F8A     MOV.D W10, [W15++]
012CB4  784180     MOV.B W0, W3
012CB6  270680     MOV #0x7068, W0
012F80  E8878F     INC2 W15, W15
012F82  BE9F88     MOV.D W8, [W15++]
012F84  BE9F8A     MOV.D W10, [W15++]
012F86  BE9F8C     MOV.D W12, [W15++]
012F88  781F8E     MOV W14, [W15++]
012F8A  784601     MOV.B W1, W12
012F8C  784582     MOV.B W2, W11
012F8E  780403     MOV W3, W8
012F90  780484     MOV W4, W9
012F92  780505     MOV W5, W10
012F94  780686     MOV W6, W13
012F96  784707     MOV.B W7, W14
0137D2  781F88     MOV W8, [W15++]
01385E  4787EE     ADD W15, #0xE, W15
013860  BE9F88     MOV.D W8, [W15++]
013862  BE9F8A     MOV.D W10, [W15++]
013864  BE9F8C     MOV.D W12, [W15++]
013866  781F8E     MOV W14, [W15++]
013868  9FEFE0     MOV.B W0, [W15-18]
01386A  784701     MOV.B W1, W14
01386C  784682     MOV.B W2, W13
01386E  9FBF83     MOV W3, [W15-16]
013976  784200     MOV.B W0, W4
013F00  BE9F88     MOV.D W8, [W15++]
013F02  781F8A     MOV W10, [W15++]
013F04  784181     MOV.B W1, W3
013F06  780502     MOV W2, W10
013F08  BE0404     MOV.D W4, W8
013F6A  BE9F88     MOV.D W8, [W15++]
013F6C  781F8A     MOV W10, [W15++]
013F6E  784181     MOV.B W1, W3
013F70  780502     MOV W2, W10
013F72  BE0404     MOV.D W4, W8
01422A  BE9F88     MOV.D W8, [W15++]
01422C  784201     MOV.B W1, W4
01422E  BE0402     MOV.D W2, W8
0142E8  BE9F88     MOV.D W8, [W15++]
0142EA  BE9F8A     MOV.D W10, [W15++]
0142EC  781F8C     MOV W12, [W15++]
0142EE  784600     MOV.B W0, W12
0142F0  780481     MOV W1, W9
0142F2  BE0502     MOV.D W2, W10
0145BC  780180     MOV W0, W3
0145BE  780201     MOV W1, W4
014614  780180     MOV W0, W3
014616  780201     MOV W1, W4
014774  781F88     MOV W8, [W15++]
014776  780400     MOV W0, W8
014960  BE9F88     MOV.D W8, [W15++]
014962  781F8A     MOV W10, [W15++]
014964  37001B     BRA 0x1499C
014EA0  784200     MOV.B W0, W4
014F58  781F88     MOV W8, [W15++]
014F5A  784401     MOV.B W1, W8
014F94  BE9F88     MOV.D W8, [W15++]
014F96  370009     BRA 0x14FAA
015412  FA0002     LNK #0x2
015414  781F88     MOV W8, [W15++]
01561E  BE9F88     MOV.D W8, [W15++]
015620  784201     MOV.B W1, W4
015622  BE0402     MOV.D W2, W8
0156E4  784180     MOV.B W0, W3
0158E2  784181     MOV.B W1, W3
0159DC  780180     MOV W0, W3
015CCC  784101     MOV.B W1, W2
1:                 /******************************************************************************
2:                 
3:                     USB Host Driver
4:                 
5:                 This file provides the hardware interface for a USB Embedded Host application.
6:                 Most applications will not make direct use of the functions in this file.
7:                 Instead, one or more client driver files should also be included in the project
8:                 to support the devices that will be attached to the host.  Application
9:                 interface will be through the client drivers.
10:                
11:                Note: USB interrupts are cleared by writing a "1" to the interrupt flag.  This
12:                means that read-modify-write instructions cannot be used to clear the flag.  A
13:                bit manipulation instruction, such as "U1OTGIRbits.T1MSECIF = 1;" will read the
14:                value of the U1OTGIR register, set the T1MSECIF bit in that value to "1", and
15:                then write that value back to U1OTGIR.  If U1OTGIR had any other flags set,
16:                those flags are written back as "1", which will clear those flags.  To avoid
17:                this issue, a constant value must be written to U1OTGIR where only the interrupt
18:                flag in question is set, such as "U1OTGIR = USB_INTERRUPT_T1MSECIF;", where
19:                USB_INTERRUPT_T1MSECIF equals 0x40.
20:                
21:                *******************************************************************************/
22:                //DOM-IGNORE-BEGIN
23:                /******************************************************************************
24:                
25:                 File Name:       usb_host.c
26:                 Dependencies:    None
27:                 Processor:       PIC24F/PIC32MX
28:                 Compiler:        C30/C32
29:                 Company:         Microchip Technology, Inc.
30:                
31:                Software License Agreement
32:                
33:                The software supplied herewith by Microchip Technology Incorporated
34:                (the ‰??Company‰??) for its PICmicroå¨ Microcontroller is intended and
35:                supplied to you, the Company‰??s customer, for use solely and
36:                exclusively on Microchip PICmicro Microcontroller products. The
37:                software is owned by the Company and/or its supplier, and is
38:                protected under applicable copyright laws. All rights are reserved.
39:                Any use in violation of the foregoing restrictions may subject the
40:                user to criminal sanctions under applicable laws, as well as to
41:                civil liability for the breach of the terms and conditions of this
42:                license.
43:                
44:                THIS SOFTWARE IS PROVIDED IN AN ‰??AS IS‰?? CONDITION. NO WARRANTIES,
45:                WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
46:                TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
47:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
48:                IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
49:                CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
50:                
51:                Change History:
52:                  Rev         Description
53:                  ----------  ----------------------------------------------------------
54:                  2.6 - 2.6a  No change
55:                  
56:                  2.7         Fixed an error where the USBHostClearEndpointErrors() function
57:                              didn't properly return USB_SUCCESS if the errors were successfully
58:                              cleared.
59:                              http://www.microchip.com/forums/fb.aspx?m=490651
60:                
61:                              Fixed an error where the DTS bits for the attached device could
62:                              be accidentally reset on a class specific request with the same
63:                              bRequest and wValue as a HALT_ENDPOINT request.
64:                
65:                              Fixed an error where device may never be able to enumerate if it
66:                              is already attached when the host stack initializes.
67:                
68:                *******************************************************************************/
69:                
70:                #include <stdlib.h>
71:                #include <string.h>
72:                #include "GenericTypeDefs.h"
73:                #include "USB/usb.h"
74:                #include "usb_host_local.h"
75:                #include "usb_hal_local.h"
76:                #include "HardwareProfile.h"
77:                //#include "USB/usb_hal.h"
78:                
79:                //#define DEBUG_HEAP
80:                #if defined(DEBUG_HEAP) && defined(ENABLE_LOGGING)
81:                #include "logging.h"
82:                
83:                static unsigned _total_nodes = 0;
84:                static unsigned _total_mem = 0;
85:                
86:                void *_debug_malloc(const char *file, int line, size_t size) {
87:                  static unsigned counter = 1;
88:                  void *ptr = malloc(size + 2 * sizeof(unsigned));
89:                  if (ptr) {
90:                    log_printf("malloc #%u, size=%u from %s: %d", counter, size, file, line);
91:                    ((unsigned *) ptr)[0] = counter;
92:                    ((unsigned *) ptr)[1] = size;
93:                    ++counter;
94:                    ++_total_nodes;
95:                    _total_mem += size;
96:                    log_printf("nodes=%u, mem=%u", _total_nodes, _total_mem);
97:                    return ((unsigned *) ptr) + 2;
98:                  } else {
99:                    log_printf("malloc FAILED, size=%u from %s: %d", size, file, line);
100:                   return NULL;
101:                 }
102:               }
103:               
104:               void _debug_free(const char *file, int line, void *ptr) {
105:                 if (ptr) {
106:                   unsigned *p = ((unsigned *) ptr) - 2;
107:                   unsigned counter = p[0];
108:                   unsigned size = p[1];
109:                   if (!(counter & 0x8000)) {
110:                     log_printf("free #%u from %s: %d", counter, file, line);
111:                     *p |= 0x8000;
112:                     free(p);
113:                     --_total_nodes;
114:                     _total_mem -= size;
115:                     log_printf("nodes=%u, mem=%u", _total_nodes, _total_mem);
116:                   } else {
117:                     log_printf("free ERROR, already freed #%u from %s: %d", counter & 0x7FFF, file, line);
118:                   }
119:                 } else {
120:                   log_printf("free ERROR: NULL from %s: %d", file, line);
121:                 }
122:               }
123:               
124:               #define debug_malloc(size) _debug_malloc(__FILE__, __LINE__, size)
125:               #define debug_free(ptr) _debug_free(__FILE__, __LINE__, ptr)
126:               
127:               #ifndef USB_MALLOC
128:                   #define USB_MALLOC(size) debug_malloc(size)
129:               #endif
130:               
131:               #ifndef USB_FREE
132:                   #define USB_FREE(ptr) debug_free(ptr)
133:               #endif
134:               
135:               #else
136:               
137:               #ifndef USB_MALLOC
138:                   #define USB_MALLOC(size) malloc(size)
139:               #endif
140:               
141:               #ifndef USB_FREE
142:                   #define USB_FREE(ptr) free(ptr)
143:               #endif
144:               
145:               #endif  // defined(DEBUG_HEAP) && defined(ENABLE_LOGGING)
146:               
147:               #define USB_FREE_AND_CLEAR(ptr) {USB_FREE(ptr); ptr = NULL;}
148:               
149:               #if defined( USB_ENABLE_TRANSFER_EVENT )
150:                   #include "struct_queue.h"
151:               #endif
152:               
153:               // *****************************************************************************
154:               // Low Level Functionality Configurations.
155:               
156:               //#define DEBUG_MODE
157:               #ifdef DEBUG_MODE
158:                   #include "uart2.h"
159:               #endif
160:               
161:               // If the TPL includes an entry specifying a VID of 0xFFFF and a PID of 0xFFFF,
162:               // the specified client driver will be used for any device that attaches.  This
163:               // can be useful for debugging or for providing generic charging functionality.
164:               #define ALLOW_GLOBAL_VID_AND_PID
165:               
166:               // If we allow multiple control transactions during a frame and a NAK is
167:               // generated, we don't get TRNIF.  So we will allow only one control transaction
168:               // per frame.
169:               #define ONE_CONTROL_TRANSACTION_PER_FRAME
170:               
171:               // This definition allow Bulk transfers to take all of the remaining bandwidth
172:               // of a frame.
173:               #define ALLOW_MULTIPLE_BULK_TRANSACTIONS_PER_FRAME
174:               
175:               // If this is defined, then we will repeat a NAK'd request in the same frame.
176:               // Otherwise, we will wait until the next frame to repeat the request.  Some
177:               // mass storage devices require the host to wait until the next frame to
178:               // repeat the request.
179:               //#define ALLOW_MULTIPLE_NAKS_PER_FRAME
180:               
181:               //#define USE_MANUAL_DETACH_DETECT
182:               
183:               // The USB specification states that transactions should be tried three times
184:               // if there is a bus error.  We will allow that number to be configurable. The
185:               // maximum value is 31.
186:               #define USB_TRANSACTION_RETRY_ATTEMPTS  20
187:               
188:               //******************************************************************************
189:               //******************************************************************************
190:               // Section: Host Global Variables
191:               //******************************************************************************
192:               //******************************************************************************
193:               
194:               // When using the PIC32, ping pong mode must be set to FULL.
195:               #if defined (__PIC32MX__)
196:                   #if (USB_PING_PONG_MODE != USB_PING_PONG__FULL_PING_PONG)
197:                       #undef USB_PING_PONG_MODE
198:                       #define USB_PING_PONG_MODE USB_PING_PONG__FULL_PING_PONG
199:                   #endif
200:               #endif
201:               
202:               #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
203:                   #if !defined(USB_SUPPORT_OTG) && !defined(USB_SUPPORT_DEVICE)
204:                   static BDT_ENTRY __attribute__ ((aligned(512)))    BDT[2];
205:                   #endif
206:                   #define BDT_IN                                  (&BDT[0])           // EP0 IN Buffer Descriptor
207:                   #define BDT_OUT                                 (&BDT[1])           // EP0 OUT Buffer Descriptor
208:               #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
209:                   #if !defined(USB_SUPPORT_OTG) && !defined(USB_SUPPORT_DEVICE)
210:                   static BDT_ENTRY __attribute__ ((aligned(512)))    BDT[3];
211:                   #endif
212:                   #define BDT_IN                                  (&BDT[0])           // EP0 IN Buffer Descriptor
213:                   #define BDT_OUT                                 (&BDT[1])           // EP0 OUT Even Buffer Descriptor
214:                   #define BDT_OUT_ODD                             (&BDT[2])           // EP0 OUT Odd Buffer Descriptor
215:               #elif (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
216:                   #if !defined(USB_SUPPORT_OTG) && !defined(USB_SUPPORT_DEVICE)
217:                   static BDT_ENTRY __attribute__ ((aligned(512)))    BDT[4];
218:                   #endif
219:                   #define BDT_IN                                  (&BDT[0])           // EP0 IN Even Buffer Descriptor
220:                   #define BDT_IN_ODD                              (&BDT[1])           // EP0 IN Odd Buffer Descriptor
221:                   #define BDT_OUT                                 (&BDT[2])           // EP0 OUT Even Buffer Descriptor
222:                   #define BDT_OUT_ODD                             (&BDT[3])           // EP0 OUT Odd Buffer Descriptor
223:               #endif
224:               
225:               #if defined(USB_SUPPORT_OTG) || defined(USB_SUPPORT_DEVICE)
226:                   extern BDT_ENTRY BDT[] __attribute__ ((aligned (512)));
227:               #endif
228:               
229:               // These should all be moved into the USB_DEVICE_INFO structure.
230:               static BYTE                          countConfigurations;                        // Count the Configuration Descriptors read during enumeration.
231:               static BYTE                          numCommandTries;                            // The number of times the current command has been tried.
232:               static BYTE                          numEnumerationTries;                        // The number of times enumeration has been attempted on the attached device.
233:               static volatile WORD                 numTimerInterrupts;                         // The number of milliseconds elapsed during the current waiting period.
234:               static volatile USB_ENDPOINT_INFO   *pCurrentEndpoint;                           // Pointer to the endpoint currently performing a transfer.
235:               BYTE                                *pCurrentConfigurationDescriptor    = NULL;  // Pointer to the current configuration descriptor of the attached device.
236:               BYTE                                *pDeviceDescriptor                  = NULL;  // Pointer to the Device Descriptor of the attached device.
237:               static BYTE                         *pEP0Data                           = NULL;  // A data buffer for use by EP0.
238:               static volatile WORD                 usbHostState;                               // State machine state of the attached device.
239:               volatile WORD                 usbOverrideHostState;                       // Next state machine state, when set by interrupt processing.
240:               #ifdef ENABLE_STATE_TRACE   // Debug trace support
241:                   static WORD prevHostState;
242:               #endif
243:               
244:               
245:               static USB_BUS_INFO                  usbBusInfo;                                 // Information about the USB bus.
246:               static USB_DEVICE_INFO               usbDeviceInfo;                              // A collection of information about the attached device.
247:               #if defined( USB_ENABLE_TRANSFER_EVENT )
248:                   static USB_EVENT_QUEUE           usbEventQueue;                              // Queue of USB events used to synchronize ISR to main tasks loop.
249:               #endif
250:               static USB_ROOT_HUB_INFO             usbRootHubInfo;                             // Information about a specific port.
251:               
252:               static volatile WORD msec_count = 0;                                             // The current millisecond count.
253:               
254:               USB_DEVICE_INFO* USBHostGetDeviceInfo() { return &usbDeviceInfo; }
255:               
256:               extern const char* accessoryDescs[6];
257:               static int currentDesc;
258:               
259:               
260:               // *****************************************************************************
261:               // *****************************************************************************
262:               // Section: Application Callable Functions
263:               // *****************************************************************************
264:               // *****************************************************************************
265:               
266:               /****************************************************************************
267:                 Function:
268:                   BYTE USBHostClearEndpointErrors( BYTE deviceAddress, BYTE endpoint )
269:               
270:                 Summary:
271:                   This function clears an endpoint's internal error condition.
272:               
273:                 Description:
274:                   This function is called to clear the internal error condition of a device's
275:                   endpoint.  It should be called after the application has dealt with the
276:                   error condition on the device.  This routine clears internal status only;
277:                   it does not interact with the device.
278:               
279:                 Precondition:
280:                   None
281:               
282:                 Parameters:
283:                   BYTE deviceAddress  - Address of device
284:                   BYTE endpoint       - Endpoint to clear error condition
285:               
286:                 Return Values:
287:                   USB_SUCCESS             - Errors cleared
288:                   USB_UNKNOWN_DEVICE      - Device not found
289:                   USB_ENDPOINT_NOT_FOUND  - Specified endpoint not found
290:               
291:                 Remarks:
292:                   None
293:                 ***************************************************************************/
294:               
295:               BYTE USBHostClearEndpointErrors( BYTE deviceAddress, BYTE endpoint )
296:               {
297:                   USB_ENDPOINT_INFO *ep;
298:               
299:                   // Find the required device
300:                   if (deviceAddress != usbDeviceInfo.deviceAddress)
0158E4  200062     MOV #0x6, W2
0158E6  2705B1     MOV #0x705B, W1
0158E8  504F91     SUB.B W0, [W1], [W15]
0158EA  3A000E     BRA NZ, 0x15908
301:                   {
302:                       return USB_UNKNOWN_DEVICE;
303:                   }
304:               
305:                   ep = _USB_FindEndpoint( endpoint );
0158EC  784003     MOV.B W3, W0
0158EE  0256E4     CALL _USB_FindEndpoint
0158F0  000001     NOP
0158F2  780080     MOV W0, W1
306:               
307:                   if (ep != NULL)
0158F4  200142     MOV #0x14, W2
0158F6  E00000     CP0 W0
0158F8  320007     BRA Z, 0x15908
308:                   {
309:                       ep->status.bfStalled    = 0;
0158FA  904020     MOV.B [W0+2], W0
0158FC  A15400     BCLR.B W0, #5
0158FE  9840A0     MOV.B W0, [W1+2]
310:                       ep->status.bfError      = 0;
015900  904021     MOV.B [W1+2], W0
015902  A16400     BCLR.B W0, #6
015904  9840A0     MOV.B W0, [W1+2]
015906  EB0100     CLR W2
311:               
312:                       return USB_SUCCESS;
313:                   }
314:                   return USB_ENDPOINT_NOT_FOUND;
315:               }
316:               
317:               
318:               /****************************************************************************
319:                 Function:
320:                   BOOL    USBHostDeviceSpecificClientDriver( BYTE deviceAddress )
321:               
322:                 Summary:
323:                   This function indicates if the specified device has explicit client
324:                   driver support specified in the TPL.
325:               
326:                 Description:
327:                   This function indicates if the specified device has explicit client
328:                   driver support specified in the TPL.  It is used in client drivers'
329:                   USB_CLIENT_INIT routines to indicate that the client driver should be
330:                   used even though the class, subclass, and protocol values may not match
331:                   those normally required by the class.  For example, some printing devices
332:                   do not fulfill all of the requirements of the printer class, so their
333:                   class, subclass, and protocol fields indicate a custom driver rather than
334:                   the printer class.  But the printer class driver can still be used, with
335:                   minor limitations.
336:               
337:                 Precondition:
338:                   None
339:               
340:                 Parameters:
341:                   BYTE deviceAddress  - Address of device
342:               
343:                 Return Values:
344:                   TRUE    - This device is listed in the TPL by VID andPID, and has explicit
345:                               client driver support.
346:                   FALSE   - This device is not listed in the TPL by VID and PID.
347:               
348:                 Remarks:
349:                   This function is used so client drivers can allow certain
350:                   devices to enumerate.  For example, some printer devices indicate a custom
351:                   class rather than the printer class, even though the device has only minor
352:                   limitations from the full printer class.   The printer client driver will
353:                   fail to initialize the device if it does not indicate printer class support
354:                   in its interface descriptor.  The printer client driver could allow any
355:                   device with an interface that matches the printer class endpoint
356:                   configuration, but both printer and mass storage devices utilize one bulk
357:                   IN and one bulk OUT endpoint.  So a mass storage device would be
358:                   erroneously initialized as a printer device.  This function allows a
359:                   client driver to know that the client driver support was specified
360:                   explicitly in the TPL, so for this particular device only, the class,
361:                   subclass, and protocol fields can be safely ignored.
362:                 ***************************************************************************/
363:               
364:               BOOL    USBHostDeviceSpecificClientDriver( BYTE deviceAddress )
365:               {
366:                   return usbDeviceInfo.flags.bfUseDeviceClientDriver;
01660A  270680     MOV #0x7068, W0
01660C  FB8010     ZE [W0], W0
01660E  DE0046     LSR W0, #6, W0
016610  600061     AND W0, #0x1, W0
367:               }
368:               
369:               
370:               /****************************************************************************
371:                 Function:
372:                   BYTE USBHostDeviceStatus( BYTE deviceAddress )
373:               
374:                 Summary:
375:                   This function returns the current status of a device.
376:               
377:                 Description:
378:                   This function returns the current status of a device.  If the device is
379:                   in a holding state due to an error, the error is returned.
380:               
381:                 Preconditions:
382:                   None
383:               
384:                 Parameters:
385:                   BYTE deviceAddress  - Device address
386:               
387:                 Return Values:
388:                   USB_DEVICE_ATTACHED                 - Device is attached and running
389:                   USB_DEVICE_DETACHED                 - No device is attached
390:                   USB_DEVICE_ENUMERATING              - Device is enumerating
391:                   USB_HOLDING_OUT_OF_MEMORY           - Not enough heap space available
392:                   USB_HOLDING_UNSUPPORTED_DEVICE      - Invalid configuration or
393:                                                           unsupported class
394:                   USB_HOLDING_UNSUPPORTED_HUB         - Hubs are not supported
395:                   USB_HOLDING_INVALID_CONFIGURATION   - Invalid configuration requested
396:                   USB_HOLDING_PROCESSING_CAPACITY     - Processing requirement excessive
397:                   USB_HOLDING_POWER_REQUIREMENT       - Power requirement excessive
398:                   USB_HOLDING_CLIENT_INIT_ERROR       - Client driver failed to initialize
399:                   USB_DEVICE_SUSPENDED                - Device is suspended
400:                   Other                               - Device is holding in an error
401:                                                           state. The return value
402:                                                           indicates the error.
403:               
404:                 Remarks:
405:                   None
406:                 ***************************************************************************/
407:               
408:               BYTE USBHostDeviceStatus( BYTE deviceAddress )
409:               {
410:                   if ((usbHostState & STATE_MASK) == STATE_DETACHED)
0153A6  838370     MOV usbHostState, W0
0153A8  20F003     MOV #0xF00, W3
0153AA  600003     AND W0, W3, W0
0153AC  200312     MOV #0x31, W2
0153AE  320014     BRA Z, 0x153D8
411:                   {
412:                       return USB_DEVICE_DETACHED;
413:                   }
414:               
415:                   if ((usbHostState & STATE_MASK) == STATE_RUNNING)
0153B0  838370     MOV usbHostState, W0
0153B2  600003     AND W0, W3, W0
0153B4  204001     MOV #0x400, W1
0153B6  500F81     SUB W0, W1, [W15]
0153B8  3A0007     BRA NZ, 0x153C8
416:                   {
417:                       if ((usbHostState & SUBSTATE_MASK) == SUBSTATE_SUSPEND_AND_RESUME)
0153BA  838370     MOV usbHostState, W0
0153BC  B20F00     AND #0xF0, W0
0153BE  410169     ADD W2, #0x9, W2
0153C0  500FF0     SUB W0, #0x10, [W15]
0153C2  32000A     BRA Z, 0x153D8
0153C4  51016A     SUB W2, #0xA, W2
0153C6  370008     BRA 0x153D8
418:                       {
419:                           return USB_DEVICE_SUSPENDED;
420:                       }
421:                       else
422:                       {
423:                           return USB_DEVICE_ATTACHED;
424:                       }
425:                   }
426:               
427:                   if ((usbHostState & STATE_MASK) == STATE_HOLDING)
0153C8  838370     MOV usbHostState, W0
0153CA  600003     AND W0, W3, W0
0153CC  200322     MOV #0x32, W2
0153CE  205001     MOV #0x500, W1
0153D0  500F81     SUB W0, W1, [W15]
0153D2  3A0002     BRA NZ, 0x153D8
428:                   {
429:                       return usbDeviceInfo.errorCode;
0153D4  2705C0     MOV #0x705C, W0
0153D6  FB8110     ZE [W0], W2
430:                   }
431:               
432:                   return USB_DEVICE_ENUMERATING;
433:               }
434:               
435:               /****************************************************************************
436:                 Function:
437:                   BOOL USBHostInit(  unsigned long flags  )
438:               
439:                 Summary:
440:                   This function initializes the variables of the USB host stack.
441:               
442:                 Description:
443:                   This function initializes the variables of the USB host stack.  It does
444:                   not initialize the hardware.  The peripheral itself is initialized in one
445:                   of the state machine states.  Therefore, USBHostTasks() should be called
446:                   soon after this function.
447:               
448:                 Precondition:
449:                   None
450:               
451:                 Parameters:
452:                   flags - reserved
453:               
454:                 Return Values:
455:                   TRUE  - Initialization successful
456:                   FALSE - Could not allocate memory.
457:               
458:                 Remarks:
459:                   If the endpoint list is empty, an entry is created in the endpoint list
460:                   for EP0.  If the list is not empty, free all allocated memory other than
461:                   the EP0 node.  This allows the routine to be called multiple times by the
462:                   application.
463:                 ***************************************************************************/
464:               
465:               BOOL USBHostInit(  unsigned long flags  )
466:               {
467:                   // Allocate space for Endpoint 0.  We will initialize it in the state machine,
468:                   // so we can reinitialize when another device connects.  If the Endpoint 0
469:                   // node already exists, free all other allocated memory.
470:                   if (usbDeviceInfo.pEndpoint0 == NULL)
0153DC  270660     MOV #0x7066, W0
0153DE  E00010     CP0 [W0]
0153E0  3A0008     BRA NZ, 0x153F2
471:                   {
472:                       if ((usbDeviceInfo.pEndpoint0 = (USB_ENDPOINT_INFO*)USB_MALLOC( sizeof(USB_ENDPOINT_INFO) )) == NULL)
0153E2  200220     MOV #0x22, W0
0153E4  0257A6     CALL malloc
0153E6  000000     NOP
0153E8  8B8330     MOV W0, 0x7066
0153EA  E00000     CP0 W0
0153EC  320011     BRA Z, 0x15410
473:                       {
474:                           #ifdef DEBUG_MODE
475:                               UART2PrintString( "HOST: Cannot allocate for endpoint 0.\r\n" );
476:                           #endif
477:                           //return USB_MEMORY_ALLOCATION_ERROR;
478:                           return FALSE;
479:                       }
480:                       usbDeviceInfo.pEndpoint0->next = NULL;
0153EE  EB0800     CLR [W0]
0153F0  370002     BRA 0x153F6
481:                   }
482:                   else
483:                   {
484:                       _USB_FreeMemory();
0153F2  024F94     CALL _USB_FreeMemory
0153F4  000001     NOP
485:                   }
486:               
487:                   // Initialize other variables.
488:                   pCurrentEndpoint                        = usbDeviceInfo.pEndpoint0;
0153F6  838330     MOV 0x7066, W0
0153F8  8B8380     MOV W0, pCurrentEndpoint
489:                   usbHostState                            = STATE_DETACHED;
0153FA  EB0080     CLR W1
0153FC  8B8371     MOV W1, usbHostState
490:                   usbOverrideHostState                    = NO_STATE;
0153FE  EB8000     SETM W0
015400  8B8280     MOV W0, usbOverrideHostState
491:                   usbDeviceInfo.deviceAddressAndSpeed     = 0;
015402  2705A0     MOV #0x705A, W0
015404  784801     MOV.B W1, [W0]
492:                   usbDeviceInfo.deviceAddress             = 0;
015406  2705B0     MOV #0x705B, W0
015408  784801     MOV.B W1, [W0]
493:                   usbRootHubInfo.flags.bPowerGoodPort0    = 1;
01540A  270540     MOV #0x7054, W0
01540C  A00410     BSET.B [W0], #0
01540E  200010     MOV #0x1, W0
494:               
495:                   // Initialize event queue
496:                   #if defined( USB_ENABLE_TRANSFER_EVENT )
497:                       StructQueueInit(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
498:                   #endif
499:               
500:                   return TRUE;
501:               }
502:               
503:               
504:               /****************************************************************************
505:                 Function:
506:                   BOOL USBHostIsochronousBuffersCreate( ISOCHRONOUS_DATA * isocData,
507:                           BYTE numberOfBuffers, WORD bufferSize )
508:               
509:                 Description:
510:                   This function initializes the isochronous data buffer information and
511:                   allocates memory for each buffer.  This function will not allocate memory
512:                   if the buffer pointer is not NULL.
513:               
514:                 Precondition:
515:                   None
516:               
517:                 Parameters:
518:                   None
519:               
520:                 Return Values:
521:                   TRUE    - All buffers are allocated successfully.
522:                   FALSE   - Not enough heap space to allocate all buffers - adjust the
523:                               project to provide more heap space.
524:               
525:                 Remarks:
526:                   This function is available only if USB_SUPPORT_ISOCHRONOUS_TRANSFERS
527:                   is defined in usb_config.h.
528:               ***************************************************************************/
529:               #ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
530:               
531:               BOOL USBHostIsochronousBuffersCreate( ISOCHRONOUS_DATA * isocData, BYTE numberOfBuffers, WORD bufferSize )
532:               {
533:                   BYTE i;
534:                   BYTE j;
535:               
536:                   USBHostIsochronousBuffersReset( isocData, numberOfBuffers );
537:                   for (i=0; i<numberOfBuffers; i++)
538:                   {
539:                       if (isocData->buffers[i].pBuffer == NULL)
540:                       {
541:                           isocData->buffers[i].pBuffer = USB_MALLOC( bufferSize );
542:                           if (isocData->buffers[i].pBuffer == NULL)
543:                           {
544:                               #ifdef DEBUG_MODE
545:                                   UART2PrintString( "HOST:  Not enough memory for isoc buffers.\r\n" );
546:                               #endif
547:                   
548:                               // Release all previous buffers.
549:                               for (j=0; j<i; j++)
550:                               {
551:                                   USB_FREE_AND_CLEAR( isocData->buffers[j].pBuffer );
552:                                   isocData->buffers[j].pBuffer = NULL;
553:                               }
554:                               return FALSE;
555:                           }
556:                       }
557:                   }
558:                   return TRUE;
559:               }
560:               #endif
561:               
562:               /****************************************************************************
563:                 Function:
564:                   void USBHostIsochronousBuffersDestroy( ISOCHRONOUS_DATA * isocData, BYTE numberOfBuffers )
565:               
566:                 Description:
567:                   This function releases all of the memory allocated for the isochronous
568:                   data buffers.  It also resets all other information about the buffers.
569:               
570:                 Precondition:
571:                   None
572:               
573:                 Parameters:
574:                   None
575:               
576:                 Returns:
577:                   None
578:               
579:                 Remarks:
580:                   This function is available only if USB_SUPPORT_ISOCHRONOUS_TRANSFERS
581:                   is defined in usb_config.h.
582:               ***************************************************************************/
583:               #ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
584:               
585:               void USBHostIsochronousBuffersDestroy( ISOCHRONOUS_DATA * isocData, BYTE numberOfBuffers )
586:               {
587:                   BYTE i;
588:               
589:                   USBHostIsochronousBuffersReset( isocData, numberOfBuffers );
590:                   for (i=0; i<numberOfBuffers; i++)
591:                   {
592:                       if (isocData->buffers[i].pBuffer != NULL)
593:                       {
594:                           USB_FREE_AND_CLEAR( isocData->buffers[i].pBuffer );
595:                           isocData->buffers[i].pBuffer = NULL;
596:                       }
597:                   }
598:               }
599:               #endif
600:               
601:               
602:               /****************************************************************************
603:                 Function:
604:                   void USBHostIsochronousBuffersReset( ISOCHRONOUS_DATA * isocData, BYTE numberOfBuffers )
605:               
606:                 Description:
607:                   This function resets all the isochronous data buffers.  It does not do
608:                   anything with the space allocated for the buffers.
609:               
610:                 Precondition:
611:                   None
612:               
613:                 Parameters:
614:                   None
615:               
616:                 Returns:
617:                   None
618:               
619:                 Remarks:
620:                   This function is available only if USB_SUPPORT_ISOCHRONOUS_TRANSFERS
621:                   is defined in usb_config.h.
622:               ***************************************************************************/
623:               #ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
624:               
625:               void USBHostIsochronousBuffersReset( ISOCHRONOUS_DATA * isocData, BYTE numberOfBuffers )
626:               {
627:                   BYTE    i;
628:               
629:                   for (i=0; i<numberOfBuffers; i++)
630:                   {
631:                       isocData->buffers[i].dataLength        = 0;
632:                       isocData->buffers[i].bfDataLengthValid = 0;
633:                   }
634:               
635:                   isocData->totalBuffers         = numberOfBuffers;
636:                   isocData->currentBufferUser    = 0;
637:                   isocData->currentBufferUSB     = 0;
638:                   isocData->pDataUser            = NULL;
639:               }
640:               #endif
641:               
642:               /****************************************************************************
643:                 Function:
644:                   BYTE USBHostIssueDeviceRequest( BYTE deviceAddress, BYTE bmRequestType,
645:                                   BYTE bRequest, WORD wValue, WORD wIndex, WORD wLength,
646:                                   BYTE *data, BYTE dataDirection, BYTE clientDriverID )
647:               
648:                 Summary:
649:                   This function sends a standard device request to the attached device.
650:               
651:                 Description:
652:                   This function sends a standard device request to the attached device.
653:                   The user must pass in the parameters of the device request.  If there is
654:                   input or output data associated with the request, a pointer to the data
655:                   must be provided.  The direction of the associated data (input or output)
656:                   must also be indicated.
657:               
658:                   This function does no special processing in regards to the request except
659:                   for three requests.  If SET INTERFACE is sent, then DTS is reset for all
660:                   endpoints.  If CLEAR FEATURE (ENDPOINT HALT) is sent, then DTS is reset
661:                   for that endpoint.
662:               
663:                   If the application wishes to change the device configuration, it should
664:                   use the function USBHostSetDeviceConfiguration() rather than this function
665:                   with the SET CONFIGURATION request, since endpoint definitions may
666:                   change.
667:               
668:                 Precondition:
669:                   The host state machine should be in the running state, and no reads or
670:                   writes to EP0 should be in progress.
671:               
672:                 Parameters:
673:                   BYTE deviceAddress  - Device address
674:                   BYTE bmRequestType  - The request type as defined by the USB
675:                                           specification.
676:                   BYTE bRequest       - The request as defined by the USB specification.
677:                   WORD wValue         - The value for the request as defined by the USB
678:                                           specification.
679:                   WORD wIndex         - The index for the request as defined by the USB
680:                                           specification.
681:                   WORD wLength        - The data length for the request as defined by the
682:                                           USB specification.
683:                   BYTE *data          - Pointer to the data for the request.
684:                   BYTE dataDirection  - USB_DEVICE_REQUEST_SET or USB_DEVICE_REQUEST_GET
685:                   BYTE clientDriverID - Client driver to send the event to.
686:               
687:                 Return Values:
688:                   USB_SUCCESS                 - Request processing started
689:                   USB_UNKNOWN_DEVICE          - Device not found
690:                   USB_INVALID_STATE           - The host must be in a normal running state
691:                                                   to do this request
692:                   USB_ENDPOINT_BUSY           - A read or write is already in progress
693:                   USB_ILLEGAL_REQUEST         - SET CONFIGURATION cannot be performed with
694:                                                   this function.
695:               
696:                 Remarks:
697:                   DTS reset is done before the command is issued.
698:                 ***************************************************************************/
699:               
700:               BYTE USBHostIssueDeviceRequest( BYTE deviceAddress, BYTE bmRequestType, BYTE bRequest,
701:                           WORD wValue, WORD wIndex, WORD wLength, BYTE *data, BYTE dataDirection,
702:                           BYTE clientDriverID )
703:               {
704:                   // Find the required device
705:                   if (deviceAddress != usbDeviceInfo.deviceAddress)
012F98  200062     MOV #0x6, W2
012F9A  2705B1     MOV #0x705B, W1
012F9C  504F91     SUB.B W0, [W1], [W15]
012F9E  3A0057     BRA NZ, 0x1304E
706:                   {
707:                       return USB_UNKNOWN_DEVICE;
708:                   }
709:               
710:                   // If we are not in a normal user running state, we cannot do this.
711:                   if ((usbHostState & STATE_MASK) != STATE_RUNNING)
012FA0  838370     MOV usbHostState, W0
012FA2  20F001     MOV #0xF00, W1
012FA4  600001     AND W0, W1, W0
012FA6  200012     MOV #0x1, W2
012FA8  204001     MOV #0x400, W1
012FAA  500F81     SUB W0, W1, [W15]
012FAC  3A0050     BRA NZ, 0x1304E
712:                   {
713:                       return USB_INVALID_STATE;
714:                   }
715:               
716:                   // Make sure no other reads or writes on EP0 are in progress.
717:                   if (!usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
012FAE  838330     MOV 0x7066, W0
012FB0  904030     MOV.B [W0+3], W0
012FB2  200102     MOV #0x10, W2
012FB4  A31800     BTST.Z W0, #1
012FB6  32004B     BRA Z, 0x1304E
718:                   {
719:                       return USB_ENDPOINT_BUSY;
720:                   }
721:               
722:                   // We can't do a SET CONFIGURATION here.  Must use USBHostSetDeviceConfiguration().
723:                   // ***** Some USB classes need to be able to do this, so we'll remove
724:                   // the constraint.
725:               //    if (bRequest == USB_REQUEST_SET_CONFIGURATION)
726:               //    {
727:               //        return USB_ILLEGAL_REQUEST;
728:               //    }
729:               
730:                   // If the user is doing a SET INTERFACE, we must reset DATA0 for all endpoints.
731:                   if (bRequest == USB_REQUEST_SET_INTERFACE)
012FB8  55CFEB     SUB.B W11, #0xB, [W15]
012FBA  3A001F     BRA NZ, 0x12FFA
732:                   {
733:                       USB_ENDPOINT_INFO           *pEndpoint;
734:                       USB_INTERFACE_INFO          *pInterface;
735:                       USB_INTERFACE_SETTING_INFO  *pSetting;
736:               
737:                       // Make sure there are no transfers currently in progress on the current
738:                       // interface setting.
739:                       pInterface = usbDeviceInfo.pInterfaceList;
012FBC  838322     MOV 0x7064, W2
012FBE  370001     BRA 0x12FC2
740:                       while (pInterface && (pInterface->interface != wIndex))
012FC2  E00002     CP0 W2
012FC4  320043     BRA Z, 0x1304C
012FC6  904062     MOV.B [W2+6], W0
012FC8  FB8000     ZE W0, W0
012FCA  500F89     SUB W0, W9, [W15]
012FCC  3AFFF9     BRA NZ, 0x12FC0
741:                       {
742:                           pInterface = pInterface->next;
012FC0  780112     MOV [W2], W2
743:                       }
744:                       if ((pInterface == NULL) || (pInterface->pCurrentSetting == NULL))
012FCE  900022     MOV [W2+4], W0
012FD0  E00000     CP0 W0
012FD2  32003C     BRA Z, 0x1304C
745:                       {
746:                           // The specified interface was not found.
747:                           return USB_ILLEGAL_REQUEST;
748:                       }
749:                       pEndpoint = pInterface->pCurrentSetting->pEndpointList;
012FD4  9000A0     MOV [W0+4], W1
012FD6  370004     BRA 0x12FE0
750:                       while (pEndpoint)
012FE0  E00001     CP0 W1
012FE2  3AFFFA     BRA NZ, 0x12FD8
751:                       {
752:                           if (!pEndpoint->status.bfTransferComplete)
012FD8  904031     MOV.B [W1+3], W0
012FDA  A31800     BTST.Z W0, #1
012FDC  320037     BRA Z, 0x1304C
753:                           {
754:                               // An endpoint on this setting is still transferring data.
755:                               return USB_ILLEGAL_REQUEST;
756:                           }
757:                           pEndpoint = pEndpoint->next;
012FDE  780091     MOV [W1], W1
758:                       }
759:               
760:                       // Make sure the new setting is valid.
761:                       pSetting = pInterface->pInterfaceSettings;
012FE4  900092     MOV [W2+2], W1
012FE6  370001     BRA 0x12FEA
762:                       while( pSetting && (pSetting->interfaceAltSetting != wValue))
012FEA  E00001     CP0 W1
012FEC  32002F     BRA Z, 0x1304C
012FEE  904021     MOV.B [W1+2], W0
012FF0  FB8000     ZE W0, W0
012FF2  500F88     SUB W0, W8, [W15]
012FF4  3AFFF9     BRA NZ, 0x12FE8
763:                       {
764:                           pSetting = pSetting->next;
012FE8  780091     MOV [W1], W1
765:                       }
766:                       if (pSetting == NULL)
767:                       {
768:                           return USB_ILLEGAL_REQUEST;
769:                       }
770:               
771:                       // Set the pointer to the new setting.
772:                       pInterface->pCurrentSetting = pSetting;
012FF6  980121     MOV W1, [W2+4]
012FF8  370009     BRA 0x1300C
773:                   }
774:               
775:                   // If the user is doing a CLEAR FEATURE(ENDPOINT_HALT), we must reset DATA0 for that endpoint.
776:                   if ((bRequest == USB_REQUEST_CLEAR_FEATURE) && (wValue == USB_FEATURE_ENDPOINT_HALT))
012FFA  55CFE1     SUB.B W11, #0x1, [W15]
012FFC  3A0007     BRA NZ, 0x1300C
012FFE  E00003     CP0 W3
013000  3A0005     BRA NZ, 0x1300C
777:                   {
778:                       switch(bmRequestType)
013002  564FE2     SUB.B W12, #0x2, [W15]
013004  3E0003     BRA GTU, 0x1300C
779:                       {
780:                           case 0x00:
781:                           case 0x01:
782:                           case 0x02:
783:                               _USB_ResetDATA0( (BYTE)wIndex );
013006  784004     MOV.B W4, W0
013008  024F1C     CALL _USB_ResetDATA0
01300A  000001     NOP
784:                               break;
785:                           default:
786:                               break;
787:                       }
788:                   }
789:               
790:                   // Set up the control packet.
791:                   pEP0Data[0] = bmRequestType;
01300C  838261     MOV pEP0Data, W1
01300E  78488C     MOV.B W12, [W1]
792:                   pEP0Data[1] = bRequest;
013010  98409B     MOV.B W11, [W1+1]
793:                   pEP0Data[2] = wValue & 0xFF;
013012  9840A8     MOV.B W8, [W1+2]
794:                   pEP0Data[3] = (wValue >> 8) & 0xFF;
013014  DE4048     LSR W8, #8, W0
013016  9840B0     MOV.B W0, [W1+3]
795:                   pEP0Data[4] = wIndex & 0xFF;
013018  9840C9     MOV.B W9, [W1+4]
796:                   pEP0Data[5] = (wIndex >> 8) & 0xFF;
01301A  DE4848     LSR W9, #8, W0
01301C  9840D0     MOV.B W0, [W1+5]
797:                   pEP0Data[6] = wLength & 0xFF;
01301E  9840EA     MOV.B W10, [W1+6]
798:                   pEP0Data[7] = (wLength >> 8) & 0xFF;
013020  DE5048     LSR W10, #8, W0
013022  9840F0     MOV.B W0, [W1+7]
799:               
800:                   // Set up the client driver for the event.
801:                   usbDeviceInfo.pEndpoint0->clientDriver = clientDriverID;
013024  838330     MOV 0x7066, W0
013026  97E92F     MOV.B [W15-22], W2
013028  985812     MOV.B W2, [W0+25]
802:               
803:                   if (dataDirection == USB_DEVICE_REQUEST_SET)
01302A  E0040E     CP0.B W14
01302C  3A0007     BRA NZ, 0x1303C
804:                   {
805:                       // We are doing a SET command that requires data be sent.
806:                       _USB_InitControlWrite( usbDeviceInfo.pEndpoint0, pEP0Data,8, data, wLength );
01302E  78020A     MOV W10, W4
013030  78018D     MOV W13, W3
013032  200082     MOV #0x8, W2
013034  838330     MOV 0x7066, W0
013036  024774     CALL _USB_InitControlWrite
013038  000001     NOP
01303A  370006     BRA 0x13048
807:                   }
808:                   else
809:                   {
810:                       // We are doing a GET request.
811:                       _USB_InitControlRead( usbDeviceInfo.pEndpoint0, pEP0Data, 8, data, wLength );
01303C  78020A     MOV W10, W4
01303E  78018D     MOV W13, W3
013040  200082     MOV #0x8, W2
013042  838330     MOV 0x7066, W0
013044  024C00     CALL _USB_InitControlRead
013046  000001     NOP
013048  EB0100     CLR W2
01304A  370001     BRA 0x1304E
01304C  200032     MOV #0x3, W2
812:                   }
813:               
814:                   return USB_SUCCESS;
815:               }
816:               
817:               /****************************************************************************
818:                 Function:
819:                   BYTE USBHostRead( BYTE deviceAddress, BYTE endpoint, BYTE *pData,
820:                                       DWORD size )
821:                 Summary:
822:                   This function initiates a read from the attached device.
823:               
824:                 Description:
825:                   This function initiates a read from the attached device.
826:               
827:                   If the endpoint is isochronous, special conditions apply.  The pData and
828:                   size parameters have slightly different meanings, since multiple buffers
829:                   are required.  Once started, an isochronous transfer will continue with
830:                   no upper layer intervention until USBHostTerminateTransfer() is called.
831:                   The ISOCHRONOUS_DATA_BUFFERS structure should not be manipulated until
832:                   the transfer is terminated.
833:               
834:                   To clarify parameter usage and to simplify casting, use the macro
835:                   USBHostReadIsochronous() when reading from an isochronous endpoint.
836:               
837:                 Precondition:
838:                   None
839:               
840:                 Parameters:
841:                   BYTE deviceAddress  - Device address
842:                   BYTE endpoint       - Endpoint number
843:                   BYTE *pData         - Pointer to where to store the data. If the endpoint
844:                                           is isochronous, this points to an
845:                                           ISOCHRONOUS_DATA_BUFFERS structure, with multiple
846:                                           data buffer pointers.
847:                   DWORD size          - Number of data bytes to read. If the endpoint is
848:                                           isochronous, this is the number of data buffer
849:                                           pointers pointed to by pData.
850:               
851:                 Return Values:
852:                   USB_SUCCESS                     - Read started successfully.
853:                   USB_UNKNOWN_DEVICE              - Device with the specified address not found.
854:                   USB_INVALID_STATE               - We are not in a normal running state.
855:                   USB_ENDPOINT_ILLEGAL_TYPE       - Must use USBHostControlRead to read
856:                                                       from a control endpoint.
857:                   USB_ENDPOINT_ILLEGAL_DIRECTION  - Must read from an IN endpoint.
858:                   USB_ENDPOINT_STALLED            - Endpoint is stalled.  Must be cleared
859:                                                       by the application.
860:                   USB_ENDPOINT_ERROR              - Endpoint has too many errors.  Must be
861:                                                       cleared by the application.
862:                   USB_ENDPOINT_BUSY               - A Read is already in progress.
863:                   USB_ENDPOINT_NOT_FOUND          - Invalid endpoint.
864:               
865:                 Remarks:
866:                   None
867:                 ***************************************************************************/
868:               
869:               BYTE USBHostRead( BYTE deviceAddress, BYTE endpoint, BYTE *pData, DWORD size )
870:               {
871:                   USB_ENDPOINT_INFO *ep;
872:               
873:                   // Find the required device
874:                   if (deviceAddress != usbDeviceInfo.deviceAddress)
013F0A  200062     MOV #0x6, W2
013F0C  2705B1     MOV #0x705B, W1
013F0E  504F91     SUB.B W0, [W1], [W15]
013F10  3A0028     BRA NZ, 0x13F62
875:                   {
876:                       return USB_UNKNOWN_DEVICE;
877:                   }
878:               
879:                   // If we are not in a normal user running state, we cannot do this.
880:                   if ((usbHostState & STATE_MASK) != STATE_RUNNING)
013F12  838370     MOV usbHostState, W0
013F14  20F001     MOV #0xF00, W1
013F16  600001     AND W0, W1, W0
013F18  200012     MOV #0x1, W2
013F1A  204001     MOV #0x400, W1
013F1C  500F81     SUB W0, W1, [W15]
013F1E  3A0021     BRA NZ, 0x13F62
881:                   {
882:                       return USB_INVALID_STATE;
883:                   }
884:               
885:                   ep = _USB_FindEndpoint( endpoint );
013F20  784003     MOV.B W3, W0
013F22  0256E4     CALL _USB_FindEndpoint
013F24  000001     NOP
013F26  780180     MOV W0, W3
886:                   if (ep)
013F28  200142     MOV #0x14, W2
013F2A  E00000     CP0 W0
013F2C  32001A     BRA Z, 0x13F62
887:                   {
888:                       if (ep->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_CONTROL)
013F2E  900850     MOV [W0+26], W0
013F30  B23000     AND #0x300, W0
013F32  200182     MOV #0x18, W2
013F34  320016     BRA Z, 0x13F62
889:                       {
890:                           // Must not be a control endpoint.
891:                           return USB_ENDPOINT_ILLEGAL_TYPE;
892:                       }
893:               
894:                       if (!(ep->bEndpointAddress & 0x80))
013F36  905823     MOV.B [W3+26], W0
013F38  200152     MOV #0x15, W2
013F3A  E00400     CP0.B W0
013F3C  3D0012     BRA GE, 0x13F62
895:                       {
896:                           // Trying to do an IN with an OUT endpoint.
897:                           return USB_ENDPOINT_ILLEGAL_DIRECTION;
898:                       }
899:               
900:                       if (ep->status.bfStalled)
013F3E  904023     MOV.B [W3+2], W0
013F40  200112     MOV #0x11, W2
013F42  A35800     BTST.Z W0, #5
013F44  3A000E     BRA NZ, 0x13F62
901:                       {
902:                           // The endpoint is stalled.  It must be restarted before a write
903:                           // can be performed.
904:                           return USB_ENDPOINT_STALLED;
905:                       }
906:               
907:                       if (ep->status.bfError)
013F46  904023     MOV.B [W3+2], W0
013F48  200122     MOV #0x12, W2
013F4A  A36800     BTST.Z W0, #6
013F4C  3A000A     BRA NZ, 0x13F62
908:                       {
909:                           // The endpoint has errored.  The error must be cleared before a
910:                           // write can be performed.
911:                           return USB_ENDPOINT_ERROR;
912:                       }
913:               
914:                       if (!ep->status.bfTransferComplete)
013F4E  904033     MOV.B [W3+3], W0
013F50  200102     MOV #0x10, W2
013F52  A31800     BTST.Z W0, #1
013F54  320006     BRA Z, 0x13F62
915:                       {
916:                           // We are already processing a request for this endpoint.
917:                           return USB_ENDPOINT_BUSY;
918:                       }
919:               
920:                       _USB_InitRead( ep, pData, size );
013F56  780108     MOV W8, W2
013F58  78008A     MOV W10, W1
013F5A  780003     MOV W3, W0
013F5C  0245BC     CALL _USB_InitRead
013F5E  000001     NOP
013F60  EB0100     CLR W2
921:               
922:                       return USB_SUCCESS;
923:                   }
924:                   return USB_ENDPOINT_NOT_FOUND;   // Endpoint not found
925:               }
926:               
927:               /****************************************************************************
928:                 Function:
929:                   BYTE USBHostResetDevice( BYTE deviceAddress )
930:               
931:                 Summary:
932:                   This function resets an attached device.
933:               
934:                 Description:
935:                   This function places the device back in the RESET state, to issue RESET
936:                   signaling.  It can be called only if the state machine is not in the
937:                   DETACHED state.
938:               
939:                 Precondition:
940:                   None
941:               
942:                 Parameters:
943:                   BYTE deviceAddress  - Device address
944:               
945:                 Return Values:
946:                   USB_SUCCESS         - Success
947:                   USB_UNKNOWN_DEVICE  - Device not found
948:                   USB_ILLEGAL_REQUEST - Device cannot RESUME unless it is suspended
949:               
950:                 Remarks:
951:                   In order to do a full clean-up, the state is set back to STATE_DETACHED
952:                   rather than a reset state.  The ATTACH interrupt will automatically be
953:                   triggered when the module is re-enabled, and the proper reset will be
954:                   performed.
955:                 ***************************************************************************/
956:               
957:               BYTE USBHostResetDevice( BYTE deviceAddress )
958:               {
959:                   // Find the required device
960:                   if (deviceAddress != usbDeviceInfo.deviceAddress)
015FB4  200062     MOV #0x6, W2
015FB6  2705B1     MOV #0x705B, W1
015FB8  504F91     SUB.B W0, [W1], [W15]
015FBA  3A0008     BRA NZ, 0x15FCC
961:                   {
962:                       return USB_UNKNOWN_DEVICE;
963:                   }
964:               
965:                   if ((usbHostState & STATE_MASK) == STATE_DETACHED)
015FBC  838370     MOV usbHostState, W0
015FBE  20F001     MOV #0xF00, W1
015FC0  600001     AND W0, W1, W0
015FC2  200032     MOV #0x3, W2
015FC4  320003     BRA Z, 0x15FCC
966:                   {
967:                       return USB_ILLEGAL_REQUEST;
968:                   }
969:               
970:                   usbHostState = STATE_DETACHED;
015FC6  EB0000     CLR W0
015FC8  8B8370     MOV W0, usbHostState
015FCA  780100     MOV W0, W2
971:               
972:                   return USB_SUCCESS;
973:               }
974:               
975:               /****************************************************************************
976:                 Function:
977:                   BYTE USBHostResumeDevice( BYTE deviceAddress )
978:               
979:                 Summary:
980:                   This function issues a RESUME to the attached device.
981:               
982:                 Description:
983:                   This function issues a RESUME to the attached device.  It can called only
984:                   if the state machine is in the suspend state.
985:               
986:                 Precondition:
987:                   None
988:               
989:                 Parameters:
990:                   BYTE deviceAddress  - Device address
991:               
992:                 Return Values:
993:                   USB_SUCCESS         - Success
994:                   USB_UNKNOWN_DEVICE  - Device not found
995:                   USB_ILLEGAL_REQUEST - Device cannot RESUME unless it is suspended
996:               
997:                 Remarks:
998:                   None
999:                 ***************************************************************************/
1000:              
1001:              BYTE USBHostResumeDevice( BYTE deviceAddress )
1002:              {
1003:                  // Find the required device
1004:                  if (deviceAddress != usbDeviceInfo.deviceAddress)
015F00  200062     MOV #0x6, W2
015F02  2705B1     MOV #0x705B, W1
015F04  504F91     SUB.B W0, [W1], [W15]
015F06  3A0009     BRA NZ, 0x15F1A
1005:                  {
1006:                      return USB_UNKNOWN_DEVICE;
1007:                  }
1008:              
1009:                  if (usbHostState != (STATE_RUNNING | SUBSTATE_SUSPEND_AND_RESUME | SUBSUBSTATE_SUSPEND))
015F08  838371     MOV usbHostState, W1
015F0A  200032     MOV #0x3, W2
015F0C  204100     MOV #0x410, W0
015F0E  508F80     SUB W1, W0, [W15]
015F10  3A0004     BRA NZ, 0x15F1A
1010:                  {
1011:                      return USB_ILLEGAL_REQUEST;
1012:                  }
1013:              
1014:                  // Advance the state machine to issue resume signalling.
1015:                  _USB_SetNextSubSubState();
015F12  838370     MOV usbHostState, W0
015F14  E80000     INC W0, W0
015F16  8B8370     MOV W0, usbHostState
015F18  EB0100     CLR W2
1016:              
1017:                  return USB_SUCCESS;
1018:              }
1019:              
1020:              /****************************************************************************
1021:                Function:
1022:                  BYTE USBHostSetDeviceConfiguration( BYTE deviceAddress, BYTE configuration )
1023:              
1024:                Summary:
1025:                  This function changes the device's configuration.
1026:              
1027:                Description:
1028:                  This function is used by the application to change the device's
1029:                  Configuration.  This function must be used instead of
1030:                  USBHostIssueDeviceRequest(), because the endpoint definitions may change.
1031:              
1032:                  To see when the reconfiguration is complete, use the USBHostDeviceStatus()
1033:                  function.  If configuration is still in progress, this function will
1034:                  return USB_DEVICE_ENUMERATING.
1035:              
1036:                Precondition:
1037:                  The host state machine should be in the running state, and no reads or
1038:                  writes should be in progress.
1039:              
1040:                Parameters:
1041:                  BYTE deviceAddress  - Device address
1042:                  BYTE configuration  - Index of the new configuration
1043:              
1044:                Return Values:
1045:                  USB_SUCCESS         - Process of changing the configuration was started
1046:                                          successfully.
1047:                  USB_UNKNOWN_DEVICE  - Device not found
1048:                  USB_INVALID_STATE   - This function cannot be called during enumeration
1049:                                          or while performing a device request.
1050:                  USB_BUSY            - No IN or OUT transfers may be in progress.
1051:              
1052:                Example:
1053:                  <code>
1054:                  rc = USBHostSetDeviceConfiguration( attachedDevice, configuration );
1055:                  if (rc)
1056:                  {
1057:                      // Error - cannot set configuration.
1058:                  }
1059:                  else
1060:                  {
1061:                      while (USBHostDeviceStatus( attachedDevice ) == USB_DEVICE_ENUMERATING)
1062:                      {
1063:                          USBHostTasks();
1064:                      }
1065:                  }
1066:                  if (USBHostDeviceStatus( attachedDevice ) != USB_DEVICE_ATTACHED)
1067:                  {
1068:                      // Error - cannot set configuration.
1069:                  }
1070:                  </code>
1071:              
1072:                Remarks:
1073:                  If an invalid configuration is specified, this function cannot return
1074:                  an error.  Instead, the event USB_UNSUPPORTED_DEVICE will the sent to the
1075:                  application layer and the device will be placed in a holding state with a
1076:                  USB_HOLDING_UNSUPPORTED_DEVICE error returned by USBHostDeviceStatus().
1077:                ***************************************************************************/
1078:              
1079:              BYTE USBHostSetDeviceConfiguration( BYTE deviceAddress, BYTE configuration )
1080:              {
1081:                  // Find the required device
1082:                  if (deviceAddress != usbDeviceInfo.deviceAddress)
014F5C  200062     MOV #0x6, W2
014F5E  2705B1     MOV #0x705B, W1
014F60  504F91     SUB.B W0, [W1], [W15]
014F62  3A0015     BRA NZ, 0x14F8E
1083:                  {
1084:                      return USB_UNKNOWN_DEVICE;
1085:                  }
1086:              
1087:                  // If we are not in a normal user running state, we cannot do this.
1088:                  if ((usbHostState & STATE_MASK) != STATE_RUNNING)
014F64  838370     MOV usbHostState, W0
014F66  20F001     MOV #0xF00, W1
014F68  600001     AND W0, W1, W0
014F6A  200012     MOV #0x1, W2
014F6C  204001     MOV #0x400, W1
014F6E  500F81     SUB W0, W1, [W15]
014F70  3A000E     BRA NZ, 0x14F8E
1089:                  {
1090:                      return USB_INVALID_STATE;
1091:                  }
1092:              
1093:                  // Make sure no other reads or writes are in progress.
1094:                  if (_USB_TransferInProgress())
014F72  0255EC     CALL _USB_TransferInProgress
014F74  000001     NOP
014F76  780180     MOV W0, W3
014F78  200022     MOV #0x2, W2
014F7A  E00000     CP0 W0
014F7C  3A0008     BRA NZ, 0x14F8E
1095:                  {
1096:                      return USB_BUSY;
1097:                  }
1098:              
1099:                  // Set the new device configuration.
1100:                  usbDeviceInfo.currentConfiguration = configuration;
014F7E  270580     MOV #0x7058, W0
014F80  784808     MOV.B W8, [W0]
1101:              
1102:                  // We're going to be sending Endpoint 0 commands, so be sure the
1103:                  // client driver indicates the host driver, so we do not send events up
1104:                  // to a client driver.
1105:                  usbDeviceInfo.pEndpoint0->clientDriver = CLIENT_DRIVER_HOST;
014F82  EBC080     SETM.B W1
014F84  838330     MOV 0x7066, W0
014F86  985811     MOV.B W1, [W0+25]
1106:              
1107:                  // Set the state back to configure the device.  This will destroy the
1108:                  // endpoint list and terminate any current transactions.  We already have
1109:                  // the configuration, so we can jump into the Select Configuration state.
1110:                  // If the configuration value is invalid, the state machine will error and
1111:                  // put the device into a holding state.
1112:                  usbHostState = STATE_CONFIGURING | SUBSTATE_SELECT_CONFIGURATION;
014F88  203300     MOV #0x330, W0
014F8A  8B8370     MOV W0, usbHostState
014F8C  780103     MOV W3, W2
1113:              
1114:                  return USB_SUCCESS;
1115:              }
1116:              
1117:              
1118:              /****************************************************************************
1119:                Function:
1120:                  BYTE USBHostSetNAKTimeout( BYTE deviceAddress, BYTE endpoint, WORD flags,
1121:                              WORD timeoutCount )
1122:              
1123:                Summary:
1124:                  This function specifies NAK timeout capability.
1125:              
1126:                Description:
1127:                  This function is used to set whether or not an endpoint on a device
1128:                  should time out a transaction based on the number of NAKs received, and
1129:                  if so, how many NAKs are allowed before the timeout.
1130:              
1131:                Precondition:
1132:                  None
1133:              
1134:                Parameters:
1135:                  BYTE deviceAddress  - Device address
1136:                  BYTE endpoint       - Endpoint number to configure
1137:                  WORD flags          - Bit 0:
1138:                                          * 0 = disable NAK timeout
1139:                                          * 1 = enable NAK timeout
1140:                  WORD timeoutCount   - Number of NAKs allowed before a timeout
1141:              
1142:                Return Values:
1143:                  USB_SUCCESS             - NAK timeout was configured successfully.
1144:                  USB_UNKNOWN_DEVICE      - Device not found.
1145:                  USB_ENDPOINT_NOT_FOUND  - The specified endpoint was not found.
1146:              
1147:                Remarks:
1148:                  None
1149:                ***************************************************************************/
1150:              
1151:              BYTE USBHostSetNAKTimeout( BYTE deviceAddress, BYTE endpoint, WORD flags, WORD timeoutCount )
1152:              {
1153:                  USB_ENDPOINT_INFO *ep;
1154:              
1155:                  // Find the required device
1156:                  if (deviceAddress != usbDeviceInfo.deviceAddress)
015624  200062     MOV #0x6, W2
015626  2705B1     MOV #0x705B, W1
015628  504F91     SUB.B W0, [W1], [W15]
01562A  3A000F     BRA NZ, 0x1564A
1157:                  {
1158:                      return USB_UNKNOWN_DEVICE;
1159:                  }
1160:              
1161:                  ep = _USB_FindEndpoint( endpoint );
01562C  784004     MOV.B W4, W0
01562E  0256E4     CALL _USB_FindEndpoint
015630  000001     NOP
015632  780180     MOV W0, W3
1162:                  if (ep)
015634  200142     MOV #0x14, W2
015636  E00000     CP0 W0
015638  320008     BRA Z, 0x1564A
1163:                  {
1164:                      ep->status.bfNAKTimeoutEnabled  = flags & 0x01;
01563A  6440E1     AND.B W8, #0x1, W1
01563C  DD08C5     SL W1, #5, W1
01563E  904030     MOV.B [W0+3], W0
015640  A15400     BCLR.B W0, #5
015642  704001     IOR.B W0, W1, W0
015644  9841B0     MOV.B W0, [W3+3]
1165:                      ep->timeoutNAKs                 = timeoutCount;
015646  981189     MOV W9, [W3+32]
015648  EB0100     CLR W2
1166:              
1167:                      return USB_SUCCESS;
1168:                  }
1169:                  return USB_ENDPOINT_NOT_FOUND;
1170:              }
1171:              
1172:              
1173:              /****************************************************************************
1174:                Function:
1175:                  void USBHostShutdown( void )
1176:              
1177:                Description:
1178:                  This function turns off the USB module and frees all unnecessary memory.
1179:                  This routine can be called by the application layer to shut down all
1180:                  USB activity, which effectively detaches all devices.  The event
1181:                  EVENT_DETACH will be sent to the client drivers for the attached device,
1182:                  and the event EVENT_VBUS_RELEASE_POWER will be sent to the application
1183:                  layer.
1184:              
1185:                Precondition:
1186:                  None
1187:              
1188:                Parameters:
1189:                  None - None
1190:              
1191:                Returns:
1192:                  None
1193:              
1194:                Remarks:
1195:                  None
1196:                ***************************************************************************/
1197:              
1198:              void USBHostShutdown( void )
1199:              {
1200:                  // Shut off the power to the module first, in case we are in an
1201:                  // overcurrent situation.
1202:              
1203:                  #ifdef  USB_SUPPORT_OTG
1204:                      if (!USBOTGHnpIsActive())
1205:                      {
1206:                          // If we currently have an attached device, notify the higher layers that
1207:                          // the device is being removed.
1208:                          if (usbDeviceInfo.deviceAddress)
1209:                          {
1210:                              USB_VBUS_POWER_EVENT_DATA   powerRequest;
1211:              
1212:                              powerRequest.port = 0;  // Currently was have only one port.
1213:              
1214:                              USB_HOST_APP_EVENT_HANDLER( usbDeviceInfo.deviceAddress, EVENT_VBUS_RELEASE_POWER,
1215:                                  &powerRequest, sizeof(USB_VBUS_POWER_EVENT_DATA) );
1216:                              _USB_NotifyClients(usbDeviceInfo.deviceAddress, EVENT_DETACH,
1217:                                  &usbDeviceInfo.deviceAddress, sizeof(BYTE) );
1218:              
1219:              
1220:                          }
1221:                      }
1222:                  #else
1223:                      U1PWRC = USB_NORMAL_OPERATION | USB_DISABLED;  //MR - Turning off Module will cause unwanted Suspends in OTG
015416  EF2488     CLR U1PWRC
1224:              
1225:                      // If we currently have an attached device, notify the higher layers that
1226:                      // the device is being removed.
1227:                      if (usbDeviceInfo.deviceAddress)
015418  2705B8     MOV #0x705B, W8
01541A  784018     MOV.B [W8], W0
01541C  E00400     CP0.B W0
01541E  32000E     BRA Z, 0x1543C
1228:                      {
1229:                          USB_VBUS_POWER_EVENT_DATA   powerRequest;
1230:              
1231:                          powerRequest.port = 0;  // Currently was have only one port.
015420  EB4080     CLR.B W1
015422  9FFFC1     MOV.B W1, [W15-4]
1232:              
1233:                          USB_HOST_APP_EVENT_HANDLER( usbDeviceInfo.deviceAddress, EVENT_VBUS_RELEASE_POWER,
015424  200024     MOV #0x2, W4
015426  200005     MOV #0x0, W5
015428  578164     SUB W15, #0x4, W2
01542A  2006A1     MOV #0x6A, W1
01542C  02623A     CALL USB_ApplicationEventHandler
01542E  000001     NOP
1234:                              &powerRequest, sizeof(USB_VBUS_POWER_EVENT_DATA) );
1235:                          _USB_NotifyClients(usbDeviceInfo.deviceAddress, EVENT_DETACH,
015430  200013     MOV #0x1, W3
015432  780108     MOV W8, W2
015434  200711     MOV #0x71, W1
015436  784018     MOV.B [W8], W0
015438  0242E8     CALL _USB_NotifyClients
01543A  000001     NOP
1236:                              &usbDeviceInfo.deviceAddress, sizeof(BYTE) );
1237:              
1238:              
1239:                      }
1240:                  #endif
1241:              
1242:                  // Free all extra allocated memory, initialize variables, and reset the
1243:                  // state machine.
1244:                  USBHostInit( 0 );
01543C  B80060     MUL.UU W0, #0, W0
01543E  0253DC     CALL USBHostInit
015440  000001     NOP
1245:              }
1246:              
1247:              
1248:              /****************************************************************************
1249:                Function:
1250:                  BYTE USBHostSuspendDevice( BYTE deviceAddress )
1251:              
1252:                Summary:
1253:                  This function suspends a device.
1254:              
1255:                Description:
1256:                  This function put a device into an IDLE state.  It can only be called
1257:                  while the state machine is in normal running mode.  After 3ms, the
1258:                  attached device should go into SUSPEND mode.
1259:              
1260:                Precondition:
1261:                  None
1262:              
1263:                Parameters:
1264:                  BYTE deviceAddress  - Device to suspend
1265:              
1266:                Return Values:
1267:                  USB_SUCCESS         - Success
1268:                  USB_UNKNOWN_DEVICE  - Device not found
1269:                  USB_ILLEGAL_REQUEST - Cannot suspend unless device is in normal run mode
1270:              
1271:                Remarks:
1272:                  None
1273:                ***************************************************************************/
1274:              
1275:              BYTE USBHostSuspendDevice( BYTE deviceAddress )
1276:              {
1277:                  // Find the required device
1278:                  if (deviceAddress != usbDeviceInfo.deviceAddress)
015F1E  200062     MOV #0x6, W2
015F20  2705B1     MOV #0x705B, W1
015F22  504F91     SUB.B W0, [W1], [W15]
015F24  3A0009     BRA NZ, 0x15F38
1279:                  {
1280:                      return USB_UNKNOWN_DEVICE;
1281:                  }
1282:              
1283:                  if (usbHostState != (STATE_RUNNING | SUBSTATE_NORMAL_RUN))
015F26  838371     MOV usbHostState, W1
015F28  200032     MOV #0x3, W2
015F2A  204000     MOV #0x400, W0
015F2C  508F80     SUB W1, W0, [W15]
015F2E  3A0004     BRA NZ, 0x15F38
1284:                  {
1285:                      return USB_ILLEGAL_REQUEST;
1286:                  }
1287:              
1288:                  // Turn off SOF's, so the bus is idle.
1289:                  U1CONbits.SOFEN = 0;
015F30  A90494     BCLR U1CON, #0
1290:              
1291:                  // Put the state machine in suspend mode.
1292:                  usbHostState = STATE_RUNNING | SUBSTATE_SUSPEND_AND_RESUME | SUBSUBSTATE_SUSPEND;
015F32  400070     ADD W0, #0x10, W0
015F34  8B8370     MOV W0, usbHostState
015F36  EB0100     CLR W2
1293:              
1294:                  return USB_SUCCESS;
1295:              }
1296:              
1297:              /****************************************************************************
1298:                Function:
1299:                  void USBHostTasks( void )
1300:              
1301:                Summary:
1302:                  This function executes the host tasks for USB host operation.
1303:              
1304:                Description:
1305:                  This function executes the host tasks for USB host operation.  It must be
1306:                  executed on a regular basis to keep everything functioning.
1307:              
1308:                  The primary purpose of this function is to handle device attach/detach
1309:                  and enumeration.  It does not handle USB packet transmission or
1310:                  reception; that must be done in the USB interrupt handler to ensure
1311:                  timely operation.
1312:              
1313:                  This routine should be called on a regular basis, but there is no
1314:                  specific time requirement.  Devices will still be able to attach,
1315:                  enumerate, and detach, but the operations will occur more slowly as the
1316:                  calling interval increases.
1317:              
1318:                Precondition:
1319:                  USBHostInit() has been called.
1320:              
1321:                Parameters:
1322:                  None
1323:              
1324:                Returns:
1325:                  None
1326:              
1327:                Remarks:
1328:                  None
1329:                ***************************************************************************/
1330:              
1331:              void USBHostTasks( void )
1332:              {
1333:                  static USB_CONFIGURATION    *pCurrentConfigurationNode;  //MR - made static for OTG
1334:                  USB_INTERFACE_INFO          *pCurrentInterface;
1335:                  BYTE                        *pTemp;
1336:                  BYTE                        temp;
1337:                  USB_VBUS_POWER_EVENT_DATA   powerRequest;
1338:              
1339:                  #ifdef DEBUG_MODE
1340:              //        UART2PutChar('<');
1341:              //        UART2PutHex( usbHostState>>8 );
1342:              //        UART2PutHex( usbHostState & 0xff );
1343:              //        UART2PutChar('-');
1344:              //        UART2PutHex( pCurrentEndpoint->transferState );
1345:              //        UART2PutChar('>');
1346:                  #endif
1347:              
1348:                  // The PIC32MX detach interrupt is not reliable.  If we are not in one of
1349:                  // the detached states, we'll do a check here to see if we've detached.
1350:                  // If the ATTACH bit is 0, we have detached.
1351:                  #ifdef __PIC32MX__
1352:                      #ifdef USE_MANUAL_DETACH_DETECT
1353:                          if (((usbHostState & STATE_MASK) != STATE_DETACHED) && !U1IRbits.ATTACHIF)
1354:                          {
1355:                              #ifdef DEBUG_MODE
1356:                                  UART2PutChar( '>' );
1357:                                  UART2PutChar( ']' );
1358:                              #endif
1359:                              usbHostState = STATE_DETACHED;
1360:                          }
1361:                      #endif
1362:                  #endif
1363:              
1364:                  // Send any queued events to the client and application layers.
1365:                  #if defined ( USB_ENABLE_TRANSFER_EVENT )
1366:                  {
1367:                      USB_EVENT_DATA *item;
1368:                      #if defined( __C30__ )
1369:                          WORD        interrupt_mask;
1370:                      #elif defined( __PIC32MX__ )
1371:                          UINT32      interrupt_mask;
1372:                      #else
1373:                          #error Cannot save interrupt status
1374:                      #endif
1375:              
1376:                      while (StructQueueIsNotEmpty(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
1377:                      {
1378:                          item = StructQueuePeekTail(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
1379:              
1380:                          switch(item->event)
1381:                          {
1382:                              case EVENT_TRANSFER:
1383:                              case EVENT_BUS_ERROR:
1384:                                  _USB_NotifyClients( usbDeviceInfo.deviceAddress, item->event, &item->TransferData, sizeof(HOST_TRANSFER_DATA) );
1385:                                  break;
1386:                              default:
1387:                                  break;
1388:                          }
1389:              
1390:                          // Guard against USB interrupts
1391:                          interrupt_mask = U1IE;
1392:                          U1IE = 0;
1393:              
1394:                          item = StructQueueRemove(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
1395:              
1396:                          // Re-enable USB interrupts
1397:                          U1IE = interrupt_mask;
1398:                      }
1399:                  }
1400:                  #endif
1401:              
1402:                  // See if we got an interrupt to change our state.
1403:                  if (usbOverrideHostState != NO_STATE)
00BF8C  838280     MOV usbOverrideHostState, W0
00BF8E  400FE1     ADD W0, #0x1, [W15]
00BF90  320004     BRA Z, 0xBF9A
1404:                  {
1405:                      #ifdef DEBUG_MODE
1406:                          UART2PutChar('>');
1407:                      #endif
1408:                      usbHostState = usbOverrideHostState;
00BF92  838280     MOV usbOverrideHostState, W0
00BF94  8B8370     MOV W0, usbHostState
1409:                      usbOverrideHostState = NO_STATE;
00BF96  EB8000     SETM W0
00BF98  8B8280     MOV W0, usbOverrideHostState
1410:                  }
1411:              
1412:                  //-------------------------------------------------------------------------
1413:                  // Main State Machine
1414:              
1415:                  switch (usbHostState & STATE_MASK)
00BF9A  838370     MOV usbHostState, W0
00BF9C  20F009     MOV #0xF00, W9
00BF9E  600409     AND W0, W9, W8
00BFA0  202000     MOV #0x200, W0
00BFA2  540F80     SUB W8, W0, [W15]
00BFA4  3201D4     BRA Z, 0xC34E
00BFA6  3E0006     BRA GTU, 0xBFB4
00BFA8  E00008     CP0 W8
00BFAA  32000E     BRA Z, 0xBFC8
00BFAC  201000     MOV #0x100, W0
00BFAE  540F80     SUB W8, W0, [W15]
00BFB0  3A04F2     BRA NZ, 0xC996
00BFB2  37008E     BRA 0xC0D0
00BFB4  204000     MOV #0x400, W0
00BFB6  540F80     SUB W8, W0, [W15]
00BFB8  320494     BRA Z, 0xC8E2
00BFBA  205003     MOV #0x500, W3
00BFBC  540F83     SUB W8, W3, [W15]
00BFBE  3204B4     BRA Z, 0xC928
00BFC0  203000     MOV #0x300, W0
00BFC2  540F80     SUB W8, W0, [W15]
00BFC4  3A04E8     BRA NZ, 0xC996
00BFC6  370203     BRA 0xC3CE
1416:                  {
1417:                      case STATE_DETACHED:
1418:                          switch (usbHostState & SUBSTATE_MASK)
00BFC8  838371     MOV usbHostState, W1
00BFCA  B20F01     AND #0xF0, W1
00BFCC  508FF0     SUB W1, #0x10, [W15]
00BFCE  320056     BRA Z, 0xC07C
00BFD0  200200     MOV #0x20, W0
00BFD2  508F80     SUB W1, W0, [W15]
00BFD4  32005D     BRA Z, 0xC090
00BFD6  E00001     CP0 W1
00BFD8  3A04DE     BRA NZ, 0xC996
1419:                          {
1420:                              case SUBSTATE_INITIALIZE:
1421:                                  // We got here either from initialization or from the user
1422:                                  // unplugging the device at any point in time.
1423:              
1424:                                  // Turn off the module and free up memory.
1425:                                  USBHostShutdown();
00BFDA  025412     CALL USBHostShutdown
00BFDC  000001     NOP
1426:              
1427:                                  #ifdef DEBUG_MODE
1428:                                      UART2PrintString( "HOST: Initializing DETACHED state.\r\n" );
1429:                                  #endif
1430:              
1431:                                  // Initialize Endpoint 0 attributes.
1432:                                  usbDeviceInfo.pEndpoint0->next                         = NULL;
00BFDE  838330     MOV 0x7066, W0
00BFE0  780808     MOV W8, [W0]
1433:                                  usbDeviceInfo.pEndpoint0->status.val                   = 0x00;
00BFE2  838330     MOV 0x7066, W0
00BFE4  980018     MOV W8, [W0+2]
1434:                                  usbDeviceInfo.pEndpoint0->status.bfUseDTS              = 1;
00BFE6  838331     MOV 0x7066, W1
00BFE8  904031     MOV.B [W1+3], W0
00BFEA  A02400     BSET.B W0, #2
00BFEC  9840B0     MOV.B W0, [W1+3]
1435:                                  usbDeviceInfo.pEndpoint0->status.bfTransferComplete    = 1;    // Initialize to success to allow preprocessing loops.
00BFEE  838331     MOV 0x7066, W1
00BFF0  904031     MOV.B [W1+3], W0
00BFF2  A01400     BSET.B W0, #1
00BFF4  9840B0     MOV.B W0, [W1+3]
1436:                                  usbDeviceInfo.pEndpoint0->status.bfNAKTimeoutEnabled   = 1;    // So we can catch devices that NAK forever during enumeration
00BFF6  838331     MOV 0x7066, W1
00BFF8  904031     MOV.B [W1+3], W0
00BFFA  A05400     BSET.B W0, #5
00BFFC  9840B0     MOV.B W0, [W1+3]
1437:                                  usbDeviceInfo.pEndpoint0->timeoutNAKs                  = USB_NUM_CONTROL_NAKS;
00BFFE  838332     MOV 0x7066, W2
00C000  201C20     MOV #0x1C2, W0
00C002  981100     MOV W0, [W2+32]
1438:                                  usbDeviceInfo.pEndpoint0->wMaxPacketSize               = 64;
00C004  200400     MOV #0x40, W0
00C006  980140     MOV W0, [W2+8]
1439:                                  usbDeviceInfo.pEndpoint0->dataCount                    = 0;    // Initialize to 0 since we set bfTransferComplete.
00C008  B80060     MUL.UU W0, #0, W0
00C00A  980900     MOV W0, [W2+16]
00C00C  980911     MOV W1, [W2+18]
1440:                                  usbDeviceInfo.pEndpoint0->bEndpointAddress             = 0;
00C00E  985928     MOV.B W8, [W2+26]
1441:                                  usbDeviceInfo.pEndpoint0->transferState                = TSTATE_IDLE;
00C010  838330     MOV 0x7066, W0
00C012  985808     MOV.B W8, [W0+24]
1442:                                  usbDeviceInfo.pEndpoint0->bmAttributes.bfTransferType  = USB_TRANSFER_TYPE_CONTROL;
00C014  838332     MOV 0x7066, W2
00C016  900852     MOV [W2+26], W0
00C018  2FCFF1     MOV #0xFCFF, W1
00C01A  600001     AND W0, W1, W0
00C01C  980950     MOV W0, [W2+26]
1443:                                  usbDeviceInfo.pEndpoint0->clientDriver                 = CLIENT_DRIVER_HOST;
00C01E  EBC080     SETM.B W1
00C020  838330     MOV 0x7066, W0
00C022  985811     MOV.B W1, [W0+25]
1444:              
1445:                                  // Initialize any device specific information.
1446:                                  numEnumerationTries                 = USB_NUM_ENUMERATION_TRIES;
00C024  B3C031     MOV #0x3, W1
00C026  270740     MOV #0x7074, W0
00C028  784801     MOV.B W1, [W0]
1447:                                  usbDeviceInfo.currentConfiguration  = 0; // Will be overwritten by config process or the user later
00C02A  270580     MOV #0x7058, W0
00C02C  784808     MOV.B W8, [W0]
1448:                                  usbDeviceInfo.attributesOTG         = 0;
00C02E  270590     MOV #0x7059, W0
00C030  784808     MOV.B W8, [W0]
1449:                                  usbDeviceInfo.deviceAddressAndSpeed = 0;
00C032  2705A0     MOV #0x705A, W0
00C034  784808     MOV.B W8, [W0]
1450:                                  usbDeviceInfo.flags.val             = 0;
00C036  8B8348     MOV W8, 0x7068
1451:                                  usbDeviceInfo.pInterfaceList        = NULL;
00C038  8B8328     MOV W8, 0x7064
1452:                                  usbBusInfo.flags.val                = 0;
00C03A  8B8358     MOV W8, usbBusInfo
1453:                                  
1454:                                  // Set up the hardware.
1455:                                  U1IE                = 0;        // Clear and turn off interrupts.
00C03C  882468     MOV W8, U1IE
1456:                                  U1IR                = 0xFF;
00C03E  200FF1     MOV #0xFF, W1
00C040  882451     MOV W1, U1IR
1457:                                  U1OTGIE             &= 0x8C;
00C042  2008C0     MOV #0x8C, W0
00C044  B62482     AND U1OTGIE
1458:                                  U1OTGIR             = 0x7D;
00C046  50006F     SUB W0, #0xF, W0
00C048  882400     MOV W0, U1OTGIR
1459:                                  U1EIE               = 0;
00C04A  882488     MOV W8, U1EIE
1460:                                  U1EIR               = 0xFF;
00C04C  882471     MOV W1, U1EIR
1461:              
1462:                                  // Initialize the Buffer Descriptor Table pointer.
1463:                                  #if defined(__C30__)
1464:                                     U1BDTP1 = (WORD)(&BDT) >> 8;
00C04E  270000     MOV #0x7000, W0
00C050  DE0048     LSR W0, #8, W0
00C052  8824C0     MOV W0, U1BDTP1
1465:                                  #elif defined(__PIC32MX__)
1466:                                     U1BDTP1 = ((DWORD)KVA_TO_PA(&BDT) & 0x0000FF00) >> 8;
1467:                                     U1BDTP2 = ((DWORD)KVA_TO_PA(&BDT) & 0x00FF0000) >> 16;
1468:                                     U1BDTP3 = ((DWORD)KVA_TO_PA(&BDT) & 0xFF000000) >> 24;
1469:                                  #else
1470:                                      #error Cannot set up the Buffer Descriptor Table pointer.
1471:                                  #endif
1472:              
1473:                                  // Configure the module
1474:                                  U1CON               = USB_HOST_MODE_ENABLE | USB_SOF_DISABLE;                       // Turn of SOF's to cut down noise
00C054  200081     MOV #0x8, W1
00C056  8824A1     MOV W1, U1CON
1475:                                  U1CON               = USB_HOST_MODE_ENABLE | USB_PINGPONG_RESET | USB_SOF_DISABLE;  // Reset the ping-pong buffers
00C058  2000A0     MOV #0xA, W0
00C05A  8824A0     MOV W0, U1CON
1476:                                  U1CON               = USB_HOST_MODE_ENABLE | USB_SOF_DISABLE;                       // Release the ping-pong buffers
00C05C  8824A1     MOV W1, U1CON
1477:                                  #ifdef  USB_SUPPORT_OTG
1478:                                      U1OTGCON            |= USB_DPLUS_PULLDOWN_ENABLE | USB_DMINUS_PULLDOWN_ENABLE | USB_OTG_ENABLE; // Pull down D+ and D-
1479:                                  #else
1480:                                      U1OTGCON            = USB_DPLUS_PULLDOWN_ENABLE | USB_DMINUS_PULLDOWN_ENABLE; // Pull down D+ and D-
00C05E  200300     MOV #0x30, W0
00C060  882430     MOV W0, U1OTGCON
1481:                                  #endif
1482:              
1483:                                  #if defined(__PIC32MX__)
1484:                                      U1OTGCON |= USB_VBUS_ON;
1485:                                  #endif
1486:              
1487:                                  U1CNFG1             = USB_PING_PONG_MODE;
00C062  200020     MOV #0x2, W0
00C064  882530     MOV W0, U1CNFG1
1488:                                  #if defined(__C30__)
1489:                                      U1CNFG2         = USB_VBUS_BOOST_ENABLE | USB_VBUS_COMPARE_ENABLE | USB_ONCHIP_ENABLE;
00C066  882548     MOV W8, U1CNFG2
1490:                                  #endif
1491:                                  U1ADDR              = 0;                        // Set default address and LSPDEN to 0
00C068  8824B8     MOV W8, U1ADDR
1492:                                  U1EP0bits.LSPD      = 0;
00C06A  A9E4AA     BCLR U1EP0, #7
1493:                                  U1SOF               = USB_SOF_THRESHOLD_64;     // Maximum EP0 packet size
00C06C  2004A0     MOV #0x4A, W0
00C06E  882500     MOV W0, U1SOF
1494:              
1495:                                  // Set the next substate.  We do this before we enable
1496:                                  // interrupts in case the interrupt changes states.
1497:                                  _USB_SetNextSubState();
00C070  838370     MOV usbHostState, W0
00C072  20FF01     MOV #0xFF0, W1
00C074  600001     AND W0, W1, W0
00C076  400070     ADD W0, #0x10, W0
00C078  8B8370     MOV W0, usbHostState
00C07A  37048D     BRA 0xC996
1498:                                  break;
1499:              
1500:                              case SUBSTATE_WAIT_FOR_POWER:
1501:                                  // We will wait here until the application tells us we can
1502:                                  // turn on power.
1503:                                  if (usbRootHubInfo.flags.bPowerGoodPort0)
00C07C  270540     MOV #0x7054, W0
00C07E  784010     MOV.B [W0], W0
00C080  604061     AND.B W0, #0x1, W0
00C082  320489     BRA Z, 0xC996
1504:                                  {
1505:                                      _USB_SetNextSubState();
00C084  838370     MOV usbHostState, W0
00C086  20FF01     MOV #0xFF0, W1
00C088  600001     AND W0, W1, W0
00C08A  400070     ADD W0, #0x10, W0
00C08C  8B8370     MOV W0, usbHostState
00C08E  370483     BRA 0xC996
1506:                                  }
1507:                                  break;
1508:              
1509:                              case SUBSTATE_TURN_ON_POWER:
1510:                                  powerRequest.port       = 0;
00C090  9FF7C8     MOV.B W8, [W15-12]
1511:                                  powerRequest.current    = USB_INITIAL_VBUS_CURRENT;
00C092  B3C320     MOV #0x32, W0
00C094  9FF7D0     MOV.B W0, [W15-11]
1512:                                  if (USB_HOST_APP_EVENT_HANDLER( USB_ROOT_HUB, EVENT_VBUS_REQUEST_POWER,
00C096  200024     MOV #0x2, W4
00C098  200005     MOV #0x0, W5
00C09A  57816C     SUB W15, #0xC, W2
00C09C  200691     MOV #0x69, W1
00C09E  EBC000     SETM.B W0
00C0A0  02623A     CALL USB_ApplicationEventHandler
00C0A2  000001     NOP
00C0A4  E00000     CP0 W0
00C0A6  32000F     BRA Z, 0xC0C6
1513:                                          &powerRequest, sizeof(USB_VBUS_POWER_EVENT_DATA) ))
1514:                                  {
1515:                                      // Power on the module
1516:                                      U1PWRC                = USB_NORMAL_OPERATION | USB_ENABLED;
00C0A8  200010     MOV #0x1, W0
00C0AA  882440     MOV W0, U1PWRC
1517:              
1518:                                      #if defined( __C30__ )
1519:                                          IFS5            &= 0xFFBF;
00C0AC  A9C08E     BCLR IFS5, #6
1520:                                          IPC21           &= 0xF0FF;
00C0AE  2F0FF0     MOV #0xF0FF, W0
00C0B0  B620CE     AND IPC21
1521:                                          IPC21           |= 0x0500;
00C0B2  205000     MOV #0x500, W0
00C0B4  B720CE     IOR IPC21
1522:                                          IEC5            |= 0x0040;
00C0B6  A8C09E     BSET IEC5, #6
1523:                                      #elif defined( __PIC32MX__ )
1524:                                          // Enable the USB interrupt.
1525:                                          IFS1CLR         = 0x02000000;
1526:                                          IPC11CLR        = 0x0000FF00;
1527:                                          IPC11SET        = 0x00001000;
1528:                                          IEC1SET         = 0x02000000;
1529:                                      #else
1530:                                          #error Cannot enable USB interrupt.
1531:                                      #endif
1532:              
1533:                                      // Set the next substate.  We do this before we enable
1534:                                      // interrupts in case the interrupt changes states.
1535:                                      _USB_SetNextSubState();
00C0B8  838370     MOV usbHostState, W0
00C0BA  20FF01     MOV #0xFF0, W1
00C0BC  600001     AND W0, W1, W0
00C0BE  400070     ADD W0, #0x10, W0
00C0C0  8B8370     MOV W0, usbHostState
1536:              
1537:                                      // Enable the ATTACH interrupt.
1538:                                      U1IEbits.ATTACHIE = 1;
00C0C2  A8C48C     BSET U1IE, #6
00C0C4  370468     BRA 0xC996
1539:              
1540:                                      #if defined(USB_ENABLE_1MS_EVENT)
1541:                                          U1OTGIR                 = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
1542:                                          U1OTGIEbits.T1MSECIE    = 1;
1543:                                      #endif
1544:                                  }
1545:                                  else
1546:                                  {
1547:                                      usbRootHubInfo.flags.bPowerGoodPort0 = 0;
00C0C6  270540     MOV #0x7054, W0
00C0C8  A10410     BCLR.B [W0], #0
1548:                                      usbHostState = STATE_DETACHED | SUBSTATE_WAIT_FOR_POWER;
00C0CA  200100     MOV #0x10, W0
00C0CC  8B8370     MOV W0, usbHostState
00C0CE  370463     BRA 0xC996
1549:                                  }
1550:                                  break;
1551:              
1552:                              case SUBSTATE_WAIT_FOR_DEVICE:
1553:                                  // Wait here for the ATTACH interrupt.
1554:                                  #ifdef  USB_SUPPORT_OTG
1555:                                      U1IEbits.ATTACHIE = 1;
1556:                                  #endif
1557:                              break;
1558:                          }
1559:                          break;
1560:              
1561:                      case STATE_ATTACHED:
1562:                          switch (usbHostState & SUBSTATE_MASK)
00C0D0  838371     MOV usbHostState, W1
00C0D2  B20F01     AND #0xF0, W1
00C0D4  200200     MOV #0x20, W0
00C0D6  508F80     SUB W1, W0, [W15]
00C0D8  32008B     BRA Z, 0xC1F0
00C0DA  3E0005     BRA GTU, 0xC0E6
00C0DC  E00001     CP0 W1
00C0DE  32000A     BRA Z, 0xC0F4
00C0E0  508FF0     SUB W1, #0x10, [W15]
00C0E2  3A0459     BRA NZ, 0xC996
00C0E4  37001F     BRA 0xC124
00C0E6  200300     MOV #0x30, W0
00C0E8  508F80     SUB W1, W0, [W15]
00C0EA  3200EF     BRA Z, 0xC2CA
00C0EC  400070     ADD W0, #0x10, W0
00C0EE  508F80     SUB W1, W0, [W15]
00C0F0  3A0452     BRA NZ, 0xC996
00C0F2  370126     BRA 0xC340
1563:                          {
1564:                              case SUBSTATE_SETTLE:
1565:                                  // Wait 100ms for the insertion process to complete and power
1566:                                  // at the device to be stable.
1567:                                  switch (usbHostState & SUBSUBSTATE_MASK)
00C0F4  838370     MOV usbHostState, W0
00C0F6  60006F     AND W0, #0xF, W0
00C0F8  320003     BRA Z, 0xC100
00C0FA  500FE2     SUB W0, #0x2, [W15]
00C0FC  3A044C     BRA NZ, 0xC996
00C0FE  37000C     BRA 0xC118
1568:                                  {
1569:                                      case SUBSUBSTATE_START_SETTLING_DELAY:
1570:                                          #ifdef DEBUG_MODE
1571:                                              UART2PrintString( "HOST: Starting settling delay.\r\n" );
1572:                                          #endif
1573:              
1574:                                          // Clear and turn on the DETACH interrupt.
1575:                                          U1IR                    = USB_INTERRUPT_DETACH;   // The interrupt is cleared by writing a '1' to the flag.
00C100  200010     MOV #0x1, W0
00C102  882450     MOV W0, U1IR
1576:                                          U1IEbits.DETACHIE       = 1;
00C104  A8048C     BSET U1IE, #0
1577:              
1578:                                          // Configure and turn on the settling timer - 100ms.
1579:                                          numTimerInterrupts      = USB_INSERT_TIME;
00C106  200FB0     MOV #0xFB, W0
00C108  8B8390     MOV W0, numTimerInterrupts
1580:                                          U1OTGIR                 = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
00C10A  200400     MOV #0x40, W0
00C10C  882400     MOV W0, U1OTGIR
1581:                                          U1OTGIEbits.T1MSECIE    = 1;
00C10E  A8C482     BSET U1OTGIE, #6
1582:                                          _USB_SetNextSubSubState();
00C110  838370     MOV usbHostState, W0
00C112  E80000     INC W0, W0
00C114  8B8370     MOV W0, usbHostState
00C116  37043F     BRA 0xC996
1583:                                          break;
1584:              
1585:                                      case SUBSUBSTATE_WAIT_FOR_SETTLING:
1586:                                          // Wait for the timer to finish in the background.
1587:                                          break;
1588:              
1589:                                      case SUBSUBSTATE_SETTLING_DONE:
1590:                                          _USB_SetNextSubState();
00C118  838370     MOV usbHostState, W0
00C11A  20FF01     MOV #0xFF0, W1
00C11C  600001     AND W0, W1, W0
00C11E  400070     ADD W0, #0x10, W0
00C120  8B8370     MOV W0, usbHostState
00C122  370439     BRA 0xC996
1591:                                          break;
1592:              
1593:                                      default:
1594:                                          // We shouldn't get here.
1595:                                          break;
1596:                                  }
1597:                                  break;
1598:              
1599:                              case SUBSTATE_RESET_DEVICE:
1600:                                  // Reset the device.  We have to do the reset timing ourselves.
1601:                                  switch (usbHostState & SUBSUBSTATE_MASK)
00C124  838370     MOV usbHostState, W0
00C126  60046F     AND W0, #0xF, W8
00C128  540FE2     SUB W8, #0x2, [W15]
00C12A  32004D     BRA Z, 0xC1C6
00C12C  540FE4     SUB W8, #0x4, [W15]
00C12E  320056     BRA Z, 0xC1DC
00C130  E00008     CP0 W8
00C132  3A0431     BRA NZ, 0xC996
1602:                                  {
1603:                                      case SUBSUBSTATE_SET_RESET:
1604:                                          #ifdef DEBUG_MODE
1605:                                              UART2PrintString( "HOST: Resetting the device.\r\n" );
1606:                                          #endif
1607:              
1608:                                          // Prepare a data buffer for us to use.  We'll make it 8 bytes for now,
1609:                                          // which is the minimum wMaxPacketSize for EP0.
1610:                                          if (pEP0Data != NULL)
00C134  838260     MOV pEP0Data, W0
00C136  E00000     CP0 W0
00C138  320003     BRA Z, 0xC140
1611:                                          {
1612:                                              USB_FREE_AND_CLEAR( pEP0Data );
00C13A  0258CA     CALL free
00C13C  000000     NOP
00C13E  8B8268     MOV W8, pEP0Data
1613:                                          }
1614:                                          if ((pEP0Data = (BYTE *)USB_MALLOC( 8 )) == NULL)
00C140  200080     MOV #0x8, W0
00C142  0257A6     CALL malloc
00C144  000000     NOP
00C146  8B8260     MOV W0, pEP0Data
00C148  E00000     CP0 W0
00C14A  3A0006     BRA NZ, 0xC158
1615:                                          {
1616:                                              #ifdef DEBUG_MODE
1617:                                                  UART2PrintString( "HOST: Error alloc-ing pEP0Data\r\n" );
1618:                                              #endif
1619:                                              _USB_SetErrorCode( USB_HOLDING_OUT_OF_MEMORY );
00C14C  B3C330     MOV #0x33, W0
00C14E  2705C1     MOV #0x705C, W1
00C150  784880     MOV.B W0, [W1]
1620:                                              _USB_SetHoldState();
00C152  205000     MOV #0x500, W0
00C154  8B8370     MOV W0, usbHostState
00C156  37041F     BRA 0xC996
00C158  2705A3     MOV #0x705A, W3
1621:                                              break;
1622:                                          }
1623:              
1624:                                          // Initialize the USB Device information
1625:                                          usbDeviceInfo.currentConfiguration      = 0;
00C15A  270580     MOV #0x7058, W0
00C15C  784808     MOV.B W8, [W0]
1626:                                          usbDeviceInfo.attributesOTG             = 0;
00C15E  270590     MOV #0x7059, W0
00C160  784808     MOV.B W8, [W0]
1627:                                          usbDeviceInfo.flags.val                 = 0;
00C162  270682     MOV #0x7068, W2
00C164  8B8348     MOV W8, 0x7068
1628:              
1629:                                          _USB_InitErrorCounters();
00C166  B3C031     MOV #0x3, W1
00C168  270750     MOV #0x7075, W0
00C16A  784801     MOV.B W1, [W0]
1630:              
1631:                                          // Disable all EP's except EP0.
1632:                                          U1EP0  = USB_ENDPOINT_CONTROL_SETUP;
00C16C  2000D0     MOV #0xD, W0
00C16E  882550     MOV W0, U1EP0
1633:                                          U1EP1  = USB_DISABLE_ENDPOINT;
00C170  882568     MOV W8, U1EP1
1634:                                          U1EP2  = USB_DISABLE_ENDPOINT;
00C172  882578     MOV W8, U1EP2
1635:                                          U1EP3  = USB_DISABLE_ENDPOINT;
00C174  882588     MOV W8, U1EP3
1636:                                          U1EP4  = USB_DISABLE_ENDPOINT;
00C176  882598     MOV W8, U1EP4
1637:                                          U1EP5  = USB_DISABLE_ENDPOINT;
00C178  8825A8     MOV W8, U1EP5
1638:                                          U1EP6  = USB_DISABLE_ENDPOINT;
00C17A  8825B8     MOV W8, U1EP6
1639:                                          U1EP7  = USB_DISABLE_ENDPOINT;
00C17C  8825C8     MOV W8, U1EP7
1640:                                          U1EP8  = USB_DISABLE_ENDPOINT;
00C17E  8825D8     MOV W8, U1EP8
1641:                                          U1EP9  = USB_DISABLE_ENDPOINT;
00C180  8825E8     MOV W8, U1EP9
1642:                                          U1EP10 = USB_DISABLE_ENDPOINT;
00C182  8825F8     MOV W8, U1EP10
1643:                                          U1EP11 = USB_DISABLE_ENDPOINT;
00C184  882608     MOV W8, U1EP11
1644:                                          U1EP12 = USB_DISABLE_ENDPOINT;
00C186  882618     MOV W8, U1EP12
1645:                                          U1EP13 = USB_DISABLE_ENDPOINT;
00C188  882628     MOV W8, U1EP13
1646:                                          U1EP14 = USB_DISABLE_ENDPOINT;
00C18A  882638     MOV W8, U1EP14
1647:                                          U1EP15 = USB_DISABLE_ENDPOINT;
00C18C  882648     MOV W8, U1EP15
1648:              
1649:                                          // See if the device is low speed.
1650:                                          if (!U1CONbits.JSTATE)
00C18E  E24494     CP0.B U1CON
00C190  350007     BRA LT, 0xC1A0
1651:                                          {
1652:                                              #ifdef DEBUG_MODE
1653:                                                  UART2PrintString( "HOST: Low Speed!\r\n" );
1654:                                              #endif
1655:                                              usbDeviceInfo.flags.bfIsLowSpeed    = 1;
00C192  A00412     BSET.B [W2], #0
1656:                                              usbDeviceInfo.deviceAddressAndSpeed = 0x80;
00C194  B3C800     MOV #0x80, W0
00C196  784980     MOV.B W0, [W3]
1657:                                              U1ADDR                              = 0x80;
00C198  200800     MOV #0x80, W0
00C19A  8824B0     MOV W0, U1ADDR
1658:                                              U1EP0bits.LSPD                      = 1;
00C19C  A8E4AA     BSET U1EP0, #7
00C19E  370004     BRA 0xC1A8
1659:                                          } else {
1660:                                              // FIX (ytai):
1661:                                              // We may reach this point after a failed
1662:                                              // enumeration (thus not passing through init
1663:                                              // state). It may be that the address has
1664:                                              // already been set. We want to set it back to
1665:                                              // 0 either way.
1666:                                              usbDeviceInfo.flags.bfIsLowSpeed    = 0;
00C1A0  A10412     BCLR.B [W2], #0
1667:                                              usbDeviceInfo.deviceAddressAndSpeed = 0x00;
00C1A2  784988     MOV.B W8, [W3]
1668:                                              U1ADDR                              = 0x00;
00C1A4  8824B8     MOV W8, U1ADDR
1669:                                              U1EP0bits.LSPD                      = 0;
00C1A6  A9E4AA     BCLR U1EP0, #7
1670:                                          }
1671:              
1672:                                          // Reset all ping-pong buffers if they are being used.
1673:                                          U1CONbits.PPBRST                    = 1;
00C1A8  A82494     BSET U1CON, #1
1674:                                          U1CONbits.PPBRST                    = 0;
00C1AA  A92494     BCLR U1CON, #1
1675:                                          usbDeviceInfo.flags.bfPingPongIn    = 0;
00C1AC  270680     MOV #0x7068, W0
00C1AE  A14410     BCLR.B [W0], #4
1676:                                          usbDeviceInfo.flags.bfPingPongOut   = 0;
00C1B0  A15410     BCLR.B [W0], #5
1677:              
1678:                                          #ifdef  USB_SUPPORT_OTG
1679:                                              //Disable HNP
1680:                                              USBOTGDisableHnp();
1681:                                              USBOTGDeactivateHnp();
1682:                                          #endif
1683:              
1684:                                          // Assert reset for 10ms.  Start a timer countdown.
1685:                                          U1CONbits.USBRST                    = 1;
00C1B2  A88494     BSET U1CON, #4
1686:                                          numTimerInterrupts                  = USB_RESET_TIME;
00C1B4  200330     MOV #0x33, W0
00C1B6  8B8390     MOV W0, numTimerInterrupts
1687:                                          //U1OTGIRbits.T1MSECIF                = 1;       // The interrupt is cleared by writing a '1' to the flag.
1688:                                          U1OTGIR                             = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
00C1B8  40006D     ADD W0, #0xD, W0
00C1BA  882400     MOV W0, U1OTGIR
1689:                                          U1OTGIEbits.T1MSECIE                = 1;
00C1BC  A8C482     BSET U1OTGIE, #6
1690:              
1691:                                          _USB_SetNextSubSubState();
00C1BE  838370     MOV usbHostState, W0
00C1C0  E80000     INC W0, W0
00C1C2  8B8370     MOV W0, usbHostState
00C1C4  3703E8     BRA 0xC996
1692:                                          break;
1693:              
1694:                                      case SUBSUBSTATE_RESET_WAIT:
1695:                                          // Wait for the timer to finish in the background.
1696:                                          break;
1697:              
1698:                                      case SUBSUBSTATE_RESET_RECOVERY:
1699:                                          #ifdef DEBUG_MODE
1700:                                              UART2PrintString( "HOST: Reset complete.\r\n" );
1701:                                          #endif
1702:              
1703:                                          // Deassert reset.
1704:                                          U1CONbits.USBRST        = 0;
00C1C6  A98494     BCLR U1CON, #4
1705:              
1706:                                          // Start sending SOF's.
1707:                                          U1CONbits.SOFEN         = 1;
00C1C8  A80494     BSET U1CON, #0
1708:              
1709:                                          // Wait for the reset recovery time.
1710:                                          numTimerInterrupts      = USB_RESET_RECOVERY_TIME;
00C1CA  2000B0     MOV #0xB, W0
00C1CC  8B8390     MOV W0, numTimerInterrupts
1711:                                          U1OTGIR                 = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
00C1CE  200400     MOV #0x40, W0
00C1D0  882400     MOV W0, U1OTGIR
1712:                                          U1OTGIEbits.T1MSECIE    = 1;
00C1D2  A8C482     BSET U1OTGIE, #6
1713:              
1714:                                          _USB_SetNextSubSubState();
00C1D4  838370     MOV usbHostState, W0
00C1D6  E80000     INC W0, W0
00C1D8  8B8370     MOV W0, usbHostState
00C1DA  3703DD     BRA 0xC996
1715:                                          break;
1716:              
1717:                                      case SUBSUBSTATE_RECOVERY_WAIT:
1718:                                          // Wait for the timer to finish in the background.
1719:                                          break;
1720:              
1721:                                      case SUBSUBSTATE_RESET_COMPLETE:
1722:                                          #ifdef DEBUG_MODE
1723:                                              UART2PrintString( "HOST: Reset complete.\r\n" );
1724:                                          #endif
1725:              
1726:                                          // Enable USB interrupts
1727:                                          U1IE                    = USB_INTERRUPT_TRANSFER | USB_INTERRUPT_SOF | USB_INTERRUPT_ERROR | USB_INTERRUPT_DETACH;
00C1DC  2000F0     MOV #0xF, W0
00C1DE  882460     MOV W0, U1IE
1728:                                          U1EIE                   = 0xFF;
00C1E0  200FF0     MOV #0xFF, W0
00C1E2  882480     MOV W0, U1EIE
1729:              
1730:                                          _USB_SetNextSubState();
00C1E4  838370     MOV usbHostState, W0
00C1E6  20FF01     MOV #0xFF0, W1
00C1E8  600001     AND W0, W1, W0
00C1EA  400070     ADD W0, #0x10, W0
00C1EC  8B8370     MOV W0, usbHostState
00C1EE  3703D3     BRA 0xC996
1731:                                          break;
1732:              
1733:                                      default:
1734:                                          // We shouldn't get here.
1735:                                          break;
1736:                                  }
1737:                                  break;
1738:              
1739:                              case SUBSTATE_GET_DEVICE_DESCRIPTOR_SIZE:
1740:                                  // Send the GET DEVICE DESCRIPTOR command to get just the size
1741:                                  // of the descriptor and the max packet size, so we can allocate
1742:                                  // a large enough buffer for getting the whole thing and enough
1743:                                  // buffer space for each piece.
1744:                                  switch (usbHostState & SUBSUBSTATE_MASK)
00C1F0  838370     MOV usbHostState, W0
00C1F2  60006F     AND W0, #0xF, W0
00C1F4  500FE1     SUB W0, #0x1, [W15]
00C1F6  320023     BRA Z, 0xC23E
00C1F8  390003     BRA NC, 0xC200
00C1FA  500FE2     SUB W0, #0x2, [W15]
00C1FC  3A03CC     BRA NZ, 0xC996
00C1FE  370037     BRA 0xC26E
1745:                                  {
1746:                                      case SUBSUBSTATE_SEND_GET_DEVICE_DESCRIPTOR_SIZE:
1747:                                          #ifdef DEBUG_MODE
1748:                                              UART2PrintString( "HOST: Getting Device Descriptor size.\r\n" );
1749:                                          #endif
1750:              
1751:                                          // Set up and send GET DEVICE DESCRIPTOR
1752:                                          if (pDeviceDescriptor != NULL)
00C200  838890     MOV pDeviceDescriptor, W0
00C202  E00000     CP0 W0
00C204  320004     BRA Z, 0xC20E
1753:                                          {
1754:                                              USB_FREE_AND_CLEAR( pDeviceDescriptor );
00C206  0258CA     CALL free
00C208  000000     NOP
00C20A  EB0000     CLR W0
00C20C  8B8890     MOV W0, pDeviceDescriptor
1755:                                          }
1756:              
1757:                                          pEP0Data[0] = USB_SETUP_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
00C20E  838263     MOV pEP0Data, W3
00C210  B3C800     MOV #0x80, W0
00C212  784980     MOV.B W0, [W3]
1758:                                          pEP0Data[1] = USB_REQUEST_GET_DESCRIPTOR;
00C214  B3C060     MOV #0x6, W0
00C216  984190     MOV.B W0, [W3+1]
1759:                                          pEP0Data[2] = 0; // Index
00C218  EB4080     CLR.B W1
00C21A  9841A1     MOV.B W1, [W3+2]
1760:                                          pEP0Data[3] = USB_DESCRIPTOR_DEVICE; // Type
00C21C  B3C010     MOV #0x1, W0
00C21E  9841B0     MOV.B W0, [W3+3]
1761:                                          pEP0Data[4] = 0;
00C220  9841C1     MOV.B W1, [W3+4]
1762:                                          pEP0Data[5] = 0;
00C222  9841D1     MOV.B W1, [W3+5]
1763:                                          pEP0Data[6] = 8;
00C224  B3C080     MOV #0x8, W0
00C226  9841E0     MOV.B W0, [W3+6]
1764:                                          pEP0Data[7] = 0;
00C228  9841F1     MOV.B W1, [W3+7]
1765:              
1766:                                          _USB_InitControlRead( usbDeviceInfo.pEndpoint0, pEP0Data, 8, pEP0Data, 8 );
00C22A  200084     MOV #0x8, W4
00C22C  780104     MOV W4, W2
00C22E  780083     MOV W3, W1
00C230  838330     MOV 0x7066, W0
00C232  024C00     CALL _USB_InitControlRead
00C234  000001     NOP
1767:                                          _USB_SetNextSubSubState();
00C236  838370     MOV usbHostState, W0
00C238  E80000     INC W0, W0
00C23A  8B8370     MOV W0, usbHostState
00C23C  3703AC     BRA 0xC996
1768:                                          break;
1769:              
1770:                                      case SUBSUBSTATE_WAIT_FOR_GET_DEVICE_DESCRIPTOR_SIZE:
1771:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
00C23E  838331     MOV 0x7066, W1
00C240  904031     MOV.B [W1+3], W0
00C242  A31800     BTST.Z W0, #1
00C244  3203A8     BRA Z, 0xC996
1772:                                          {
1773:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
00C246  904031     MOV.B [W1+3], W0
00C248  A30800     BTST.Z W0, #0
00C24A  32000E     BRA Z, 0xC268
1774:                                              {
1775:                                                  #ifndef USB_HUB_SUPPORT_INCLUDED
1776:                                                      // See if a hub is attached.  Hubs are not supported.
1777:                                                      if (pEP0Data[4] == USB_HUB_CLASSCODE)   // bDeviceClass
00C24C  838260     MOV pEP0Data, W0
00C24E  904040     MOV.B [W0+4], W0
00C250  504FE9     SUB.B W0, #0x9, [W15]
00C252  3A0006     BRA NZ, 0xC260
1778:                                                      {
1779:                                                          _USB_SetErrorCode( USB_HOLDING_UNSUPPORTED_HUB );
00C254  B3C350     MOV #0x35, W0
00C256  2705C1     MOV #0x705C, W1
00C258  784880     MOV.B W0, [W1]
1780:                                                          _USB_SetHoldState();
00C25A  205000     MOV #0x500, W0
00C25C  8B8370     MOV W0, usbHostState
00C25E  37039B     BRA 0xC996
1781:                                                      }
1782:                                                      else
1783:                                                      {
1784:                                                          _USB_SetNextSubSubState();
00C260  838370     MOV usbHostState, W0
00C262  E80000     INC W0, W0
00C264  8B8370     MOV W0, usbHostState
00C266  370397     BRA 0xC996
1785:                                                      }
1786:                                                  #else
1787:                                                      _USB_SetNextSubSubState();
1788:                                                  #endif
1789:                                              }
1790:                                              else
1791:                                              {
1792:                                                  // We are here because of either a STALL or a NAK.  See if
1793:                                                  // we have retries left to try the command again or try to
1794:                                                  // enumerate again.
1795:                                                  _USB_CheckCommandAndEnumerationAttempts();
00C268  02551E     CALL _USB_CheckCommandAndEnumerationAttempts
00C26A  000001     NOP
00C26C  370394     BRA 0xC996
1796:                                              }
1797:                                          }
1798:                                          break;
1799:              
1800:                                      case SUBSUBSTATE_GET_DEVICE_DESCRIPTOR_SIZE_COMPLETE:
1801:                                          // Allocate a buffer for the entire Device Descriptor
1802:                                          if ((pDeviceDescriptor = (BYTE *)USB_MALLOC( *pEP0Data )) == NULL)
00C26E  838260     MOV pEP0Data, W0
00C270  FB8010     ZE [W0], W0
00C272  0257A6     CALL malloc
00C274  000000     NOP
00C276  780080     MOV W0, W1
00C278  8B8890     MOV W0, pDeviceDescriptor
00C27A  E00000     CP0 W0
00C27C  3A0006     BRA NZ, 0xC28A
1803:                                          {
1804:                                              // We cannot continue.  Freeze until the device is removed.
1805:                                              _USB_SetErrorCode( USB_HOLDING_OUT_OF_MEMORY );
00C27E  B3C330     MOV #0x33, W0
00C280  2705C1     MOV #0x705C, W1
00C282  784880     MOV.B W0, [W1]
1806:                                              _USB_SetHoldState();
00C284  205000     MOV #0x500, W0
00C286  8B8370     MOV W0, usbHostState
00C288  370386     BRA 0xC996
1807:                                              break;
1808:                                          }
1809:                                          // Save the descriptor size in the descriptor (bLength)
1810:                                          *pDeviceDescriptor = *pEP0Data;
00C28A  838260     MOV pEP0Data, W0
00C28C  784890     MOV.B [W0], [W1]
1811:              
1812:                                          // Set the EP0 packet size.
1813:                                          usbDeviceInfo.pEndpoint0->wMaxPacketSize = ((USB_DEVICE_DESCRIPTOR *)pEP0Data)->bMaxPacketSize0;
00C28E  9040F0     MOV.B [W0+7], W1
00C290  FB8081     ZE W1, W1
00C292  838332     MOV 0x7066, W2
00C294  980141     MOV W1, [W2+8]
1814:              
1815:                                          // Make our pEP0Data buffer the size of the max packet.
1816:                                          USB_FREE_AND_CLEAR( pEP0Data );
00C296  0258CA     CALL free
00C298  000000     NOP
00C29A  EB0000     CLR W0
00C29C  8B8260     MOV W0, pEP0Data
1817:                                          if ((pEP0Data = (BYTE *)USB_MALLOC( usbDeviceInfo.pEndpoint0->wMaxPacketSize )) == NULL)
00C29E  838330     MOV 0x7066, W0
00C2A0  900040     MOV [W0+8], W0
00C2A2  0257A6     CALL malloc
00C2A4  000000     NOP
00C2A6  8B8260     MOV W0, pEP0Data
00C2A8  E00000     CP0 W0
00C2AA  3A0006     BRA NZ, 0xC2B8
1818:                                          {
1819:                                              // We cannot continue.  Freeze until the device is removed.
1820:                                              #ifdef DEBUG_MODE
1821:                                                  UART2PrintString( "HOST: Error re-alloc-ing pEP0Data\r\n" );
1822:                                              #endif
1823:                                              _USB_SetErrorCode( USB_HOLDING_OUT_OF_MEMORY );
00C2AC  B3C330     MOV #0x33, W0
00C2AE  2705C1     MOV #0x705C, W1
00C2B0  784880     MOV.B W0, [W1]
1824:                                              _USB_SetHoldState();
00C2B2  205000     MOV #0x500, W0
00C2B4  8B8370     MOV W0, usbHostState
00C2B6  37036F     BRA 0xC996
1825:                                              break;
1826:                                          }
1827:              
1828:                                          // Clean up and advance to the next substate.
1829:                                          _USB_InitErrorCounters();
00C2B8  B3C031     MOV #0x3, W1
00C2BA  270750     MOV #0x7075, W0
00C2BC  784801     MOV.B W1, [W0]
1830:                                          _USB_SetNextSubState();
00C2BE  838370     MOV usbHostState, W0
00C2C0  20FF01     MOV #0xFF0, W1
00C2C2  600001     AND W0, W1, W0
00C2C4  400070     ADD W0, #0x10, W0
00C2C6  8B8370     MOV W0, usbHostState
00C2C8  370366     BRA 0xC996
1831:                                          break;
1832:              
1833:                                      default:
1834:                                          break;
1835:                                  }
1836:                                  break;
1837:              
1838:                              case SUBSTATE_GET_DEVICE_DESCRIPTOR:
1839:                                  // Send the GET DEVICE DESCRIPTOR command and receive the response
1840:                                  switch (usbHostState & SUBSUBSTATE_MASK)
00C2CA  838370     MOV usbHostState, W0
00C2CC  60006F     AND W0, #0xF, W0
00C2CE  500FE1     SUB W0, #0x1, [W15]
00C2D0  320020     BRA Z, 0xC312
00C2D2  390003     BRA NC, 0xC2DA
00C2D4  500FE2     SUB W0, #0x2, [W15]
00C2D6  3A035F     BRA NZ, 0xC996
00C2D8  37002A     BRA 0xC32E
1841:                                  {
1842:                                      case SUBSUBSTATE_SEND_GET_DEVICE_DESCRIPTOR:
1843:                                          #ifdef DEBUG_MODE
1844:                                              UART2PrintString( "HOST: Getting device descriptor.\r\n" );
1845:                                          #endif
1846:              
1847:                                          // If we are currently sending a token, we cannot do anything.
1848:                                          if (usbBusInfo.flags.bfTokenAlreadyWritten)   //(U1CONbits.TOKBUSY)
00C2DA  2706A0     MOV #0x706A, W0
00C2DC  784010     MOV.B [W0], W0
00C2DE  604170     AND.B W0, #0x10, W2
00C2E0  3A035A     BRA NZ, 0xC996
1849:                                              break;
1850:              
1851:                                          // Set up and send GET DEVICE DESCRIPTOR
1852:                                          pEP0Data[0] = USB_SETUP_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
00C2E2  838261     MOV pEP0Data, W1
00C2E4  B3C800     MOV #0x80, W0
00C2E6  784880     MOV.B W0, [W1]
1853:                                          pEP0Data[1] = USB_REQUEST_GET_DESCRIPTOR;
00C2E8  B3C060     MOV #0x6, W0
00C2EA  984090     MOV.B W0, [W1+1]
1854:                                          pEP0Data[2] = 0; // Index
00C2EC  9840A2     MOV.B W2, [W1+2]
1855:                                          pEP0Data[3] = USB_DESCRIPTOR_DEVICE; // Type
00C2EE  B3C010     MOV #0x1, W0
00C2F0  9840B0     MOV.B W0, [W1+3]
1856:                                          pEP0Data[4] = 0;
00C2F2  9840C2     MOV.B W2, [W1+4]
1857:                                          pEP0Data[5] = 0;
00C2F4  9840D2     MOV.B W2, [W1+5]
1858:                                          pEP0Data[6] = *pDeviceDescriptor;
00C2F6  838890     MOV pDeviceDescriptor, W0
00C2F8  784010     MOV.B [W0], W0
00C2FA  9840E0     MOV.B W0, [W1+6]
1859:                                          pEP0Data[7] = 0;
00C2FC  9840F2     MOV.B W2, [W1+7]
1860:                                          _USB_InitControlRead( usbDeviceInfo.pEndpoint0, pEP0Data, 8, pDeviceDescriptor, *pDeviceDescriptor  );
00C2FE  838893     MOV pDeviceDescriptor, W3
00C300  FB8213     ZE [W3], W4
00C302  200082     MOV #0x8, W2
00C304  838330     MOV 0x7066, W0
00C306  024C00     CALL _USB_InitControlRead
00C308  000001     NOP
1861:                                          _USB_SetNextSubSubState();
00C30A  838370     MOV usbHostState, W0
00C30C  E80000     INC W0, W0
00C30E  8B8370     MOV W0, usbHostState
00C310  370342     BRA 0xC996
1862:                                          break;
1863:              
1864:                                      case SUBSUBSTATE_WAIT_FOR_GET_DEVICE_DESCRIPTOR:
1865:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
00C312  838331     MOV 0x7066, W1
00C314  904031     MOV.B [W1+3], W0
00C316  A31800     BTST.Z W0, #1
00C318  32033E     BRA Z, 0xC996
1866:                                          {
1867:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
00C31A  904031     MOV.B [W1+3], W0
00C31C  A30800     BTST.Z W0, #0
00C31E  320004     BRA Z, 0xC328
1868:                                              {
1869:                                                  _USB_SetNextSubSubState();
00C320  838370     MOV usbHostState, W0
00C322  E80000     INC W0, W0
00C324  8B8370     MOV W0, usbHostState
00C326  370337     BRA 0xC996
1870:                                              }
1871:                                              else
1872:                                              {
1873:                                                  // We are here because of either a STALL or a NAK.  See if
1874:                                                  // we have retries left to try the command again or try to
1875:                                                  // enumerate again.
1876:                                                  _USB_CheckCommandAndEnumerationAttempts();
00C328  02551E     CALL _USB_CheckCommandAndEnumerationAttempts
00C32A  000001     NOP
00C32C  370334     BRA 0xC996
1877:                                              }
1878:                                          }
1879:                                          break;
1880:              
1881:                                      case SUBSUBSTATE_GET_DEVICE_DESCRIPTOR_COMPLETE:
1882:                                          // Clean up and advance to the next substate.
1883:                                          _USB_InitErrorCounters();
00C32E  B3C031     MOV #0x3, W1
00C330  270750     MOV #0x7075, W0
00C332  784801     MOV.B W1, [W0]
1884:                                          _USB_SetNextSubState();
00C334  838370     MOV usbHostState, W0
00C336  20FF01     MOV #0xFF0, W1
00C338  600001     AND W0, W1, W0
00C33A  400070     ADD W0, #0x10, W0
00C33C  8B8370     MOV W0, usbHostState
00C33E  37032B     BRA 0xC996
1885:                                          break;
1886:              
1887:                                      default:
1888:                                          break;
1889:                                  }
1890:                                  break;
1891:              
1892:                              case SUBSTATE_VALIDATE_VID_PID:
1893:                                  #ifdef DEBUG_MODE
1894:                                      UART2PrintString( "HOST: Validating VID and PID.\r\n" );
1895:                                  #endif
1896:              
1897:                                  // Search the TPL for the device's VID & PID.  If a client driver is
1898:                                  // available for the over-all device, use it.  Otherwise, we'll search
1899:                                  // again later for an appropriate class driver.
1900:                                  _USB_FindDeviceLevelClientDriver();
00C340  0237D2     CALL _USB_FindDeviceLevelClientDriver
00C342  000001     NOP
1901:              
1902:                                  // Advance to the next state to assign an address to the device.
1903:                                  //
1904:                                  // Note: We assign an address to all devices and hold later if
1905:                                  // we can't find a supported configuration.
1906:                                  _USB_SetNextState();
00C344  838370     MOV usbHostState, W0
00C346  600009     AND W0, W9, W0
00C348  B01000     ADD #0x100, W0
00C34A  8B8370     MOV W0, usbHostState
00C34C  370324     BRA 0xC996
1907:                                  break;
1908:                          }
1909:                          break;
1910:              
1911:                      case STATE_ADDRESSING:
1912:                          switch (usbHostState & SUBSTATE_MASK)
00C34E  838374     MOV usbHostState, W4
00C350  B20F04     AND #0xF0, W4
00C352  3A0321     BRA NZ, 0xC996
1913:                          {
1914:                              case SUBSTATE_SET_DEVICE_ADDRESS:
1915:                                  // Send the SET ADDRESS command.  We can't set the device address
1916:                                  // in hardware until the entire transaction is complete.
1917:                                  switch (usbHostState & SUBSUBSTATE_MASK)
00C354  838370     MOV usbHostState, W0
00C356  60006F     AND W0, #0xF, W0
00C358  500FE1     SUB W0, #0x1, [W15]
00C35A  32001B     BRA Z, 0xC392
00C35C  390003     BRA NC, 0xC364
00C35E  500FE2     SUB W0, #0x2, [W15]
00C360  3A031A     BRA NZ, 0xC996
00C362  370025     BRA 0xC3AE
1918:                                  {
1919:                                      case SUBSUBSTATE_SEND_SET_DEVICE_ADDRESS:
1920:                                          #ifdef DEBUG_MODE
1921:                                              UART2PrintString( "HOST: Setting device address.\r\n" );
1922:                                          #endif
1923:              
1924:                                          // Select an address for the device.  Store it so we can access it again
1925:                                          // easily.  We'll put the low speed indicator on later.
1926:                                          // This has been broken out so when we allow multiple devices, we have
1927:                                          // a single interface point to allocate a new address.
1928:                                          usbDeviceInfo.deviceAddress = USB_SINGLE_DEVICE_ADDRESS;
00C364  2705B2     MOV #0x705B, W2
00C366  B3C010     MOV #0x1, W0
00C368  784900     MOV.B W0, [W2]
1929:              
1930:                                          // Set up and send SET ADDRESS
1931:                                          pEP0Data[0] = USB_SETUP_HOST_TO_DEVICE | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
00C36A  838261     MOV pEP0Data, W1
00C36C  784884     MOV.B W4, [W1]
1932:                                          pEP0Data[1] = USB_REQUEST_SET_ADDRESS;
00C36E  B3C050     MOV #0x5, W0
00C370  984090     MOV.B W0, [W1+1]
1933:                                          pEP0Data[2] = usbDeviceInfo.deviceAddress;
00C372  784112     MOV.B [W2], W2
00C374  9840A2     MOV.B W2, [W1+2]
1934:                                          pEP0Data[3] = 0;
00C376  9840B4     MOV.B W4, [W1+3]
1935:                                          pEP0Data[4] = 0;
00C378  9840C4     MOV.B W4, [W1+4]
1936:                                          pEP0Data[5] = 0;
00C37A  9840D4     MOV.B W4, [W1+5]
1937:                                          pEP0Data[6] = 0;
00C37C  9840E4     MOV.B W4, [W1+6]
1938:                                          pEP0Data[7] = 0;
00C37E  9840F4     MOV.B W4, [W1+7]
1939:                                          _USB_InitControlWrite( usbDeviceInfo.pEndpoint0, pEP0Data, 8, NULL, 0 );
00C380  780184     MOV W4, W3
00C382  200082     MOV #0x8, W2
00C384  838330     MOV 0x7066, W0
00C386  024774     CALL _USB_InitControlWrite
00C388  000001     NOP
1940:                                          _USB_SetNextSubSubState();
00C38A  838370     MOV usbHostState, W0
00C38C  E80000     INC W0, W0
00C38E  8B8370     MOV W0, usbHostState
00C390  370302     BRA 0xC996
1941:                                          break;
1942:              
1943:                                      case SUBSUBSTATE_WAIT_FOR_SET_DEVICE_ADDRESS:
1944:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
00C392  838331     MOV 0x7066, W1
00C394  904031     MOV.B [W1+3], W0
00C396  A31800     BTST.Z W0, #1
00C398  3202FE     BRA Z, 0xC996
1945:                                          {
1946:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
00C39A  904031     MOV.B [W1+3], W0
00C39C  A30800     BTST.Z W0, #0
00C39E  320004     BRA Z, 0xC3A8
1947:                                              {
1948:                                                  _USB_SetNextSubSubState();
00C3A0  838370     MOV usbHostState, W0
00C3A2  E80000     INC W0, W0
00C3A4  8B8370     MOV W0, usbHostState
00C3A6  3702F7     BRA 0xC996
1949:                                              }
1950:                                              else
1951:                                              {
1952:                                                  // We are here because of either a STALL or a NAK.  See if
1953:                                                  // we have retries left to try the command again or try to
1954:                                                  // enumerate again.
1955:                                                  _USB_CheckCommandAndEnumerationAttempts();
00C3A8  02551E     CALL _USB_CheckCommandAndEnumerationAttempts
00C3AA  000001     NOP
00C3AC  3702F4     BRA 0xC996
1956:                                              }
1957:                                          }
1958:                                          break;
1959:              
1960:                                      case SUBSUBSTATE_SET_DEVICE_ADDRESS_COMPLETE:
1961:                                          // Set the device's address here.
1962:                                          usbDeviceInfo.deviceAddressAndSpeed = (usbDeviceInfo.flags.bfIsLowSpeed << 7) | usbDeviceInfo.deviceAddress;
00C3AE  270680     MOV #0x7068, W0
00C3B0  784010     MOV.B [W0], W0
00C3B2  604061     AND.B W0, #0x1, W0
00C3B4  FB8000     ZE W0, W0
00C3B6  DD0047     SL W0, #7, W0
00C3B8  2705B2     MOV #0x705B, W2
00C3BA  2705A1     MOV #0x705A, W1
00C3BC  704892     IOR.B W0, [W2], [W1]
1963:              
1964:                                          // Clean up and advance to the next state.
1965:                                          _USB_InitErrorCounters();
00C3BE  B3C031     MOV #0x3, W1
00C3C0  270750     MOV #0x7075, W0
00C3C2  784801     MOV.B W1, [W0]
1966:                                          _USB_SetNextState();
00C3C4  838370     MOV usbHostState, W0
00C3C6  600009     AND W0, W9, W0
00C3C8  B01000     ADD #0x100, W0
00C3CA  8B8370     MOV W0, usbHostState
00C3CC  3702E4     BRA 0xC996
1967:                                          break;
1968:              
1969:                                      default:
1970:                                          break;
1971:                                  }
1972:                                  break;
1973:                          }
1974:                          break;
1975:              
1976:                      case STATE_CONFIGURING:
1977:                          switch (usbHostState & SUBSTATE_MASK)
00C3CE  838372     MOV usbHostState, W2
00C3D0  B20F02     AND #0xF0, W2
00C3D2  200200     MOV #0x20, W0
00C3D4  510F80     SUB W2, W0, [W15]
00C3D6  320091     BRA Z, 0xC4FA
00C3D8  3E0005     BRA GTU, 0xC3E4
00C3DA  E00002     CP0 W2
00C3DC  32000D     BRA Z, 0xC3F8
00C3DE  510FF0     SUB W2, #0x10, [W15]
00C3E0  3A02DA     BRA NZ, 0xC996
00C3E2  370021     BRA 0xC426
00C3E4  200400     MOV #0x40, W0
00C3E6  510F80     SUB W2, W0, [W15]
00C3E8  320161     BRA Z, 0xC6AC
00C3EA  400070     ADD W0, #0x10, W0
00C3EC  510F80     SUB W2, W0, [W15]
00C3EE  320202     BRA Z, 0xC7F4
00C3F0  200300     MOV #0x30, W0
00C3F2  510F80     SUB W2, W0, [W15]
00C3F4  3A02D0     BRA NZ, 0xC996
00C3F6  3700CB     BRA 0xC58E
1978:                          {
1979:                              case SUBSTATE_INIT_CONFIGURATION:
1980:                                  // Delete the old list of configuration descriptors and
1981:                                  // initialize the counter.  We will request the descriptors
1982:                                  // from highest to lowest so the lowest will be first in
1983:                                  // the list.
1984:                                  countConfigurations = ((USB_DEVICE_DESCRIPTOR *)pDeviceDescriptor)->bNumConfigurations;
00C3F8  838891     MOV pDeviceDescriptor, W1
00C3FA  270760     MOV #0x7076, W0
00C3FC  905091     MOV.B [W1+17], W1
00C3FE  784801     MOV.B W1, [W0]
00C400  370009     BRA 0xC414
1985:                                  while (usbDeviceInfo.pConfigurationDescriptorList != NULL)
00C414  838310     MOV 0x7062, W0
00C416  E00000     CP0 W0
00C418  3AFFF4     BRA NZ, 0xC402
1986:                                  {
1987:                                      pTemp = (BYTE *)usbDeviceInfo.pConfigurationDescriptorList->next;
00C402  900410     MOV [W0+2], W8
1988:                                      USB_FREE_AND_CLEAR( usbDeviceInfo.pConfigurationDescriptorList->descriptor );
00C404  780010     MOV [W0], W0
00C406  0258CA     CALL free
00C408  000000     NOP
00C40A  838310     MOV 0x7062, W0
00C40C  EB0800     CLR [W0]
1989:                                      USB_FREE_AND_CLEAR( usbDeviceInfo.pConfigurationDescriptorList );
00C40E  0258CA     CALL free
00C410  000000     NOP
1990:                                      usbDeviceInfo.pConfigurationDescriptorList = (USB_CONFIGURATION *)pTemp;
00C412  8B8318     MOV W8, 0x7062
1991:                                  }
1992:                                  _USB_SetNextSubState();
00C41A  838370     MOV usbHostState, W0
00C41C  20FF01     MOV #0xFF0, W1
00C41E  600001     AND W0, W1, W0
00C420  400070     ADD W0, #0x10, W0
00C422  8B8370     MOV W0, usbHostState
00C424  3702B8     BRA 0xC996
1993:                                  break;
1994:              
1995:                              case SUBSTATE_GET_CONFIG_DESCRIPTOR_SIZE:
1996:                                  // Get the size of the Configuration Descriptor for the current configuration
1997:                                  switch (usbHostState & SUBSUBSTATE_MASK)
00C426  838370     MOV usbHostState, W0
00C428  60006F     AND W0, #0xF, W0
00C42A  500FE1     SUB W0, #0x1, [W15]
00C42C  32001E     BRA Z, 0xC46A
00C42E  390003     BRA NC, 0xC436
00C430  500FE2     SUB W0, #0x2, [W15]
00C432  3A02B1     BRA NZ, 0xC996
00C434  370028     BRA 0xC486
1998:                                  {
1999:                                      case SUBSUBSTATE_SEND_GET_CONFIG_DESCRIPTOR_SIZE:
2000:                                          #ifdef DEBUG_MODE
2001:                                              UART2PrintString( "HOST: Getting Config Descriptor size.\r\n" );
2002:                                          #endif
2003:              
2004:                                          // Set up and send GET CONFIGURATION (n) DESCRIPTOR with a length of 8
2005:                                          pEP0Data[0] = USB_SETUP_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
00C436  838263     MOV pEP0Data, W3
00C438  B3C800     MOV #0x80, W0
00C43A  784980     MOV.B W0, [W3]
2006:                                          pEP0Data[1] = USB_REQUEST_GET_DESCRIPTOR;
00C43C  B3C060     MOV #0x6, W0
00C43E  984190     MOV.B W0, [W3+1]
2007:                                          pEP0Data[2] = countConfigurations-1;    // USB 2.0 - range is 0 - count-1
00C440  270760     MOV #0x7076, W0
00C442  E94010     DEC.B [W0], W0
00C444  9841A0     MOV.B W0, [W3+2]
2008:                                          pEP0Data[3] = USB_DESCRIPTOR_CONFIGURATION;
00C446  B3C020     MOV #0x2, W0
00C448  9841B0     MOV.B W0, [W3+3]
2009:                                          pEP0Data[4] = 0;
00C44A  EB4080     CLR.B W1
00C44C  9841C1     MOV.B W1, [W3+4]
2010:                                          pEP0Data[5] = 0;
00C44E  9841D1     MOV.B W1, [W3+5]
2011:                                          pEP0Data[6] = 8;
00C450  B3C080     MOV #0x8, W0
00C452  9841E0     MOV.B W0, [W3+6]
2012:                                          pEP0Data[7] = 0;
00C454  9841F1     MOV.B W1, [W3+7]
2013:                                          _USB_InitControlRead( usbDeviceInfo.pEndpoint0, pEP0Data, 8, pEP0Data, 8 );
00C456  200084     MOV #0x8, W4
00C458  780104     MOV W4, W2
00C45A  780083     MOV W3, W1
00C45C  838330     MOV 0x7066, W0
00C45E  024C00     CALL _USB_InitControlRead
00C460  000001     NOP
2014:                                          _USB_SetNextSubSubState();
00C462  838370     MOV usbHostState, W0
00C464  E80000     INC W0, W0
00C466  8B8370     MOV W0, usbHostState
00C468  370296     BRA 0xC996
2015:                                          break;
2016:              
2017:                                      case SUBSUBSTATE_WAIT_FOR_GET_CONFIG_DESCRIPTOR_SIZE:
2018:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
00C46A  838331     MOV 0x7066, W1
00C46C  904031     MOV.B [W1+3], W0
00C46E  A31800     BTST.Z W0, #1
00C470  320292     BRA Z, 0xC996
2019:                                          {
2020:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
00C472  904031     MOV.B [W1+3], W0
00C474  A30800     BTST.Z W0, #0
00C476  320004     BRA Z, 0xC480
2021:                                              {
2022:                                                  _USB_SetNextSubSubState();
00C478  838370     MOV usbHostState, W0
00C47A  E80000     INC W0, W0
00C47C  8B8370     MOV W0, usbHostState
00C47E  37028B     BRA 0xC996
2023:                                              }
2024:                                              else
2025:                                              {
2026:                                                  // We are here because of either a STALL or a NAK.  See if
2027:                                                  // we have retries left to try the command again or try to
2028:                                                  // enumerate again.
2029:                                                  _USB_CheckCommandAndEnumerationAttempts();
00C480  02551E     CALL _USB_CheckCommandAndEnumerationAttempts
00C482  000001     NOP
00C484  370288     BRA 0xC996
2030:                                              }
2031:                                          }
2032:                                          break;
2033:              
2034:                                      case SUBSUBSTATE_GET_CONFIG_DESCRIPTOR_SIZECOMPLETE:
2035:                                          // Allocate a buffer for an entry in the configuration descriptor list.
2036:                                          if ((pTemp = (BYTE *)USB_MALLOC( sizeof (USB_CONFIGURATION) )) == NULL)
00C486  200060     MOV #0x6, W0
00C488  0257A6     CALL malloc
00C48A  000000     NOP
00C48C  780400     MOV W0, W8
00C48E  E00000     CP0 W0
00C490  3A0006     BRA NZ, 0xC49E
2037:                                          {
2038:                                              // We cannot continue.  Freeze until the device is removed.
2039:                                              _USB_SetErrorCode( USB_HOLDING_OUT_OF_MEMORY );
00C492  B3C330     MOV #0x33, W0
00C494  2705C1     MOV #0x705C, W1
00C496  784880     MOV.B W0, [W1]
2040:                                              _USB_SetHoldState();
00C498  205000     MOV #0x500, W0
00C49A  8B8370     MOV W0, usbHostState
00C49C  37027C     BRA 0xC996
2041:                                              break;
2042:                                          }
2043:              
2044:                                          // Allocate a buffer for the entire Configuration Descriptor
2045:                                          if ((((USB_CONFIGURATION *)pTemp)->descriptor = (BYTE *)USB_MALLOC( ((WORD)pEP0Data[3] << 8) + (WORD)pEP0Data[2] )) == NULL)
00C49E  838261     MOV pEP0Data, W1
00C4A0  904031     MOV.B [W1+3], W0
00C4A2  DD0048     SL W0, #8, W0
00C4A4  9040A1     MOV.B [W1+2], W1
00C4A6  FB8081     ZE W1, W1
00C4A8  400001     ADD W0, W1, W0
00C4AA  0257A6     CALL malloc
00C4AC  000000     NOP
00C4AE  780100     MOV W0, W2
00C4B0  780C00     MOV W0, [W8]
00C4B2  E00000     CP0 W0
00C4B4  3A0009     BRA NZ, 0xC4C8
2046:                                          {
2047:                                              // Not enough memory for the descriptor!
2048:                                              USB_FREE_AND_CLEAR( pTemp );
00C4B6  780008     MOV W8, W0
00C4B8  0258CA     CALL free
00C4BA  000000     NOP
2049:              
2050:                                              // We cannot continue.  Freeze until the device is removed.
2051:                                              _USB_SetErrorCode( USB_HOLDING_OUT_OF_MEMORY );
00C4BC  B3C330     MOV #0x33, W0
00C4BE  2705C1     MOV #0x705C, W1
00C4C0  784880     MOV.B W0, [W1]
2052:                                              _USB_SetHoldState();
00C4C2  205000     MOV #0x500, W0
00C4C4  8B8370     MOV W0, usbHostState
00C4C6  370267     BRA 0xC996
2053:                                              break;
2054:                                          }
2055:              
2056:                                          // Save wTotalLength
2057:                                          ((USB_CONFIGURATION_DESCRIPTOR *)((USB_CONFIGURATION *)pTemp)->descriptor)->wTotalLength =
00C4C8  838260     MOV pEP0Data, W0
00C4CA  9040B0     MOV.B [W0+3], W1
00C4CC  DD08C8     SL W1, #8, W1
00C4CE  904020     MOV.B [W0+2], W0
00C4D0  FB8000     ZE W0, W0
00C4D2  408080     ADD W1, W0, W1
00C4D4  984121     MOV.B W1, [W2+2]
00C4D6  DE08C8     LSR W1, #8, W1
00C4D8  984131     MOV.B W1, [W2+3]
2058:                                                  ((WORD)pEP0Data[3] << 8) + (WORD)pEP0Data[2];
2059:              
2060:                                          // Put the new node at the front of the list.
2061:                                          ((USB_CONFIGURATION *)pTemp)->next = usbDeviceInfo.pConfigurationDescriptorList;
00C4DA  838311     MOV 0x7062, W1
00C4DC  980411     MOV W1, [W8+2]
2062:                                          usbDeviceInfo.pConfigurationDescriptorList = (USB_CONFIGURATION *)pTemp;
00C4DE  8B8318     MOV W8, 0x7062
2063:              
2064:                                          // Save the configuration descriptor pointer and number
2065:                                          pCurrentConfigurationDescriptor            = ((USB_CONFIGURATION *)pTemp)->descriptor;
00C4E0  8B88A2     MOV W2, pCurrentConfigurationDescriptor
2066:                                          ((USB_CONFIGURATION *)pTemp)->configNumber = countConfigurations;
00C4E2  270760     MOV #0x7076, W0
00C4E4  784010     MOV.B [W0], W0
00C4E6  984440     MOV.B W0, [W8+4]
2067:              
2068:                                          // Clean up and advance to the next state.
2069:                                          _USB_InitErrorCounters();
00C4E8  B3C031     MOV #0x3, W1
00C4EA  270750     MOV #0x7075, W0
00C4EC  784801     MOV.B W1, [W0]
2070:                                          _USB_SetNextSubState();
00C4EE  838370     MOV usbHostState, W0
00C4F0  20FF01     MOV #0xFF0, W1
00C4F2  600001     AND W0, W1, W0
00C4F4  400070     ADD W0, #0x10, W0
00C4F6  8B8370     MOV W0, usbHostState
00C4F8  37024E     BRA 0xC996
2071:                                          break;
2072:              
2073:                                      default:
2074:                                          break;
2075:                                  }
2076:                                  break;
2077:              
2078:                              case SUBSTATE_GET_CONFIG_DESCRIPTOR:
2079:                                  // Get the entire Configuration Descriptor for this configuration
2080:                                  switch (usbHostState & SUBSUBSTATE_MASK)
00C4FA  838370     MOV usbHostState, W0
00C4FC  60006F     AND W0, #0xF, W0
00C4FE  500FE1     SUB W0, #0x1, [W15]
00C500  320028     BRA Z, 0xC552
00C502  390003     BRA NC, 0xC50A
00C504  500FE2     SUB W0, #0x2, [W15]
00C506  3A0247     BRA NZ, 0xC996
00C508  370032     BRA 0xC56E
2081:                                  {
2082:                                      case SUBSUBSTATE_SEND_GET_CONFIG_DESCRIPTOR:
2083:                                          #ifdef DEBUG_MODE
2084:                                              UART2PrintString( "HOST: Getting Config Descriptor.\r\n" );
2085:                                          #endif
2086:              
2087:                                          // Set up and send GET CONFIGURATION (n) DESCRIPTOR.
2088:                                          pEP0Data[0] = USB_SETUP_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
00C50A  838261     MOV pEP0Data, W1
00C50C  B3C800     MOV #0x80, W0
00C50E  784880     MOV.B W0, [W1]
2089:                                          pEP0Data[1] = USB_REQUEST_GET_DESCRIPTOR;
00C510  B3C060     MOV #0x6, W0
00C512  984090     MOV.B W0, [W1+1]
2090:                                          pEP0Data[2] = countConfigurations-1;
00C514  270760     MOV #0x7076, W0
00C516  E94010     DEC.B [W0], W0
00C518  9840A0     MOV.B W0, [W1+2]
2091:                                          pEP0Data[3] = USB_DESCRIPTOR_CONFIGURATION;
00C51A  B3C020     MOV #0x2, W0
00C51C  9840B0     MOV.B W0, [W1+3]
2092:                                          pEP0Data[4] = 0;
00C51E  EB4000     CLR.B W0
00C520  9840C0     MOV.B W0, [W1+4]
2093:                                          pEP0Data[5] = 0;
00C522  9840D0     MOV.B W0, [W1+5]
2094:                                          pEP0Data[6] = usbDeviceInfo.pConfigurationDescriptorList->descriptor[2];    // wTotalLength
00C524  838310     MOV 0x7062, W0
00C526  780010     MOV [W0], W0
00C528  904020     MOV.B [W0+2], W0
00C52A  9840E0     MOV.B W0, [W1+6]
2095:                                          pEP0Data[7] = usbDeviceInfo.pConfigurationDescriptorList->descriptor[3];
00C52C  838310     MOV 0x7062, W0
00C52E  780010     MOV [W0], W0
00C530  904030     MOV.B [W0+3], W0
00C532  9840F0     MOV.B W0, [W1+7]
2096:                                          _USB_InitControlRead( usbDeviceInfo.pEndpoint0, pEP0Data, 8, usbDeviceInfo.pConfigurationDescriptorList->descriptor,
00C534  838310     MOV 0x7062, W0
00C536  780190     MOV [W0], W3
00C538  904023     MOV.B [W3+2], W0
00C53A  FB8000     ZE W0, W0
00C53C  904233     MOV.B [W3+3], W4
00C53E  DD2248     SL W4, #8, W4
00C540  720200     IOR W4, W0, W4
00C542  200082     MOV #0x8, W2
00C544  838330     MOV 0x7066, W0
00C546  024C00     CALL _USB_InitControlRead
00C548  000001     NOP
2097:                                                  ((USB_CONFIGURATION_DESCRIPTOR *)usbDeviceInfo.pConfigurationDescriptorList->descriptor)->wTotalLength );
2098:                                          _USB_SetNextSubSubState();
00C54A  838370     MOV usbHostState, W0
00C54C  E80000     INC W0, W0
00C54E  8B8370     MOV W0, usbHostState
00C550  370222     BRA 0xC996
2099:                                          break;
2100:              
2101:                                      case SUBSUBSTATE_WAIT_FOR_GET_CONFIG_DESCRIPTOR:
2102:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
00C552  838331     MOV 0x7066, W1
00C554  904031     MOV.B [W1+3], W0
00C556  A31800     BTST.Z W0, #1
00C558  32021E     BRA Z, 0xC996
2103:                                          {
2104:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
00C55A  904031     MOV.B [W1+3], W0
00C55C  A30800     BTST.Z W0, #0
00C55E  320004     BRA Z, 0xC568
2105:                                              {
2106:                                                  _USB_SetNextSubSubState();
00C560  838370     MOV usbHostState, W0
00C562  E80000     INC W0, W0
00C564  8B8370     MOV W0, usbHostState
00C566  370217     BRA 0xC996
2107:                                              }
2108:                                              else
2109:                                              {
2110:                                                  // We are here because of either a STALL or a NAK.  See if
2111:                                                  // we have retries left to try the command again or try to
2112:                                                  // enumerate again.
2113:                                                  _USB_CheckCommandAndEnumerationAttempts();
00C568  02551E     CALL _USB_CheckCommandAndEnumerationAttempts
00C56A  000001     NOP
00C56C  370214     BRA 0xC996
2114:                                              }
2115:                                          }
2116:                                          break;
2117:              
2118:                                      case SUBSUBSTATE_GET_CONFIG_DESCRIPTOR_COMPLETE:
2119:                                          // Clean up and advance to the next state.  Keep the data for later use.
2120:                                          _USB_InitErrorCounters();
00C56E  B3C031     MOV #0x3, W1
00C570  270750     MOV #0x7075, W0
00C572  784801     MOV.B W1, [W0]
2121:                                          countConfigurations --;
00C574  270760     MOV #0x7076, W0
00C576  E94090     DEC.B [W0], W1
00C578  784801     MOV.B W1, [W0]
2122:                                          if (countConfigurations)
00C57A  320003     BRA Z, 0xC582
2123:                                          {
2124:                                              // There are more descriptors that we need to get.
2125:                                              usbHostState = STATE_CONFIGURING | SUBSTATE_GET_CONFIG_DESCRIPTOR_SIZE;
00C57C  203100     MOV #0x310, W0
00C57E  8B8370     MOV W0, usbHostState
00C580  37020A     BRA 0xC996
2126:                                          }
2127:                                          else
2128:                                          {
2129:                                              // Start configuring the device.
2130:                                              _USB_SetNextSubState();
00C582  838370     MOV usbHostState, W0
00C584  20FF01     MOV #0xFF0, W1
00C586  600001     AND W0, W1, W0
00C588  400070     ADD W0, #0x10, W0
00C58A  8B8370     MOV W0, usbHostState
00C58C  370204     BRA 0xC996
2131:                                            }
2132:                                          break;
2133:              
2134:                                      default:
2135:                                          break;
2136:                                  }
2137:                                  break;
2138:              
2139:                              case SUBSTATE_SELECT_CONFIGURATION:
2140:                                  // Set the OTG configuration of the device
2141:                                  switch (usbHostState & SUBSUBSTATE_MASK)
00C58E  838370     MOV usbHostState, W0
00C590  6000EF     AND W0, #0xF, W1
00C592  508FE1     SUB W1, #0x1, [W15]
00C594  320046     BRA Z, 0xC622
00C596  390005     BRA NC, 0xC5A2
00C598  508FE2     SUB W1, #0x2, [W15]
00C59A  320069     BRA Z, 0xC66E
00C59C  508FE3     SUB W1, #0x3, [W15]
00C59E  3A01FB     BRA NZ, 0xC996
00C5A0  370074     BRA 0xC68A
2142:                                  {
2143:                                      case SUBSUBSTATE_SELECT_CONFIGURATION:
2144:                                          // Free the old configuration (if any)
2145:                                          _USB_FreeConfigMemory();
00C5A2  024960     CALL _USB_FreeConfigMemory
00C5A4  000001     NOP
2146:              
2147:                                          // If the configuration wasn't selected based on the VID & PID
2148:                                          if (usbDeviceInfo.currentConfiguration == 0)
00C5A6  270580     MOV #0x7058, W0
00C5A8  784110     MOV.B [W0], W2
00C5AA  E00402     CP0.B W2
00C5AC  3A0011     BRA NZ, 0xC5D0
2149:                                          {
2150:                                              // Search for a supported class-specific configuration.
2151:                                              pCurrentConfigurationNode = usbDeviceInfo.pConfigurationDescriptorList;
00C5AE  838310     MOV 0x7062, W0
00C5B0  37000A     BRA 0xC5C6
2152:                                              while (pCurrentConfigurationNode)
00C5C8  838270     MOV pCurrentConfigurationNode, W0
00C5CA  E00000     CP0 W0
00C5CC  3AFFF2     BRA NZ, 0xC5B2
00C5CE  370014     BRA 0xC5F8
2153:                                              {
2154:                                                  pCurrentConfigurationDescriptor = pCurrentConfigurationNode->descriptor;
00C5B2  780010     MOV [W0], W0
00C5B4  8B88A0     MOV W0, pCurrentConfigurationDescriptor
2155:                                                  if (_USB_ParseConfigurationDescriptor())
00C5B6  020B1C     CALL _USB_ParseConfigurationDescriptor
00C5B8  000001     NOP
00C5BA  E00000     CP0 W0
00C5BC  3A001D     BRA NZ, 0xC5F8
2156:                                                  {
2157:                                                      break;
2158:                                                  }
2159:                                                  else
2160:                                                  {
2161:                                                      // Free the memory allocated and
2162:                                                      // advance to  next configuration
2163:                                                      _USB_FreeConfigMemory();
00C5BE  024960     CALL _USB_FreeConfigMemory
00C5C0  000001     NOP
2164:                                                      pCurrentConfigurationNode = pCurrentConfigurationNode->next;
00C5C2  838270     MOV pCurrentConfigurationNode, W0
00C5C4  900010     MOV [W0+2], W0
00C5C6  8B8270     MOV W0, pCurrentConfigurationNode
2165:                                                  }
2166:                                              }
2167:                                          }
2168:                                          else
2169:                                          {
2170:                                              // Configuration selected by VID & PID, initialize data structures
2171:                                              pCurrentConfigurationNode = usbDeviceInfo.pConfigurationDescriptorList;
00C5D0  838311     MOV 0x7062, W1
00C5D2  8B8271     MOV W1, pCurrentConfigurationNode
00C5D4  370001     BRA 0xC5D8
2172:                                              while (pCurrentConfigurationNode && pCurrentConfigurationNode->configNumber != usbDeviceInfo.currentConfiguration)
00C5D8  E00001     CP0 W1
00C5DA  320003     BRA Z, 0xC5E2
00C5DC  904041     MOV.B [W1+4], W0
00C5DE  504F82     SUB.B W0, W2, [W15]
00C5E0  3AFFFA     BRA NZ, 0xC5D6
00C5E2  8B8271     MOV W1, pCurrentConfigurationNode
2173:                                              {
2174:                                                  pCurrentConfigurationNode = pCurrentConfigurationNode->next;
00C5D6  900091     MOV [W1+2], W1
2175:                                              }
2176:                                              pCurrentConfigurationDescriptor = pCurrentConfigurationNode->descriptor;
00C5E4  780091     MOV [W1], W1
00C5E6  8B88A1     MOV W1, pCurrentConfigurationDescriptor
2177:                                              if (!_USB_ParseConfigurationDescriptor())
00C5E8  020B1C     CALL _USB_ParseConfigurationDescriptor
00C5EA  000001     NOP
00C5EC  780400     MOV W0, W8
00C5EE  E00000     CP0 W0
00C5F0  3A0003     BRA NZ, 0xC5F8
2178:                                              {
2179:                                                  // Free the memory allocated, config attempt failed.
2180:                                                  _USB_FreeConfigMemory();
00C5F2  024960     CALL _USB_FreeConfigMemory
00C5F4  000001     NOP
2181:                                                  pCurrentConfigurationNode = NULL;
00C5F6  8B8278     MOV W8, pCurrentConfigurationNode
2182:                                              }
2183:                                          }
2184:              
2185:                                          //If No OTG Then
2186:                                          if (usbDeviceInfo.flags.bfConfiguredOTG)
00C5F8  270680     MOV #0x7068, W0
00C5FA  784010     MOV.B [W0], W0
00C5FC  604064     AND.B W0, #0x4, W0
00C5FE  32000D     BRA Z, 0xC61A
2187:                                          {
2188:                                              // Did we fail to configure?
2189:                                              if (pCurrentConfigurationNode == NULL)
00C600  838270     MOV pCurrentConfigurationNode, W0
00C602  E00000     CP0 W0
00C604  3A0006     BRA NZ, 0xC612
2190:                                              {
2191:                                                  _USB_SetNextSubState();
00C606  838370     MOV usbHostState, W0
00C608  20FF01     MOV #0xFF0, W1
00C60A  600001     AND W0, W1, W0
00C60C  400070     ADD W0, #0x10, W0
00C60E  8B8370     MOV W0, usbHostState
00C610  3701C2     BRA 0xC996
2192:                                              }
2193:                                              else
2194:                                              {
2195:                                                  _USB_SetNextSubSubState();
00C612  838370     MOV usbHostState, W0
00C614  E80000     INC W0, W0
00C616  8B8370     MOV W0, usbHostState
00C618  3701BE     BRA 0xC996
2196:                                              }
2197:                                          }
2198:                                          else
2199:                                          {
2200:                                              _USB_SetNextSubSubState();
00C61A  838370     MOV usbHostState, W0
00C61C  E80000     INC W0, W0
00C61E  8B8370     MOV W0, usbHostState
00C620  3701BA     BRA 0xC996
2201:                                          }
2202:                                          break;
2203:              
2204:                                      case SUBSUBSTATE_SEND_SET_OTG:
2205:                                          #ifdef DEBUG_MODE
2206:                                              UART2PrintString( "HOST: Determine OTG capability.\r\n" );
2207:                                          #endif
2208:              
2209:                                          // If the device does not support OTG, or
2210:                                          // if the device has already been configured, bail.
2211:                                          // Otherwise, send SET FEATURE to configure it.
2212:                                          if (!usbDeviceInfo.flags.bfConfiguredOTG)
00C622  270680     MOV #0x7068, W0
00C624  784090     MOV.B [W0], W1
00C626  60C164     AND.B W1, #0x4, W2
00C628  3A001C     BRA NZ, 0xC662
2213:                                          {
2214:                                              #ifdef DEBUG_MODE
2215:                                                  UART2PrintString( "HOST: ...OTG needs configuring.\r\n" );
2216:                                              #endif
2217:                                              usbDeviceInfo.flags.bfConfiguredOTG = 1;
00C62A  A02410     BSET.B [W0], #2
2218:              
2219:                                              // Send SET FEATURE
2220:                                              pEP0Data[0] = USB_SETUP_HOST_TO_DEVICE | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
00C62C  838261     MOV pEP0Data, W1
00C62E  784882     MOV.B W2, [W1]
2221:                                              pEP0Data[1] = USB_REQUEST_SET_FEATURE;
00C630  B3C032     MOV #0x3, W2
00C632  984092     MOV.B W2, [W1+1]
2222:                                              if (usbDeviceInfo.flags.bfAllowHNP) // Needs to be set by the user
00C634  784010     MOV.B [W0], W0
00C636  604068     AND.B W0, #0x8, W0
00C638  320002     BRA Z, 0xC63E
2223:                                              {
2224:                                                  pEP0Data[2] = OTG_FEATURE_B_HNP_ENABLE;
00C63A  9840A2     MOV.B W2, [W1+2]
00C63C  370002     BRA 0xC642
2225:                                              }
2226:                                              else
2227:                                              {
2228:                                                  pEP0Data[2] = OTG_FEATURE_A_HNP_SUPPORT;
00C63E  B3C040     MOV #0x4, W0
00C640  9840A0     MOV.B W0, [W1+2]
2229:                                              }
2230:                                              pEP0Data[3] = 0;
00C642  EB4000     CLR.B W0
00C644  9840B0     MOV.B W0, [W1+3]
2231:                                              pEP0Data[4] = 0;
00C646  9840C0     MOV.B W0, [W1+4]
2232:                                              pEP0Data[5] = 0;
00C648  9840D0     MOV.B W0, [W1+5]
2233:                                              pEP0Data[6] = 0;
00C64A  9840E0     MOV.B W0, [W1+6]
2234:                                              pEP0Data[7] = 0;
00C64C  9840F0     MOV.B W0, [W1+7]
2235:                                              _USB_InitControlWrite( usbDeviceInfo.pEndpoint0, pEP0Data, 8, NULL, 0 );
00C64E  EB0200     CLR W4
00C650  780184     MOV W4, W3
00C652  200082     MOV #0x8, W2
00C654  838330     MOV 0x7066, W0
00C656  024774     CALL _USB_InitControlWrite
00C658  000001     NOP
2236:                                              _USB_SetNextSubSubState();
00C65A  838370     MOV usbHostState, W0
00C65C  E80000     INC W0, W0
00C65E  8B8370     MOV W0, usbHostState
00C660  37019A     BRA 0xC996
2237:                                          }
2238:                                          else
2239:                                          {
2240:                                              #ifdef DEBUG_MODE
2241:                                                  UART2PrintString( "HOST: ...No OTG.\r\n" );
2242:                                              #endif
2243:                                              _USB_SetNextSubState();
00C662  838370     MOV usbHostState, W0
00C664  20FF01     MOV #0xFF0, W1
00C666  600001     AND W0, W1, W0
00C668  400070     ADD W0, #0x10, W0
00C66A  8B8370     MOV W0, usbHostState
00C66C  370194     BRA 0xC996
2244:                                          }
2245:                                          break;
2246:              
2247:                                      case SUBSUBSTATE_WAIT_FOR_SET_OTG_DONE:
2248:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
00C66E  838331     MOV 0x7066, W1
00C670  904031     MOV.B [W1+3], W0
00C672  A31800     BTST.Z W0, #1
00C674  320190     BRA Z, 0xC996
2249:                                          {
2250:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
00C676  904031     MOV.B [W1+3], W0
00C678  A30800     BTST.Z W0, #0
00C67A  320004     BRA Z, 0xC684
2251:                                              {
2252:                                                  #ifdef  USB_SUPPORT_OTG
2253:                                                      if (usbDeviceInfo.flags.bfAllowHNP)
2254:                                                      {
2255:                                                          USBOTGEnableHnp();
2256:                                                      }
2257:                                                   #endif
2258:                                                  _USB_SetNextSubSubState();
00C67C  838370     MOV usbHostState, W0
00C67E  E80000     INC W0, W0
00C680  8B8370     MOV W0, usbHostState
00C682  370189     BRA 0xC996
2259:                                              }
2260:                                              else
2261:                                              {
2262:                                                  #ifdef  USB_SUPPORT_OTG
2263:                                                      USBOTGDisableHnp();
2264:                                                  #endif
2265:                                                  // We are here because of either a STALL or a NAK.  See if
2266:                                                  // we have retries left to try the command again or try to
2267:                                                  // enumerate again.
2268:                                                  _USB_CheckCommandAndEnumerationAttempts();
00C684  02551E     CALL _USB_CheckCommandAndEnumerationAttempts
00C686  000001     NOP
00C688  370186     BRA 0xC996
2269:              
2270:                                                  #if defined(DEBUG_MODE) && defined(USB_SUPPORT_OTG)
2271:                                                      UART2PrintString( "\r\n***** USB OTG Error - Set Feature B_HNP_ENABLE Stalled - Device Not Responding *****\r\n" );
2272:                                                  #endif
2273:                                              }
2274:                                          }
2275:                                          break;
2276:              
2277:                                      case SUBSUBSTATE_SET_OTG_COMPLETE:
2278:                                           // Clean up and advance to the next state.
2279:                                         _USB_InitErrorCounters();
00C68A  270750     MOV #0x7075, W0
00C68C  784801     MOV.B W1, [W0]
2280:              
2281:                                          //MR - Moved For OTG Set Feature Support For Unsupported Devices
2282:                                          // Did we fail to configure?
2283:                                          if (pCurrentConfigurationNode == NULL)
00C68E  838270     MOV pCurrentConfigurationNode, W0
00C690  E00000     CP0 W0
00C692  3A0006     BRA NZ, 0xC6A0
2284:                                          {
2285:                                              _USB_SetNextSubState();
00C694  838370     MOV usbHostState, W0
00C696  20FF01     MOV #0xFF0, W1
00C698  600001     AND W0, W1, W0
00C69A  400070     ADD W0, #0x10, W0
00C69C  8B8370     MOV W0, usbHostState
00C69E  37017B     BRA 0xC996
2286:                                          }
2287:                                          else
2288:                                          {
2289:                                              //_USB_SetNextSubSubState();
2290:                                              _USB_InitErrorCounters();
2291:                                              _USB_SetNextSubState();
00C6A0  838370     MOV usbHostState, W0
00C6A2  20FF01     MOV #0xFF0, W1
00C6A4  600001     AND W0, W1, W0
00C6A6  400070     ADD W0, #0x10, W0
00C6A8  8B8370     MOV W0, usbHostState
00C6AA  370175     BRA 0xC996
2292:                                          }
2293:                                          break;
2294:              
2295:                                      default:
2296:                                          break;
2297:                                  }
2298:                                  break;
2299:              
2300:                              case SUBSTATE_ENABLE_ACCESSORY:
2301:                                  #ifdef DISABLE_ACCESSORY
2302:                                      _USB_SetNextSubState();
2303:                                  #else
2304:                                      if (pCurrentConfigurationNode == NULL) {
00C6AC  83827C     MOV pCurrentConfigurationNode, W12
00C6AE  E0000C     CP0 W12
00C6B0  3A009B     BRA NZ, 0xC7E8
2305:                                          // we haven't found any matching configuration.
2306:                                          // last resort: try to enable the device as an
2307:                                          // android accessory
2308:                                          switch (usbHostState & SUBSUBSTATE_MASK)
00C6B2  838370     MOV usbHostState, W0
00C6B4  60006F     AND W0, #0xF, W0
00C6B6  500FE2     SUB W0, #0x2, [W15]
00C6B8  32003D     BRA Z, 0xC734
00C6BA  3E0005     BRA GTU, 0xC6C6
00C6BC  E00000     CP0 W0
00C6BE  320009     BRA Z, 0xC6D2
00C6C0  500FE1     SUB W0, #0x1, [W15]
00C6C2  3A0169     BRA NZ, 0xC996
00C6C4  37001C     BRA 0xC6FE
00C6C6  500FE4     SUB W0, #0x4, [W15]
00C6C8  32006B     BRA Z, 0xC7A0
00C6CA  390050     BRA NC, 0xC76C
00C6CC  500FE5     SUB W0, #0x5, [W15]
00C6CE  3A0163     BRA NZ, 0xC996
00C6D0  37007B     BRA 0xC7C8
2309:                                          {
2310:                                              case SUBSUBSTATE_SEND_GET_PROTOCOL:
2311:                                                  #ifdef DEBUG_MODE
2312:                                                      UART2PrintString( "HOST: Trying to enable accessory mode.\r\n" );
2313:                                                  #endif
2314:                                                  // Set up and send GET DEVICE DESCRIPTOR
2315:                                                  pEP0Data[0] = USB_SETUP_DEVICE_TO_HOST | USB_SETUP_TYPE_VENDOR | USB_SETUP_RECIPIENT_DEVICE;
00C6D2  838261     MOV pEP0Data, W1
00C6D4  B3CC00     MOV #0xC0, W0
00C6D6  784880     MOV.B W0, [W1]
2316:                                                  pEP0Data[1] = 51;
00C6D8  B3C330     MOV #0x33, W0
00C6DA  984090     MOV.B W0, [W1+1]
2317:                                                  pEP0Data[2] = 0;
00C6DC  9840AC     MOV.B W12, [W1+2]
2318:                                                  pEP0Data[3] = 0;
00C6DE  9840BC     MOV.B W12, [W1+3]
2319:                                                  pEP0Data[4] = 0;
00C6E0  9840CC     MOV.B W12, [W1+4]
2320:                                                  pEP0Data[5] = 0;
00C6E2  9840DC     MOV.B W12, [W1+5]
2321:                                                  pEP0Data[6] = 2;
00C6E4  B3C020     MOV #0x2, W0
00C6E6  9840E0     MOV.B W0, [W1+6]
2322:                                                  pEP0Data[7] = 0;
00C6E8  9840FC     MOV.B W12, [W1+7]
2323:                                                  _USB_InitControlRead( usbDeviceInfo.pEndpoint0, pEP0Data, 8, (BYTE*)&usbDeviceInfo.accessoryVersion, 2 );
00C6EA  200024     MOV #0x2, W4
00C6EC  270603     MOV #0x7060, W3
00C6EE  200082     MOV #0x8, W2
00C6F0  838330     MOV 0x7066, W0
00C6F2  024C00     CALL _USB_InitControlRead
00C6F4  000001     NOP
2324:                                                  _USB_SetNextSubSubState();
00C6F6  838370     MOV usbHostState, W0
00C6F8  E80000     INC W0, W0
00C6FA  8B8370     MOV W0, usbHostState
00C6FC  37014C     BRA 0xC996
2325:                                                  break;
2326:              
2327:                                              case SUBSUBSTATE_WAIT_FOR_GET_PROTOCOL:
2328:                                                  if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
00C6FE  838331     MOV 0x7066, W1
00C700  904031     MOV.B [W1+3], W0
00C702  A31800     BTST.Z W0, #1
00C704  320148     BRA Z, 0xC996
2329:                                                  {
2330:                                                      if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
00C706  904031     MOV.B [W1+3], W0
00C708  A30800     BTST.Z W0, #0
00C70A  32000E     BRA Z, 0xC728
2331:                                                      {
2332:                                                          #ifdef DEBUG_MODE
2333:                                                              UART2PrintString( "HOST: Accessory mode version is: 0x" );
2334:                                                              UART2PutHexWord(usbDeviceInfo.accessoryVersion);
2335:                                                              UART2PrintString( "\r\n" );
2336:                                                          #endif
2337:                                                          if (usbDeviceInfo.accessoryVersion == 0) {
00C70C  270600     MOV #0x7060, W0
00C70E  E00010     CP0 [W0]
00C710  3A0006     BRA NZ, 0xC71E
2338:                                                              // failed
2339:                                                              #ifdef DEBUG_MODE
2340:                                                                  UART2PrintString( "HOST: Accessory mode is not supported\r\n" );
2341:                                                              #endif
2342:                                                              _USB_SetNextSubState();
00C712  838370     MOV usbHostState, W0
00C714  20FF01     MOV #0xFF0, W1
00C716  600001     AND W0, W1, W0
00C718  400070     ADD W0, #0x10, W0
00C71A  8B8370     MOV W0, usbHostState
00C71C  37013C     BRA 0xC996
2343:                                                          } else {
2344:                                                            #ifdef DEBUG_MODE
2345:                                                                UART2PrintString( "HOST: Accessory mode is supported\r\n" );
2346:                                                            #endif
2347:                                                            currentDesc = 0;
00C71E  8B829C     MOV W12, currentDesc
2348:                                                            _USB_SetNextSubSubState();
00C720  838370     MOV usbHostState, W0
00C722  E80000     INC W0, W0
00C724  8B8370     MOV W0, usbHostState
00C726  370137     BRA 0xC996
2349:                                                          }
2350:                                                      }
2351:                                                      else
2352:                                                      {
2353:                                                          #ifdef DEBUG_MODE
2354:                                                              UART2PrintString( "HOST: Accessory mode version failed.\r\n" );
2355:                                                          #endif
2356:                                                          _USB_SetNextSubState();
00C728  838370     MOV usbHostState, W0
00C72A  20FF01     MOV #0xFF0, W1
00C72C  600001     AND W0, W1, W0
00C72E  400070     ADD W0, #0x10, W0
00C730  8B8370     MOV W0, usbHostState
00C732  370131     BRA 0xC996
2357:                                                      }
2358:                                                  }
2359:                                                  break;
2360:              
2361:                                              case SUBSUBSTATE_SEND_ACCESSORY_STRING:
2362:                                                  #ifdef DEBUG_MODE
2363:                                                      UART2PrintString( "HOST: Sending string\r\n" );
2364:                                                  #endif
2365:                                                  pEP0Data[0] = USB_SETUP_HOST_TO_DEVICE | USB_SETUP_TYPE_VENDOR | USB_SETUP_RECIPIENT_DEVICE;
00C734  838268     MOV pEP0Data, W8
00C736  784C02     MOV.B W2, [W8]
2366:                                                  pEP0Data[1] = 52;
00C738  B3C340     MOV #0x34, W0
00C73A  984410     MOV.B W0, [W8+1]
2367:                                                  pEP0Data[2] = 0;
00C73C  98442C     MOV.B W12, [W8+2]
2368:                                                  pEP0Data[3] = 0;
00C73E  98443C     MOV.B W12, [W8+3]
2369:                                                  pEP0Data[4] = currentDesc;
00C740  838299     MOV currentDesc, W9
00C742  984449     MOV.B W9, [W8+4]
2370:                                                  pEP0Data[5] = 0;
00C744  98445C     MOV.B W12, [W8+5]
2371:                                                  pEP0Data[6] = strlen(accessoryDescs[currentDesc]) + 1;
00C746  4405E6     ADD W8, #0x6, W11
00C748  448489     ADD W9, W9, W9
00C74A  21C74A     MOV #0x1C74, W10
00C74C  7C806A     MOV [W10+W9], W0
00C74E  02578A     CALL strlen
00C750  000000     NOP
00C752  E84D80     INC.B W0, [W11]
2372:                                                  pEP0Data[7] = 0;
00C754  98447C     MOV.B W12, [W8+7]
2373:                                                  _USB_InitControlWrite( usbDeviceInfo.pEndpoint0, pEP0Data, 8, (BYTE*) accessoryDescs[currentDesc], pEP0Data[6] );
00C756  FB821B     ZE [W11], W4
00C758  7C81EA     MOV [W10+W9], W3
00C75A  200082     MOV #0x8, W2
00C75C  780088     MOV W8, W1
00C75E  838330     MOV 0x7066, W0
00C760  024774     CALL _USB_InitControlWrite
00C762  000001     NOP
2374:                                                  _USB_SetNextSubSubState();
00C764  838370     MOV usbHostState, W0
00C766  E80000     INC W0, W0
00C768  8B8370     MOV W0, usbHostState
00C76A  370115     BRA 0xC996
2375:                                                  break;
2376:              
2377:                                            case SUBSUBSTATE_WAIT_FOR_ACCESSORY_STRING:
2378:                                                  if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
00C76C  838331     MOV 0x7066, W1
00C76E  904031     MOV.B [W1+3], W0
00C770  A31800     BTST.Z W0, #1
00C772  320111     BRA Z, 0xC996
2379:                                                  {
2380:                                                      if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
00C774  904031     MOV.B [W1+3], W0
00C776  A30800     BTST.Z W0, #0
00C778  32000D     BRA Z, 0xC794
2381:                                                      {
2382:                                                          #ifdef DEBUG_MODE
2383:                                                              UART2PrintString( "HOST: Wrote string\r\n" );
2384:                                                          #endif
2385:                                                          if (++currentDesc == 6) {
00C77A  838290     MOV currentDesc, W0
00C77C  E80000     INC W0, W0
00C77E  8B8290     MOV W0, currentDesc
00C780  500FE6     SUB W0, #0x6, [W15]
00C782  3A0004     BRA NZ, 0xC78C
2386:                                                              // done
2387:                                                              _USB_SetNextSubSubState();
00C784  838370     MOV usbHostState, W0
00C786  E80000     INC W0, W0
00C788  8B8370     MOV W0, usbHostState
00C78A  370105     BRA 0xC996
2388:                                                          } else {
2389:                                                              _USB_SetPreviousSubSubState();
00C78C  838370     MOV usbHostState, W0
00C78E  E90000     DEC W0, W0
00C790  8B8370     MOV W0, usbHostState
00C792  370101     BRA 0xC996
2390:                                                          }
2391:                                                      } else {
2392:                                                          #ifdef DEBUG_MODE
2393:                                                              UART2PrintString( "HOST: Failed to write string\r\n" );
2394:                                                          #endif
2395:                                                          _USB_SetNextSubState();
00C794  838370     MOV usbHostState, W0
00C796  20FF01     MOV #0xFF0, W1
00C798  600001     AND W0, W1, W0
00C79A  400070     ADD W0, #0x10, W0
00C79C  8B8370     MOV W0, usbHostState
00C79E  3700FB     BRA 0xC996
2396:                                                      }
2397:                                                  }
2398:                                                  break;
2399:              
2400:                                            case SUBSUBSTATE_SEND_START_ACCESSORY:
2401:                                                pEP0Data[0] = USB_SETUP_HOST_TO_DEVICE | USB_SETUP_TYPE_VENDOR | USB_SETUP_RECIPIENT_DEVICE;
00C7A0  838261     MOV pEP0Data, W1
00C7A2  784882     MOV.B W2, [W1]
2402:                                                pEP0Data[1] = 53;
00C7A4  B3C350     MOV #0x35, W0
00C7A6  984090     MOV.B W0, [W1+1]
2403:                                                pEP0Data[2] = 0;
00C7A8  9840AC     MOV.B W12, [W1+2]
2404:                                                pEP0Data[3] = 0;
00C7AA  9840BC     MOV.B W12, [W1+3]
2405:                                                pEP0Data[4] = 0;
00C7AC  9840CC     MOV.B W12, [W1+4]
2406:                                                pEP0Data[5] = 0;
00C7AE  9840DC     MOV.B W12, [W1+5]
2407:                                                pEP0Data[6] = 0;
00C7B0  9840EC     MOV.B W12, [W1+6]
2408:                                                pEP0Data[7] = 0;
00C7B2  9840FC     MOV.B W12, [W1+7]
2409:                                                _USB_InitControlWrite( usbDeviceInfo.pEndpoint0, pEP0Data, 8, NULL, 0 );
00C7B4  78020C     MOV W12, W4
00C7B6  78018C     MOV W12, W3
00C7B8  200082     MOV #0x8, W2
00C7BA  838330     MOV 0x7066, W0
00C7BC  024774     CALL _USB_InitControlWrite
00C7BE  000001     NOP
2410:                                                _USB_SetNextSubSubState();
00C7C0  838370     MOV usbHostState, W0
00C7C2  E80000     INC W0, W0
00C7C4  8B8370     MOV W0, usbHostState
00C7C6  3700E7     BRA 0xC996
2411:                                                break;
2412:              
2413:                                            case SUBSUBSTATE_WAIT_FOR_START_ACCESSORY:
2414:                                                  if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
00C7C8  838331     MOV 0x7066, W1
00C7CA  904031     MOV.B [W1+3], W0
00C7CC  A31800     BTST.Z W0, #1
00C7CE  3200E3     BRA Z, 0xC996
2415:                                                  {
2416:                                                      if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
00C7D0  904031     MOV.B [W1+3], W0
00C7D2  A30800     BTST.Z W0, #0
00C7D4  320003     BRA Z, 0xC7DC
2417:                                                      {
2418:                                                        #ifdef DEBUG_MODE
2419:                                                            UART2PrintString( "HOST: Started accessory mode. Waiting for reconnect\r\n" );
2420:                                                        #endif
2421:                                                        _USB_SetHoldState();
00C7D6  205000     MOV #0x500, W0
00C7D8  8B8370     MOV W0, usbHostState
00C7DA  3700DD     BRA 0xC996
2422:                                                      } else {
2423:                                                        #ifdef DEBUG_MODE
2424:                                                            UART2PrintString( "HOST: Failed to start accessory mode\r\n" );
2425:                                                        #endif
2426:                                                        _USB_SetNextSubState();
00C7DC  838370     MOV usbHostState, W0
00C7DE  20FF01     MOV #0xFF0, W1
00C7E0  600001     AND W0, W1, W0
00C7E2  400070     ADD W0, #0x10, W0
00C7E4  8B8370     MOV W0, usbHostState
00C7E6  3700D7     BRA 0xC996
2427:                                                      }
2428:                                                  }
2429:                                                break;
2430:                                          }
2431:                                      } else {
2432:                                        // we're good, move on
2433:                                        _USB_SetNextSubState();
00C7E8  838370     MOV usbHostState, W0
00C7EA  20FF01     MOV #0xFF0, W1
00C7EC  600001     AND W0, W1, W0
00C7EE  400070     ADD W0, #0x10, W0
00C7F0  8B8370     MOV W0, usbHostState
00C7F2  3700D1     BRA 0xC996
2434:                                      }
2435:                                  #endif
2436:                                  break;
2437:              
2438:                              case SUBSTATE_SET_CONFIGURATION:
2439:                                  if (pCurrentConfigurationNode == NULL) {
00C7F4  838270     MOV pCurrentConfigurationNode, W0
00C7F6  E00000     CP0 W0
00C7F8  3A0005     BRA NZ, 0xC804
2440:                                      #ifdef CONFIGURE_UNKNOWN_DEVICE
2441:                                              // set usbDeviceInfo.currentConfiguration to a valid value (first)
2442:                                              usbDeviceInfo.currentConfiguration = ((USB_CONFIGURATION_DESCRIPTOR *) usbDeviceInfo.pConfigurationDescriptorList->descriptor)->bConfigurationValue;
2443:                                      #else
2444:                                              // failed
2445:                                              #ifdef DEBUG_MODE
2446:                                                  UART2PrintString( "HOST: Device is not supported\r\n" );
2447:                                              #endif
2448:                                              // Failed to find a supported configuration.
2449:                                              _USB_SetErrorCode( USB_HOLDING_UNSUPPORTED_DEVICE );
00C7FA  B3C341     MOV #0x34, W1
00C7FC  2705C0     MOV #0x705C, W0
00C7FE  784801     MOV.B W1, [W0]
2450:                                              _USB_SetHoldState();
00C800  8B8373     MOV W3, usbHostState
00C802  3700C9     BRA 0xC996
2451:                                              break;
2452:                                      #endif
2453:                                  }
2454:              
2455:                                  // Set the configuration to the one specified for this device
2456:                                  switch (usbHostState & SUBSUBSTATE_MASK)
00C804  838370     MOV usbHostState, W0
00C806  60006F     AND W0, #0xF, W0
00C808  500FE1     SUB W0, #0x1, [W15]
00C80A  32001D     BRA Z, 0xC846
00C80C  390005     BRA NC, 0xC818
00C80E  500FE2     SUB W0, #0x2, [W15]
00C810  320028     BRA Z, 0xC862
00C812  500FE3     SUB W0, #0x3, [W15]
00C814  3A00C0     BRA NZ, 0xC996
00C816  37002C     BRA 0xC870
2457:                                  {
2458:                                      case SUBSUBSTATE_SEND_SET_CONFIGURATION:
2459:                                          #ifdef DEBUG_MODE
2460:                                              UART2PrintString( "HOST: Set configuration.\r\n" );
2461:                                          #endif
2462:              
2463:                                          // Set up and send SET CONFIGURATION.
2464:                                          pEP0Data[0] = USB_SETUP_HOST_TO_DEVICE | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
00C818  838261     MOV pEP0Data, W1
00C81A  EB4100     CLR.B W2
00C81C  784882     MOV.B W2, [W1]
2465:                                          pEP0Data[1] = USB_REQUEST_SET_CONFIGURATION;
00C81E  B3C090     MOV #0x9, W0
00C820  984090     MOV.B W0, [W1+1]
2466:                                          pEP0Data[2] = usbDeviceInfo.currentConfiguration;
00C822  270580     MOV #0x7058, W0
00C824  784010     MOV.B [W0], W0
00C826  9840A0     MOV.B W0, [W1+2]
2467:                                          pEP0Data[3] = 0;
00C828  9840B2     MOV.B W2, [W1+3]
2468:                                          pEP0Data[4] = 0;
00C82A  9840C2     MOV.B W2, [W1+4]
2469:                                          pEP0Data[5] = 0;
00C82C  9840D2     MOV.B W2, [W1+5]
2470:                                          pEP0Data[6] = 0;
00C82E  9840E2     MOV.B W2, [W1+6]
2471:                                          pEP0Data[7] = 0;
00C830  9840F2     MOV.B W2, [W1+7]
2472:                                          _USB_InitControlWrite( usbDeviceInfo.pEndpoint0, pEP0Data, 8, NULL, 0 );
00C832  EB0200     CLR W4
00C834  780184     MOV W4, W3
00C836  200082     MOV #0x8, W2
00C838  838330     MOV 0x7066, W0
00C83A  024774     CALL _USB_InitControlWrite
00C83C  000001     NOP
2473:                                          _USB_SetNextSubSubState();
00C83E  838370     MOV usbHostState, W0
00C840  E80000     INC W0, W0
00C842  8B8370     MOV W0, usbHostState
00C844  3700A8     BRA 0xC996
2474:                                          break;
2475:              
2476:                                      case SUBSUBSTATE_WAIT_FOR_SET_CONFIGURATION:
2477:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
00C846  838331     MOV 0x7066, W1
00C848  904031     MOV.B [W1+3], W0
00C84A  A31800     BTST.Z W0, #1
00C84C  3200A4     BRA Z, 0xC996
2478:                                          {
2479:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
00C84E  904031     MOV.B [W1+3], W0
00C850  A30800     BTST.Z W0, #0
00C852  320004     BRA Z, 0xC85C
2480:                                              {
2481:                                                  _USB_SetNextSubSubState();
00C854  838370     MOV usbHostState, W0
00C856  E80000     INC W0, W0
00C858  8B8370     MOV W0, usbHostState
00C85A  37009D     BRA 0xC996
2482:                                              }
2483:                                              else
2484:                                              {
2485:                                                  // We are here because of either a STALL or a NAK.  See if
2486:                                                  // we have retries left to try the command again or try to
2487:                                                  // enumerate again.
2488:                                                  _USB_CheckCommandAndEnumerationAttempts();
00C85C  02551E     CALL _USB_CheckCommandAndEnumerationAttempts
00C85E  000001     NOP
00C860  37009A     BRA 0xC996
2489:                                              }
2490:                                          }
2491:                                          break;
2492:              
2493:                                      case SUBSUBSTATE_SET_CONFIGURATION_COMPLETE:
2494:                                          if (pCurrentConfigurationNode == NULL) {
2495:                                              // Failed to find a supported configuration.
2496:                                              _USB_SetErrorCode( USB_HOLDING_UNSUPPORTED_DEVICE );
2497:                                              _USB_SetHoldState();
2498:                                          } else {
2499:                                              // Clean up and advance to the next state.
2500:                                              _USB_InitErrorCounters();
00C862  B3C031     MOV #0x3, W1
00C864  270750     MOV #0x7075, W0
00C866  784801     MOV.B W1, [W0]
2501:                                              _USB_SetNextSubSubState();
00C868  838370     MOV usbHostState, W0
00C86A  E80000     INC W0, W0
00C86C  8B8370     MOV W0, usbHostState
00C86E  370093     BRA 0xC996
2502:                                          }
2503:                                          break;
2504:              
2505:                                      case SUBSUBSTATE_INIT_CLIENT_DRIVERS:
2506:                                          #ifdef DEBUG_MODE
2507:                                              UART2PrintString( "HOST: Initializing client drivers...\r\n" );
2508:                                          #endif
2509:                                          _USB_SetNextState();
00C870  838370     MOV usbHostState, W0
00C872  20F001     MOV #0xF00, W1
00C874  600001     AND W0, W1, W0
00C876  B01000     ADD #0x100, W0
00C878  8B8370     MOV W0, usbHostState
2510:                                          // Initialize client driver(s) for this configuration.
2511:                                          if (usbDeviceInfo.flags.bfUseDeviceClientDriver)
00C87A  270680     MOV #0x7068, W0
00C87C  B3C401     MOV #0x40, W1
00C87E  60C010     AND.B W1, [W0], W0
00C880  320016     BRA Z, 0xC8AE
2512:                                          {
2513:                                              // We have a device that requires only one client driver.  Make sure
2514:                                              // that client driver can initialize this device.  If the client
2515:                                              // driver initialization fails, we cannot enumerate this device.
2516:                                              #ifdef DEBUG_MODE
2517:                                                  UART2PrintString( "HOST: Using device client driver.\r\n" );
2518:                                              #endif
2519:                                              temp = usbDeviceInfo.deviceClientDriver;
00C882  2705D0     MOV #0x705D, W0
00C884  784090     MOV.B [W0], W1
2520:                                              if (!usbClientDrvTable[temp].Initialize(usbDeviceInfo.deviceAddress, usbClientDrvTable[temp].flags, temp, &usbDeviceInfo, NULL))
00C886  FB8001     ZE W1, W0
00C888  DD0043     SL W0, #3, W0
00C88A  21F822     MOV #0x1F82, W2
00C88C  400182     ADD W0, W2, W3
00C88E  780362     MOV [W2+W0], W6
00C890  EB0280     CLR W5
00C892  270564     MOV #0x7056, W4
00C894  900123     MOV [W3+4], W2
00C896  9001B3     MOV [W3+6], W3
00C898  2705B0     MOV #0x705B, W0
00C89A  784010     MOV.B [W0], W0
00C89C  010006     CALL W6
00C89E  E00000     CP0 W0
00C8A0  3A007A     BRA NZ, 0xC996
2521:                                              {
2522:                                                  _USB_SetErrorCode( USB_HOLDING_CLIENT_INIT_ERROR );
00C8A2  B3C390     MOV #0x39, W0
00C8A4  2705C1     MOV #0x705C, W1
00C8A6  784880     MOV.B W0, [W1]
2523:                                                  _USB_SetHoldState();
00C8A8  205000     MOV #0x500, W0
00C8AA  8B8370     MOV W0, usbHostState
00C8AC  370074     BRA 0xC996
2524:                                              }
2525:                                          }
2526:                                          else
2527:                                          {
2528:                                              // We have a device that requires multiple client drivers.  Make sure
2529:                                              // every required client driver can initialize this device.  If any
2530:                                              // client driver initialization fails, we cannot enumerate the device.
2531:                                              #ifdef DEBUG_MODE
2532:                                                  UART2PrintString( "HOST: Scanning interfaces.\r\n" );
2533:                                              #endif
2534:                                              pCurrentInterface = usbDeviceInfo.pInterfaceList;
00C8AE  838328     MOV 0x7064, W8
00C8B0  370015     BRA 0xC8DC
2535:                                              while (pCurrentInterface)
00C8DC  E00008     CP0 W8
00C8DE  3AFFE9     BRA NZ, 0xC8B2
00C8E0  37005A     BRA 0xC996
2536:                                              {
2537:                                                  temp = pCurrentInterface->clientDriver;
00C8B2  9040F8     MOV.B [W8+7], W1
2538:                                                  if (!usbClientDrvTable[temp].Initialize(usbDeviceInfo.deviceAddress, usbClientDrvTable[temp].flags, temp, &usbDeviceInfo, pCurrentInterface))
00C8B4  FB8001     ZE W1, W0
00C8B6  DD0043     SL W0, #3, W0
00C8B8  21F822     MOV #0x1F82, W2
00C8BA  400182     ADD W0, W2, W3
00C8BC  780362     MOV [W2+W0], W6
00C8BE  780288     MOV W8, W5
00C8C0  270564     MOV #0x7056, W4
00C8C2  900123     MOV [W3+4], W2
00C8C4  9001B3     MOV [W3+6], W3
00C8C6  2705B0     MOV #0x705B, W0
00C8C8  784010     MOV.B [W0], W0
00C8CA  010006     CALL W6
00C8CC  E00000     CP0 W0
00C8CE  3A0005     BRA NZ, 0xC8DA
2539:                                                  {
2540:                                                      _USB_SetErrorCode( USB_HOLDING_CLIENT_INIT_ERROR );
00C8D0  B3C390     MOV #0x39, W0
00C8D2  2705C1     MOV #0x705C, W1
00C8D4  784880     MOV.B W0, [W1]
2541:                                                      _USB_SetHoldState();
00C8D6  205000     MOV #0x500, W0
00C8D8  8B8370     MOV W0, usbHostState
2542:                                                  }
2543:                                                  pCurrentInterface = pCurrentInterface->next;
00C8DA  780418     MOV [W8], W8
2544:                                              }
2545:                                          }
2546:                                          break;
2547:              
2548:                                      default:
2549:                                          break;
2550:                                  }
2551:                                  break;
2552:                          }
2553:                          break;
2554:              
2555:                      case STATE_RUNNING:
2556:                          switch (usbHostState & SUBSTATE_MASK)
00C8E2  838370     MOV usbHostState, W0
00C8E4  B20F00     AND #0xF0, W0
00C8E6  500FF0     SUB W0, #0x10, [W15]
00C8E8  3A0056     BRA NZ, 0xC996
2557:                          {
2558:                              case SUBSTATE_NORMAL_RUN:
2559:                                  break;
2560:              
2561:                              case SUBSTATE_SUSPEND_AND_RESUME:
2562:                                  switch (usbHostState & SUBSUBSTATE_MASK)
00C8EA  838370     MOV usbHostState, W0
00C8EC  60006F     AND W0, #0xF, W0
00C8EE  500FE3     SUB W0, #0x3, [W15]
00C8F0  32000E     BRA Z, 0xC90E
00C8F2  500FE5     SUB W0, #0x5, [W15]
00C8F4  320017     BRA Z, 0xC924
00C8F6  500FE1     SUB W0, #0x1, [W15]
00C8F8  3A004E     BRA NZ, 0xC996
2563:                                  {
2564:                                      case SUBSUBSTATE_SUSPEND:
2565:                                          // The IDLE state has already been set.  We need to wait here
2566:                                          // until the application decides to RESUME.
2567:                                          break;
2568:              
2569:                                      case SUBSUBSTATE_RESUME:
2570:                                          // Issue a RESUME.
2571:                                          U1CONbits.RESUME = 1;
00C8FA  A84494     BSET U1CON, #2
2572:              
2573:                                          // Wait for the RESUME time.
2574:                                          numTimerInterrupts      = USB_RESUME_TIME;
00C8FC  200150     MOV #0x15, W0
00C8FE  8B8390     MOV W0, numTimerInterrupts
2575:                                          U1OTGIR                 = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
00C900  200400     MOV #0x40, W0
00C902  882400     MOV W0, U1OTGIR
2576:                                          U1OTGIEbits.T1MSECIE    = 1;
00C904  A8C482     BSET U1OTGIE, #6
2577:              
2578:                                          _USB_SetNextSubSubState();
00C906  838370     MOV usbHostState, W0
00C908  E80000     INC W0, W0
00C90A  8B8370     MOV W0, usbHostState
00C90C  370044     BRA 0xC996
2579:                                          break;
2580:              
2581:                                      case SUBSUBSTATE_RESUME_WAIT:
2582:                                          // Wait here until the timer expires.
2583:                                          break;
2584:              
2585:                                      case SUBSUBSTATE_RESUME_RECOVERY:
2586:                                          // Turn off RESUME.
2587:                                          U1CONbits.RESUME        = 0;
00C90E  A94494     BCLR U1CON, #2
2588:              
2589:                                          // Start sending SOF's, so the device doesn't go back into the SUSPEND state.
2590:                                          U1CONbits.SOFEN         = 1;
00C910  A80494     BSET U1CON, #0
2591:              
2592:                                          // Wait for the RESUME recovery time.
2593:                                          numTimerInterrupts      = USB_RESUME_RECOVERY_TIME;
00C912  2000B0     MOV #0xB, W0
00C914  8B8390     MOV W0, numTimerInterrupts
2594:                                          U1OTGIR                 = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
00C916  200400     MOV #0x40, W0
00C918  882400     MOV W0, U1OTGIR
2595:                                          U1OTGIEbits.T1MSECIE    = 1;
00C91A  A8C482     BSET U1OTGIE, #6
2596:              
2597:                                          _USB_SetNextSubSubState();
00C91C  838370     MOV usbHostState, W0
00C91E  E80000     INC W0, W0
00C920  8B8370     MOV W0, usbHostState
00C922  370039     BRA 0xC996
2598:                                          break;
2599:              
2600:                                      case SUBSUBSTATE_RESUME_RECOVERY_WAIT:
2601:                                          // Wait here until the timer expires.
2602:                                          break;
2603:              
2604:                                      case SUBSUBSTATE_RESUME_COMPLETE:
2605:                                          // Go back to normal running.
2606:                                          usbHostState = STATE_RUNNING | SUBSTATE_NORMAL_RUN;
00C924  8B8378     MOV W8, usbHostState
00C926  370037     BRA 0xC996
2607:                                          break;
2608:                                  }
2609:                          }
2610:                          break;
2611:              
2612:                      case STATE_HOLDING:
2613:                          switch (usbHostState & SUBSTATE_MASK)
00C928  838372     MOV usbHostState, W2
00C92A  B20F02     AND #0xF0, W2
00C92C  3A0034     BRA NZ, 0xC996
2614:                          {
2615:                              case SUBSTATE_HOLD_INIT:
2616:                                  // We're here because we cannot communicate with the current device
2617:                                  // that is plugged in.  Turn off SOF's and all interrupts except
2618:                                  // the DETACH interrupt.
2619:                                  #ifdef DEBUG_MODE
2620:                                      UART2PrintString( "HOST: Holding.\r\n" );
2621:                                  #endif
2622:                                  U1CON               = USB_HOST_MODE_ENABLE | USB_SOF_DISABLE;                       // Turn of SOF's to cut down noise
00C92E  200080     MOV #0x8, W0
00C930  8824A0     MOV W0, U1CON
2623:                                  U1IE                = 0;
00C932  882462     MOV W2, U1IE
2624:                                  U1IR                = 0xFF;
00C934  200FF1     MOV #0xFF, W1
00C936  882451     MOV W1, U1IR
2625:                                  U1OTGIE             &= 0x8C;
00C938  2008C0     MOV #0x8C, W0
00C93A  B62482     AND U1OTGIE
2626:                                  U1OTGIR             = 0x7D;
00C93C  50006F     SUB W0, #0xF, W0
00C93E  882400     MOV W0, U1OTGIR
2627:                                  U1EIE               = 0;
00C940  882482     MOV W2, U1EIE
2628:                                  U1EIR               = 0xFF;
00C942  882471     MOV W1, U1EIR
2629:                                  U1IEbits.DETACHIE   = 1;
00C944  A8048C     BSET U1IE, #0
2630:              
2631:                                  #if defined(USB_ENABLE_1MS_EVENT)
2632:                                      U1OTGIR                 = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
2633:                                      U1OTGIEbits.T1MSECIE    = 1;
2634:                                  #endif
2635:              
2636:                                  switch (usbDeviceInfo.errorCode )
00C946  2705C0     MOV #0x705C, W0
00C948  784110     MOV.B [W0], W2
00C94A  B3C340     MOV #0x34, W0
00C94E  514F80     SUB.B W2, W0, [W15]
00C950  320015     BRA Z, 0xC97C
00C952  3E0007     BRA GTU, 0xC962
00C956  514FE7     SUB.B W2, #0x7, [W15]
00C958  320011     BRA Z, 0xC97C
00C95A  E94000     DEC.B W0, W0
00C95C  514F80     SUB.B W2, W0, [W15]
00C95E  3A000B     BRA NZ, 0xC976
00C960  370008     BRA 0xC972
00C962  B3C651     MOV #0x65, W1
00C964  B3C350     MOV #0x35, W0
00C966  514F80     SUB.B W2, W0, [W15]
00C968  320009     BRA Z, 0xC97C
00C96A  404064     ADD.B W0, #0x4, W0
00C96C  514F80     SUB.B W2, W0, [W15]
00C96E  3A0003     BRA NZ, 0xC976
00C970  370004     BRA 0xC97A
00C972  B3C6F1     MOV #0x6F, W1
00C974  370003     BRA 0xC97C
00C976  B3C701     MOV #0x70, W1
00C978  370001     BRA 0xC97C
2637:                                  {
2638:                                      case USB_HOLDING_UNSUPPORTED_HUB:
2639:                                          temp = EVENT_HUB_ATTACH;
2640:                                          break;
00C94C  B3C6C1     MOV #0x6C, W1
2641:              
2642:                                      case USB_HOLDING_UNSUPPORTED_DEVICE:
2643:                                          temp = EVENT_UNSUPPORTED_DEVICE;
2644:              
2645:                                          #ifdef  USB_SUPPORT_OTG
2646:                                          //Abort HNP
2647:                                          USB_OTGEventHandler (0, OTG_EVENT_HNP_ABORT , 0, 0 );
2648:                                          #endif
2649:              
2650:                                          break;
00C954  E84081     INC.B W1, W1
2651:              
2652:                                      case USB_CANNOT_ENUMERATE:
2653:                                          temp = EVENT_CANNOT_ENUMERATE;
2654:                                          break;
00C97A  B3C6E1     MOV #0x6E, W1
2655:              
2656:                                      case USB_HOLDING_CLIENT_INIT_ERROR:
2657:                                          temp = EVENT_CLIENT_INIT_ERROR;
2658:                                          break;
2659:              
2660:                                      case USB_HOLDING_OUT_OF_MEMORY:
2661:                                          temp = EVENT_OUT_OF_MEMORY;
2662:                                          break;
2663:              
2664:                                      default:
2665:                                          temp = EVENT_UNSPECIFIED_ERROR; // This should never occur
2666:                                          break;
2667:                                  }
2668:              
2669:                                  // Report the problem to the application.
2670:                                  USB_HOST_APP_EVENT_HANDLER( usbDeviceInfo.deviceAddress, temp, &usbDeviceInfo.currentConfigurationPower , 1 );
00C97C  FB8081     ZE W1, W1
00C97E  200014     MOV #0x1, W4
00C980  200005     MOV #0x0, W5
00C982  2705E2     MOV #0x705E, W2
00C984  2705B0     MOV #0x705B, W0
00C986  784010     MOV.B [W0], W0
00C988  02623A     CALL USB_ApplicationEventHandler
00C98A  000001     NOP
2671:              
2672:                                  _USB_SetNextSubState();
00C98C  838370     MOV usbHostState, W0
00C98E  20FF01     MOV #0xFF0, W1
00C990  600001     AND W0, W1, W0
00C992  400070     ADD W0, #0x10, W0
00C994  8B8370     MOV W0, usbHostState
2673:                                  break;
2674:              
2675:                              case SUBSTATE_HOLD:
2676:                                  // Hold here until a DETACH interrupt frees us.
2677:                                  break;
2678:              
2679:                              default:
2680:                                  break;
2681:                          }
2682:                          break;
2683:                  }
2684:              
2685:              }
2686:              
2687:              /****************************************************************************
2688:                Function:
2689:                  void USBHostTerminateTransfer( BYTE deviceAddress, BYTE endpoint )
2690:              
2691:              
2692:                Summary:
2693:                  This function terminates the current transfer for the given endpoint.
2694:              
2695:                Description:
2696:                  This function terminates the current transfer for the given endpoint.  It
2697:                  can be used to terminate reads or writes that the device is not
2698:                  responding to.  It is also the only way to terminate an isochronous
2699:                  transfer.
2700:              
2701:                Precondition:
2702:                  None
2703:              
2704:                Parameters:
2705:                  BYTE deviceAddress  - Device address
2706:                  BYTE endpoint       - Endpoint number
2707:              
2708:                Returns:
2709:                  None
2710:              
2711:                Remarks:
2712:                  None
2713:                ***************************************************************************/
2714:              
2715:              void USBHostTerminateTransfer( BYTE deviceAddress, BYTE endpoint )
2716:              {
2717:                  USB_ENDPOINT_INFO *ep;
2718:              
2719:                  // Find the required device
2720:                  if (deviceAddress != usbDeviceInfo.deviceAddress)
015CCE  2705B1     MOV #0x705B, W1
015CD0  504F91     SUB.B W0, [W1], [W15]
015CD2  3A000C     BRA NZ, 0x15CEC
2721:                  {
2722:                      return; // USB_UNKNOWN_DEVICE;
2723:                  }
2724:              
2725:                  ep = _USB_FindEndpoint( endpoint );
015CD4  784002     MOV.B W2, W0
015CD6  0256E4     CALL _USB_FindEndpoint
015CD8  000001     NOP
015CDA  780080     MOV W0, W1
2726:                  if (ep != NULL)
015CDC  E00000     CP0 W0
015CDE  320006     BRA Z, 0x15CEC
2727:                  {
2728:                      ep->status.bfUserAbort          = 1;
015CE0  904020     MOV.B [W0+2], W0
015CE2  A07400     BSET.B W0, #7
015CE4  9840A0     MOV.B W0, [W1+2]
2729:                      ep->status.bfTransferComplete   = 1;
2730:                  }
2731:              }
2732:              
2733:              /****************************************************************************
2734:                Function:
2735:                  BOOL USBHostTransferIsComplete( BYTE deviceAddress, BYTE endpoint,
2736:                                      BYTE *errorCode, DWORD *byteCount )
2737:              
2738:                Summary:
2739:                  This function initiates whether or not the last endpoint transaction is
2740:                  complete.
2741:              
2742:                Description:
2743:                  This function initiates whether or not the last endpoint transaction is
2744:                  complete.  If it is complete, an error code and the number of bytes
2745:                  transferred are returned.
2746:              
2747:                  For isochronous transfers, byteCount is not valid.  Instead, use the
2748:                  returned byte counts for each EVENT_TRANSFER event that was generated
2749:                  during the transfer.
2750:              
2751:                Precondition:
2752:                  None
2753:              
2754:                Parameters:
2755:                  BYTE deviceAddress  - Device address
2756:                  BYTE endpoint       - Endpoint number
2757:                  BYTE *errorCode     - Error code indicating the status of the transfer.
2758:                                          Only valid if the transfer is complete.
2759:                  DWORD *byteCount    - The number of bytes sent or received.  Invalid
2760:                                          for isochronous transfers.
2761:              
2762:                Return Values:
2763:                  TRUE    - Transfer is complete.
2764:                  FALSE   - Transfer is not complete.
2765:              
2766:                Remarks:
2767:                  Possible values for errorCode are:
2768:                      * USB_SUCCESS                     - Transfer successful
2769:                      * USB_UNKNOWN_DEVICE              - Device not attached
2770:                      * USB_ENDPOINT_STALLED            - Endpoint STALL'd
2771:                      * USB_ENDPOINT_ERROR_ILLEGAL_PID  - Illegal PID returned
2772:                      * USB_ENDPOINT_ERROR_BIT_STUFF
2773:                      * USB_ENDPOINT_ERROR_DMA
2774:                      * USB_ENDPOINT_ERROR_TIMEOUT
2775:                      * USB_ENDPOINT_ERROR_DATA_FIELD
2776:                      * USB_ENDPOINT_ERROR_CRC16
2777:                      * USB_ENDPOINT_ERROR_END_OF_FRAME
2778:                      * USB_ENDPOINT_ERROR_PID_CHECK
2779:                      * USB_ENDPOINT_ERROR              - Other error
2780:                ***************************************************************************/
2781:              
2782:              BOOL USBHostTransferIsComplete( BYTE deviceAddress, BYTE endpoint, BYTE *errorCode,
2783:                          DWORD *byteCount )
2784:              {
2785:                  USB_ENDPOINT_INFO   *ep;
2786:                  BYTE                transferComplete;
2787:              
2788:                  // Find the required device
2789:                  if (deviceAddress != usbDeviceInfo.deviceAddress)
014230  2705B1     MOV #0x705B, W1
014232  504F91     SUB.B W0, [W1], [W15]
014234  320005     BRA Z, 0x14240
2790:                  {
2791:                      *errorCode = USB_UNKNOWN_DEVICE;
014236  B3C060     MOV #0x6, W0
014238  784900     MOV.B W0, [W2]
2792:                      *byteCount = 0;
01423A  EB0980     CLR [W3]
01423C  7811B3     MOV [W3++], [W3--]
01423E  370022     BRA 0x14284
2793:                      return TRUE;
2794:                  }
2795:              
2796:                  ep = _USB_FindEndpoint( endpoint );
014240  784004     MOV.B W4, W0
014242  0256E4     CALL _USB_FindEndpoint
014244  000001     NOP
014246  780080     MOV W0, W1
2797:                  if (ep != NULL)
014248  E00000     CP0 W0
01424A  32001A     BRA Z, 0x14280
2798:                  {
2799:                      // bfTransferComplete, the status flags, and byte count can be
2800:                      // changed in an interrupt service routine.  Therefore, we'll
2801:                      // grab it first, save it locally, and then determine the rest of
2802:                      // the information.  It is better to say that the transfer is not
2803:                      // yet complete, since the caller will simply try again.
2804:              
2805:                      // Save off the Transfer Complete status.  That way, we won't
2806:                      // load up bad values and then say the transfer is complete.
2807:                      transferComplete = ep->status.bfTransferComplete;
01424C  904030     MOV.B [W0+3], W0
01424E  D10000     LSR W0, W0
014250  600161     AND W0, #0x1, W2
2808:              
2809:                      // Set up error code.  This is only valid if the transfer is complete.
2810:                      if (ep->status.bfTransferSuccessful)
014252  904031     MOV.B [W1+3], W0
014254  A30800     BTST.Z W0, #0
014256  320005     BRA Z, 0x14262
2811:                      {
2812:                          *errorCode = USB_SUCCESS;
014258  EB4C00     CLR.B [W8]
2813:                          *byteCount = ep->dataCount;
01425A  900A01     MOV [W1+16], W4
01425C  900A91     MOV [W1+18], W5
01425E  BE8C84     MOV.D W4, [W9]
014260  37000D     BRA 0x1427C
2814:                      }
2815:                      else if (ep->status.bfStalled)
014262  904021     MOV.B [W1+2], W0
014264  A35800     BTST.Z W0, #5
014266  320002     BRA Z, 0x1426C
2816:                      {
2817:                          *errorCode = USB_ENDPOINT_STALLED;
014268  B3C110     MOV #0x11, W0
01426A  370007     BRA 0x1427A
2818:                      }
2819:                      else if (ep->status.bfError)
01426C  904021     MOV.B [W1+2], W0
01426E  A36800     BTST.Z W0, #6
014270  320003     BRA Z, 0x14278
2820:                      {
2821:                          *errorCode = ep->bErrorCode;
014272  9058C1     MOV.B [W1+28], W1
014274  784C01     MOV.B W1, [W8]
014276  370002     BRA 0x1427C
2822:                      }
2823:                      else
2824:                      {
2825:                          *errorCode = USB_ENDPOINT_UNRESOLVED_STATE;
014278  B3C190     MOV #0x19, W0
01427A  784C00     MOV.B W0, [W8]
2826:                      }
2827:              
2828:                      return transferComplete;
01427C  FB8002     ZE W2, W0
01427E  370003     BRA 0x14286
2829:                  }
2830:              
2831:                  // The endpoint was not found.  Return TRUE so we can return a valid error code.
2832:                  *errorCode = USB_ENDPOINT_NOT_FOUND;
014280  B3C140     MOV #0x14, W0
014282  784C00     MOV.B W0, [W8]
014284  200010     MOV #0x1, W0
2833:                  return TRUE;
2834:              }
2835:              
2836:              /****************************************************************************
2837:                Function:
2838:                  BYTE  USBHostVbusEvent( USB_EVENT vbusEvent, BYTE hubAddress,
2839:                                                      BYTE portNumber)
2840:              
2841:                Summary:
2842:                  This function handles Vbus events that are detected by the application.
2843:              
2844:                Description:
2845:                  This function handles Vbus events that are detected by the application.
2846:                  Since Vbus management is application dependent, the application is
2847:                  responsible for monitoring Vbus and detecting overcurrent conditions
2848:                  and removal of the overcurrent condition.  If the application detects
2849:                  an overcurrent condition, it should call this function with the event
2850:                  EVENT_VBUS_OVERCURRENT with the address of the hub and port number that
2851:                  has the condition.  When a port returns to normal operation, the
2852:                  application should call this function with the event
2853:                  EVENT_VBUS_POWER_AVAILABLE so the stack knows that it can allow devices
2854:                  to attach to that port.
2855:              
2856:                Precondition:
2857:                  None
2858:              
2859:                Parameters:
2860:                  USB_EVENT vbusEvent     - Vbus event that occured.  Valid events:
2861:                                                  * EVENT_VBUS_OVERCURRENT
2862:                                                  * EVENT_VBUS_POWER_AVAILABLE
2863:                  BYTE hubAddress         - Address of the hub device (USB_ROOT_HUB for the
2864:                                              root hub)
2865:                  BYTE portNumber         - Number of the physical port on the hub (0 - based)
2866:              
2867:                Return Values:
2868:                  USB_SUCCESS             - Event handled
2869:                  USB_ILLEGAL_REQUEST     - Invalid event, hub, or port
2870:              
2871:                Remarks:
2872:                  None
2873:                ***************************************************************************/
2874:              
2875:              BYTE  USBHostVbusEvent(USB_EVENT vbusEvent, BYTE hubAddress, BYTE portNumber)
2876:              {
2877:                  if ((hubAddress == USB_ROOT_HUB) &&
0159DE  40CFE1     ADD.B W1, #0x1, [W15]
0159E0  3A0010     BRA NZ, 0x15A02
0159E2  E00402     CP0.B W2
0159E4  3A000E     BRA NZ, 0x15A02
2878:                      (portNumber == 0 ))
2879:                  {
2880:                      if (vbusEvent == EVENT_VBUS_OVERCURRENT)
0159E6  200680     MOV #0x68, W0
0159E8  518F80     SUB W3, W0, [W15]
0159EA  3A0005     BRA NZ, 0x159F6
2881:                      {
2882:                          USBHostShutdown();
0159EC  025412     CALL USBHostShutdown
0159EE  000001     NOP
2883:                          usbRootHubInfo.flags.bPowerGoodPort0 = 0;
0159F0  270540     MOV #0x7054, W0
0159F2  A10410     BCLR.B [W0], #0
0159F4  370005     BRA 0x15A00
2884:                          return USB_SUCCESS;
2885:                      }
2886:                      if (vbusEvent == EVENT_VBUS_POWER_AVAILABLE)
0159F6  2006B0     MOV #0x6B, W0
0159F8  518F80     SUB W3, W0, [W15]
0159FA  3A0003     BRA NZ, 0x15A02
2887:                      {
2888:                          usbRootHubInfo.flags.bPowerGoodPort0 = 1;
0159FC  270540     MOV #0x7054, W0
0159FE  A00410     BSET.B [W0], #0
015A00  050000     RETLW #0x0, W0
2889:                          return USB_SUCCESS;
2890:                      }
2891:                  }
2892:              
2893:                  return USB_ILLEGAL_REQUEST;
2894:              }
2895:              
2896:              
2897:              /****************************************************************************
2898:                Function:
2899:                  BYTE USBHostWrite( BYTE deviceAddress, BYTE endpoint, BYTE *data,
2900:                                      DWORD size )
2901:              
2902:                Summary:
2903:                  This function initiates a write to the attached device.
2904:              
2905:                Description:
2906:                  This function initiates a write to the attached device.  The data buffer
2907:                  pointed to by *data must remain valid during the entire time that the
2908:                  write is taking place; the data is not buffered by the stack.
2909:              
2910:                  If the endpoint is isochronous, special conditions apply.  The pData and
2911:                  size parameters have slightly different meanings, since multiple buffers
2912:                  are required.  Once started, an isochronous transfer will continue with
2913:                  no upper layer intervention until USBHostTerminateTransfer() is called.
2914:                  The ISOCHRONOUS_DATA_BUFFERS structure should not be manipulated until
2915:                  the transfer is terminated.
2916:              
2917:                  To clarify parameter usage and to simplify casting, use the macro
2918:                  USBHostWriteIsochronous() when writing to an isochronous endpoint.
2919:              
2920:                Precondition:
2921:                  None
2922:              
2923:                Parameters:
2924:                  BYTE deviceAddress  - Device address
2925:                  BYTE endpoint       - Endpoint number
2926:                  BYTE *data          - Pointer to where the data is stored. If the endpoint
2927:                                          is isochronous, this points to an
2928:                                          ISOCHRONOUS_DATA_BUFFERS structure, with multiple
2929:                                          data buffer pointers.
2930:                  DWORD size          - Number of data bytes to send. If the endpoint is
2931:                                          isochronous, this is the number of data buffer
2932:                                          pointers pointed to by pData.
2933:              
2934:                Return Values:
2935:                  USB_SUCCESS                     - Write started successfully.
2936:                  USB_UNKNOWN_DEVICE              - Device with the specified address not found.
2937:                  USB_INVALID_STATE               - We are not in a normal running state.
2938:                  USB_ENDPOINT_ILLEGAL_TYPE       - Must use USBHostControlWrite to write
2939:                                                      to a control endpoint.
2940:                  USB_ENDPOINT_ILLEGAL_DIRECTION  - Must write to an OUT endpoint.
2941:                  USB_ENDPOINT_STALLED            - Endpoint is stalled.  Must be cleared
2942:                                                      by the application.
2943:                  USB_ENDPOINT_ERROR              - Endpoint has too many errors.  Must be
2944:                                                      cleared by the application.
2945:                  USB_ENDPOINT_BUSY               - A Write is already in progress.
2946:                  USB_ENDPOINT_NOT_FOUND          - Invalid endpoint.
2947:              
2948:                Remarks:
2949:                  None
2950:                ***************************************************************************/
2951:              
2952:              BYTE USBHostWrite( BYTE deviceAddress, BYTE endpoint, BYTE *data, DWORD size )
2953:              {
2954:                  USB_ENDPOINT_INFO *ep;
2955:              
2956:                  // Find the required device
2957:                  if (deviceAddress != usbDeviceInfo.deviceAddress)
013F74  200062     MOV #0x6, W2
013F76  2705B1     MOV #0x705B, W1
013F78  504F91     SUB.B W0, [W1], [W15]
013F7A  3A0028     BRA NZ, 0x13FCC
2958:                  {
2959:                      return USB_UNKNOWN_DEVICE;
2960:                  }
2961:              
2962:                  // If we are not in a normal user running state, we cannot do this.
2963:                  if ((usbHostState & STATE_MASK) != STATE_RUNNING)
013F7C  838370     MOV usbHostState, W0
013F7E  20F001     MOV #0xF00, W1
013F80  600001     AND W0, W1, W0
013F82  200012     MOV #0x1, W2
013F84  204001     MOV #0x400, W1
013F86  500F81     SUB W0, W1, [W15]
013F88  3A0021     BRA NZ, 0x13FCC
2964:                  {
2965:                      return USB_INVALID_STATE;
2966:                  }
2967:              
2968:                  ep = _USB_FindEndpoint( endpoint );
013F8A  784003     MOV.B W3, W0
013F8C  0256E4     CALL _USB_FindEndpoint
013F8E  000001     NOP
013F90  780180     MOV W0, W3
2969:                  if (ep != NULL)
013F92  200142     MOV #0x14, W2
013F94  E00000     CP0 W0
013F96  32001A     BRA Z, 0x13FCC
2970:                  {
2971:                      if (ep->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_CONTROL)
013F98  900850     MOV [W0+26], W0
013F9A  B23000     AND #0x300, W0
013F9C  200182     MOV #0x18, W2
013F9E  320016     BRA Z, 0x13FCC
2972:                      {
2973:                          // Must not be a control endpoint.
2974:                          return USB_ENDPOINT_ILLEGAL_TYPE;
2975:                      }
2976:              
2977:                      if (ep->bEndpointAddress & 0x80)
013FA0  905823     MOV.B [W3+26], W0
013FA2  200152     MOV #0x15, W2
013FA4  E00400     CP0.B W0
013FA6  350012     BRA LT, 0x13FCC
2978:                      {
2979:                          // Trying to do an OUT with an IN endpoint.
2980:                          return USB_ENDPOINT_ILLEGAL_DIRECTION;
2981:                      }
2982:              
2983:                      if (ep->status.bfStalled)
013FA8  904023     MOV.B [W3+2], W0
013FAA  200112     MOV #0x11, W2
013FAC  A35800     BTST.Z W0, #5
013FAE  3A000E     BRA NZ, 0x13FCC
2984:                      {
2985:                          // The endpoint is stalled.  It must be restarted before a write
2986:                          // can be performed.
2987:                          return USB_ENDPOINT_STALLED;
2988:                      }
2989:              
2990:                      if (ep->status.bfError)
013FB0  904023     MOV.B [W3+2], W0
013FB2  200122     MOV #0x12, W2
013FB4  A36800     BTST.Z W0, #6
013FB6  3A000A     BRA NZ, 0x13FCC
2991:                      {
2992:                          // The endpoint has errored.  The error must be cleared before a
2993:                          // write can be performed.
2994:                          return USB_ENDPOINT_ERROR;
2995:                      }
2996:              
2997:                      if (!ep->status.bfTransferComplete)
013FB8  904033     MOV.B [W3+3], W0
013FBA  200102     MOV #0x10, W2
013FBC  A31800     BTST.Z W0, #1
013FBE  320006     BRA Z, 0x13FCC
2998:                      {
2999:                          // We are already processing a request for this endpoint.
3000:                          return USB_ENDPOINT_BUSY;
3001:                      }
3002:              
3003:                      _USB_InitWrite( ep, data, size );
013FC0  780108     MOV W8, W2
013FC2  78008A     MOV W10, W1
013FC4  780003     MOV W3, W0
013FC6  024614     CALL _USB_InitWrite
013FC8  000001     NOP
013FCA  EB0100     CLR W2
3004:              
3005:                      return USB_SUCCESS;
3006:                  }
3007:                  return USB_ENDPOINT_NOT_FOUND;   // Endpoint not found
3008:              }
3009:              
3010:              
3011:              // *****************************************************************************
3012:              // *****************************************************************************
3013:              // Section: Internal Functions
3014:              // *****************************************************************************
3015:              // *****************************************************************************
3016:              
3017:              /****************************************************************************
3018:                Function:
3019:                  void _USB_CheckCommandAndEnumerationAttempts( void )
3020:              
3021:                Summary:
3022:                  This function is called when we've received a STALL or a NAK when trying
3023:                  to enumerate.
3024:              
3025:                Description:
3026:                  This function is called when we've received a STALL or a NAK when trying
3027:                  to enumerate.  We allow so many attempts at each command, and so many
3028:                  attempts at enumeration.  If the command fails and there are more command
3029:                  attempts, we try the command again.  If the command fails and there are
3030:                  more enumeration attempts, we reset and try to enumerate again.
3031:                  Otherwise, we go to the holding state.
3032:              
3033:                Precondition:
3034:                  usbHostState != STATE_RUNNING
3035:              
3036:                Parameters:
3037:                  None - None
3038:              
3039:                Returns:
3040:                  None
3041:              
3042:                Remarks:
3043:                  None
3044:                ***************************************************************************/
3045:              
3046:              void _USB_CheckCommandAndEnumerationAttempts( void )
3047:              {
3048:                  #ifdef DEBUG_MODE
3049:                      UART2PutChar( '=' );
3050:                  #endif
3051:              
3052:                  // Clear the error and stall flags.  A stall here does not require
3053:                  // host intervention to clear.
3054:                  pCurrentEndpoint->status.bfError    = 0;
01551E  838381     MOV pCurrentEndpoint, W1
015520  904021     MOV.B [W1+2], W0
015522  A16400     BCLR.B W0, #6
015524  9840A0     MOV.B W0, [W1+2]
3055:                  pCurrentEndpoint->status.bfStalled  = 0;
015526  904021     MOV.B [W1+2], W0
015528  A15400     BCLR.B W0, #5
01552A  9840A0     MOV.B W0, [W1+2]
3056:              
3057:                  numCommandTries --;
01552C  270750     MOV #0x7075, W0
01552E  E94090     DEC.B [W0], W1
015530  784801     MOV.B W1, [W0]
3058:                  if (numCommandTries != 0)
015532  320004     BRA Z, 0x1553C
3059:                  {
3060:                      // We still have retries left on this command.  Try again.
3061:                      usbHostState &= ~SUBSUBSTATE_MASK;
015534  838370     MOV usbHostState, W0
015536  2FFF01     MOV #0xFFF0, W1
015538  600001     AND W0, W1, W0
01553A  370009     BRA 0x1554E
3062:                  }
3063:                  else
3064:                  {
3065:                      // This command has timed out.
3066:                      // We are enumerating.  See if we can try to enumerate again.
3067:                      numEnumerationTries --;
01553C  270740     MOV #0x7074, W0
01553E  E94090     DEC.B [W0], W1
015540  784801     MOV.B W1, [W0]
3068:                      if (numEnumerationTries != 0)
015544  3A0004     BRA NZ, 0x1554E
3069:                      {
3070:                          // We still have retries left to try to enumerate.  Reset and try again.
3071:                          usbHostState = STATE_ATTACHED | SUBSTATE_RESET_DEVICE;
015542  201100     MOV #0x110, W0
3072:                      }
3073:                      else
3074:                      {
3075:                          // Give up.  The device is not responding properly.
3076:                          _USB_SetErrorCode( USB_CANNOT_ENUMERATE );
015546  B3C070     MOV #0x7, W0
015548  2705C1     MOV #0x705C, W1
01554A  784880     MOV.B W0, [W1]
3077:                          _USB_SetHoldState();
3078:                      }
3079:                  }
3080:              }
3081:              
3082:              
3083:              /****************************************************************************
3084:                Function:
3085:                  BOOL _USB_FindClassDriver( BYTE bClass, BYTE bSubClass, BYTE bProtocol, BYTE *pbClientDrv )
3086:              
3087:                Summary:
3088:              
3089:              
3090:                Description:
3091:                  This routine scans the TPL table looking for the entry with
3092:                              the given class, subclass, and protocol values.
3093:              
3094:                Precondition:
3095:                  usbTPL must be define by the application.
3096:              
3097:                Parameters:
3098:                  bClass      - The class of the desired entry
3099:                  bSubClass   - The subclass of the desired entry
3100:                  bProtocol   - The protocol of the desired entry
3101:                  pbClientDrv - Returned index to the client driver in the client driver
3102:                                  table.
3103:              
3104:                Return Values:
3105:                  TRUE    - A class driver was found.
3106:                  FALSE   - A class driver was not found.
3107:              
3108:                Remarks:
3109:                  None
3110:                ***************************************************************************/
3111:              
3112:              BOOL _USB_FindClassDriver( BYTE bClass, BYTE bSubClass, BYTE bProtocol, BYTE *pbClientDrv )
3113:              {
3114:                  USB_OVERRIDE_CLIENT_DRIVER_EVENT_DATA   eventData;
3115:                  int                                     i;
3116:                  USB_DEVICE_DESCRIPTOR                   *pDesc = (USB_DEVICE_DESCRIPTOR *)pDeviceDescriptor;
013870  838898     MOV pDeviceDescriptor, W8
013872  EB0600     CLR W12
013874  21F649     MOV #0x1F64, W9
013876  21F67B     MOV #0x1F67, W11
013878  21F68A     MOV #0x1F68, W10
3117:              
3118:                  i = 0;
3119:                  while (i < NUM_TPL_ENTRIES)
0138D8  560FE4     SUB W12, #0x4, [W15]
0138DA  3AFFCF     BRA NZ, 0x1387A
0138DC  EB0000     CLR W0
3120:                  {
3121:                      if (usbTPL[i].flags.bfIsInterfaceDriver)
01387A  78001A     MOV [W10], W0
01387C  A34800     BTST.Z W0, #4
01387E  320028     BRA Z, 0x138D0
3122:                      {
3123:                          if ((usbTPL[i].flags.bfIsClassDriver == 1        ) &&
013880  A31800     BTST.Z W0, #1
013882  320026     BRA Z, 0x138D0
013884  97F869     MOV.B [W9-2], W0
013886  97E8EF     MOV.B [W15-18], W1
013888  504F81     SUB.B W0, W1, [W15]
01388A  3A0022     BRA NZ, 0x138D0
01388C  97F879     MOV.B [W9-1], W0
01388E  504F8E     SUB.B W0, W14, [W15]
013890  3A001F     BRA NZ, 0x138D0
013892  16CF99     SUBR.B W13, [W9], [W15]
013894  3A001D     BRA NZ, 0x138D0
3124:                              (usbTPL[i].device.bClass         == bClass   ) &&
3125:                              (usbTPL[i].device.bSubClass      == bSubClass) &&
3126:                              (usbTPL[i].device.bProtocol      == bProtocol)   )
3127:                          {
3128:                              // Make sure the application layer does not have a problem with the selection.
3129:                              // If the application layer returns FALSE, which it should if the event is not
3130:                              // defined, then accept the selection.
3131:                              eventData.idVendor          = pDesc->idVendor;
013896  904888     MOV.B [W8+8], W1
013898  FB8081     ZE W1, W1
01389A  904818     MOV.B [W8+9], W0
01389C  DD0048     SL W0, #8, W0
01389E  700081     IOR W0, W1, W1
0138A0  9FB7B1     MOV W1, [W15-26]
3132:                              eventData.idProduct         = pDesc->idProduct;
0138A2  9048A8     MOV.B [W8+10], W1
0138A4  FB8081     ZE W1, W1
0138A6  904838     MOV.B [W8+11], W0
0138A8  DD0048     SL W0, #8, W0
0138AA  700001     IOR W0, W1, W0
0138AC  9FB7C0     MOV W0, [W15-24]
3133:                              eventData.bDeviceClass      = bClass;
0138AE  97E86F     MOV.B [W15-18], W0
0138B0  9FEFA0     MOV.B W0, [W15-22]
3134:                              eventData.bDeviceSubClass   = bSubClass;
0138B2  9FEFBE     MOV.B W14, [W15-21]
3135:                              eventData.bDeviceProtocol   = bProtocol;
0138B4  9FEFCD     MOV.B W13, [W15-20]
3136:              
3137:                              if (!USB_HOST_APP_EVENT_HANDLER( USB_ROOT_HUB, EVENT_OVERRIDE_CLIENT_DRIVER_SELECTION,
0138B6  200084     MOV #0x8, W4
0138B8  200005     MOV #0x0, W5
0138BA  57817A     SUB W15, #0x1A, W2
0138BC  200791     MOV #0x79, W1
0138BE  EBC000     SETM.B W0
0138C0  02623A     CALL USB_ApplicationEventHandler
0138C2  000001     NOP
0138C4  E00000     CP0 W0
0138C6  3A0004     BRA NZ, 0x138D0
3138:                                              &eventData, sizeof(USB_OVERRIDE_CLIENT_DRIVER_EVENT_DATA) ))
3139:                              {
3140:                                  *pbClientDrv = usbTPL[i].ClientDriver;
0138C8  97B88F     MOV [W15-16], W1
0138CA  78489B     MOV.B [W11], [W1]
0138CC  200010     MOV #0x1, W0
0138CE  370007     BRA 0x138DE
3141:                                  #ifdef DEBUG_MODE
3142:                                      UART2PrintString( "HOST: Client driver found.\r\n" );
3143:                                  #endif
3144:                                  return TRUE;
3145:                              }
3146:                          }
3147:                      }
3148:                      i++;
0138D0  E8060C     INC W12, W12
0138D2  450568     ADD W10, #0x8, W10
0138D4  4585E8     ADD W11, #0x8, W11
0138D6  4484E8     ADD W9, #0x8, W9
3149:                  }
3150:              
3151:                  #ifdef DEBUG_MODE
3152:                      UART2PrintString( "HOST: Client driver NOT found.\r\n" );
3153:                  #endif
3154:                  return FALSE;
3155:              
3156:              } // _USB_FindClassDriver
3157:              
3158:              
3159:              /****************************************************************************
3160:                Function:
3161:                  BOOL _USB_FindDeviceLevelClientDriver( void )
3162:              
3163:                Description:
3164:                  This function searches the TPL to try to find a device-level client
3165:                  driver.
3166:              
3167:                Precondition:
3168:                  * usbHostState == STATE_ATTACHED|SUBSTATE_VALIDATE_VID_PID
3169:                  * usbTPL must be define by the application.
3170:              
3171:                Parameters:
3172:                  None - None
3173:              
3174:                Return Values:
3175:                  TRUE    - Client driver found
3176:                  FALSE   - Client driver not found
3177:              
3178:                Remarks:
3179:                  If successful, this function preserves the client's index from the client
3180:                  driver table and sets flags indicating that the device should use a
3181:                  single client driver.
3182:                ***************************************************************************/
3183:              
3184:              BOOL _USB_FindDeviceLevelClientDriver( void )
3185:              {
3186:                  WORD                   i;
3187:                  USB_DEVICE_DESCRIPTOR *pDesc = (USB_DEVICE_DESCRIPTOR *)pDeviceDescriptor;
0137D4  838892     MOV pDeviceDescriptor, W2
3188:              
3189:                  // Scan TPL
3190:                  i = 0;
3191:                  usbDeviceInfo.flags.bfUseDeviceClientDriver = 0;
0137D6  270680     MOV #0x7068, W0
0137D8  A16410     BCLR.B [W0], #6
0137DA  EB0380     CLR W7
0137DC  21F643     MOV #0x1F64, W3
0137DE  780280     MOV W0, W5
0137E0  21F668     MOV #0x1F66, W8
0137E2  21F686     MOV #0x1F68, W6
3192:                  while (i < NUM_TPL_ENTRIES)
013852  538FE4     SUB W7, #0x4, [W15]
013854  3AFFC7     BRA NZ, 0x137E4
013856  EB0080     CLR W1
3193:                  {
3194:                      if (usbTPL[i].flags.bfIsDeviceDriver)
0137E4  780016     MOV [W6], W0
0137E6  A33800     BTST.Z W0, #3
0137E8  320030     BRA Z, 0x1384A
3195:                      {
3196:                        if (usbTPL[i].flags.bfIsClassDriver)
0137EA  A31800     BTST.Z W0, #1
0137EC  32000C     BRA Z, 0x13806
3197:                        {
3198:                            // Check for a device-class client driver
3199:                            if ((usbTPL[i].device.bClass    == pDesc->bDeviceClass   ) &&
0137EE  97F8E3     MOV.B [W3-2], W1
0137F0  904042     MOV.B [W2+4], W0
0137F2  50CF80     SUB.B W1, W0, [W15]
0137F4  3A001D     BRA NZ, 0x13830
0137F6  97F8F3     MOV.B [W3-1], W1
0137F8  904052     MOV.B [W2+5], W0
0137FA  50CF80     SUB.B W1, W0, [W15]
0137FC  3A0019     BRA NZ, 0x13830
0137FE  904062     MOV.B [W2+6], W0
013800  104F93     SUBR.B W0, [W3], [W15]
013802  3A0016     BRA NZ, 0x13830
013804  370014     BRA 0x1382E
3200:                                (usbTPL[i].device.bSubClass == pDesc->bDeviceSubClass) &&
3201:                                (usbTPL[i].device.bProtocol == pDesc->bDeviceProtocol)   )
3202:                            {
3203:                                #ifdef DEBUG_MODE
3204:                                    UART2PrintString( "HOST: Device validated by class\r\n" );
3205:                                #endif
3206:                                usbDeviceInfo.flags.bfUseDeviceClientDriver = 1;
3207:                            }
3208:                        }
3209:                        else
3210:                        {
3211:                            // Check for a device-specific client driver by VID & PID
3212:                            #ifdef ALLOW_GLOBAL_VID_AND_PID
3213:                            if (((usbTPL[i].device.idVendor  == pDesc->idVendor ) &&
013806  97BA73     MOV [W3-2], W4
013808  904882     MOV.B [W2+8], W1
01380A  FB8081     ZE W1, W1
01380C  904812     MOV.B [W2+9], W0
01380E  DD0048     SL W0, #8, W0
013810  700001     IOR W0, W1, W0
013812  520F80     SUB W4, W0, [W15]
013814  3A0007     BRA NZ, 0x13824
013816  9048A2     MOV.B [W2+10], W1
013818  FB8081     ZE W1, W1
01381A  904832     MOV.B [W2+11], W0
01381C  DD0048     SL W0, #8, W0
01381E  700001     IOR W0, W1, W0
013820  100F93     SUBR W0, [W3], [W15]
013822  320005     BRA Z, 0x1382E
013824  420FE1     ADD W4, #0x1, [W15]
013826  3A0004     BRA NZ, 0x13830
013828  EB8000     SETM W0
01382A  100F93     SUBR W0, [W3], [W15]
01382C  3A0001     BRA NZ, 0x13830
3214:                                 (usbTPL[i].device.idProduct == pDesc->idProduct)) ||
3215:                                ((usbTPL[i].device.idVendor  == 0xFFFF) &&
3216:                                 (usbTPL[i].device.idProduct == 0xFFFF)))
3217:                            #else
3218:                            if ((usbTPL[i].device.idVendor  == pDesc->idVendor ) &&
3219:                                (usbTPL[i].device.idProduct == pDesc->idProduct)   )
3220:                            #endif
3221:                            {
3222:                                #ifdef DEBUG_MODE
3223:                                    UART2PrintString( "HOST: Device validated by VID/PID\r\n" );
3224:                                #endif
3225:                                usbDeviceInfo.flags.bfUseDeviceClientDriver = 1;
01382E  A06415     BSET.B [W5], #6
3226:                            }
3227:                        }
3228:              
3229:                        if (usbDeviceInfo.flags.bfUseDeviceClientDriver)
013830  B3C401     MOV #0x40, W1
013832  60C015     AND.B W1, [W5], W0
013834  32000A     BRA Z, 0x1384A
3230:                        {
3231:                            // Save client driver info
3232:                            usbDeviceInfo.deviceClientDriver = usbTPL[i].ClientDriver;
013836  2705D0     MOV #0x705D, W0
013838  97F8F6     MOV.B [W6-1], W1
01383A  784801     MOV.B W1, [W0]
3233:              
3234:                            // Select configuration if it is given in the TPL
3235:                            if (usbTPL[i].flags.bfSetConfiguration)
01383C  780016     MOV [W6], W0
01383E  200011     MOV #0x1, W1
013840  A32800     BTST.Z W0, #2
013842  32000A     BRA Z, 0x13858
3236:                            {
3237:                                usbDeviceInfo.currentConfiguration = usbTPL[i].bConfiguration;
013844  270580     MOV #0x7058, W0
013846  784818     MOV.B [W8], [W0]
013848  370007     BRA 0x13858
3238:                            }
3239:              
3240:                            return TRUE;
3241:                        }
3242:                      }
3243:              
3244:                      i++;
01384A  E80387     INC W7, W7
01384C  440468     ADD W8, #0x8, W8
01384E  430368     ADD W6, #0x8, W6
013850  4181E8     ADD W3, #0x8, W3
3245:                  }
3246:              
3247:                  #ifdef DEBUG_MODE
3248:                      UART2PrintString( "HOST: Device not yet validated\r\n" );
3249:                  #endif
3250:              
3251:                  return FALSE;
3252:              }
3253:              
3254:              /****************************************************************************
3255:                Function:
3256:                  USB_ENDPOINT_INFO * _USB_FindEndpoint( BYTE endpoint )
3257:              
3258:                Description:
3259:                  This function searches the list of interfaces to try to find the specified
3260:                  endpoint.
3261:              
3262:                Precondition:
3263:                  None
3264:              
3265:                Parameters:
3266:                  BYTE endpoint   - The endpoint to find.
3267:              
3268:                Returns:
3269:                  Returns a pointer to the USB_ENDPOINT_INFO structure for the endpoint.
3270:              
3271:                Remarks:
3272:                  None
3273:                ***************************************************************************/
3274:              
3275:              USB_ENDPOINT_INFO * _USB_FindEndpoint( BYTE endpoint )
3276:              {
3277:                  USB_ENDPOINT_INFO           *pEndpoint;
3278:                  USB_INTERFACE_INFO          *pInterface;
3279:              
3280:                  if (endpoint == 0)
0156E6  E00400     CP0.B W0
0156E8  3A0002     BRA NZ, 0x156EE
3281:                  {
3282:                      return usbDeviceInfo.pEndpoint0;
0156EA  838331     MOV 0x7066, W1
0156EC  370011     BRA 0x15710
3283:                  }
3284:              
3285:                  pInterface = usbDeviceInfo.pInterfaceList;
0156EE  838322     MOV 0x7064, W2
0156F0  37000C     BRA 0x1570A
3286:                  while (pInterface)
01570A  E00002     CP0 W2
01570C  3AFFF2     BRA NZ, 0x156F2
01570E  780082     MOV W2, W1
3287:                  {
3288:                      // Look for the endpoint in the currently active setting.
3289:                      if (pInterface->pCurrentSetting)
0156F2  900022     MOV [W2+4], W0
0156F4  E00000     CP0 W0
0156F6  320008     BRA Z, 0x15708
3290:                      {
3291:                          pEndpoint = pInterface->pCurrentSetting->pEndpointList;
0156F8  9000A0     MOV [W0+4], W1
0156FA  370004     BRA 0x15704
3292:                          while (pEndpoint)
015704  E00001     CP0 W1
015706  3AFFFA     BRA NZ, 0x156FC
3293:                          {
3294:                              if (pEndpoint->bEndpointAddress == endpoint)
0156FC  905821     MOV.B [W1+26], W0
0156FE  504F83     SUB.B W0, W3, [W15]
015700  320007     BRA Z, 0x15710
3295:                              {
3296:                                  // We have found the endpoint.
3297:                                  return pEndpoint;
3298:                              }
3299:                              pEndpoint = pEndpoint->next;
015702  780091     MOV [W1], W1
3300:                          }
3301:                      }
3302:                      
3303:                      // Go to the next interface.
3304:                      pInterface = pInterface->next;
015708  780112     MOV [W2], W2
3305:                  }
3306:              
3307:                  return NULL;
3308:              }
3309:              
3310:              
3311:              /****************************************************************************
3312:                Function:
3313:                  USB_INTERFACE_INFO * _USB_FindInterface ( BYTE bInterface, BYTE bAltSetting )
3314:              
3315:                Description:
3316:                  This routine scans the interface linked list and returns a pointer to the
3317:                  node identified by the interface and alternate setting.
3318:              
3319:                Precondition:
3320:                  None
3321:              
3322:                Parameters:
3323:                  bInterface  - Interface number
3324:                  bAltSetting - Interface alternate setting number
3325:              
3326:                Returns:
3327:                  USB_INTERFACE_INFO *  - Pointer to the interface linked list node.
3328:              
3329:                Remarks:
3330:                  None
3331:                ***************************************************************************/
3332:              /*
3333:              USB_INTERFACE_INFO * _USB_FindInterface ( BYTE bInterface, BYTE bAltSetting )
3334:              {
3335:                  USB_INTERFACE_INFO *pCurIntf = usbDeviceInfo.pInterfaceList;
3336:              
3337:                  while (pCurIntf)
3338:                  {
3339:                      if (pCurIntf->interface           == bInterface &&
3340:                          pCurIntf->interfaceAltSetting == bAltSetting  )
3341:                      {
3342:                          return pCurIntf;
3343:                      }
3344:                  }
3345:              
3346:                  return NULL;
3347:              
3348:              } // _USB_FindInterface
3349:              */
3350:              
3351:              /****************************************************************************
3352:                Function:
3353:                  void _USB_FindNextToken( void )
3354:              
3355:                Description:
3356:                  This function determines the next token to send of all current pending
3357:                  transfers.
3358:              
3359:                Precondition:
3360:                  None
3361:              
3362:                Parameters:
3363:                  None - None
3364:              
3365:                Return Values:
3366:                  TRUE    - A token was sent
3367:                  FALSE   - No token was found to send, so the routine can be called again.
3368:              
3369:                Remarks:
3370:                  This routine is only called from an interrupt handler, either SOFIF or
3371:                  TRNIF.
3372:                ***************************************************************************/
3373:              
3374:              void _USB_FindNextToken( void )
3375:              {
3376:                  BOOL    illegalState = FALSE;
3377:              
3378:                  // If the device is suspended or resuming, do not send any tokens.  We will
3379:                  // send the next token on an SOF interrupt after the resume recovery time
3380:                  // has expired.
3381:                  if ((usbHostState & (SUBSTATE_MASK | SUBSUBSTATE_MASK)) == (STATE_RUNNING | SUBSTATE_SUSPEND_AND_RESUME))
011682  838370     MOV usbHostState, W0
3382:                  {
3383:                      return;
3384:                  }
3385:              
3386:                  // If we are currently sending a token, we cannot do anything.  We will come
3387:                  // back in here when we get either the Token Done or the Start of Frame interrupt.
3388:                  if (usbBusInfo.flags.bfTokenAlreadyWritten) //(U1CONbits.TOKBUSY)
011684  2706AA     MOV #0x706A, W10
011686  78409A     MOV.B [W10], W1
011688  60C070     AND.B W1, #0x10, W0
01168A  3A0107     BRA NZ, 0x1189A
3389:                  {
3390:                      return;
3391:                  }
3392:              
3393:                  // We will handle control transfers first.  We only allow one control
3394:                  // transfer per frame.
3395:                  if (!usbBusInfo.flags.bfControlTransfersDone)
01168C  78401A     MOV.B [W10], W0
01168E  6044E1     AND.B W0, #0x1, W9
011690  EB0580     CLR W11
011692  3A0073     BRA NZ, 0x1177A
3396:                  {
3397:                      // Look for any control transfers.
3398:                      if (_USB_FindServiceEndpoint( USB_TRANSFER_TYPE_CONTROL ))
011694  784009     MOV.B W9, W0
011696  023976     CALL _USB_FindServiceEndpoint
011698  000001     NOP
01169A  E00000     CP0 W0
01169C  3A0002     BRA NZ, 0x116A2
01169E  780580     MOV W0, W11
0116A0  37006A     BRA 0x11776
3399:                      {
3400:                          switch (pCurrentEndpoint->transferState & TSTATE_MASK)
0116A2  838382     MOV pCurrentEndpoint, W2
0116A4  905802     MOV.B [W2+24], W0
0116A6  780080     MOV W0, W1
0116A8  B20F01     AND #0xF0, W1
0116AA  200200     MOV #0x20, W0
0116AC  508F80     SUB W1, W0, [W15]
0116AE  320021     BRA Z, 0x116F2
0116B0  400070     ADD W0, #0x10, W0
0116B2  508F80     SUB W1, W0, [W15]
0116B4  32003B     BRA Z, 0x1172C
0116B6  508FF0     SUB W1, #0x10, [W15]
0116B8  3A00E9     BRA NZ, 0x1188C
3401:                          {
3402:                              case TSTATE_CONTROL_NO_DATA:
3403:                                  switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
0116BA  905802     MOV.B [W2+24], W0
0116BC  60006F     AND W0, #0xF, W0
0116BE  500FE1     SUB W0, #0x1, [W15]
0116C0  320007     BRA Z, 0x116D0
0116C2  3C0003     BRA GT, 0x116CA
0116C4  E00000     CP0 W0
0116C6  320041     BRA Z, 0x1174A
0116C8  3700E1     BRA 0x1188C
0116CA  500FE2     SUB W0, #0x2, [W15]
0116CC  32004F     BRA Z, 0x1176C
0116CE  37001D     BRA 0x1170A
3404:                                  {
3405:                                      case TSUBSTATE_CONTROL_NO_DATA_SETUP:
3406:                                          _USB_SetDATA01( DTS_DATA0 );
3407:                                          _USB_SetBDT( USB_TOKEN_SETUP );
3408:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_SETUP );
3409:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3410:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
3411:                                          #endif
3412:                                          return;
3413:                                          break;
3414:              
3415:                                      case TSUBSTATE_CONTROL_NO_DATA_ACK:
3416:                                          pCurrentEndpoint->dataCountMax = pCurrentEndpoint->dataCount;
0116D0  900802     MOV [W2+16], W0
0116D2  900892     MOV [W2+18], W1
0116D4  980150     MOV W0, [W2+10]
0116D6  980161     MOV W1, [W2+12]
3417:                                          _USB_SetDATA01( DTS_DATA1 );
0116D8  904032     MOV.B [W2+3], W0
0116DA  A03400     BSET.B W0, #3
0116DC  984130     MOV.B W0, [W2+3]
3418:                                          _USB_SetBDT( USB_TOKEN_IN );
0116DE  B3C090     MOV #0x9, W0
0116E0  022CB4     CALL _USB_SetBDT
0116E2  000001     NOP
3419:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN );
0116E4  838380     MOV pCurrentEndpoint, W0
0116E6  905820     MOV.B [W0+26], W0
0116E8  B3C091     MOV #0x9, W1
0116EA  024EA0     CALL _USB_SendToken
0116EC  000001     NOP
3420:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3421:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
0116EE  A0041A     BSET.B [W10], #0
0116F0  3700D4     BRA 0x1189A
3422:                                          #endif
3423:                                          return;
3424:                                          break;
3425:              
3426:                                      case TSUBSTATE_CONTROL_NO_DATA_COMPLETE:
3427:                                          pCurrentEndpoint->transferState               = TSTATE_IDLE;
3428:                                          pCurrentEndpoint->status.bfTransferComplete   = 1;
3429:                                          #if defined( USB_ENABLE_TRANSFER_EVENT )
3430:                                              if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3431:                                              {
3432:                                                  USB_EVENT_DATA *data;
3433:              
3434:                                                  data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3435:                                                  data->event = EVENT_TRANSFER;
3436:                                                  data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
3437:                                                  data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
3438:                                                  data->TransferData.bErrorCode       = USB_SUCCESS;
3439:                                                  data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3440:                                                  data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3441:                                                  data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3442:                                              }
3443:                                              else
3444:                                              {
3445:                                                  pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3446:                                              }
3447:                                          #endif
3448:                                  break;
3449:              
3450:                                      case TSUBSTATE_ERROR:
3451:                                          pCurrentEndpoint->transferState               = TSTATE_IDLE;
3452:                                          pCurrentEndpoint->status.bfTransferComplete   = 1;
3453:                                          #if defined( USB_ENABLE_TRANSFER_EVENT )
3454:                                              if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3455:                                              {
3456:                                                  USB_EVENT_DATA *data;
3457:              
3458:                                                  data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3459:                                                  data->event = EVENT_BUS_ERROR;
3460:                                                  data->TransferData.dataCount        = 0;
3461:                                                  data->TransferData.pUserData        = NULL;
3462:                                                  data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
3463:                                                  data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3464:                                                  data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3465:                                                  data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3466:                                              }
3467:                                              else
3468:                                              {
3469:                                                  pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3470:                                              }
3471:                                          #endif
3472:                                          break;
3473:              
3474:                                      default:
3475:                                          illegalState = TRUE;
3476:                                          break;
3477:                                  }
3478:                                  break;
3479:              
3480:                              case TSTATE_CONTROL_READ:
3481:                                  switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
0116F2  905802     MOV.B [W2+24], W0
0116F4  60006F     AND W0, #0xF, W0
0116F6  500FE2     SUB W0, #0x2, [W15]
0116F8  32000B     BRA Z, 0x11710
0116FA  3C0005     BRA GT, 0x11706
0116FC  E00000     CP0 W0
0116FE  320025     BRA Z, 0x1174A
011700  500FE1     SUB W0, #0x1, [W15]
011702  3A00C4     BRA NZ, 0x1188C
011704  37FFEC     BRA 0x116DE
011706  500FE3     SUB W0, #0x3, [W15]
011708  320031     BRA Z, 0x1176C
01170A  500FEF     SUB W0, #0xF, [W15]
01170C  3A00BF     BRA NZ, 0x1188C
01170E  37002E     BRA 0x1176C
3482:                                  {
3483:                                      case TSUBSTATE_CONTROL_READ_SETUP:
3484:                                          _USB_SetDATA01( DTS_DATA0 );
3485:                                          _USB_SetBDT( USB_TOKEN_SETUP );
3486:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_SETUP );
3487:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3488:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
3489:                                          #endif
3490:                                          return;
3491:                                          break;
3492:              
3493:                                      case TSUBSTATE_CONTROL_READ_DATA:
3494:                                          _USB_SetBDT( USB_TOKEN_IN );
3495:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN );
3496:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3497:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
3498:                                          #endif
3499:                                          return;
3500:                                          break;
3501:              
3502:                                      case TSUBSTATE_CONTROL_READ_ACK:
3503:                                          pCurrentEndpoint->dataCountMax = pCurrentEndpoint->dataCount;
011710  900802     MOV [W2+16], W0
011712  900892     MOV [W2+18], W1
011714  980150     MOV W0, [W2+10]
011716  980161     MOV W1, [W2+12]
3504:                                          _USB_SetDATA01( DTS_DATA1 );
011718  904032     MOV.B [W2+3], W0
01171A  A03400     BSET.B W0, #3
01171C  984130     MOV.B W0, [W2+3]
3505:                                          _USB_SetBDT( USB_TOKEN_OUT );
01171E  B3C010     MOV #0x1, W0
011720  022CB4     CALL _USB_SetBDT
011722  000001     NOP
3506:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT );
011724  838380     MOV pCurrentEndpoint, W0
011726  905820     MOV.B [W0+26], W0
011728  B3C011     MOV #0x1, W1
01172A  37FFDF     BRA 0x116EA
3507:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3508:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
3509:                                          #endif
3510:                                          return;
3511:                                          break;
3512:              
3513:                                      case TSUBSTATE_CONTROL_READ_COMPLETE:
3514:                                          pCurrentEndpoint->transferState               = TSTATE_IDLE;
3515:                                          pCurrentEndpoint->status.bfTransferComplete   = 1;
3516:                                          #if defined( USB_ENABLE_TRANSFER_EVENT )
3517:                                              if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3518:                                              {
3519:                                                  USB_EVENT_DATA *data;
3520:              
3521:                                                  data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3522:                                                  data->event = EVENT_TRANSFER;
3523:                                                  data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
3524:                                                  data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
3525:                                                  data->TransferData.bErrorCode       = USB_SUCCESS;
3526:                                                  data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3527:                                                  data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3528:                                                  data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3529:                                              }
3530:                                              else
3531:                                              {
3532:                                                  pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3533:                                              }
3534:                                          #endif
3535:                                          break;
3536:              
3537:                                      case TSUBSTATE_ERROR:
3538:                                          pCurrentEndpoint->transferState               = TSTATE_IDLE;
3539:                                          pCurrentEndpoint->status.bfTransferComplete   = 1;
3540:                                          #if defined( USB_ENABLE_TRANSFER_EVENT )
3541:                                              if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3542:                                              {
3543:                                                  USB_EVENT_DATA *data;
3544:              
3545:                                                  data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3546:                                                  data->event = EVENT_BUS_ERROR;
3547:                                                  data->TransferData.dataCount        = 0;
3548:                                                  data->TransferData.pUserData        = NULL;
3549:                                                  data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
3550:                                                  data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3551:                                                  data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3552:                                                  data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3553:                                              }
3554:                                              else
3555:                                              {
3556:                                                  pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3557:                                              }
3558:                                          #endif
3559:                                          break;
3560:              
3561:                                      default:
3562:                                          illegalState = TRUE;
3563:                                          break;
3564:                                  }
3565:                                  break;
3566:              
3567:                              case TSTATE_CONTROL_WRITE:
3568:                                  switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
01172C  905802     MOV.B [W2+24], W0
01172E  60046F     AND W0, #0xF, W8
011730  540FE2     SUB W8, #0x2, [W15]
011732  32FFCE     BRA Z, 0x116D0
011734  3C0005     BRA GT, 0x11740
011736  E00008     CP0 W8
011738  320008     BRA Z, 0x1174A
01173A  540FE1     SUB W8, #0x1, [W15]
01173C  3A00A7     BRA NZ, 0x1188C
01173E  37000F     BRA 0x1175E
011740  540FE3     SUB W8, #0x3, [W15]
011742  320014     BRA Z, 0x1176C
011744  540FEF     SUB W8, #0xF, [W15]
011746  3A00A2     BRA NZ, 0x1188C
011748  370011     BRA 0x1176C
3569:                                  {
3570:                                      case TSUBSTATE_CONTROL_WRITE_SETUP:
3571:                                          _USB_SetDATA01( DTS_DATA0 );
01174A  904032     MOV.B [W2+3], W0
01174C  A13400     BCLR.B W0, #3
01174E  984130     MOV.B W0, [W2+3]
3572:                                          _USB_SetBDT( USB_TOKEN_SETUP );
011750  B3C0D0     MOV #0xD, W0
011752  022CB4     CALL _USB_SetBDT
011754  000001     NOP
3573:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_SETUP );
011756  838380     MOV pCurrentEndpoint, W0
011758  905820     MOV.B [W0+26], W0
01175A  B3C0D1     MOV #0xD, W1
01175C  37FFC6     BRA 0x116EA
3574:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3575:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
3576:                                          #endif
3577:                                          return;
3578:                                          break;
3579:              
3580:                                      case TSUBSTATE_CONTROL_WRITE_DATA:
3581:                                          _USB_SetBDT( USB_TOKEN_OUT );
01175E  784008     MOV.B W8, W0
011760  022CB4     CALL _USB_SetBDT
011762  000001     NOP
3582:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT );
011764  838380     MOV pCurrentEndpoint, W0
011766  905820     MOV.B [W0+26], W0
011768  784088     MOV.B W8, W1
01176A  37FFBF     BRA 0x116EA
3583:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3584:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
3585:                                          #endif
3586:                                          return;
3587:                                          break;
3588:              
3589:                                      case TSUBSTATE_CONTROL_WRITE_ACK:
3590:                                          pCurrentEndpoint->dataCountMax = pCurrentEndpoint->dataCount;
3591:                                          _USB_SetDATA01( DTS_DATA1 );
3592:                                          _USB_SetBDT( USB_TOKEN_IN );
3593:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN );
3594:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3595:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
3596:                                          #endif
3597:                                          return;
3598:                                          break;
3599:              
3600:                                      case TSUBSTATE_CONTROL_WRITE_COMPLETE:
3601:                                          pCurrentEndpoint->transferState               = TSTATE_IDLE;
3602:                                          pCurrentEndpoint->status.bfTransferComplete   = 1;
3603:                                          #if defined( USB_ENABLE_TRANSFER_EVENT )
3604:                                              if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3605:                                              {
3606:                                                  USB_EVENT_DATA *data;
3607:              
3608:                                                  data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3609:                                                  data->event = EVENT_TRANSFER;
3610:                                                  data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
3611:                                                  data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
3612:                                                  data->TransferData.bErrorCode       = USB_SUCCESS;
3613:                                                  data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3614:                                                  data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3615:                                                  data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3616:                                              }
3617:                                              else
3618:                                              {
3619:                                                  pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3620:                                              }
3621:                                          #endif
3622:                                          break;
3623:              
3624:                                      case TSUBSTATE_ERROR:
3625:                                          pCurrentEndpoint->transferState               = TSTATE_IDLE;
01176C  985909     MOV.B W9, [W2+24]
3626:                                          pCurrentEndpoint->status.bfTransferComplete   = 1;
01176E  904032     MOV.B [W2+3], W0
011770  A01400     BSET.B W0, #1
011772  984130     MOV.B W0, [W2+3]
011774  EB0580     CLR W11
3627:                                          #if defined( USB_ENABLE_TRANSFER_EVENT )
3628:                                              if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3629:                                              {
3630:                                                  USB_EVENT_DATA *data;
3631:              
3632:                                                  data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3633:                                                  data->event = EVENT_BUS_ERROR;
3634:                                                  data->TransferData.dataCount        = 0;
3635:                                                  data->TransferData.pUserData        = NULL;
3636:                                                  data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
3637:                                                  data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3638:                                                  data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3639:                                                  data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3640:                                              }
3641:                                              else
3642:                                              {
3643:                                                  pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3644:                                              }
3645:                                          #endif
3646:                                          break;
3647:              
3648:                                      default:
3649:                                          illegalState = TRUE;
3650:                                          break;
3651:                                  }
3652:                                  break;
3653:              
3654:                              default:
3655:                                  illegalState = TRUE;
3656:                          }
3657:              
3658:                          if (illegalState)
3659:                          {
3660:                              // We should never use this, but in case we do, put the endpoint
3661:                              // in a recoverable state.
3662:                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
01188C  EB4000     CLR.B W0
01188E  985900     MOV.B W0, [W2+24]
3663:                              pCurrentEndpoint->status.bfTransferComplete   = 1;
011890  904032     MOV.B [W2+3], W0
011892  A01400     BSET.B W0, #1
011894  984130     MOV.B W0, [W2+3]
011896  20001B     MOV #0x1, W11
011898  37FF6E     BRA 0x11776
3664:                          }
3665:                      }
3666:              
3667:                      // If we've gone through all the endpoints, we do not have any more control transfers.
3668:                      usbBusInfo.flags.bfControlTransfersDone = 1;
011776  2706A0     MOV #0x706A, W0
011778  A00410     BSET.B [W0], #0
3669:                  }
3670:              
3671:                  #ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
3672:                      // Next, we will handle isochronous transfers.  We must be careful with
3673:                      // these.  The maximum packet size for an isochronous transfer is 1023
3674:                      // bytes, so we cannot use the threshold register (U1SOF) to ensure that
3675:                      // we do not write too many tokens during a frame.  Instead, we must count
3676:                      // the number of bytes we are sending and stop sending isochronous
3677:                      // transfers when we reach that limit.
3678:              
3679:                      // TODO: Implement scheduling by using usbBusInfo.dBytesSentInFrame
3680:              
3681:                      // Current Limitation:  The stack currently supports only one attached
3682:                      // device.  We will make the assumption that the control, isochronous, and
3683:                      // interrupt transfers requested by a single device will not exceed one
3684:                      // frame, and defer the scheduler.
3685:              
3686:                      // Due to the nature of isochronous transfers, transfer events must be used.
3687:                      #if !defined( USB_ENABLE_TRANSFER_EVENT )
3688:                          #error Transfer events are required for isochronous transfers
3689:                      #endif
3690:              
3691:                      if (!usbBusInfo.flags.bfIsochronousTransfersDone)
3692:                      {
3693:                          // Look for any isochronous operations.
3694:                          if (_USB_FindServiceEndpoint( USB_TRANSFER_TYPE_ISOCHRONOUS ))
3695:                          {
3696:                              switch (pCurrentEndpoint->transferState & TSTATE_MASK)
3697:                              {
3698:                                  case TSTATE_ISOCHRONOUS_READ:
3699:                                      switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
3700:                                      {
3701:                                          case TSUBSTATE_ISOCHRONOUS_READ_DATA:
3702:                                              if (pCurrentEndpoint->wIntervalCount == 0)
3703:                                              {
3704:                                                  // Reset the interval count for the next packet.
3705:                                                  pCurrentEndpoint->wIntervalCount  = pCurrentEndpoint->wInterval;
3706:              
3707:                                                  // Don't overwrite data the user has not yet processed.  We will skip this interval.    
3708:                                                  if (((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid)
3709:                                                  {
3710:                                                      // We have buffer overflow.
3711:                                                  }
3712:                                                  else
3713:                                                  {
3714:                                                      // Initialize the data buffer.
3715:                                                      ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid = 0;
3716:                                                      pCurrentEndpoint->dataCount = 0;
3717:                  
3718:                                                      _USB_SetDATA01( DTS_DATA0 );    // Always DATA0 for isochronous
3719:                                                      _USB_SetBDT( USB_TOKEN_IN );
3720:                                                      _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN );
3721:                                                      return;
3722:                                                  }    
3723:                                              }
3724:                                              break;
3725:              
3726:                                          case TSUBSTATE_ISOCHRONOUS_READ_COMPLETE:
3727:                                              // Isochronous transfers are continuous until the user stops them.
3728:                                              // Send an event that there is new data, and reset for the next
3729:                                              // interval.
3730:                                              pCurrentEndpoint->transferState = TSTATE_ISOCHRONOUS_READ | TSUBSTATE_ISOCHRONOUS_READ_DATA;
3731:              
3732:                                              // Update the valid data length for this buffer.
3733:                                              ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].dataLength = pCurrentEndpoint->dataCount;
3734:                                              ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid = 1;
3735:                                              #if defined( USB_ENABLE_ISOC_TRANSFER_EVENT )
3736:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3737:                                                  {
3738:                                                      USB_EVENT_DATA *data;
3739:              
3740:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3741:                                                      data->event = EVENT_TRANSFER;
3742:                                                      data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
3743:                                                      data->TransferData.pUserData        = ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer;
3744:                                                      data->TransferData.bErrorCode       = USB_SUCCESS;
3745:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3746:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3747:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3748:                                                  }
3749:                                                  else
3750:                                                  {
3751:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3752:                                                  }
3753:                                              #endif
3754:                                              
3755:                                              // If the user wants an event from the interrupt handler to handle the data as quickly as
3756:                                              // possible, send up the event.  Then mark the packet as used.
3757:                                              #ifdef USB_HOST_APP_DATA_EVENT_HANDLER
3758:                                                  usbClientDrvTable[pCurrentEndpoint->clientDriver].DataEventHandler( usbDeviceInfo.deviceAddress, EVENT_DATA_ISOC_READ, ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer, pCurrentEndpoint->dataCount );
3759:                                                  ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid = 0;
3760:                                              #endif
3761:                                              
3762:                                              // Move to the next data buffer.
3763:                                              ((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->currentBufferUSB++;
3764:                                              if (((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->currentBufferUSB >= ((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->totalBuffers)
3765:                                              {
3766:                                                  ((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->currentBufferUSB = 0;
3767:                                              }
3768:                                              break;
3769:              
3770:                                          case TSUBSTATE_ERROR:
3771:                                              // Isochronous transfers are continuous until the user stops them.
3772:                                              // Send an event that there is an error, and reset for the next
3773:                                              // interval.
3774:                                              pCurrentEndpoint->transferState = TSTATE_ISOCHRONOUS_READ | TSUBSTATE_ISOCHRONOUS_READ_DATA;
3775:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
3776:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3777:                                                  {
3778:                                                      USB_EVENT_DATA *data;
3779:              
3780:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3781:                                                      data->event = EVENT_BUS_ERROR;
3782:                                                      data->TransferData.dataCount        = 0;
3783:                                                      data->TransferData.pUserData        = NULL;
3784:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3785:                                                      data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
3786:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3787:                                                  }
3788:                                                  else
3789:                                                  {
3790:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3791:                                                  }
3792:                                              #endif
3793:                                              break;
3794:              
3795:                                          default:
3796:                                              illegalState = TRUE;
3797:                                              break;
3798:                                      }
3799:                                      break;
3800:              
3801:                                  case TSTATE_ISOCHRONOUS_WRITE:
3802:                                      switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
3803:                                      {
3804:                                          case TSUBSTATE_ISOCHRONOUS_WRITE_DATA:
3805:                                              if (pCurrentEndpoint->wIntervalCount == 0)
3806:                                              {
3807:                                                  // Reset the interval count for the next packet.
3808:                                                  pCurrentEndpoint->wIntervalCount  = pCurrentEndpoint->wInterval;
3809:              
3810:                                                  if (!((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid)
3811:                                                  {
3812:                                                      // We have buffer underrun.
3813:                                                  }
3814:                                                  else
3815:                                                  {
3816:                                                      pCurrentEndpoint->dataCount = ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].dataLength;
3817:                  
3818:                                                      _USB_SetDATA01( DTS_DATA0 );    // Always DATA0 for isochronous
3819:                                                      _USB_SetBDT( USB_TOKEN_OUT );
3820:                                                      _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT );
3821:                                                      return;
3822:                                                  }    
3823:                                              }
3824:                                              break;
3825:              
3826:                                          case TSUBSTATE_ISOCHRONOUS_WRITE_COMPLETE:
3827:                                              // Isochronous transfers are continuous until the user stops them.
3828:                                              // Send an event that data has been sent, and reset for the next
3829:                                              // interval.
3830:                                              pCurrentEndpoint->transferState = TSTATE_ISOCHRONOUS_WRITE | TSUBSTATE_ISOCHRONOUS_WRITE_DATA;
3831:              
3832:                                              // Update the valid data length for this buffer.
3833:                                              ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid = 0;
3834:                                              #if defined( USB_ENABLE_ISOC_TRANSFER_EVENT )
3835:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3836:                                                  {
3837:                                                      USB_EVENT_DATA *data;
3838:              
3839:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3840:                                                      data->event = EVENT_TRANSFER;
3841:                                                      data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
3842:                                                      data->TransferData.pUserData        = ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer;
3843:                                                      data->TransferData.bErrorCode       = USB_SUCCESS;
3844:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3845:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3846:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3847:                                                  }
3848:                                                  else
3849:                                                  {
3850:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3851:                                                  }
3852:                                              #endif
3853:              
3854:                                              // If the user wants an event from the interrupt handler to handle the data as quickly as
3855:                                              // possible, send up the event.
3856:                                              #ifdef USB_HOST_APP_DATA_EVENT_HANDLER
3857:                                                  usbClientDrvTable[pCurrentEndpoint->clientDriver].DataEventHandler( usbDeviceInfo.deviceAddress, EVENT_DATA_ISOC_WRITE, ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer, pCurrentEndpoint->dataCount );
3858:                                              #endif
3859:                                                                              
3860:                                              // Move to the next data buffer.
3861:                                              ((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->currentBufferUSB++;
3862:                                              if (((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->currentBufferUSB >= ((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->totalBuffers)
3863:                                              {
3864:                                                  ((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->currentBufferUSB = 0;
3865:                                              }
3866:                                              break;
3867:              
3868:                                          case TSUBSTATE_ERROR:
3869:                                              // Isochronous transfers are continuous until the user stops them.
3870:                                              // Send an event that there is an error, and reset for the next
3871:                                              // interval.
3872:                                              pCurrentEndpoint->transferState = TSTATE_ISOCHRONOUS_WRITE | TSUBSTATE_ISOCHRONOUS_WRITE_DATA;
3873:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
3874:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3875:                                                  {
3876:                                                      USB_EVENT_DATA *data;
3877:              
3878:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3879:                                                      data->event = EVENT_BUS_ERROR;
3880:                                                      data->TransferData.dataCount        = 0;
3881:                                                      data->TransferData.pUserData        = NULL;
3882:                                                      data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
3883:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3884:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3885:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3886:                                                  }
3887:                                                  else
3888:                                                  {
3889:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3890:                                                  }
3891:                                              #endif
3892:                                              break;
3893:              
3894:                                          default:
3895:                                              illegalState = TRUE;
3896:                                              break;
3897:                                      }
3898:                                      break;
3899:              
3900:                                  default:
3901:                                      illegalState = TRUE;
3902:                                      break;
3903:                              }
3904:              
3905:                              if (illegalState)
3906:                              {
3907:                                  // We should never use this, but in case we do, put the endpoint
3908:                                  // in a recoverable state.
3909:                                  pCurrentEndpoint->transferState               = TSTATE_IDLE;
3910:                                  pCurrentEndpoint->status.bfTransferComplete   = 1;
3911:                              }
3912:                          }
3913:              
3914:                          // If we've gone through all the endpoints, we do not have any more isochronous transfers.
3915:                          usbBusInfo.flags.bfIsochronousTransfersDone = 1;
3916:                      }
3917:                  #endif
3918:              
3919:                  #ifdef USB_SUPPORT_INTERRUPT_TRANSFERS
3920:                      if (!usbBusInfo.flags.bfInterruptTransfersDone)
01177A  2706A0     MOV #0x706A, W0
01177C  784010     MOV.B [W0], W0
01177E  604462     AND.B W0, #0x2, W8
011780  3A003B     BRA NZ, 0x117F8
3921:                      {
3922:                          // Look for any interrupt operations.
3923:                          if (_USB_FindServiceEndpoint( USB_TRANSFER_TYPE_INTERRUPT ))
011782  B3C030     MOV #0x3, W0
011784  023976     CALL _USB_FindServiceEndpoint
011786  000001     NOP
011788  E00000     CP0 W0
01178A  320034     BRA Z, 0x117F4
3924:                          {
3925:                              switch (pCurrentEndpoint->transferState & TSTATE_MASK)
01178C  838381     MOV pCurrentEndpoint, W1
01178E  905801     MOV.B [W1+24], W0
011790  780100     MOV W0, W2
011792  B20F02     AND #0xF0, W2
011794  200400     MOV #0x40, W0
011796  510F80     SUB W2, W0, [W15]
011798  320004     BRA Z, 0x117A2
01179A  400070     ADD W0, #0x10, W0
01179C  510F80     SUB W2, W0, [W15]
01179E  3A0024     BRA NZ, 0x117E8
0117A0  37000E     BRA 0x117BE
3926:                              {
3927:                                  case TSTATE_INTERRUPT_READ:
3928:                                      switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
0117A2  905801     MOV.B [W1+24], W0
0117A4  60006F     AND W0, #0xF, W0
0117A6  500FE1     SUB W0, #0x1, [W15]
0117A8  320018     BRA Z, 0x117DA
0117AA  500FEF     SUB W0, #0xF, [W15]
0117AC  320016     BRA Z, 0x117DA
0117AE  E00000     CP0 W0
0117B0  3A001B     BRA NZ, 0x117E8
3929:                                      {
3930:                                          case TSUBSTATE_INTERRUPT_READ_DATA:
3931:                                              if (pCurrentEndpoint->wIntervalCount == 0)
0117B2  900031     MOV [W1+6], W0
0117B4  E00000     CP0 W0
0117B6  3A0015     BRA NZ, 0x117E2
3932:                                              {
3933:                                                  // Reset the interval count for the next packet.
3934:                                                  pCurrentEndpoint->wIntervalCount = pCurrentEndpoint->wInterval;
0117B8  900021     MOV [W1+4], W0
0117BA  9800B0     MOV W0, [W1+6]
0117BC  370039     BRA 0x11830
3935:              
3936:                                                  _USB_SetBDT( USB_TOKEN_IN );
3937:                                                  _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN );
3938:                                                  return;
3939:                                              }
3940:                                              break;
3941:              
3942:                                          case TSUBSTATE_INTERRUPT_READ_COMPLETE:
3943:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
3944:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
3945:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
3946:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3947:                                                  {
3948:                                                      USB_EVENT_DATA *data;
3949:              
3950:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3951:                                                      data->event = EVENT_TRANSFER;
3952:                                                      data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
3953:                                                      data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
3954:                                                      data->TransferData.bErrorCode       = USB_SUCCESS;
3955:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3956:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3957:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3958:                                                  }
3959:                                                  else
3960:                                                  {
3961:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3962:                                                  }
3963:                                              #endif
3964:                                              break;
3965:              
3966:                                          case TSUBSTATE_ERROR:
3967:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
3968:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
3969:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
3970:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3971:                                                  {
3972:                                                      USB_EVENT_DATA *data;
3973:              
3974:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3975:                                                      data->event = EVENT_BUS_ERROR;
3976:                                                      data->TransferData.dataCount        = 0;
3977:                                                      data->TransferData.pUserData        = NULL;
3978:                                                      data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
3979:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3980:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3981:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3982:                                                  }
3983:                                                  else
3984:                                                  {
3985:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3986:                                                  }
3987:                                              #endif
3988:                                              break;
3989:              
3990:                                          default:
3991:                                              illegalState = TRUE;
3992:                                              break;
3993:                                      }
3994:                                      break;
3995:              
3996:                                  case TSTATE_INTERRUPT_WRITE:
3997:                                      switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
0117BE  905801     MOV.B [W1+24], W0
0117C0  60006F     AND W0, #0xF, W0
0117C2  500FE1     SUB W0, #0x1, [W15]
0117C4  32000A     BRA Z, 0x117DA
0117C6  500FEF     SUB W0, #0xF, [W15]
0117C8  320008     BRA Z, 0x117DA
0117CA  E00000     CP0 W0
0117CC  3A000D     BRA NZ, 0x117E8
3998:                                      {
3999:                                          case TSUBSTATE_INTERRUPT_WRITE_DATA:
4000:                                              if (pCurrentEndpoint->wIntervalCount == 0)
0117CE  900031     MOV [W1+6], W0
0117D0  E00000     CP0 W0
0117D2  3A0007     BRA NZ, 0x117E2
4001:                                              {
4002:                                                  // Reset the interval count for the next packet.
4003:                                                  pCurrentEndpoint->wIntervalCount = pCurrentEndpoint->wInterval;
0117D4  900021     MOV [W1+4], W0
0117D6  9800B0     MOV W0, [W1+6]
0117D8  37003A     BRA 0x1184E
4004:              
4005:                                                  _USB_SetBDT( USB_TOKEN_OUT );
4006:                                                  _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT );
4007:                                                  return;
4008:                                              }
4009:                                              break;
4010:              
4011:                                          case TSUBSTATE_INTERRUPT_WRITE_COMPLETE:
4012:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
4013:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
4014:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
4015:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
4016:                                                  {
4017:                                                      USB_EVENT_DATA *data;
4018:              
4019:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
4020:                                                      data->event = EVENT_TRANSFER;
4021:                                                      data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
4022:                                                      data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
4023:                                                      data->TransferData.bErrorCode       = USB_SUCCESS;
4024:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
4025:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
4026:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
4027:                                                  }
4028:                                                  else
4029:                                                  {
4030:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
4031:                                                  }
4032:                                              #endif
4033:                                              break;
4034:              
4035:                                          case TSUBSTATE_ERROR:
4036:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
0117DA  985888     MOV.B W8, [W1+24]
4037:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
0117DC  904031     MOV.B [W1+3], W0
0117DE  A01400     BSET.B W0, #1
0117E0  9840B0     MOV.B W0, [W1+3]
4038:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
4039:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
4040:                                                  {
4041:                                                      USB_EVENT_DATA *data;
4042:              
4043:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
4044:                                                      data->event = EVENT_BUS_ERROR;
4045:                                                      data->TransferData.dataCount        = 0;
4046:                                                      data->TransferData.pUserData        = NULL;
4047:                                                      data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
4048:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
4049:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
4050:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
4051:                                                  }
4052:                                                  else
4053:                                                  {
4054:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
4055:                                                  }
4056:                                              #endif
4057:                                              break;
4058:              
4059:                                          default:
4060:                                              illegalState = TRUE;
4061:                                              break;
4062:                                      }
4063:                                      break;
4064:              
4065:                                  default:
4066:                                      illegalState = TRUE;
4067:                                      break;
4068:                              }
4069:              
4070:                              if (illegalState)
0117E2  E0000B     CP0 W11
0117E4  3A0002     BRA NZ, 0x117EA
0117E6  370006     BRA 0x117F4
0117E8  20001B     MOV #0x1, W11
4071:                              {
4072:                                  // We should never use this, but in case we do, put the endpoint
4073:                                  // in a recoverable state.
4074:                                  pCurrentEndpoint->status.bfTransferComplete   = 1;
0117EA  904031     MOV.B [W1+3], W0
0117EC  A01400     BSET.B W0, #1
0117EE  9840B0     MOV.B W0, [W1+3]
4075:                                  pCurrentEndpoint->transferState               = TSTATE_IDLE;
0117F0  EB4000     CLR.B W0
0117F2  985880     MOV.B W0, [W1+24]
4076:                              }
4077:                          }
4078:              
4079:                          // If we've gone through all the endpoints, we do not have any more interrupt transfers.
4080:                          usbBusInfo.flags.bfInterruptTransfersDone = 1;
0117F4  2706A0     MOV #0x706A, W0
0117F6  A01410     BSET.B [W0], #1
4081:                      }
4082:                  #endif
4083:              
4084:                  #ifdef USB_SUPPORT_BULK_TRANSFERS
4085:              #ifdef ALLOW_MULTIPLE_BULK_TRANSACTIONS_PER_FRAME
4086:              TryBulk:
4087:              #endif
4088:              
4089:                      if (!usbBusInfo.flags.bfBulkTransfersDone)
0117F8  2706A0     MOV #0x706A, W0
0117FA  784010     MOV.B [W0], W0
0117FC  604468     AND.B W0, #0x8, W8
0117FE  3A004D     BRA NZ, 0x1189A
4090:                      {
4091:                          #ifndef ALLOW_MULTIPLE_BULK_TRANSACTIONS_PER_FRAME
4092:                              // Only go through this section once if we are not allowing multiple transactions
4093:                              // per frame.
4094:                              usbBusInfo.flags.bfBulkTransfersDone = 1;
4095:                          #endif
4096:              
4097:                          // Look for any bulk operations.  Try to service all pending requests within the frame.
4098:                          if (_USB_FindServiceEndpoint( USB_TRANSFER_TYPE_BULK ))
011800  B3C020     MOV #0x2, W0
011802  023976     CALL _USB_FindServiceEndpoint
011804  000001     NOP
011806  E00000     CP0 W0
011808  320038     BRA Z, 0x1187A
4099:                          {
4100:                              switch (pCurrentEndpoint->transferState & TSTATE_MASK)
01180A  838381     MOV pCurrentEndpoint, W1
01180C  905801     MOV.B [W1+24], W0
01180E  780100     MOV W0, W2
011810  B20F02     AND #0xF0, W2
011812  200800     MOV #0x80, W0
011814  510F80     SUB W2, W0, [W15]
011816  320004     BRA Z, 0x11820
011818  400070     ADD W0, #0x10, W0
01181A  510F80     SUB W2, W0, [W15]
01181C  3A0028     BRA NZ, 0x1186E
01181E  37000F     BRA 0x1183E
4101:                              {
4102:                                  case TSTATE_BULK_READ:
4103:                                      switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
011820  905801     MOV.B [W1+24], W0
011822  60006F     AND W0, #0xF, W0
011824  500FE1     SUB W0, #0x1, [W15]
011826  32001C     BRA Z, 0x11860
011828  500FEF     SUB W0, #0xF, [W15]
01182A  32001A     BRA Z, 0x11860
01182C  E00000     CP0 W0
01182E  3A001F     BRA NZ, 0x1186E
4104:                                      {
4105:                                          case TSUBSTATE_BULK_READ_DATA:
4106:                                              _USB_SetBDT( USB_TOKEN_IN );
011830  B3C090     MOV #0x9, W0
011832  022CB4     CALL _USB_SetBDT
011834  000001     NOP
4107:                                              _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN );
011836  838380     MOV pCurrentEndpoint, W0
011838  905820     MOV.B [W0+26], W0
01183A  B3C091     MOV #0x9, W1
01183C  37000E     BRA 0x1185A
4108:                                              return;
4109:                                              break;
4110:              
4111:                                          case TSUBSTATE_BULK_READ_COMPLETE:
4112:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
4113:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
4114:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
4115:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
4116:                                                  {
4117:                                                      USB_EVENT_DATA *data;
4118:              
4119:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
4120:                                                      data->event = EVENT_TRANSFER;
4121:                                                      data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
4122:                                                      data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
4123:                                                      data->TransferData.bErrorCode       = USB_SUCCESS;
4124:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
4125:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
4126:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
4127:                                                  }
4128:                                                  else
4129:                                                  {
4130:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
4131:                                                  }
4132:                                              #endif
4133:                                              break;
4134:              
4135:                                          case TSUBSTATE_ERROR:
4136:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
4137:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
4138:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
4139:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
4140:                                                  {
4141:                                                      USB_EVENT_DATA *data;
4142:              
4143:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
4144:                                                      data->event = EVENT_BUS_ERROR;
4145:                                                      data->TransferData.dataCount        = 0;
4146:                                                      data->TransferData.pUserData        = NULL;
4147:                                                      data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
4148:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
4149:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
4150:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
4151:                                                  }
4152:                                                  else
4153:                                                  {
4154:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
4155:                                                  }
4156:                                              #endif
4157:                                              break;
4158:              
4159:                                          default:
4160:                                              illegalState = TRUE;
4161:                                              break;
4162:                                      }
4163:                                      break;
4164:              
4165:                                  case TSTATE_BULK_WRITE:
4166:                                      switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
01183E  905801     MOV.B [W1+24], W0
011840  60006F     AND W0, #0xF, W0
011842  500FE1     SUB W0, #0x1, [W15]
011844  32000D     BRA Z, 0x11860
011846  500FEF     SUB W0, #0xF, [W15]
011848  32000B     BRA Z, 0x11860
01184A  E00000     CP0 W0
01184C  3A0010     BRA NZ, 0x1186E
4167:                                      {
4168:                                          case TSUBSTATE_BULK_WRITE_DATA:
4169:                                              _USB_SetBDT( USB_TOKEN_OUT );
01184E  B3C010     MOV #0x1, W0
011850  022CB4     CALL _USB_SetBDT
011852  000001     NOP
4170:                                              _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT );
011854  838380     MOV pCurrentEndpoint, W0
011856  905820     MOV.B [W0+26], W0
011858  B3C011     MOV #0x1, W1
01185A  024EA0     CALL _USB_SendToken
01185C  000001     NOP
01185E  37001D     BRA 0x1189A
4171:                                              return;
4172:                                              break;
4173:              
4174:                                          case TSUBSTATE_BULK_WRITE_COMPLETE:
4175:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
4176:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
4177:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
4178:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
4179:                                                  {
4180:                                                      USB_EVENT_DATA *data;
4181:              
4182:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
4183:                                                      data->event = EVENT_TRANSFER;
4184:                                                      data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
4185:                                                      data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
4186:                                                      data->TransferData.bErrorCode       = USB_SUCCESS;
4187:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
4188:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
4189:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
4190:                                                  }
4191:                                                  else
4192:                                                  {
4193:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
4194:                                                  }
4195:                                              #endif
4196:                                              break;
4197:              
4198:                                          case TSUBSTATE_ERROR:
4199:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
011860  985888     MOV.B W8, [W1+24]
4200:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
011862  904031     MOV.B [W1+3], W0
011864  A01400     BSET.B W0, #1
011866  9840B0     MOV.B W0, [W1+3]
4201:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
4202:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
4203:                                                  {
4204:                                                      USB_EVENT_DATA *data;
4205:              
4206:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
4207:                                                      data->event = EVENT_BUS_ERROR;
4208:                                                      data->TransferData.dataCount        = 0;
4209:                                                      data->TransferData.pUserData        = NULL;
4210:                                                      data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
4211:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
4212:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
4213:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
4214:                                                  }
4215:                                                  else
4216:                                                  {
4217:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
4218:                                                  }
4219:                                              #endif
4220:                                              break;
4221:              
4222:                                          default:
4223:                                              illegalState = TRUE;
4224:                                              break;
4225:                                      }
4226:                                      break;
4227:              
4228:                                  default:
4229:                                      illegalState = TRUE;
4230:                                      break;
4231:                              }
4232:              
4233:                              if (illegalState)
011868  E0000B     CP0 W11
01186A  3A0002     BRA NZ, 0x11870
01186C  370006     BRA 0x1187A
01186E  20001B     MOV #0x1, W11
4234:                              {
4235:                                  // We should never use this, but in case we do, put the endpoint
4236:                                  // in a recoverable state.
4237:                                  pCurrentEndpoint->transferState               = TSTATE_IDLE;
011870  EB4000     CLR.B W0
011872  985880     MOV.B W0, [W1+24]
4238:                                  pCurrentEndpoint->status.bfTransferComplete   = 1;
011874  904031     MOV.B [W1+3], W0
011876  A01400     BSET.B W0, #1
011878  9840B0     MOV.B W0, [W1+3]
4239:                              }
4240:                          }
4241:              
4242:                          // We've gone through all the bulk transactions, but we have time for more.
4243:                          // If we have any bulk transactions, go back to the beginning of the list
4244:                          // and start over.
4245:                          #ifdef ALLOW_MULTIPLE_BULK_TRANSACTIONS_PER_FRAME
4246:                              if (usbBusInfo.countBulkTransactions)
01187A  2706D0     MOV #0x706D, W0
01187C  E00410     CP0.B [W0]
01187E  320003     BRA Z, 0x11886
4247:                              {
4248:                                  usbBusInfo.lastBulkTransaction = 0;
011880  2706C0     MOV #0x706C, W0
011882  EB4800     CLR.B [W0]
011884  37FFB9     BRA 0x117F8
4249:                                  goto TryBulk;
4250:              
4251:                              }
4252:                          #endif
4253:              
4254:                          // If we've gone through all the endpoints, we do not have any more bulk transfers.
4255:                          usbBusInfo.flags.bfBulkTransfersDone = 1;
011886  2706A0     MOV #0x706A, W0
011888  A03410     BSET.B [W0], #3
01188A  370007     BRA 0x1189A
4256:                      }
4257:                  #endif
4258:              
4259:                  return;
4260:              }
4261:              
4262:              
4263:              /****************************************************************************
4264:                Function:
4265:                  BOOL _USB_FindServiceEndpoint( BYTE transferType )
4266:              
4267:                Description:
4268:                  This function finds an endpoint of the specified transfer type that is
4269:                  ready for servicing.  If it finds one, usbDeviceInfo.pCurrentEndpoint is
4270:                  updated to point to the endpoint information structure.
4271:              
4272:                Precondition:
4273:                  None
4274:              
4275:                Parameters:
4276:                  BYTE transferType - Endpoint transfer type.  Valid values are:
4277:                                          * USB_TRANSFER_TYPE_CONTROL
4278:                                          * USB_TRANSFER_TYPE_ISOCHRONOUS
4279:                                          * USB_TRANSFER_TYPE_INTERRUPT
4280:                                          * USB_TRANSFER_TYPE_BULK
4281:              
4282:                Return Values:
4283:                  TRUE    - An endpoint of the indicated transfer type needs to be serviced,
4284:                              and pCurrentEndpoint has been updated to point to the endpoint.
4285:                  FALSE   - No endpoints of the indicated transfer type need to be serviced.
4286:              
4287:                Remarks:
4288:                  The EP 0 block is retained.
4289:                ***************************************************************************/
4290:              BOOL _USB_FindServiceEndpoint( BYTE transferType )
4291:              {
4292:                  USB_ENDPOINT_INFO           *pEndpoint;
4293:                  USB_INTERFACE_INFO          *pInterface;
4294:              
4295:                  // Check endpoint 0.
4296:                  if ((usbDeviceInfo.pEndpoint0->bmAttributes.bfTransferType == transferType) &&
013978  838331     MOV 0x7066, W1
01397A  FB8280     ZE W0, W5
01397C  900851     MOV [W1+26], W0
01397E  DE0048     LSR W0, #8, W0
013980  600063     AND W0, #0x3, W0
013982  500F85     SUB W0, W5, [W15]
013984  3A0003     BRA NZ, 0x1398C
013986  904031     MOV.B [W1+3], W0
013988  A31800     BTST.Z W0, #1
01398A  320035     BRA Z, 0x139F6
4297:                      !usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
4298:                  {
4299:                      pCurrentEndpoint = usbDeviceInfo.pEndpoint0;
4300:                      return TRUE;
4301:                  }
4302:              
4303:                  usbBusInfo.countBulkTransactions = 0;
01398C  2706D0     MOV #0x706D, W0
01398E  EB4800     CLR.B [W0]
4304:                  pEndpoint = NULL;
4305:                  pInterface = usbDeviceInfo.pInterfaceList;
013990  838323     MOV 0x7064, W3
013992  370027     BRA 0x139E2
4306:                  if (pInterface && pInterface->pCurrentSetting)
4307:                  {
4308:                      pEndpoint = pInterface->pCurrentSetting->pEndpointList;
4309:                  }
4310:              
4311:                  while (pInterface)
4312:                  {
4313:                      if (pEndpoint != NULL)
0139EE  E00001     CP0 W1
0139F0  3AFFD1     BRA NZ, 0x13994
0139F2  37FFF6     BRA 0x139E0
4314:                      {
4315:              			if (pEndpoint->bmAttributes.bfTransferType == transferType)
013994  900851     MOV [W1+26], W0
013996  DE0048     LSR W0, #8, W0
013998  600063     AND W0, #0x3, W0
01399A  500F85     SUB W0, W5, [W15]
01399C  3A001F     BRA NZ, 0x139DC
4316:              			{
4317:              				switch (transferType)
01399E  524FE2     SUB.B W4, #0x2, [W15]
0139A0  320011     BRA Z, 0x139C4
0139A2  524FE3     SUB.B W4, #0x3, [W15]
0139A4  320006     BRA Z, 0x139B2
0139A6  E00404     CP0.B W4
0139A8  3A0019     BRA NZ, 0x139DC
4318:              				{
4319:              					case USB_TRANSFER_TYPE_CONTROL:
4320:              						if (!pEndpoint->status.bfTransferComplete)
0139AA  904031     MOV.B [W1+3], W0
0139AC  A31800     BTST.Z W0, #1
0139AE  3A0016     BRA NZ, 0x139DC
0139B0  370022     BRA 0x139F6
4321:              						{
4322:              							pCurrentEndpoint = pEndpoint;
4323:              							return TRUE;
4324:              						}
4325:              						break;
4326:              
4327:              					#ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
4328:              					case USB_TRANSFER_TYPE_ISOCHRONOUS:
4329:              					#endif
4330:              					#ifdef USB_SUPPORT_INTERRUPT_TRANSFERS
4331:              					case USB_TRANSFER_TYPE_INTERRUPT:
4332:              					#endif
4333:              					#if defined( USB_SUPPORT_ISOCHRONOUS_TRANSFERS ) || defined( USB_SUPPORT_INTERRUPT_TRANSFERS )
4334:              						if (pEndpoint->status.bfTransferComplete)
0139B2  904031     MOV.B [W1+3], W0
0139B4  A31800     BTST.Z W0, #1
0139B6  32001F     BRA Z, 0x139F6
4335:              						{
4336:              							// The endpoint doesn't need servicing.  If the interval count
4337:              							// has reached 0 and the user has not initiated another transaction,
4338:              							// reset the interval count for the next interval.
4339:              							if (pEndpoint->wIntervalCount == 0)
0139B8  900031     MOV [W1+6], W0
0139BA  E00000     CP0 W0
0139BC  3A000F     BRA NZ, 0x139DC
4340:              							{
4341:              								// Reset the interval count for the next packet.
4342:              								pEndpoint->wIntervalCount = pEndpoint->wInterval;
0139BE  900021     MOV [W1+4], W0
0139C0  9800B0     MOV W0, [W1+6]
0139C2  37000C     BRA 0x139DC
4343:              							}
4344:              						}
4345:              						else
4346:              						{
4347:              							pCurrentEndpoint = pEndpoint;
4348:              							return TRUE;
4349:              						}
4350:              						break;
4351:              					#endif
4352:              
4353:              					#ifdef USB_SUPPORT_BULK_TRANSFERS
4354:              					case USB_TRANSFER_TYPE_BULK:
4355:              						#ifdef ALLOW_MULTIPLE_NAKS_PER_FRAME
4356:              						if (!pEndpoint->status.bfTransferComplete)
4357:              						#else
4358:              						if (!pEndpoint->status.bfTransferComplete &&
0139C4  904031     MOV.B [W1+3], W0
0139C6  A31800     BTST.Z W0, #1
0139C8  3A0009     BRA NZ, 0x139DC
0139CA  904031     MOV.B [W1+3], W0
0139CC  A34800     BTST.Z W0, #4
0139CE  3A0006     BRA NZ, 0x139DC
4359:              							!pEndpoint->status.bfLastTransferNAKd)
4360:              						#endif
4361:              						{
4362:              							usbBusInfo.countBulkTransactions ++;
0139D0  2706D0     MOV #0x706D, W0
0139D2  E84810     INC.B [W0], [W0]
4363:              							if (usbBusInfo.countBulkTransactions > usbBusInfo.lastBulkTransaction)
0139D4  2706C2     MOV #0x706C, W2
0139D6  784310     MOV.B [W0], W6
0139D8  534F92     SUB.B W6, [W2], [W15]
0139DA  3E000C     BRA GTU, 0x139F4
4364:              							{
4365:              								usbBusInfo.lastBulkTransaction  = usbBusInfo.countBulkTransactions;
0139F4  784910     MOV.B [W0], [W2]
4366:              								pCurrentEndpoint                = pEndpoint;
0139F6  8B8381     MOV W1, pCurrentEndpoint
0139F8  050010     RETLW #0x1, W0
4367:              								return TRUE;
4368:              							}
4369:              						}
4370:              						break;
4371:              					#endif
4372:              				}
4373:              			}
4374:              
4375:              	        // Go to the next endpoint.
4376:                          pEndpoint = pEndpoint->next;
0139DC  780091     MOV [W1], W1
0139DE  370007     BRA 0x139EE
4377:                      }
4378:              
4379:                      if (pEndpoint == NULL)
4380:                      {
4381:                          // Go to the next interface.
4382:                          pInterface = pInterface->next;
0139E0  780193     MOV [W3], W3
4383:                          if (pInterface && pInterface->pCurrentSetting)
0139E2  E00003     CP0 W3
0139E4  32000A     BRA Z, 0x139FA
0139E6  900023     MOV [W3+4], W0
0139E8  E00000     CP0 W0
0139EA  32FFFA     BRA Z, 0x139E0
4384:                          {
4385:                              pEndpoint = pInterface->pCurrentSetting->pEndpointList;
0139EC  9000A0     MOV [W0+4], W1
4386:                          }
4387:                      }
4388:                  }
4389:              
4390:                  // No endpoints with the desired description are ready for servicing.
4391:                  return FALSE;
4392:              }
4393:              
4394:              
4395:              /****************************************************************************
4396:                Function:
4397:                  void _USB_FreeConfigMemory( void )
4398:              
4399:                Description:
4400:                  This function frees the interface and endpoint lists associated
4401:                              with a configuration.
4402:              
4403:                Precondition:
4404:                  None
4405:              
4406:                Parameters:
4407:                  None - None
4408:              
4409:                Returns:
4410:                  None
4411:              
4412:                Remarks:
4413:                  The EP 0 block is retained.
4414:                ***************************************************************************/
4415:              
4416:              void _USB_FreeConfigMemory( void )
4417:              {
4418:                  USB_INTERFACE_INFO          *pTempInterface;
4419:                  USB_INTERFACE_SETTING_INFO  *pTempSetting;
4420:                  USB_ENDPOINT_INFO           *pTempEndpoint;
4421:              
4422:                  while (usbDeviceInfo.pInterfaceList != NULL)
01499C  838320     MOV 0x7064, W0
01499E  E00000     CP0 W0
0149A0  3AFFE2     BRA NZ, 0x14966
4423:                  {
4424:                      pTempInterface = usbDeviceInfo.pInterfaceList->next;
014966  780510     MOV [W0], W10
014968  370012     BRA 0x1498E
4425:              
4426:                      while (usbDeviceInfo.pInterfaceList->pInterfaceSettings != NULL)
01498E  838320     MOV 0x7064, W0
014990  900090     MOV [W0+2], W1
014992  E00001     CP0 W1
014994  3AFFEA     BRA NZ, 0x1496A
4427:                      {
4428:                          pTempSetting = usbDeviceInfo.pInterfaceList->pInterfaceSettings->next;
01496A  780491     MOV [W1], W9
01496C  370006     BRA 0x1497A
4429:              
4430:                          while (usbDeviceInfo.pInterfaceList->pInterfaceSettings->pEndpointList != NULL)
01497A  838320     MOV 0x7064, W0
01497C  900090     MOV [W0+2], W1
01497E  900021     MOV [W1+4], W0
014980  E00000     CP0 W0
014982  3AFFF5     BRA NZ, 0x1496E
4431:                          {
4432:                              pTempEndpoint = usbDeviceInfo.pInterfaceList->pInterfaceSettings->pEndpointList->next;
01496E  780410     MOV [W0], W8
4433:                              USB_FREE_AND_CLEAR( usbDeviceInfo.pInterfaceList->pInterfaceSettings->pEndpointList );
014970  0258CA     CALL free
014972  000000     NOP
014974  838320     MOV 0x7064, W0
014976  900010     MOV [W0+2], W0
4434:                              usbDeviceInfo.pInterfaceList->pInterfaceSettings->pEndpointList = pTempEndpoint;
014978  980028     MOV W8, [W0+4]
4435:                          }
4436:                          USB_FREE_AND_CLEAR( usbDeviceInfo.pInterfaceList->pInterfaceSettings );
014984  780001     MOV W1, W0
014986  0258CA     CALL free
014988  000000     NOP
4437:                          usbDeviceInfo.pInterfaceList->pInterfaceSettings = pTempSetting;
01498A  838320     MOV 0x7064, W0
01498C  980019     MOV W9, [W0+2]
4438:                      }
4439:                      USB_FREE_AND_CLEAR( usbDeviceInfo.pInterfaceList );
014996  0258CA     CALL free
014998  000000     NOP
4440:                      usbDeviceInfo.pInterfaceList = pTempInterface;
01499A  8B832A     MOV W10, 0x7064
4441:                  }
4442:              
4443:                  pCurrentEndpoint = usbDeviceInfo.pEndpoint0;
0149A2  838330     MOV 0x7066, W0
0149A4  8B8380     MOV W0, pCurrentEndpoint
4444:              
4445:              } // _USB_FreeConfigMemory
4446:              
4447:              
4448:              /****************************************************************************
4449:                Function:
4450:                  void _USB_FreeMemory( void )
4451:              
4452:                Description:
4453:                  This function frees all memory that can be freed.  Only the EP0
4454:                  information block is retained.
4455:              
4456:                Precondition:
4457:                  None
4458:              
4459:                Parameters:
4460:                  None - None
4461:              
4462:                Returns:
4463:                  None
4464:              
4465:                Remarks:
4466:                  None
4467:                ***************************************************************************/
4468:              
4469:              void _USB_FreeMemory( void )
4470:              {
4471:                  BYTE    *pTemp;
4472:              
4473:                  while (usbDeviceInfo.pConfigurationDescriptorList != NULL)
014FAA  838319     MOV 0x7062, W9
014FAC  E00009     CP0 W9
014FAE  3AFFF4     BRA NZ, 0x14F98
4474:                  {
4475:                      pTemp = (BYTE *)usbDeviceInfo.pConfigurationDescriptorList->next;
014F98  900419     MOV [W9+2], W8
4476:                      USB_FREE_AND_CLEAR( usbDeviceInfo.pConfigurationDescriptorList->descriptor );
014F9A  780019     MOV [W9], W0
014F9C  0258CA     CALL free
014F9E  000000     NOP
014FA0  838310     MOV 0x7062, W0
014FA2  EB0800     CLR [W0]
4477:                      USB_FREE_AND_CLEAR( usbDeviceInfo.pConfigurationDescriptorList );
014FA4  0258CA     CALL free
014FA6  000000     NOP
4478:                      usbDeviceInfo.pConfigurationDescriptorList = (USB_CONFIGURATION *)pTemp;
014FA8  8B8318     MOV W8, 0x7062
4479:                  }
4480:                  if (pDeviceDescriptor != NULL)
014FB0  838890     MOV pDeviceDescriptor, W0
014FB2  E00000     CP0 W0
014FB4  320003     BRA Z, 0x14FBC
4481:                  {
4482:                      USB_FREE_AND_CLEAR( pDeviceDescriptor );
014FB6  0258CA     CALL free
014FB8  000000     NOP
014FBA  8B8899     MOV W9, pDeviceDescriptor
4483:                  }
4484:                  if (pEP0Data != NULL)
014FBC  838260     MOV pEP0Data, W0
014FBE  E00000     CP0 W0
014FC0  320003     BRA Z, 0x14FC8
4485:                  {
4486:                      USB_FREE_AND_CLEAR( pEP0Data );
014FC2  0258CA     CALL free
014FC4  000000     NOP
014FC6  8B8269     MOV W9, pEP0Data
4487:                  }
4488:              
4489:                  _USB_FreeConfigMemory();
014FC8  024960     CALL _USB_FreeConfigMemory
014FCA  000001     NOP
4490:              
4491:              }
4492:              
4493:              
4494:              /****************************************************************************
4495:                Function:
4496:                  void _USB_InitControlRead( USB_ENDPOINT_INFO *pEndpoint,
4497:                                      BYTE *pControlData, WORD controlSize, BYTE *pData,
4498:                                      WORD size )
4499:              
4500:                Description:
4501:                  This function sets up the endpoint information for a control (SETUP)
4502:                  transfer that will read information.
4503:              
4504:                Precondition:
4505:                  All error checking must be done prior to calling this function.
4506:              
4507:                Parameters:
4508:                  USB_ENDPOINT_INFO *pEndpoint    - Points to the desired endpoint
4509:                                                      in the endpoint information list.
4510:                  BYTE *pControlData              - Points to the SETUP message.
4511:                  WORD controlSize                - Size of the SETUP message.
4512:                  BYTE *pData                     - Points to where the read data
4513:                                                      is to be stored.
4514:                  WORD size                       - Number of data bytes to read.
4515:              
4516:                Returns:
4517:                  None
4518:              
4519:                Remarks:
4520:                  Since endpoint servicing is interrupt driven, the bfTransferComplete
4521:                  flag must be set last.
4522:                ***************************************************************************/
4523:              
4524:              void _USB_InitControlRead( USB_ENDPOINT_INFO *pEndpoint, BYTE *pControlData, WORD controlSize,
4525:                                          BYTE *pData, WORD size )
4526:              {
4527:                  pEndpoint->status.bfStalled             = 0;
014C00  9042A0     MOV.B [W0+2], W5
014C02  A15405     BCLR.B W5, #5
014C04  984025     MOV.B W5, [W0+2]
4528:                  pEndpoint->status.bfError               = 0;
014C06  9042A0     MOV.B [W0+2], W5
014C08  A16405     BCLR.B W5, #6
014C0A  984025     MOV.B W5, [W0+2]
4529:                  pEndpoint->status.bfUserAbort           = 0;
014C0C  9042A0     MOV.B [W0+2], W5
014C0E  A17405     BCLR.B W5, #7
014C10  984025     MOV.B W5, [W0+2]
4530:                  pEndpoint->status.bfTransferSuccessful  = 0;
014C12  9042B0     MOV.B [W0+3], W5
014C14  A10405     BCLR.B W5, #0
014C16  984035     MOV.B W5, [W0+3]
4531:                  pEndpoint->status.bfErrorCount          = 0;
014C18  9042A0     MOV.B [W0+2], W5
014C1A  B3CE06     MOV #0xE0, W6
014C1C  62C286     AND.B W5, W6, W5
014C1E  984025     MOV.B W5, [W0+2]
4532:                  pEndpoint->status.bfLastTransferNAKd    = 0;
014C20  9042B0     MOV.B [W0+3], W5
014C22  A14405     BCLR.B W5, #4
014C24  984035     MOV.B W5, [W0+3]
4533:                  pEndpoint->pUserData                    = pData;
014C26  980833     MOV W3, [W0+22]
4534:                  pEndpoint->dataCount                    = 0;
014C28  B83360     MUL.UU W6, #0, W6
014C2A  980806     MOV W6, [W0+16]
014C2C  980817     MOV W7, [W0+18]
4535:                  pEndpoint->dataCountMax                 = size;
014C2E  200005     MOV #0x0, W5
014C30  980054     MOV W4, [W0+10]
014C32  980065     MOV W5, [W0+12]
4536:                  pEndpoint->countNAKs                    = 0;
014C34  EB0180     CLR W3
014C36  980873     MOV W3, [W0+30]
4537:              
4538:                  pEndpoint->pUserDataSETUP               = pControlData;
014C38  980821     MOV W1, [W0+20]
4539:                  pEndpoint->dataCountMaxSETUP            = controlSize;
014C3A  980072     MOV W2, [W0+14]
4540:                  pEndpoint->transferState                = TSTATE_CONTROL_READ;
014C3C  B3C201     MOV #0x20, W1
014C3E  985801     MOV.B W1, [W0+24]
4541:              
4542:                  // Set the flag last so all the parameters are set for an interrupt.
4543:                  pEndpoint->status.bfTransferComplete    = 0;
014C40  9040B0     MOV.B [W0+3], W1
014C42  A11401     BCLR.B W1, #1
014C44  984031     MOV.B W1, [W0+3]
4544:              }
4545:              
4546:              
4547:              /****************************************************************************
4548:                Function:
4549:                  void _USB_InitControlWrite( USB_ENDPOINT_INFO *pEndpoint,
4550:                                      BYTE *pControlData, WORD controlSize, BYTE *pData,
4551:                                      WORD size )
4552:              
4553:                Description:
4554:                  This function sets up the endpoint information for a control (SETUP)
4555:                  transfer that will write information.
4556:              
4557:                Precondition:
4558:                  All error checking must be done prior to calling this function.
4559:              
4560:                Parameters:
4561:                  USB_ENDPOINT_INFO *pEndpoint    - Points to the desired endpoint
4562:                                                                    in the endpoint information list.
4563:                  BYTE *pControlData              - Points to the SETUP message.
4564:                  WORD controlSize                - Size of the SETUP message.
4565:                  BYTE *pData                     - Points to where the write data
4566:                                                                    is to be stored.
4567:                  WORD size                       - Number of data bytes to write.
4568:              
4569:                Returns:
4570:                  None
4571:              
4572:                Remarks:
4573:                  Since endpoint servicing is interrupt driven, the bfTransferComplete
4574:                  flag must be set last.
4575:                ***************************************************************************/
4576:              
4577:              void _USB_InitControlWrite( USB_ENDPOINT_INFO *pEndpoint, BYTE *pControlData,
4578:                              WORD controlSize, BYTE *pData, WORD size )
4579:              {
4580:                  pEndpoint->status.bfStalled             = 0;
014778  904020     MOV.B [W0+2], W0
01477A  A15400     BCLR.B W0, #5
01477C  984420     MOV.B W0, [W8+2]
4581:                  pEndpoint->status.bfError               = 0;
01477E  904028     MOV.B [W8+2], W0
014780  A16400     BCLR.B W0, #6
014782  984420     MOV.B W0, [W8+2]
4582:                  pEndpoint->status.bfUserAbort           = 0;
014784  904028     MOV.B [W8+2], W0
014786  A17400     BCLR.B W0, #7
014788  984420     MOV.B W0, [W8+2]
4583:                  pEndpoint->status.bfTransferSuccessful  = 0;
01478A  904038     MOV.B [W8+3], W0
01478C  A10400     BCLR.B W0, #0
01478E  984430     MOV.B W0, [W8+3]
4584:                  pEndpoint->status.bfErrorCount          = 0;
014790  904028     MOV.B [W8+2], W0
014792  B3CE05     MOV #0xE0, W5
014794  604005     AND.B W0, W5, W0
014796  984420     MOV.B W0, [W8+2]
4585:                  pEndpoint->status.bfLastTransferNAKd    = 0;
014798  904038     MOV.B [W8+3], W0
01479A  A14400     BCLR.B W0, #4
01479C  984430     MOV.B W0, [W8+3]
4586:                  pEndpoint->pUserData                    = pData;
01479E  980C33     MOV W3, [W8+22]
4587:                  pEndpoint->dataCount                    = 0;
0147A0  B83360     MUL.UU W6, #0, W6
0147A2  980C06     MOV W6, [W8+16]
0147A4  980C17     MOV W7, [W8+18]
4588:                  pEndpoint->dataCountMax                 = size;
0147A6  B82361     MUL.UU W4, #1, W6
0147A8  980456     MOV W6, [W8+10]
0147AA  980467     MOV W7, [W8+12]
4589:                  pEndpoint->countNAKs                    = 0;
0147AC  EB0000     CLR W0
0147AE  980C70     MOV W0, [W8+30]
4590:              
4591:                  pEndpoint->pUserDataSETUP               = pControlData;
0147B0  980C21     MOV W1, [W8+20]
4592:                  pEndpoint->dataCountMaxSETUP            = controlSize;
0147B2  980472     MOV W2, [W8+14]
4593:              
4594:                  if (size == 0)
0147B6  E00004     CP0 W4
0147B8  320001     BRA Z, 0x147BC
4595:                  {
4596:                      pEndpoint->transferState    = TSTATE_CONTROL_NO_DATA;
0147B4  B3C100     MOV #0x10, W0
4597:                  }
4598:                  else
4599:                  {
4600:                      pEndpoint->transferState    = TSTATE_CONTROL_WRITE;
0147BA  B3C300     MOV #0x30, W0
0147BC  985C00     MOV.B W0, [W8+24]
4601:                  }
4602:              
4603:                  // Set the flag last so all the parameters are set for an interrupt.
4604:                  pEndpoint->status.bfTransferComplete    = 0;
0147BE  904038     MOV.B [W8+3], W0
0147C0  A11400     BCLR.B W0, #1
0147C2  984430     MOV.B W0, [W8+3]
4605:              }
4606:              
4607:              
4608:              /****************************************************************************
4609:                Function:
4610:                  void _USB_InitRead( USB_ENDPOINT_INFO *pEndpoint, BYTE *pData,
4611:                                      WORD size )
4612:              
4613:                Description:
4614:                  This function sets up the endpoint information for an interrupt,
4615:                  isochronous, or bulk read.  If the transfer is isochronous, the pData
4616:                  and size parameters have different meaning.
4617:              
4618:                Precondition:
4619:                  All error checking must be done prior to calling this function.
4620:              
4621:                Parameters:
4622:                  USB_ENDPOINT_INFO *pEndpoint  - Points to the desired endpoint in the
4623:                                                  endpoint information list.
4624:                  BYTE *pData                   - Points to where the data is to be
4625:                                                  stored.  If the endpoint is isochronous,
4626:                                                  this points to an ISOCHRONOUS_DATA_BUFFERS
4627:                                                  structure.
4628:                  WORD size                     - Number of data bytes to read. If the
4629:                                                  endpoint is isochronous, this is the number
4630:                                                  of data buffer pointers pointed to by
4631:                                                  pData.
4632:              
4633:                Returns:
4634:                  None
4635:              
4636:                Remarks:
4637:                  * Control reads should use the routine _USB_InitControlRead().  Since
4638:                      endpoint servicing is interrupt driven, the bfTransferComplete flag
4639:                      must be set last.
4640:              
4641:                  * For interrupt and isochronous endpoints, we let the interval count
4642:                      free run.  The transaction will begin when the interval count
4643:                      reaches 0.
4644:                ***************************************************************************/
4645:              
4646:              void _USB_InitRead( USB_ENDPOINT_INFO *pEndpoint, BYTE *pData, WORD size )
4647:              {
4648:                  pEndpoint->status.bfUserAbort           = 0;
0145C0  904020     MOV.B [W0+2], W0
0145C2  A17400     BCLR.B W0, #7
0145C4  9841A0     MOV.B W0, [W3+2]
4649:                  pEndpoint->status.bfTransferSuccessful  = 0;
0145C6  904033     MOV.B [W3+3], W0
0145C8  A10400     BCLR.B W0, #0
0145CA  9841B0     MOV.B W0, [W3+3]
4650:                  pEndpoint->status.bfErrorCount          = 0;
0145CC  904023     MOV.B [W3+2], W0
0145CE  B3CE01     MOV #0xE0, W1
0145D0  604001     AND.B W0, W1, W0
0145D2  9841A0     MOV.B W0, [W3+2]
4651:                  pEndpoint->status.bfLastTransferNAKd    = 0;
0145D4  904033     MOV.B [W3+3], W0
0145D6  A14400     BCLR.B W0, #4
0145D8  9841B0     MOV.B W0, [W3+3]
4652:                  pEndpoint->pUserData                    = pData;
0145DA  9809B4     MOV W4, [W3+22]
4653:                  pEndpoint->dataCount                    = 0;
0145DC  B80060     MUL.UU W0, #0, W0
0145DE  980980     MOV W0, [W3+16]
0145E0  980991     MOV W1, [W3+18]
4654:                  pEndpoint->dataCountMax                 = size; // Not used for isochronous.
0145E2  B81061     MUL.UU W2, #1, W0
0145E4  9801D0     MOV W0, [W3+10]
0145E6  9801E1     MOV W1, [W3+12]
4655:                  pEndpoint->countNAKs                    = 0;
0145E8  EB0100     CLR W2
0145EA  9809F2     MOV W2, [W3+30]
4656:              
4657:                  if (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_INTERRUPT)
0145EC  9008D3     MOV [W3+26], W1
0145EE  B23001     AND #0x300, W1
0145F0  203000     MOV #0x300, W0
0145F2  508F80     SUB W1, W0, [W15]
0145F4  3A0002     BRA NZ, 0x145FA
4658:                  {
4659:                      pEndpoint->transferState            = TSTATE_INTERRUPT_READ;
0145F6  B3C400     MOV #0x40, W0
0145F8  370008     BRA 0x1460A
4660:                  }
4661:                  else if (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
0145FA  201000     MOV #0x100, W0
0145FC  508F80     SUB W1, W0, [W15]
0145FE  3A0004     BRA NZ, 0x14608
4662:                  {
4663:                      pEndpoint->transferState                                        = TSTATE_ISOCHRONOUS_READ;
014600  B3C600     MOV #0x60, W0
014602  985980     MOV.B W0, [W3+24]
4664:                      ((ISOCHRONOUS_DATA *)pEndpoint->pUserData)->currentBufferUSB    = 0;
014604  984212     MOV.B W2, [W4+1]
014606  370002     BRA 0x1460C
4665:                  }
4666:                  else // Bulk
4667:                  {
4668:                      pEndpoint->transferState            = TSTATE_BULK_READ;
014608  B3C800     MOV #0x80, W0
01460A  985980     MOV.B W0, [W3+24]
4669:                  }
4670:              
4671:                  // Set the flag last so all the parameters are set for an interrupt.
4672:                  pEndpoint->status.bfTransferComplete    = 0;
01460C  904033     MOV.B [W3+3], W0
01460E  A11400     BCLR.B W0, #1
014610  9841B0     MOV.B W0, [W3+3]
4673:              }
4674:              
4675:              /****************************************************************************
4676:                Function:
4677:                  void _USB_InitWrite( USB_ENDPOINT_INFO *pEndpoint, BYTE *pData,
4678:                                          WORD size )
4679:              
4680:                Description:
4681:                  This function sets up the endpoint information for an interrupt,
4682:                  isochronous, or bulk  write.  If the transfer is isochronous, the pData
4683:                  and size parameters have different meaning.
4684:              
4685:                Precondition:
4686:                  All error checking must be done prior to calling this function.
4687:              
4688:                Parameters:
4689:                  USB_ENDPOINT_INFO *pEndpoint  - Points to the desired endpoint in the
4690:                                                  endpoint information list.
4691:                  BYTE *pData                   - Points to where the data to send is
4692:                                                  stored.  If the endpoint is isochronous,
4693:                                                  this points to an ISOCHRONOUS_DATA_BUFFERS
4694:                                                  structure.
4695:                  WORD size                     - Number of data bytes to write.  If the
4696:                                                  endpoint is isochronous, this is the number
4697:                                                  of data buffer pointers pointed to by
4698:                                                  pData.
4699:              
4700:                Returns:
4701:                  None
4702:              
4703:                Remarks:
4704:                  * Control writes should use the routine _USB_InitControlWrite().  Since
4705:                      endpoint servicing is interrupt driven, the bfTransferComplete flag
4706:                      must be set last.
4707:              
4708:                  * For interrupt and isochronous endpoints, we let the interval count
4709:                      free run.  The transaction will begin when the interval count
4710:                      reaches 0.
4711:                ***************************************************************************/
4712:              
4713:              void _USB_InitWrite( USB_ENDPOINT_INFO *pEndpoint, BYTE *pData, WORD size )
4714:              {
4715:                  pEndpoint->status.bfUserAbort           = 0;
014618  904020     MOV.B [W0+2], W0
01461A  A17400     BCLR.B W0, #7
01461C  9841A0     MOV.B W0, [W3+2]
4716:                  pEndpoint->status.bfTransferSuccessful  = 0;
01461E  904033     MOV.B [W3+3], W0
014620  A10400     BCLR.B W0, #0
014622  9841B0     MOV.B W0, [W3+3]
4717:                  pEndpoint->status.bfErrorCount          = 0;
014624  904023     MOV.B [W3+2], W0
014626  B3CE01     MOV #0xE0, W1
014628  604001     AND.B W0, W1, W0
01462A  9841A0     MOV.B W0, [W3+2]
4718:                  pEndpoint->status.bfLastTransferNAKd    = 0;
01462C  904033     MOV.B [W3+3], W0
01462E  A14400     BCLR.B W0, #4
014630  9841B0     MOV.B W0, [W3+3]
4719:                  pEndpoint->pUserData                    = pData;
014632  9809B4     MOV W4, [W3+22]
4720:                  pEndpoint->dataCount                    = 0;
014634  B80060     MUL.UU W0, #0, W0
014636  980980     MOV W0, [W3+16]
014638  980991     MOV W1, [W3+18]
4721:                  pEndpoint->dataCountMax                 = size; // Not used for isochronous.
01463A  B81061     MUL.UU W2, #1, W0
01463C  9801D0     MOV W0, [W3+10]
01463E  9801E1     MOV W1, [W3+12]
4722:                  pEndpoint->countNAKs                    = 0;
014640  EB0100     CLR W2
014642  9809F2     MOV W2, [W3+30]
4723:              
4724:                  if (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_INTERRUPT)
014644  9008D3     MOV [W3+26], W1
014646  B23001     AND #0x300, W1
014648  203000     MOV #0x300, W0
01464A  508F80     SUB W1, W0, [W15]
01464C  3A0002     BRA NZ, 0x14652
4725:                  {
4726:                      pEndpoint->transferState            = TSTATE_INTERRUPT_WRITE;
01464E  B3C500     MOV #0x50, W0
014650  370008     BRA 0x14662
4727:                  }
4728:                  else if (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
014652  201000     MOV #0x100, W0
014654  508F80     SUB W1, W0, [W15]
014656  3A0004     BRA NZ, 0x14660
4729:                  {
4730:                      pEndpoint->transferState                                        = TSTATE_ISOCHRONOUS_WRITE;
014658  B3C700     MOV #0x70, W0
01465A  985980     MOV.B W0, [W3+24]
4731:                      ((ISOCHRONOUS_DATA *)pEndpoint->pUserData)->currentBufferUSB    = 0;
01465C  984212     MOV.B W2, [W4+1]
01465E  370002     BRA 0x14664
4732:                  }
4733:                  else // Bulk
4734:                  {
4735:                      pEndpoint->transferState            = TSTATE_BULK_WRITE;
014660  B3C900     MOV #0x90, W0
014662  985980     MOV.B W0, [W3+24]
4736:                  }
4737:              
4738:                  // Set the flag last so all the parameters are set for an interrupt.
4739:                  pEndpoint->status.bfTransferComplete    = 0;
014664  904033     MOV.B [W3+3], W0
014666  A11400     BCLR.B W0, #1
014668  9841B0     MOV.B W0, [W3+3]
4740:              }
4741:              
4742:              
4743:              /****************************************************************************
4744:                Function:
4745:                  void _USB_NotifyClients( BYTE address, USB_EVENT event, void *data,
4746:                              unsigned int size )
4747:              
4748:                Description:
4749:                  This routine notifies all active client drivers for the given device of
4750:                  the given event.
4751:              
4752:                Precondition:
4753:                  None
4754:              
4755:                Parameters:
4756:                  BYTE address        - Address of the device generating the event
4757:                  USB_EVENT event     - Event ID
4758:                  void *data          - Pointer to event data
4759:                  unsigned int size   - Size of data pointed to by data
4760:              
4761:                Returns:
4762:                  None
4763:              
4764:                Remarks:
4765:                  When this driver is modified to support multiple devices, this function
4766:                  will require modification.
4767:                ***************************************************************************/
4768:              
4769:              void _USB_NotifyClients( BYTE address, USB_EVENT event, void *data, unsigned int size )
4770:              {
4771:                  USB_INTERFACE_INFO  *pInterface;
4772:              
4773:                  // Some events go to all drivers, some only to specific drivers.
4774:                  switch(event)
0142F4  200720     MOV #0x72, W0
0142F6  508F80     SUB W1, W0, [W15]
0142F8  320003     BRA Z, 0x14300
0142FA  27FFF0     MOV #0x7FFF, W0
0142FC  508F80     SUB W1, W0, [W15]
0142FE  3A000E     BRA NZ, 0x1431C
4775:                  {
4776:                      case EVENT_TRANSFER:
4777:                      case EVENT_BUS_ERROR:
4778:                          if (((HOST_TRANSFER_DATA *)data)->clientDriver != CLIENT_DRIVER_HOST)
014300  90481A     MOV.B [W10+9], W0
014302  404FE1     ADD.B W0, #0x1, [W15]
014304  32001B     BRA Z, 0x1433C
4779:                          {
4780:                              usbClientDrvTable[((HOST_TRANSFER_DATA *)data)->clientDriver].EventHandler(address, event, data, size);
014306  FB8000     ZE W0, W0
014308  DD0043     SL W0, #3, W0
01430A  E88000     INC2 W0, W0
01430C  21F821     MOV #0x1F82, W1
01430E  7801E1     MOV [W1+W0], W3
014310  B85A61     MUL.UU W11, #1, W4
014312  78010A     MOV W10, W2
014314  780089     MOV W9, W1
014316  78400C     MOV.B W12, W0
014318  010003     CALL W3
01431A  370010     BRA 0x1433C
4781:                          }
4782:                          break;
4783:                      default:
4784:                          pInterface = usbDeviceInfo.pInterfaceList;
01431C  838328     MOV 0x7064, W8
01431E  37000C     BRA 0x14338
4785:                          while (pInterface != NULL)  // Scan the interface list for all active drivers.
014338  E00008     CP0 W8
01433A  3AFFF2     BRA NZ, 0x14320
4786:                          {
4787:                              usbClientDrvTable[pInterface->clientDriver].EventHandler(address, event, data, size);
014320  904078     MOV.B [W8+7], W0
014322  FB8000     ZE W0, W0
014324  DD0043     SL W0, #3, W0
014326  E88000     INC2 W0, W0
014328  21F821     MOV #0x1F82, W1
01432A  7801E1     MOV [W1+W0], W3
01432C  B85A61     MUL.UU W11, #1, W4
01432E  78010A     MOV W10, W2
014330  780089     MOV W9, W1
014332  78400C     MOV.B W12, W0
014334  010003     CALL W3
4788:                              pInterface = pInterface->next;
014336  780418     MOV [W8], W8
4789:                          }
4790:                          break;
4791:                  }
4792:              } // _USB_NotifyClients
4793:              
4794:              /****************************************************************************
4795:                Function:
4796:                  void _USB_NotifyClients( BYTE address, USB_EVENT event, void *data,
4797:                              unsigned int size )
4798:              
4799:                Description:
4800:                  This routine notifies all active client drivers for the given device of
4801:                  the given event.
4802:              
4803:                Precondition:
4804:                  None
4805:              
4806:                Parameters:
4807:                  BYTE address        - Address of the device generating the event
4808:                  USB_EVENT event     - Event ID
4809:                  void *data          - Pointer to event data
4810:                  unsigned int size   - Size of data pointed to by data
4811:              
4812:                Returns:
4813:                  None
4814:              
4815:                Remarks:
4816:                  When this driver is modified to support multiple devices, this function
4817:                  will require modification.
4818:                ***************************************************************************/
4819:              #ifdef USB_HOST_APP_DATA_EVENT_HANDLER
4820:              void _USB_NotifyDataClients( BYTE address, USB_EVENT event, void *data, unsigned int size )
4821:              {
4822:                  USB_INTERFACE_INFO  *pInterface;
4823:              
4824:                  // Some events go to all drivers, some only to specific drivers.
4825:                  switch(event)
4826:                  {
4827:                      default:
4828:                          pInterface = usbDeviceInfo.pInterfaceList;
4829:                          while (pInterface != NULL)  // Scan the interface list for all active drivers.
4830:                          {
4831:                              usbClientDrvTable[pInterface->clientDriver].DataEventHandler(address, event, data, size);
4832:                              pInterface = pInterface->next;
4833:                          }
4834:                          break;
4835:                  }
4836:              } // _USB_NotifyClients
4837:              #endif
4838:              
4839:              /****************************************************************************
4840:                Function:
4841:                  void _USB_NotifyAllDataClients( BYTE address, USB_EVENT event, void *data,
4842:                              unsigned int size )
4843:              
4844:                Description:
4845:                  This routine notifies all client drivers (active or not) for the given device of
4846:                  the given event.
4847:              
4848:                Precondition:
4849:                  None
4850:              
4851:                Parameters:
4852:                  BYTE address        - Address of the device generating the event
4853:                  USB_EVENT event     - Event ID
4854:                  void *data          - Pointer to event data
4855:                  unsigned int size   - Size of data pointed to by data
4856:              
4857:                Returns:
4858:                  None
4859:              
4860:                Remarks:
4861:                  When this driver is modified to support multiple devices, this function
4862:                  will require modification.
4863:                ***************************************************************************/
4864:              #if defined(USB_ENABLE_1MS_EVENT) && defined(USB_HOST_APP_DATA_EVENT_HANDLER)
4865:              void _USB_NotifyAllDataClients( BYTE address, USB_EVENT event, void *data, unsigned int size )
4866:              {
4867:                  WORD i;
4868:              
4869:                  // Some events go to all drivers, some only to specific drivers.
4870:                  switch(event)
4871:                  {
4872:                      default:
4873:                          for(i=0;i<NUM_CLIENT_DRIVER_ENTRIES;i++)
4874:                          {
4875:                              usbClientDrvTable[i].DataEventHandler(address, event, data, size);
4876:                          }
4877:                          break;
4878:                  }
4879:              } // _USB_NotifyClients
4880:              #endif
4881:              
4882:              /****************************************************************************
4883:                Function:
4884:                  BOOL _USB_ParseConfigurationDescriptor( void )
4885:              
4886:                Description:
4887:                  This function parses all the endpoint descriptors for the required
4888:                  setting of the required interface and sets up the internal endpoint
4889:                  information.
4890:              
4891:                Precondition:
4892:                  pCurrentConfigurationDescriptor points to a valid Configuration
4893:                  Descriptor, which contains the endpoint descriptors.  The current
4894:                  interface and the current interface settings must be set up in
4895:                  usbDeviceInfo.
4896:              
4897:                Parameters:
4898:                  None - None
4899:              
4900:                Returns:
4901:                  TRUE    - Successful
4902:                  FALSE   - Configuration not supported.
4903:              
4904:                Remarks:
4905:                  * This function also automatically resets all endpoints (except
4906:                      endpoint 0) to DATA0, so _USB_ResetDATA0 does not have to be
4907:                      called.
4908:              
4909:                  * If the configuration is not supported, the caller will need to clean
4910:                      up, freeing memory by calling _USB_FreeConfigMemory.
4911:              
4912:                  * We do not currently implement checks for descriptors that are shorter
4913:                      than the expected length, in the case of invalid USB Peripherals.
4914:              
4915:                  * If there is not enough available heap space for storing the
4916:                      interface or endpoint information, this function will return FALSE.
4917:                      Currently, there is no other mechanism for informing the user of
4918:                      an out of dynamic memory condition.
4919:              
4920:                  * We are assuming that we can support a single interface on a single
4921:                      device.  When the driver is modified to support multiple devices,
4922:                      each endpoint should be checked to ensure that we have enough
4923:                      bandwidth to support it.
4924:                ***************************************************************************/
4925:              
4926:              BOOL _USB_ParseConfigurationDescriptor( void )
4927:              {
4928:                  BYTE                        bAlternateSetting;
4929:                  BYTE                        bDescriptorType;
4930:                  BYTE                        bInterfaceNumber;
4931:                  BYTE                        bLength;
4932:                  BYTE                        bNumEndpoints;
4933:                  BYTE                        bNumInterfaces;
4934:                  BYTE                        bMaxPower;
4935:                  BOOL                        error;
4936:                  BYTE                        Class;
4937:                  BYTE                        SubClass;
4938:                  BYTE                        Protocol;
4939:                  BYTE                        ClientDriver;
4940:                  WORD                        wTotalLength;
4941:              
4942:                  BYTE                        currentAlternateSetting;
4943:                  BYTE                        currentConfiguration;
4944:                  BYTE                        currentEndpoint;
4945:                  BYTE                        currentInterface;
4946:                  WORD                        index;
4947:                  USB_ENDPOINT_INFO           *newEndpointInfo;
4948:                  USB_INTERFACE_INFO          *newInterfaceInfo;
4949:                  USB_INTERFACE_SETTING_INFO  *newSettingInfo;
4950:                  USB_VBUS_POWER_EVENT_DATA   powerRequest;
4951:                  USB_INTERFACE_INFO          *pTempInterfaceList;
4952:                  BYTE                        *ptr;
4953:              
4954:                  // Prime the loops.
4955:                  currentEndpoint         = 0;
4956:                  error                   = FALSE;
4957:                  index                   = 0;
4958:                  ptr                     = pCurrentConfigurationDescriptor;
010B26  8388A2     MOV pCurrentConfigurationDescriptor, W2
4959:                  currentInterface        = 0;
4960:                  currentAlternateSetting = 0;
4961:                  pTempInterfaceList      = usbDeviceInfo.pInterfaceList; // Don't set until everything is in place.
010B28  83832C     MOV 0x7064, W12
4962:              
4963:                  // Assume no OTG support (determine otherwise, below).
4964:                  usbDeviceInfo.flags.bfSupportsOTG   = 0;
010B2A  270680     MOV #0x7068, W0
010B2C  A11410     BCLR.B [W0], #1
4965:                  usbDeviceInfo.flags.bfConfiguredOTG = 1;
010B2E  A02410     BSET.B [W0], #2
4966:              
4967:                  #ifdef USB_SUPPORT_OTG
4968:                      usbDeviceInfo.flags.bfAllowHNP = 1;  //Allow HNP From Host
4969:                  #endif
4970:              
4971:                  // Load up the values from the Configuration Descriptor
4972:                  bLength              = *ptr++;
010B30  784412     MOV.B [W2], W8
4973:                  bDescriptorType      = *ptr++;
4974:                  wTotalLength         = *ptr++;           // In case these are not word aligned
010B32  9040A2     MOV.B [W2+2], W1
010B34  FB8081     ZE W1, W1
4975:                  wTotalLength        += (*ptr++) << 8;
010B36  904032     MOV.B [W2+3], W0
010B38  DD0048     SL W0, #8, W0
010B3A  408080     ADD W1, W0, W1
010B3C  9FB7C1     MOV W1, [W15-24]
4976:                  bNumInterfaces       = *ptr++;
4977:                  currentConfiguration = *ptr++;  // bConfigurationValue
010B3E  904052     MOV.B [W2+5], W0
010B40  9FEFB0     MOV.B W0, [W15-21]
4978:                                          ptr++;  // iConfiguration
4979:                                          ptr++;  // bmAttributes
4980:                  bMaxPower            = *ptr;
010B42  904902     MOV.B [W2+8], W2
010B44  9FEFE2     MOV.B W2, [W15-18]
4981:              
4982:                  // Check Max Power to see if we can support this configuration.
4983:                  powerRequest.current = bMaxPower;
010B46  57817B     SUB W15, #0x1B, W2
010B48  97E8EF     MOV.B [W15-18], W1
010B4A  984111     MOV.B W1, [W2+1]
4984:                  powerRequest.port    = 0;        // Port 0
010B4C  EB4900     CLR.B [W2]
4985:                  if (!USB_HOST_APP_EVENT_HANDLER( USB_ROOT_HUB, EVENT_VBUS_REQUEST_POWER,
010B4E  200024     MOV #0x2, W4
010B50  200005     MOV #0x0, W5
010B52  200691     MOV #0x69, W1
010B54  EBC000     SETM.B W0
010B56  02623A     CALL USB_ApplicationEventHandler
010B58  000001     NOP
010B5A  EB0100     CLR W2
010B5C  E00000     CP0 W0
010B5E  3A0004     BRA NZ, 0x10B68
4986:                          &powerRequest, sizeof(USB_VBUS_POWER_EVENT_DATA) ))
4987:                  {
4988:                      usbDeviceInfo.errorCode = USB_ERROR_INSUFFICIENT_POWER;
010B60  B3C281     MOV #0x28, W1
010B62  2705C0     MOV #0x705C, W0
010B64  784801     MOV.B W1, [W0]
010B66  200012     MOV #0x1, W2
4989:                      error = TRUE;
4990:                  }
4991:              
4992:                  // Skip over the rest of the Configuration Descriptor
4993:                  index += bLength;
010B68  FB8088     ZE W8, W1
4994:                  ptr    = &pCurrentConfigurationDescriptor[index];
010B6A  8388A0     MOV pCurrentConfigurationDescriptor, W0
010B6C  408480     ADD W1, W0, W9
010B6E  780501     MOV W1, W10
010B70  EB4000     CLR.B W0
010B72  9FEFA0     MOV.B W0, [W15-22]
010B74  3700BA     BRA 0x10CEA
4995:              
4996:                  while (!error && (index < wTotalLength))
010CEA  E00002     CP0 W2
010CEC  320006     BRA Z, 0x10CFA
010CEE  37000A     BRA 0x10D04
010CF8  EB0100     CLR W2
010CFA  97B04F     MOV [W15-24], W0
010CFC  550F80     SUB W10, W0, [W15]
010CFE  39FF3B     BRA NC, 0x10B76
010D00  370001     BRA 0x10D04
010D02  200012     MOV #0x1, W2
4997:                  {
4998:                      // Check the descriptor length and type
4999:                      bLength         = *ptr++;
010B76  784699     MOV.B [W9], W13
5000:                      bDescriptorType = *ptr++;
010B78  904019     MOV.B [W9+1], W0
010B7A  E88089     INC2 W9, W1
5001:              
5002:              
5003:                      // Find the OTG discriptor (if present)
5004:                      if (bDescriptorType == USB_DESCRIPTOR_OTG)
010B7C  504FE9     SUB.B W0, #0x9, [W15]
010B7E  3A000F     BRA NZ, 0x10B9E
5005:                      {
5006:                          // We found an OTG Descriptor, so the device supports OTG.
5007:                          usbDeviceInfo.flags.bfSupportsOTG = 1;
010B80  270682     MOV #0x7068, W2
010B82  A01412     BSET.B [W2], #1
5008:                          usbDeviceInfo.attributesOTG       = *ptr;
010B84  784091     MOV.B [W1], W1
010B86  270590     MOV #0x7059, W0
010B88  784801     MOV.B W1, [W0]
5009:              
5010:                          // See if we need to send the SET FEATURE command.  If we do,
5011:                          // clear the bConfiguredOTG flag.
5012:                          if ( (usbDeviceInfo.attributesOTG & OTG_HNP_SUPPORT) && (usbDeviceInfo.flags.bfAllowHNP))
010B8A  A31801     BTST.Z W1, #1
010B8C  320005     BRA Z, 0x10B98
010B8E  784092     MOV.B [W2], W1
010B90  60C068     AND.B W1, #0x8, W0
010B92  320002     BRA Z, 0x10B98
5013:                          {
5014:                              usbDeviceInfo.flags.bfConfiguredOTG = 0;
010B94  A12412     BCLR.B [W2], #2
010B96  3700AC     BRA 0x10CF0
5015:                          }
5016:                          else
5017:                          {
5018:                              usbDeviceInfo.flags.bfAllowHNP = 0;
010B98  270680     MOV #0x7068, W0
010B9A  A13410     BCLR.B [W0], #3
010B9C  3700A9     BRA 0x10CF0
5019:                          }
5020:                      }
5021:              
5022:                      // Find an interface descriptor
5023:                      if (bDescriptorType != USB_DESCRIPTOR_INTERFACE)
010B9E  504FE4     SUB.B W0, #0x4, [W15]
010BA0  3A00A7     BRA NZ, 0x10CF0
5024:                      {
5025:                          // Skip over the rest of the Descriptor
5026:                          index += bLength;
5027:                          ptr = &pCurrentConfigurationDescriptor[index];
5028:                      }
5029:                      else
5030:                      {
5031:                          // Read some data from the interface descriptor
5032:                          bInterfaceNumber  = *ptr++;
010BA2  784591     MOV.B [W1], W11
5033:                          bAlternateSetting = *ptr++;
010BA4  904039     MOV.B [W9+3], W0
010BA6  9FF780     MOV.B W0, [W15-16]
5034:                          bNumEndpoints     = *ptr++;
010BA8  9040C9     MOV.B [W9+4], W1
010BAA  9FEFF1     MOV.B W1, [W15-17]
5035:                          Class             = *ptr++;
010BAC  904059     MOV.B [W9+5], W0
010BAE  9FEFD0     MOV.B W0, [W15-19]
5036:                          SubClass          = *ptr++;
010BB0  9040E9     MOV.B [W9+6], W1
010BB2  9FEFC1     MOV.B W1, [W15-20]
5037:                          Protocol          = *ptr++;
010BB4  904779     MOV.B [W9+7], W14
010BB6  4484E8     ADD W9, #0x8, W9
5038:              
5039:                          // Get client driver index
5040:                          if (usbDeviceInfo.flags.bfUseDeviceClientDriver)
010BB8  270680     MOV #0x7068, W0
010BBA  B3C401     MOV #0x40, W1
010BBC  60C010     AND.B W1, [W0], W0
010BBE  320004     BRA Z, 0x10BC8
5041:                          {
5042:                              ClientDriver = usbDeviceInfo.deviceClientDriver;
010BC0  2705D0     MOV #0x705D, W0
010BC2  784010     MOV.B [W0], W0
010BC4  9FE7C0     MOV.B W0, [W15-28]
010BC6  370008     BRA 0x10BD8
5043:                          }
5044:                          else
5045:                          {
5046:                              if (!_USB_FindClassDriver(Class, SubClass, Protocol, &ClientDriver))
010BC8  5781FC     SUB W15, #0x1C, W3
010BCA  78410E     MOV.B W14, W2
010BCC  97E8CF     MOV.B [W15-20], W1
010BCE  97E85F     MOV.B [W15-19], W0
010BD0  02385E     CALL _USB_FindClassDriver
010BD2  000001     NOP
010BD4  E00000     CP0 W0
010BD6  32008C     BRA Z, 0x10CF0
5047:                              {
5048:                                  // If we cannot support this interface, skip it.
5049:                                  index += bLength;
010CF0  FB800D     ZE W13, W0
010CF2  450500     ADD W10, W0, W10
5050:                                  ptr = &pCurrentConfigurationDescriptor[index];
010CF4  8388A0     MOV pCurrentConfigurationDescriptor, W0
010CF6  450480     ADD W10, W0, W9
5051:                                  continue;
010BD8  78040C     MOV W12, W8
010BDA  370001     BRA 0x10BDE
5052:                              }
5053:                          }
5054:              
5055:                          // We can support this interface.  See if we already have a USB_INTERFACE_INFO node for it.
5056:                          newInterfaceInfo = pTempInterfaceList;
5057:                          while ((newInterfaceInfo != NULL) && (newInterfaceInfo->interface != bInterfaceNumber))
010BDE  E00008     CP0 W8
010BE0  320004     BRA Z, 0x10BEA
010BE2  904068     MOV.B [W8+6], W0
010BE4  504F8B     SUB.B W0, W11, [W15]
010BE6  3AFFFA     BRA NZ, 0x10BDC
010BE8  37001B     BRA 0x10C20
5058:                          {
5059:                              newInterfaceInfo = newInterfaceInfo->next;
010BDC  780418     MOV [W8], W8
5060:                          }
5061:                          if (newInterfaceInfo == NULL)
5062:                          {
5063:                              // This is the first instance of this interface, so create a new node for it.
5064:                              if ((newInterfaceInfo = (USB_INTERFACE_INFO *)USB_MALLOC( sizeof(USB_INTERFACE_INFO) )) == NULL)
010BEA  2000C0     MOV #0xC, W0
010BEC  0257A6     CALL malloc
010BEE  000000     NOP
010BF0  780400     MOV W0, W8
010BF2  EA0080     NEG W0, W1
010BF4  708080     IOR W1, W0, W1
010BF6  DE08CF     LSR W1, #15, W1
010BF8  B3C010     MOV #0x1, W0
010BFA  504081     SUB.B W0, W1, W1
010BFC  FB8101     ZE W1, W2
5065:                              {
5066:                                  // Out of memory
5067:                                  error = TRUE;   
5068:                              }
5069:              
5070:                              // Initialize the interface node
5071:                              newInterfaceInfo->interface             = bInterfaceNumber;
010BFE  98446B     MOV.B W11, [W8+6]
5072:                              newInterfaceInfo->clientDriver          = ClientDriver;
010C00  97E04F     MOV.B [W15-28], W0
010C02  984470     MOV.B W0, [W8+7]
5073:                              newInterfaceInfo->pInterfaceSettings    = NULL;
010C04  EB0000     CLR W0
010C06  980410     MOV W0, [W8+2]
5074:                              newInterfaceInfo->pCurrentSetting       = NULL;
010C08  980420     MOV W0, [W8+4]
5075:                              newInterfaceInfo->type.cls              = Class;
010C0A  97E85F     MOV.B [W15-19], W0
010C0C  984C00     MOV.B W0, [W8+8]
5076:                              newInterfaceInfo->type.subcls           = SubClass;
010C0E  97E84F     MOV.B [W15-20], W0
010C10  984C10     MOV.B W0, [W8+9]
5077:                              newInterfaceInfo->type.proto            = Protocol;
010C12  984C2E     MOV.B W14, [W8+10]
5078:              
5079:                              // Insert it into the list.
5080:                              newInterfaceInfo->next                  = pTempInterfaceList;
010C14  780C0C     MOV W12, [W8]
5081:                              pTempInterfaceList                      = newInterfaceInfo;
5082:                          }
5083:              
5084:                          if (!error)
010C16  E00401     CP0.B W1
010C18  320002     BRA Z, 0x10C1E
010C1A  780608     MOV W8, W12
010C1C  370062     BRA 0x10CE2
010C1E  780608     MOV W8, W12
5085:                          {
5086:                              // Create a new setting for this interface, and add it to the list.
5087:                              if ((newSettingInfo = (USB_INTERFACE_SETTING_INFO *)USB_MALLOC( sizeof(USB_INTERFACE_SETTING_INFO) )) == NULL)
010C20  200060     MOV #0x6, W0
010C22  0257A6     CALL malloc
010C24  000000     NOP
010C26  780580     MOV W0, W11
010C28  200012     MOV #0x1, W2
010C2A  E00000     CP0 W0
010C2C  32005A     BRA Z, 0x10CE2
010C2E  370092     BRA 0x10D54
5088:                              {
5089:                                  // Out of memory
5090:                                  error = TRUE;   
5091:                              }
5092:                          }    
5093:                           
5094:                          if (!error)   
5095:                          {
5096:                              newSettingInfo->next                    = newInterfaceInfo->pInterfaceSettings;
010D54  900018     MOV [W8+2], W0
010D56  780D80     MOV W0, [W11]
5097:                              newSettingInfo->interfaceAltSetting     = bAlternateSetting;
010D58  97F08F     MOV.B [W15-16], W1
010D5A  9845A1     MOV.B W1, [W11+2]
5098:                              newSettingInfo->pEndpointList           = NULL;
010D5C  EB0000     CLR W0
010D5E  9805A0     MOV W0, [W11+4]
5099:                              newInterfaceInfo->pInterfaceSettings    = newSettingInfo;
010D60  98041B     MOV W11, [W8+2]
5100:                              if (bAlternateSetting == 0)
010D62  E00401     CP0.B W1
010D64  32FF65     BRA Z, 0x10C30
010D66  37FF65     BRA 0x10C32
5101:                              {
5102:                                  newInterfaceInfo->pCurrentSetting   = newSettingInfo;
010C30  98042B     MOV W11, [W8+4]
5103:                              }
5104:              
5105:                              // Skip over the rest of the Interface Descriptor
5106:                              index += bLength;
010C32  FB800D     ZE W13, W0
010C34  450500     ADD W10, W0, W10
5107:                              ptr = &pCurrentConfigurationDescriptor[index];
010C36  8388A0     MOV pCurrentConfigurationDescriptor, W0
010C38  450480     ADD W10, W0, W9
010C3A  EB4080     CLR.B W1
010C3C  9FEFA1     MOV.B W1, [W15-22]
010C3E  370049     BRA 0x10CD2
5108:              
5109:                              // Find the Endpoint Descriptors.  There might be Class and Vendor descriptors in here
5110:                              currentEndpoint = 0;
5111:                              while (!error && (index < wTotalLength) && (currentEndpoint < bNumEndpoints))
010CD2  97B0CF     MOV [W15-24], W1
010CD4  550F81     SUB W10, W1, [W15]
010CD6  310004     BRA C, 0x10CE0
010CD8  97E82F     MOV.B [W15-22], W0
010CDA  97E8FF     MOV.B [W15-17], W1
010CDC  504F81     SUB.B W0, W1, [W15]
010CDE  39FFB0     BRA NC, 0x10C40
010CE0  EB0100     CLR W2
5112:                              {
5113:                                  bLength = *ptr++;
010C40  784699     MOV.B [W9], W13
5114:                                  bDescriptorType = *ptr++;
010C42  E88409     INC2 W9, W8
5115:              
5116:                                  if (bDescriptorType != USB_DESCRIPTOR_ENDPOINT)
010C44  904019     MOV.B [W9+1], W0
010C46  504FE5     SUB.B W0, #0x5, [W15]
010C48  3A0040     BRA NZ, 0x10CCA
5117:                                  {
5118:                                      // Skip over the rest of the Descriptor
5119:                                      index += bLength;
5120:                                      ptr = &pCurrentConfigurationDescriptor[index];
5121:                                  }
5122:                                  else
5123:                                  {
5124:                                      // Create an entry for the new endpoint.
5125:                                      if ((newEndpointInfo = (USB_ENDPOINT_INFO *)USB_MALLOC( sizeof(USB_ENDPOINT_INFO) )) == NULL)
010C4A  200220     MOV #0x22, W0
010C4C  0257A6     CALL malloc
010C4E  000000     NOP
010C50  780180     MOV W0, W3
010C52  E00000     CP0 W0
010C54  320056     BRA Z, 0x10D02
5126:                                      {
5127:                                          // Out of memory
5128:                                          error = TRUE;
5129:                                          break;
5130:                                      }
5131:                                      newEndpointInfo->bEndpointAddress           = *ptr++;
010C56  784418     MOV.B [W8], W8
010C58  985828     MOV.B W8, [W0+26]
5132:                                      newEndpointInfo->bmAttributes.val           = *ptr++;
010C5A  904039     MOV.B [W9+3], W0
010C5C  9859B0     MOV.B W0, [W3+27]
5133:                                      newEndpointInfo->wMaxPacketSize             = *ptr++;
010C5E  9040C9     MOV.B [W9+4], W1
010C60  FB8081     ZE W1, W1
010C62  9801C1     MOV W1, [W3+8]
5134:                                      newEndpointInfo->wMaxPacketSize            += (*ptr++) << 8;
010C64  904059     MOV.B [W9+5], W0
010C66  DD0048     SL W0, #8, W0
010C68  408080     ADD W1, W0, W1
010C6A  9801C1     MOV W1, [W3+8]
5135:                                      newEndpointInfo->wInterval                  = *ptr++;
010C6C  904069     MOV.B [W9+6], W0
010C6E  FB8200     ZE W0, W4
010C70  9801A4     MOV W4, [W3+4]
5136:                                      newEndpointInfo->status.val                 = 0x00;
010C72  EB0100     CLR W2
010C74  980192     MOV W2, [W3+2]
5137:                                      newEndpointInfo->status.bfUseDTS            = 1;
010C76  904033     MOV.B [W3+3], W0
010C78  A02400     BSET.B W0, #2
010C7A  9841B0     MOV.B W0, [W3+3]
5138:                                      newEndpointInfo->status.bfTransferComplete  = 1;  // Initialize to success to allow preprocessing loops.
010C7C  904033     MOV.B [W3+3], W0
010C7E  A01400     BSET.B W0, #1
010C80  9841B0     MOV.B W0, [W3+3]
5139:                                      newEndpointInfo->dataCount                  = 0;  // Initialize to 0 since we set bfTransferComplete.
010C82  B80060     MUL.UU W0, #0, W0
010C84  980980     MOV W0, [W3+16]
010C86  980991     MOV W1, [W3+18]
5140:                                      newEndpointInfo->transferState              = TSTATE_IDLE;
010C88  985982     MOV.B W2, [W3+24]
5141:                                      newEndpointInfo->clientDriver               = ClientDriver;
010C8A  97E0CF     MOV.B [W15-28], W1
010C8C  985991     MOV.B W1, [W3+25]
5142:              
5143:                                      // Special setup for isochronous endpoints.
5144:                                      if (newEndpointInfo->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
010C8E  900853     MOV [W3+26], W0
010C90  B23000     AND #0x300, W0
010C92  201001     MOV #0x100, W1
010C94  500F81     SUB W0, W1, [W15]
010C96  3A0011     BRA NZ, 0x10CBA
5145:                                      {
5146:                                          // Validate and convert the interval to the number of frames.  The value must
5147:                                          // be between 1 and 16, and the frames is 2^(bInterval-1).
5148:                                          if (newEndpointInfo->wInterval == 0) newEndpointInfo->wInterval = 1;
010C98  E00004     CP0 W4
010C9A  3A0002     BRA NZ, 0x10CA0
010C9C  200010     MOV #0x1, W0
010C9E  9801A0     MOV W0, [W3+4]
5149:                                          if (newEndpointInfo->wInterval > 16) newEndpointInfo->wInterval = 16;
010CA0  900023     MOV [W3+4], W0
010CA2  500FF0     SUB W0, #0x10, [W15]
010CA4  360002     BRA LEU, 0x10CAA
010CA6  200100     MOV #0x10, W0
010CA8  9801A0     MOV W0, [W3+4]
5150:                                          newEndpointInfo->wInterval = 1 << (newEndpointInfo->wInterval-1);
010CAA  900023     MOV [W3+4], W0
010CAC  E90000     DEC W0, W0
010CAE  200011     MOV #0x1, W1
010CB0  DD0880     SL W1, W0, W1
010CB2  9801A1     MOV W1, [W3+4]
5151:              
5152:                                          // Disable DTS
5153:                                          newEndpointInfo->status.bfUseDTS = 0;
010CB4  904033     MOV.B [W3+3], W0
010CB6  A12400     BCLR.B W0, #2
010CB8  9841B0     MOV.B W0, [W3+3]
5154:                                      }
5155:              
5156:                                      // Initialize interval count
5157:                                      newEndpointInfo->wIntervalCount = newEndpointInfo->wInterval;
010CBA  900023     MOV [W3+4], W0
010CBC  9801B0     MOV W0, [W3+6]
5158:              
5159:                                      // Put the new endpoint in the list.
5160:                                      newEndpointInfo->next           = newSettingInfo->pEndpointList;
010CBE  9000AB     MOV [W11+4], W1
010CC0  780981     MOV W1, [W3]
5161:                                      newSettingInfo->pEndpointList   = newEndpointInfo;
010CC2  9805A3     MOV W3, [W11+4]
5162:              
5163:                                      // When multiple devices are supported, check the available
5164:                                      // bandwidth here to make sure that we can support this
5165:                                      // endpoint.
5166:              
5167:                                      // Get ready for the next endpoint.
5168:                                      currentEndpoint++;
010CC4  97E82F     MOV.B [W15-22], W0
010CC6  E84000     INC.B W0, W0
010CC8  9FEFA0     MOV.B W0, [W15-22]
5169:                                      index += bLength;
010CCA  FB800D     ZE W13, W0
010CCC  450500     ADD W10, W0, W10
5170:                                      ptr = &pCurrentConfigurationDescriptor[index];
010CCE  8388A0     MOV pCurrentConfigurationDescriptor, W0
010CD0  450480     ADD W10, W0, W9
5171:                                  }
5172:                              }
5173:                          }    
5174:              
5175:                          // Ensure that we found all the endpoints for this interface.
5176:                          if (currentEndpoint != bNumEndpoints)
010CE2  97E82F     MOV.B [W15-22], W0
010CE4  97E8FF     MOV.B [W15-17], W1
010CE6  504F81     SUB.B W0, W1, [W15]
010CE8  3A000C     BRA NZ, 0x10D02
5177:                          {
5178:                              error = TRUE;
5179:                          }
5180:                      }
5181:                  }
5182:              
5183:                  // Ensure that we found all the interfaces in this configuration.
5184:                  // This is a nice check, but some devices have errors where they have a
5185:                  // different number of interfaces than they report they have!
5186:              //    if (currentInterface != bNumInterfaces)
5187:              //    {
5188:              //        error = TRUE;
5189:              //    }
5190:              
5191:                  if (pTempInterfaceList == NULL)
010D04  E0000C     CP0 W12
010D06  320024     BRA Z, 0x10D50
5192:                  {
5193:                      // We could find no supported interfaces.
5194:                      #ifdef DEBUG_MODE
5195:                          UART2PrintString( "HOST: No supported interfaces.\r\n" );
5196:                      #endif
5197:              
5198:                      error = TRUE;
5199:                  }
5200:              
5201:                  if (error)
010D08  E00002     CP0 W2
010D0A  320019     BRA Z, 0x10D3E
5202:                  {
5203:                      // Destroy whatever list of interfaces, settings, and endpoints we created.
5204:                      // The "new" variables point to the current node we are trying to remove.
5205:                      while (pTempInterfaceList != NULL)
010D36  E00009     CP0 W9
010D38  32000B     BRA Z, 0x10D50
010D3A  780609     MOV W9, W12
010D3C  37FFE7     BRA 0x10D0C
5206:                      {
5207:                          newInterfaceInfo = pTempInterfaceList;
5208:                          pTempInterfaceList = pTempInterfaceList->next;
010D0C  78049C     MOV [W12], W9
010D0E  37000D     BRA 0x10D2A
5209:                          
5210:                          while (newInterfaceInfo->pInterfaceSettings != NULL)
010D2A  90041C     MOV [W12+2], W8
010D2C  E00008     CP0 W8
010D2E  3AFFF0     BRA NZ, 0x10D10
5211:                          {
5212:                              newSettingInfo = newInterfaceInfo->pInterfaceSettings;
5213:                              newInterfaceInfo->pInterfaceSettings = newInterfaceInfo->pInterfaceSettings->next;
010D10  780098     MOV [W8], W1
010D12  980611     MOV W1, [W12+2]
010D14  370004     BRA 0x10D1E
5214:                              
5215:                              while (newSettingInfo->pEndpointList != NULL)
010D1E  900028     MOV [W8+4], W0
010D20  E00000     CP0 W0
010D22  3AFFF9     BRA NZ, 0x10D16
5216:                              {
5217:                                  newEndpointInfo = newSettingInfo->pEndpointList;
5218:                                  newSettingInfo->pEndpointList = newSettingInfo->pEndpointList->next;
010D16  780090     MOV [W0], W1
010D18  980421     MOV W1, [W8+4]
5219:                                  
5220:                                  USB_FREE_AND_CLEAR( newEndpointInfo );
010D1A  0258CA     CALL free
010D1C  000000     NOP
5221:                              }    
5222:                  
5223:                              USB_FREE_AND_CLEAR( newSettingInfo );
010D24  780008     MOV W8, W0
010D26  0258CA     CALL free
010D28  000000     NOP
5224:                          }
5225:                  
5226:                          USB_FREE_AND_CLEAR( newInterfaceInfo );
010D30  78000C     MOV W12, W0
010D32  0258CA     CALL free
010D34  000000     NOP
5227:                      }    
5228:                      return FALSE;
5229:                  }
5230:                  else
5231:                  {    
5232:                      // Set configuration.
5233:                      usbDeviceInfo.currentConfiguration      = currentConfiguration;
010D3E  270580     MOV #0x7058, W0
010D40  97E8BF     MOV.B [W15-21], W1
010D42  784801     MOV.B W1, [W0]
5234:                      usbDeviceInfo.currentConfigurationPower = bMaxPower;
010D44  97E8EF     MOV.B [W15-18], W1
010D46  FB8001     ZE W1, W0
010D48  8B82F0     MOV W0, 0x705E
5235:                  
5236:                      // Success!
5237:                      #ifdef DEBUG_MODE
5238:                          UART2PrintString( "HOST: Parse Descriptor success\r\n" );
5239:                      #endif
5240:                      usbDeviceInfo.pInterfaceList = pTempInterfaceList;
010D4A  8B832C     MOV W12, 0x7064
010D4C  200010     MOV #0x1, W0
010D4E  37000C     BRA 0x10D68
5241:                      return TRUE;
010D50  EB0000     CLR W0
010D52  37000A     BRA 0x10D68
5242:                  }    
5243:              }
5244:              
5245:              
5246:              /****************************************************************************
5247:                Function:
5248:                  void _USB_ResetDATA0( BYTE endpoint )
5249:              
5250:                Description:
5251:                  This function resets DATA0 for the specified endpoint.  If the
5252:                  specified endpoint is 0, it resets DATA0 for all endpoints.
5253:              
5254:                Precondition:
5255:                  None
5256:              
5257:                Parameters:
5258:                  BYTE endpoint   - Endpoint number to reset.
5259:              
5260:              
5261:                Returns:
5262:                  None
5263:              
5264:                Remarks:
5265:                  None
5266:                ***************************************************************************/
5267:              
5268:              void _USB_ResetDATA0( BYTE endpoint )
5269:              {
5270:                  USB_ENDPOINT_INFO   *pEndpoint;
5271:              
5272:                  if (endpoint == 0)
014F1C  E00400     CP0.B W0
014F1E  3A0013     BRA NZ, 0x14F46
5273:                  {
5274:                      // Reset DATA0 for all endpoints.
5275:                      USB_INTERFACE_INFO          *pInterface;
5276:                      USB_INTERFACE_SETTING_INFO  *pSetting;
5277:              
5278:                      pInterface = usbDeviceInfo.pInterfaceList;
014F20  838323     MOV 0x7064, W3
014F22  37000E     BRA 0x14F40
5279:                      while (pInterface)
014F40  E00003     CP0 W3
014F42  3AFFF0     BRA NZ, 0x14F24
014F44  060000     RETURN
5280:                      {
5281:                          pSetting = pInterface->pInterfaceSettings;
014F24  900113     MOV [W3+2], W2
014F26  370009     BRA 0x14F3A
5282:                          while (pSetting)
014F3A  E00002     CP0 W2
014F3C  3AFFF5     BRA NZ, 0x14F28
5283:                          {
5284:                              pEndpoint = pSetting->pEndpointList;
014F28  9000A2     MOV [W2+4], W1
014F2A  370004     BRA 0x14F34
5285:                              while (pEndpoint)
014F34  E00001     CP0 W1
014F36  3AFFFA     BRA NZ, 0x14F2C
5286:                              {
5287:                                  pEndpoint->status.bfNextDATA01 = 0;
014F2C  904031     MOV.B [W1+3], W0
014F2E  A13400     BCLR.B W0, #3
014F30  9840B0     MOV.B W0, [W1+3]
5288:                                  pEndpoint = pEndpoint->next;
014F32  780091     MOV [W1], W1
5289:                              }
5290:                              pSetting = pSetting->next;
014F38  780112     MOV [W2], W2
5291:                          }
5292:                          pInterface = pInterface->next;
014F3E  780193     MOV [W3], W3
5293:                      }
5294:                  }
5295:                  else
5296:                  {
5297:                      pEndpoint = _USB_FindEndpoint( endpoint );
014F46  0256E4     CALL _USB_FindEndpoint
014F48  000001     NOP
014F4A  780080     MOV W0, W1
5298:                      if (pEndpoint != NULL)
014F4C  E00000     CP0 W0
014F4E  320003     BRA Z, 0x14F56
5299:                      {
5300:                          pEndpoint->status.bfNextDATA01 = 0;
5301:                      }
5302:                  }
5303:              }
5304:              
5305:              
5306:              /****************************************************************************
5307:                Function:
5308:                  void _USB_SendToken( BYTE endpoint, BYTE tokenType )
5309:              
5310:                Description:
5311:                  This function sets up the endpoint control register and sends the token.
5312:              
5313:                Precondition:
5314:                  None
5315:              
5316:                Parameters:
5317:                  BYTE endpoint   - Endpoint number
5318:                  BYTE tokenType  - Token to send
5319:              
5320:                Returns:
5321:                  None
5322:              
5323:                Remarks:
5324:                  If the device is low speed, the transfer must be set to low speed.  If
5325:                  the endpoint is isochronous, handshaking must be disabled.
5326:                ***************************************************************************/
5327:              
5328:              void _USB_SendToken( BYTE endpoint, BYTE tokenType )
5329:              {
5330:                  BYTE    temp;
5331:              
5332:                  // Disable retries, disable control transfers, enable Rx and Tx and handshaking.
5333:                  temp = 0x5D;
5334:              
5335:                  // Enable low speed transfer if the device is low speed.
5336:                  if (usbDeviceInfo.flags.bfIsLowSpeed)
014EA2  270680     MOV #0x7068, W0
014EA4  784010     MOV.B [W0], W0
014EA6  604061     AND.B W0, #0x1, W0
014EA8  B3CDD3     MOV #0xDD, W3
014EAA  3A0001     BRA NZ, 0x14EAE
014EAC  B3C5D3     MOV #0x5D, W3
5337:                  {
5338:                      temp |= 0x80;   // Set LSPD
5339:                  }
5340:              
5341:                  // Enable control transfers if necessary.
5342:                  if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_CONTROL)
014EAE  838382     MOV pCurrentEndpoint, W2
014EB0  905832     MOV.B [W2+27], W0
014EB2  604063     AND.B W0, #0x3, W0
014EB4  3A0001     BRA NZ, 0x14EB8
5343:                  {
5344:                      temp &= 0xEF;   // Clear EPCONDIS
014EB6  A14403     BCLR.B W3, #4
5345:                  }
5346:              
5347:                  // Disable handshaking for isochronous endpoints.
5348:                  if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
014EB8  905832     MOV.B [W2+27], W0
014EBA  604063     AND.B W0, #0x3, W0
014EBC  504FE1     SUB.B W0, #0x1, [W15]
014EBE  3A0001     BRA NZ, 0x14EC2
5349:                  {
5350:                      temp &= 0xFE;   // Clear EPHSHK
014EC0  A10403     BCLR.B W3, #0
5351:                  }
5352:              
5353:                  U1EP0 = temp;
014EC2  FB8003     ZE W3, W0
014EC4  882550     MOV W0, U1EP0
5354:              
5355:                  #ifdef DEBUG_MODE
5356:                      if (usbBusInfo.flags.bfTokenAlreadyWritten) UART2PutChar( '+' );
5357:              //        if (U1CONbits.TOKBUSY) UART2PutChar( '+' );
5358:                  #endif
5359:              
5360:                  U1ADDR = usbDeviceInfo.deviceAddressAndSpeed;
014EC6  2705A0     MOV #0x705A, W0
014EC8  FB8010     ZE [W0], W0
014ECA  8824B0     MOV W0, U1ADDR
5361:                  U1TOK = (tokenType << 4) | (endpoint & 0x7F);
014ECC  FB8001     ZE W1, W0
014ECE  DD0044     SL W0, #4, W0
014ED0  780084     MOV W4, W1
014ED2  B207F1     AND #0x7F, W1
014ED4  700001     IOR W0, W1, W0
014ED6  8824F0     MOV W0, U1TOK
5362:              
5363:                  // Lock out anyone from writing another token until this one has finished.
5364:              //    U1CONbits.TOKBUSY = 1;
5365:                  usbBusInfo.flags.bfTokenAlreadyWritten = 1;
014ED8  2706A0     MOV #0x706A, W0
014EDA  A04410     BSET.B [W0], #4
5366:              
5367:                  #ifdef DEBUG_MODE
5368:                      //UART2PutChar('(');
5369:                      //UART2PutHex(U1ADDR);
5370:                      //UART2PutHex(U1EP0);
5371:                      //UART2PutHex(U1TOK);
5372:                      //UART2PutChar(')');
5373:                  #endif
5374:              }
5375:              
5376:              
5377:              /****************************************************************************
5378:                Function:
5379:                  void _USB_SetBDT( BYTE token )
5380:              
5381:                Description:
5382:                  This function sets up the BDT for the transfer.  The function handles the
5383:                  different ping-pong modes.
5384:              
5385:                Precondition:
5386:                  pCurrentEndpoint must point to the current endpoint being serviced.
5387:              
5388:                Parameters:
5389:                  BYTE token  - Token for the transfer.  That way we can tell which
5390:                                  ping-pong buffer and which data pointer to use.  Valid
5391:                                  values are:
5392:                                      * USB_TOKEN_SETUP
5393:                                      * USB_TOKEN_IN
5394:                                      * USB_TOKEN_OUT
5395:              
5396:                Returns:
5397:                  None
5398:              
5399:                Remarks:
5400:                  None
5401:                ***************************************************************************/
5402:              
5403:              void _USB_SetBDT( BYTE token )
5404:              {
5405:                  WORD                currentPacketSize;
5406:                  BDT_ENTRY           *pBDT;
5407:              
5408:                  if (token == USB_TOKEN_IN)
012CB8  51CFE9     SUB.B W3, #0x9, [W15]
012CBA  3A000F     BRA NZ, 0x12CDA
5409:                  {
5410:                      // Find the BDT we need to use.
5411:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
5412:                          pBDT = BDT_IN;
5413:                          if (usbDeviceInfo.flags.bfPingPongIn)
012CBC  784010     MOV.B [W0], W0
012CBE  604070     AND.B W0, #0x10, W0
012CC0  270047     MOV #0x7004, W7
012CC2  3A0001     BRA NZ, 0x12CC6
012CC4  270007     MOV #0x7000, W7
5414:                          {
5415:                              pBDT = BDT_IN_ODD;
5416:                          }
5417:                      #else
5418:                          pBDT = BDT_IN;
5419:                      #endif
5420:              
5421:                      // Set up ping-pong for the next transfer
5422:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
5423:                          usbDeviceInfo.flags.bfPingPongIn = ~usbDeviceInfo.flags.bfPingPongIn;
012CC6  270680     MOV #0x7068, W0
012CC8  FB8090     ZE [W0], W1
012CCA  DE08C4     LSR W1, #4, W1
012CCC  60C0E1     AND.B W1, #0x1, W1
012CCE  A20401     BTG.B W1, #0
012CD0  DD08C4     SL W1, #4, W1
012CD2  784110     MOV.B [W0], W2
012CD4  A14402     BCLR.B W2, #4
012CD6  714801     IOR.B W2, W1, [W0]
012CD8  370023     BRA 0x12D20
5424:                      #endif
5425:                  }
5426:                  else  // USB_TOKEN_OUT or USB_TOKEN_SETUP
5427:                  {
5428:                      // Find the BDT we need to use.
5429:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
5430:                          pBDT = BDT_OUT;
5431:                          if (usbDeviceInfo.flags.bfPingPongOut)
012CDA  B3C201     MOV #0x20, W1
012CDC  60C010     AND.B W1, [W0], W0
012CDE  2700C7     MOV #0x700C, W7
012CE0  3A0001     BRA NZ, 0x12CE4
012CE2  270087     MOV #0x7008, W7
5432:                          {
5433:                              pBDT = BDT_OUT_ODD;
5434:                          }
5435:                      #else
5436:                          pBDT = BDT_OUT;
5437:                      #endif
5438:              
5439:                      // Set up ping-pong for the next transfer
5440:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
5441:                          usbDeviceInfo.flags.bfPingPongOut = ~usbDeviceInfo.flags.bfPingPongOut;
012CE4  270680     MOV #0x7068, W0
012CE6  FB8090     ZE [W0], W1
012CE8  DE08C5     LSR W1, #5, W1
012CEA  60C0E1     AND.B W1, #0x1, W1
012CEC  A20401     BTG.B W1, #0
012CEE  DD08C5     SL W1, #5, W1
012CF0  784110     MOV.B [W0], W2
012CF2  A15402     BCLR.B W2, #5
012CF4  714801     IOR.B W2, W1, [W0]
5442:                      #endif
5443:                  }
5444:              
5445:                  // Determine how much data we'll transfer in this packet.
5446:                  if (token == USB_TOKEN_SETUP)
012CF6  51CFED     SUB.B W3, #0xD, [W15]
012CF8  3A0013     BRA NZ, 0x12D20
5447:                  {
5448:                      if ((pCurrentEndpoint->dataCountMaxSETUP - pCurrentEndpoint->dataCount) > pCurrentEndpoint->wMaxPacketSize)
012CFA  838386     MOV pCurrentEndpoint, W6
012CFC  900076     MOV [W6+14], W0
012CFE  900A06     MOV [W6+16], W4
012D00  900A96     MOV [W6+18], W5
012D02  900146     MOV [W6+8], W2
012D04  200001     MOV #0x0, W1
012D06  500004     SUB W0, W4, W0
012D08  588085     SUBB W1, W5, W1
012D0A  200003     MOV #0x0, W3
012D0C  500F82     SUB W0, W2, [W15]
012D0E  588F83     SUBB W1, W3, [W15]
012D10  360002     BRA LEU, 0x12D16
5449:                      {
5450:                          currentPacketSize = pCurrentEndpoint->wMaxPacketSize;
012D12  9001C6     MOV [W6+8], W3
012D14  37001D     BRA 0x12D50
5451:                      }
5452:                      else
5453:                      {
5454:                          currentPacketSize = pCurrentEndpoint->dataCountMaxSETUP - pCurrentEndpoint->dataCount;
012D16  900176     MOV [W6+14], W2
012D18  900806     MOV [W6+16], W0
012D1A  900896     MOV [W6+18], W1
012D1C  510180     SUB W2, W0, W3
012D1E  370018     BRA 0x12D50
5455:                      }
5456:                  }
5457:                  else
5458:                  {
5459:                      if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
012D20  838386     MOV pCurrentEndpoint, W6
012D22  905836     MOV.B [W6+27], W0
012D24  604063     AND.B W0, #0x3, W0
012D26  504FE1     SUB.B W0, #0x1, [W15]
012D28  32000B     BRA Z, 0x12D40
5460:                      {
5461:                          // Isochronous transfers are always the same size, though the device may choose to send less.
5462:                          currentPacketSize = pCurrentEndpoint->wMaxPacketSize;
5463:                      }
5464:                      else
5465:                      {
5466:                          if ((pCurrentEndpoint->dataCountMax - pCurrentEndpoint->dataCount) > pCurrentEndpoint->wMaxPacketSize)
012D2A  900056     MOV [W6+10], W0
012D2C  9000E6     MOV [W6+12], W1
012D2E  900A06     MOV [W6+16], W4
012D30  900A96     MOV [W6+18], W5
012D32  900146     MOV [W6+8], W2
012D34  500004     SUB W0, W4, W0
012D36  588085     SUBB W1, W5, W1
012D38  200003     MOV #0x0, W3
012D3A  500F82     SUB W0, W2, [W15]
012D3C  588F83     SUBB W1, W3, [W15]
012D3E  360002     BRA LEU, 0x12D44
5467:                          {
5468:                              currentPacketSize = pCurrentEndpoint->wMaxPacketSize;
012D40  9001C6     MOV [W6+8], W3
012D42  37002D     BRA 0x12D9E
5469:                          }
5470:                          else
5471:                          {
5472:                              currentPacketSize = pCurrentEndpoint->dataCountMax - pCurrentEndpoint->dataCount;
012D44  900156     MOV [W6+10], W2
012D46  9001E6     MOV [W6+12], W3
012D48  900806     MOV [W6+16], W0
012D4A  900896     MOV [W6+18], W1
012D4C  510180     SUB W2, W0, W3
012D4E  370027     BRA 0x12D9E
5473:                          }
5474:                      }
5475:                  }
5476:              
5477:                  // Load up the BDT address.
5478:                  if (token == USB_TOKEN_SETUP)
5479:                  {
5480:                      #if defined(__C30__) || defined(__PIC32MX__)
5481:                          pBDT->ADR  = ConvertToPhysicalAddress(pCurrentEndpoint->pUserDataSETUP);
012D50  900B26     MOV [W6+20], W6
012D52  980396     MOV W6, [W7+2]
012D54  37000E     BRA 0x12D72
5482:                      #else
5483:                          #error Cannot set BDT address.
5484:                      #endif
5485:                  }
5486:                  else
5487:                  {
5488:                      #if defined(__C30__)
5489:                          if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
5490:                          {
5491:                              pBDT->ADR  = ConvertToPhysicalAddress(((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer);
012D56  9008B6     MOV [W6+22], W1
012D58  900836     MOV [W6+22], W0
012D5A  904010     MOV.B [W0+1], W0
012D5C  B3C062     MOV #0x6, W2
012D5E  BC4004     MUL.B WREG2
012D60  410166     ADD W2, #0x6, W2
012D62  7900E1     MOV [W1+W2], W1
012D64  980391     MOV W1, [W7+2]
012D66  370005     BRA 0x12D72
5492:                          }
5493:                          else
5494:                          {
5495:                              pBDT->ADR  = ConvertToPhysicalAddress((WORD)pCurrentEndpoint->pUserData + (WORD)pCurrentEndpoint->dataCount);
012D68  900936     MOV [W6+22], W2
012D6A  900806     MOV [W6+16], W0
012D6C  900896     MOV [W6+18], W1
012D6E  410100     ADD W2, W0, W2
012D70  980392     MOV W2, [W7+2]
5496:                          }
5497:                      #elif defined(__PIC32MX__)
5498:                          if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
5499:                          {
5500:                              pBDT->ADR  = ConvertToPhysicalAddress(((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer);
5501:                          }
5502:                          else
5503:                          {
5504:                              pBDT->ADR  = ConvertToPhysicalAddress((DWORD)pCurrentEndpoint->pUserData + (DWORD)pCurrentEndpoint->dataCount);
5505:                          }
5506:                      #else
5507:                          #error Cannot set BDT address.
5508:                      #endif
5509:                  }
5510:              
5511:                  // Load up the BDT status register.
5512:                  pBDT->STAT.Val      = 0;
012D72  EB4000     CLR.B W0
012D74  984390     MOV.B W0, [W7+1]
5513:                  pBDT->count         = currentPacketSize;
012D76  B23FF3     AND #0x3FF, W3
012D78  2FC000     MOV #0xFC00, W0
012D7A  600B97     AND W0, [W7], [W7]
012D7C  718B97     IOR W3, [W7], [W7]
5514:                  pBDT->STAT.DTS      = pCurrentEndpoint->status.bfNextDATA01;
012D7E  838381     MOV pCurrentEndpoint, W1
012D80  904031     MOV.B [W1+3], W0
012D82  DE0043     LSR W0, #3, W0
012D84  600061     AND W0, #0x1, W0
012D86  DD004E     SL W0, #14, W0
012D88  A1E017     BCLR [W7], #14
012D8A  700B97     IOR W0, [W7], [W7]
5515:                  pBDT->STAT.DTSEN    = pCurrentEndpoint->status.bfUseDTS;
012D8C  904031     MOV.B [W1+3], W0
012D8E  DE0042     LSR W0, #2, W0
012D90  600061     AND W0, #0x1, W0
012D92  DD004B     SL W0, #11, W0
012D94  A1B017     BCLR [W7], #11
012D96  700B97     IOR W0, [W7], [W7]
5516:              
5517:                  // Transfer the BD to the USB OTG module.
5518:                  pBDT->STAT.UOWN     = 1;
012D98  280000     MOV #0x8000, W0
012D9A  700B97     IOR W0, [W7], [W7]
5519:              
5520:                  #ifdef DEBUG_MODE
5521:              //        UART2PutChar('{');
5522:              //        UART2PutHex((pBDT->v[0] >> 24) & 0xff);
5523:              //        UART2PutHex((pBDT->v[0] >> 16) & 0xff);
5524:              //        UART2PutHex((pBDT->v[0] >> 8) & 0xff);
5525:              //        UART2PutHex((pBDT->v[0]) & 0xff);
5526:              //        UART2PutChar('-');
5527:              //        UART2PutHex((currentPacketSize >> 24) & 0xff);
5528:              //        UART2PutHex((pBDT->v[1] >> 16) & 0xff);
5529:              //        UART2PutHex((currentPacketSize >> 8) & 0xff);
5530:              //        UART2PutHex(currentPacketSize & 0xff);
5531:              //        UART2PutChar('}');
5532:                  #endif
5533:              
5534:              }
012D9C  060000     RETURN
5535:              
5536:              
5537:              /****************************************************************************
5538:                Function:
5539:                  BOOL _USB_TransferInProgress( void )
5540:              
5541:                Description:
5542:                  This function checks to see if any read or write transfers are in
5543:                  progress.
5544:              
5545:                Precondition:
5546:                  None
5547:              
5548:                Parameters:
5549:                  None - None
5550:              
5551:                Returns:
5552:                  TRUE    - At least one read or write transfer is occurring.
5553:                  FALSE   - No read or write transfers are occurring.
5554:              
5555:                Remarks:
5556:                  None
5557:                ***************************************************************************/
5558:              
5559:              BOOL _USB_TransferInProgress( void )
5560:              {
5561:                  USB_ENDPOINT_INFO           *pEndpoint;
5562:                  USB_INTERFACE_INFO          *pInterface;
5563:                  USB_INTERFACE_SETTING_INFO  *pSetting;
5564:              
5565:                  // Check EP0.
5566:                  if (!usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
0155EC  838330     MOV 0x7066, W0
0155EE  904030     MOV.B [W0+3], W0
0155F0  A31800     BTST.Z W0, #1
0155F2  320014     BRA Z, 0x1561C
5567:                  {
5568:                      return TRUE;
5569:                  }
5570:              
5571:                  // Check all of the other endpoints.
5572:                  pInterface = usbDeviceInfo.pInterfaceList;
0155F4  838323     MOV 0x7064, W3
0155F6  37000E     BRA 0x15614
5573:                  while (pInterface)
5574:                  {
5575:                      pSetting = pInterface->pInterfaceSettings;
0155F8  900113     MOV [W3+2], W2
0155FA  370009     BRA 0x1560E
5576:                      while (pSetting)
01560E  E00002     CP0 W2
015610  3AFFF5     BRA NZ, 0x155FC
5577:                      {
5578:                          pEndpoint = pSetting->pEndpointList;
0155FC  9000A2     MOV [W2+4], W1
0155FE  370004     BRA 0x15608
5579:                          while (pEndpoint)
015608  E00001     CP0 W1
01560A  3AFFFA     BRA NZ, 0x15600
5580:                          {
5581:                              if (!pEndpoint->status.bfTransferComplete)
015600  904031     MOV.B [W1+3], W0
015602  A31800     BTST.Z W0, #1
015604  32000B     BRA Z, 0x1561C
5582:                              {
5583:                                  return TRUE;
5584:                              }
5585:                              pEndpoint = pEndpoint->next;
015606  780091     MOV [W1], W1
5586:                          }
5587:                          pSetting = pSetting->next;
01560C  780112     MOV [W2], W2
5588:                      }
5589:                      pInterface = pInterface->next;
015612  780193     MOV [W3], W3
5590:                  }
5591:              
5592:                  return FALSE;
5593:              }
5594:              
5595:              
5596:              // *****************************************************************************
5597:              // *****************************************************************************
5598:              // Section: Interrupt Handlers
5599:              // *****************************************************************************
5600:              // *****************************************************************************
5601:              
5602:              /****************************************************************************
5603:                Function:
5604:                  void _USB1Interrupt( void )
5605:              
5606:                Summary:
5607:                  This is the interrupt service routine for the USB interrupt.
5608:              
5609:                Description:
5610:                  This is the interrupt service routine for the USB interrupt.  The
5611:                  following cases are serviced:
5612:                       * Device Attach
5613:                       * Device Detach
5614:                       * One millisecond Timer
5615:                       * Start of Frame
5616:                       * Transfer Done
5617:                       * USB Error
5618:              
5619:                Precondition:
5620:                  In TRNIF handling, pCurrentEndpoint is still pointing to the last
5621:                  endpoint to which a token was sent.
5622:              
5623:                Parameters:
5624:                  None - None
5625:              
5626:                Returns:
5627:                  None
5628:              
5629:                Remarks:
5630:                  None
5631:                ***************************************************************************/
5632:              #define U1STAT_TX_MASK                      0x08    // U1STAT bit mask for Tx/Rx indication
5633:              #define U1STAT_ODD_MASK                     0x04    // U1STAT bit mask for even/odd buffer bank
5634:              
5635:              #if defined(__C30__)
5636:              void __attribute__((__interrupt__, no_auto_psv)) _USB1Interrupt( void )
5637:              #elif defined(__PIC32MX__)
5638:              #pragma interrupt _USB1Interrupt ipl4 vector 45
5639:              void _USB1Interrupt( void )
5640:              #else
5641:                  #error Cannot define timer interrupt vector.
5642:              #endif
5643:              {
5644:              
5645:                  #if defined( __C30__)
5646:                      IFS5 &= 0xFFBF;
005FEC  A9C08E     BCLR IFS5, #6
5647:                  #elif defined( __PIC32MX__)
5648:                      IFS1CLR = 0x02000000;
5649:                  #else
5650:                      #error Cannot clear USB interrupt.
5651:                  #endif
5652:              
5653:                  // -------------------------------------------------------------------------
5654:                  // One Millisecond Timer ISR
5655:              
5656:                  if (U1OTGIEbits.T1MSECIE && U1OTGIRbits.T1MSECIF)
005FEE  BFC482     MOV.B U1OTGIE, WREG
005FF0  A36800     BTST.Z W0, #6
005FF2  320012     BRA Z, 0x6018
005FF4  BFC480     MOV.B U1OTGIR, WREG
005FF6  A36800     BTST.Z W0, #6
005FF8  32000F     BRA Z, 0x6018
5657:                  {
5658:                      // The interrupt is cleared by writing a '1' to it.
5659:                      U1OTGIR = USB_INTERRUPT_T1MSECIF;
005FFA  200400     MOV #0x40, W0
005FFC  882400     MOV W0, U1OTGIR
5660:              
5661:                      #if defined(USB_ENABLE_1MS_EVENT) && defined(USB_HOST_APP_DATA_EVENT_HANDLER)
5662:                          msec_count++;
5663:              
5664:                          //Notify ping all client drivers of 1MSEC event (address, event, data, sizeof_data)
5665:                          _USB_NotifyAllDataClients(0, EVENT_1MS, (void*)&msec_count, 0);
5666:                      #endif
5667:              
5668:                      #ifdef DEBUG_MODE
5669:                          UART2PutChar('~');
5670:                      #endif
5671:              
5672:                      #ifdef  USB_SUPPORT_OTG
5673:                          if (USBOTGGetSRPTimeOutFlag())
5674:                          {
5675:                              if (USBOTGIsSRPTimeOutExpired())
5676:                              {
5677:                                  USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
5678:                              }
5679:              
5680:                          }
5681:              
5682:                          else if (USBOTGGetHNPTimeOutFlag())
5683:                          {
5684:                              if (USBOTGIsHNPTimeOutExpired())
5685:                              {
5686:                                  USB_OTGEventHandler(0,OTG_EVENT_HNP_FAILED,0,0);
5687:                              }
5688:              
5689:                          }
5690:              
5691:                          else
5692:                          {
5693:                              if(numTimerInterrupts != 0)
5694:                              {
5695:                                  numTimerInterrupts--;
5696:              
5697:                                  if (numTimerInterrupts == 0)
5698:                                  {
5699:                                      //If we aren't using the 1ms events, then turn of the interrupt to
5700:                                      // save CPU time
5701:                                      #if !defined(USB_ENABLE_1MS_EVENT)
5702:                                          // Turn off the timer interrupt.
5703:                                          U1OTGIEbits.T1MSECIE = 0;
5704:                                      #endif
5705:                  
5706:                                      // Advance to the next state.  We can do this here, because the only time
5707:                                      // we'll get a timer interrupt is while we are in one of the holding states.
5708:                                      _USB_SetNextSubSubState();
5709:                                  }
5710:                              }
5711:                          }
5712:                       #else
5713:              
5714:                          if(numTimerInterrupts != 0)
005FFE  838390     MOV numTimerInterrupts, W0
006000  E00000     CP0 W0
006002  32000A     BRA Z, 0x6018
5715:                          {
5716:                              numTimerInterrupts--;
006004  838390     MOV numTimerInterrupts, W0
006006  E90000     DEC W0, W0
006008  8B8390     MOV W0, numTimerInterrupts
5717:              
5718:                              if (numTimerInterrupts == 0)
00600A  838390     MOV numTimerInterrupts, W0
00600C  E00000     CP0 W0
00600E  3A0004     BRA NZ, 0x6018
5719:                              {
5720:                                  //If we aren't using the 1ms events, then turn of the interrupt to
5721:                                  // save CPU time
5722:                                  #if !defined(USB_ENABLE_1MS_EVENT)
5723:                                      // Turn off the timer interrupt.
5724:                                      U1OTGIEbits.T1MSECIE = 0;
006010  A9C482     BCLR U1OTGIE, #6
5725:                                  #endif
5726:              
5727:                                  // Advance to the next state.  We can do this here, because the only time
5728:                                  // we'll get a timer interrupt is while we are in one of the holding states.
5729:                                  _USB_SetNextSubSubState();
006012  838370     MOV usbHostState, W0
006014  E80000     INC W0, W0
006016  8B8370     MOV W0, usbHostState
5730:                              }
5731:                          }
5732:                       #endif
5733:                  }
5734:              
5735:                  // -------------------------------------------------------------------------
5736:                  // Attach ISR
5737:              
5738:                  // The attach interrupt is level, not edge, triggered.  So make sure we have it enabled.
5739:                  if (U1IEbits.ATTACHIE && U1IRbits.ATTACHIF)
006018  BFC48C     MOV.B U1IE, WREG
00601A  A36800     BTST.Z W0, #6
00601C  32000C     BRA Z, 0x6036
00601E  BFC48A     MOV.B U1IR, WREG
006020  A36800     BTST.Z W0, #6
006022  320009     BRA Z, 0x6036
5740:                  {
5741:                      #ifdef DEBUG_MODE
5742:                          UART2PutChar( '[' );
5743:                      #endif
5744:              
5745:                      // The attach interrupt is level, not edge, triggered.  If we clear it, it just
5746:                      // comes right back.  So clear the enable instead
5747:                      U1IEbits.ATTACHIE   = 0;
006024  A9C48C     BCLR U1IE, #6
5748:                      U1IR                = USB_INTERRUPT_ATTACH;
006026  200400     MOV #0x40, W0
006028  882450     MOV W0, U1IR
5749:              
5750:                      if (usbHostState == (STATE_DETACHED | SUBSTATE_WAIT_FOR_DEVICE))
00602A  838371     MOV usbHostState, W1
00602C  500070     SUB W0, #0x10, W0
00602E  508F80     SUB W1, W0, [W15]
006030  3A0002     BRA NZ, 0x6036
5751:                      {
5752:                          usbOverrideHostState = STATE_ATTACHED;
006032  201000     MOV #0x100, W0
006034  8B8280     MOV W0, usbOverrideHostState
5753:                      }
5754:              
5755:                      #ifdef  USB_SUPPORT_OTG
5756:                          //If HNP Related Attach, Process Connect Event
5757:                          USB_OTGEventHandler(0, OTG_EVENT_CONNECT, 0, 0 );
5758:              
5759:                          //If SRP Related A side D+ High, Process D+ High Event
5760:                          USB_OTGEventHandler (0, OTG_EVENT_SRP_DPLUS_HIGH, 0, 0 );
5761:              
5762:                          //If SRP Related B side Attach
5763:                          USB_OTGEventHandler (0, OTG_EVENT_SRP_CONNECT, 0, 0 );
5764:                      #endif
5765:                  }
5766:              
5767:                  // -------------------------------------------------------------------------
5768:                  // Detach ISR
5769:              
5770:                  if (U1IEbits.DETACHIE && U1IRbits.DETACHIF)
006036  BFC48C     MOV.B U1IE, WREG
006038  A30800     BTST.Z W0, #0
00603A  320008     BRA Z, 0x604C
00603C  BFC48A     MOV.B U1IR, WREG
00603E  A30800     BTST.Z W0, #0
006040  320005     BRA Z, 0x604C
5771:                  {
5772:                      #ifdef DEBUG_MODE
5773:                          UART2PutChar( ']' );
5774:                      #endif
5775:              
5776:                      U1IR                    = USB_INTERRUPT_DETACH;
006042  200010     MOV #0x1, W0
006044  882450     MOV W0, U1IR
5777:                      U1IEbits.DETACHIE       = 0;
006046  A9048C     BCLR U1IE, #0
5778:                      usbOverrideHostState    = STATE_DETACHED;
006048  EB0000     CLR W0
00604A  8B8280     MOV W0, usbOverrideHostState
5779:              
5780:                      #ifdef  USB_SUPPORT_OTG
5781:                          //If HNP Related Detach Detected, Process Disconnect Event
5782:                          USB_OTGEventHandler (0, OTG_EVENT_DISCONNECT, 0, 0 );
5783:              
5784:                          //If SRP Related D+ Low and SRP Is Active, Process D+ Low Event
5785:                          USB_OTGEventHandler (0, OTG_EVENT_SRP_DPLUS_LOW, 0, 0 );
5786:              
5787:                          //Disable HNP, Detach Interrupt Could've Triggered From Cable Being Unplugged
5788:                          USBOTGDisableHnp();
5789:                      #endif
5790:                  }
5791:              
5792:                  #ifdef USB_SUPPORT_OTG
5793:              
5794:                      // -------------------------------------------------------------------------
5795:                      //ID Pin Change ISR
5796:                      if (U1OTGIRbits.IDIF && U1OTGIEbits.IDIE)
5797:                      {
5798:                           USBOTGInitialize();
5799:              
5800:                           //Clear Interrupt Flag
5801:                           U1OTGIR = 0x80;
5802:                      }
5803:              
5804:                      // -------------------------------------------------------------------------
5805:                      //VB_SESS_END ISR
5806:                      if (U1OTGIRbits.SESENDIF && U1OTGIEbits.SESENDIE)
5807:                      {
5808:                          //If B side Host And Cable Was Detached Then
5809:                          if (U1OTGSTATbits.ID == CABLE_B_SIDE && USBOTGCurrentRoleIs() == ROLE_HOST)
5810:                          {
5811:                              //Reinitialize
5812:                              USBOTGInitialize();
5813:                          }
5814:              
5815:                          //Clear Interrupt Flag
5816:                          U1OTGIR = 0x04;
5817:                      }
5818:              
5819:                      // -------------------------------------------------------------------------
5820:                      //VA_SESS_VLD ISR
5821:                      if (U1OTGIRbits.SESVDIF && U1OTGIEbits.SESVDIE)
5822:                      {
5823:                          //If A side Host and SRP Is Active Then
5824:                          if (USBOTGDefaultRoleIs() == ROLE_HOST && USBOTGSrpIsActive())
5825:                          {
5826:                              //If VBUS > VA_SESS_VLD Then
5827:                              if (U1OTGSTATbits.SESVD == 1)
5828:                              {
5829:                                  //Process SRP VBUS High Event
5830:                                  USB_OTGEventHandler (0, OTG_EVENT_SRP_VBUS_HIGH, 0, 0 );
5831:                              }
5832:              
5833:                              //If VBUS < VA_SESS_VLD Then
5834:                              else
5835:                              {
5836:                                   //Process SRP Low Event
5837:                                  USB_OTGEventHandler (0, OTG_EVENT_SRP_VBUS_LOW, 0, 0 );
5838:                              }
5839:                          }
5840:              
5841:                          U1OTGIR = 0x08;
5842:                      }
5843:              
5844:                      // -------------------------------------------------------------------------
5845:                      //Resume Signaling for Remote Wakeup
5846:                      if (U1IRbits.RESUMEIF && U1IEbits.RESUMEIE)
5847:                      {
5848:                          //Process SRP VBUS High Event
5849:                          USB_OTGEventHandler (0, OTG_EVENT_RESUME_SIGNALING,0, 0 );
5850:              
5851:                          //Clear Resume Interrupt Flag
5852:                          U1IR = 0x20;
5853:                      }
5854:                  #endif
5855:              
5856:              
5857:                  // -------------------------------------------------------------------------
5858:                  // Transfer Done ISR - only process if there was no error
5859:              
5860:                  if ((U1IEbits.TRNIE && U1IRbits.TRNIF) &&
00604C  BFC48C     MOV.B U1IE, WREG
00604E  A33800     BTST.Z W0, #3
006050  3200D0     BRA Z, 0x61F2
006052  BFC48A     MOV.B U1IR, WREG
006054  A33800     BTST.Z W0, #3
006056  3200CD     BRA Z, 0x61F2
006058  BFC48C     MOV.B U1IE, WREG
00605A  A31800     BTST.Z W0, #1
00605C  320008     BRA Z, 0x606E
00605E  BFC48A     MOV.B U1IR, WREG
006060  A31800     BTST.Z W0, #1
006062  320005     BRA Z, 0x606E
006064  838380     MOV pCurrentEndpoint, W0
006066  905830     MOV.B [W0+27], W0
006068  604063     AND.B W0, #0x3, W0
00606A  504FE1     SUB.B W0, #0x1, [W15]
00606C  3A00C2     BRA NZ, 0x61F2
5861:                      (!(U1IEbits.UERRIE && U1IRbits.UERRIF) || (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)))
5862:                  {
5863:                      #if defined(__C30__)
5864:                          U1STATBITS          copyU1STATbits;
5865:                      #elif defined(__PIC32MX__)
5866:                          __U1STATbits_t      copyU1STATbits;
5867:                      #else
5868:                          #error Need structure name for copyU1STATbits.
5869:                      #endif
5870:                      WORD                    packetSize;
5871:                      BDT_ENTRY               *pBDT;
5872:              
5873:                      #ifdef DEBUG_MODE
5874:              //            UART2PutChar( '!' );
5875:                      #endif
5876:              
5877:                      // The previous token has finished, so clear the way for writing a new one.
5878:                      usbBusInfo.flags.bfTokenAlreadyWritten = 0;
00606E  2706A0     MOV #0x706A, W0
006070  A14410     BCLR.B [W0], #4
5879:              
5880:                      copyU1STATbits = U1STATbits;    // Read the status register before clearing the flag.
006072  802492     MOV U1STAT, W2
5881:              
5882:                      U1IR = USB_INTERRUPT_TRANSFER;  // Clear the interrupt by writing a '1' to the flag.
006074  200080     MOV #0x8, W0
006076  882450     MOV W0, U1IR
5883:              
5884:                      // In host mode, U1STAT does NOT reflect the endpoint.  It is really the last updated
5885:                      // BDT, which, in host mode, is always 0.  To get the endpoint, we either need to look
5886:                      // at U1TOK, or trust that pCurrentEndpoint is still accurate.
5887:                      if ((pCurrentEndpoint->bEndpointAddress & 0x0F) == (U1TOK & 0x0F))
006078  838384     MOV pCurrentEndpoint, W4
00607A  9058A4     MOV.B [W4+26], W1
00607C  8024F0     MOV U1TOK, W0
00607E  6080EF     AND W1, #0xF, W1
006080  60006F     AND W0, #0xF, W0
006082  508F80     SUB W1, W0, [W15]
006084  3A00B4     BRA NZ, 0x61EE
006086  610064     AND W2, #0x4, W0
5888:                      {
5889:                          if (copyU1STATbits.DIR)     // TX
006088  A33802     BTST.Z W2, #3
00608A  320005     BRA Z, 0x6096
5890:                          {
5891:                              // We are processing OUT or SETUP packets.
5892:                              // Set up the BDT pointer for the transaction we just received.
5893:                              #if (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
5894:                                  pBDT = BDT_OUT;
5895:                                  if (copyU1STATbits.PPBI) // Odd
00608C  2700C2     MOV #0x700C, W2
00608E  E00000     CP0 W0
006090  3A0006     BRA NZ, 0x609E
006092  270082     MOV #0x7008, W2
006094  370004     BRA 0x609E
5896:                                  {
5897:                                      pBDT = BDT_OUT_ODD;
5898:                                  }
5899:                              #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
5900:                                  pBDT = BDT_OUT;
5901:                              #endif
5902:                          }
5903:                          else
5904:                          {
5905:                              // We are processing IN packets.
5906:                              // Set up the BDT pointer for the transaction we just received.
5907:                              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
5908:                                  pBDT = BDT_IN;
5909:                                  if (copyU1STATbits.PPBI) // Odd
006096  270042     MOV #0x7004, W2
006098  E00000     CP0 W0
00609A  3A0001     BRA NZ, 0x609E
00609C  270002     MOV #0x7000, W2
5910:                                  {
5911:                                      pBDT = BDT_IN_ODD;
5912:                                  }
5913:                              #else
5914:                                  pBDT = BDT_IN;
5915:                              #endif
5916:                          }
5917:              
5918:                          if (pBDT->STAT.PID == PID_ACK)
00609E  23C000     MOV #0x3C00, W0
0060A0  600092     AND W0, [W2], W1
0060A2  208000     MOV #0x800, W0
0060A4  508F80     SUB W1, W0, [W15]
0060A6  3A0037     BRA NZ, 0x6116
5919:                          {
5920:                              // We will only get this PID from an OUT or SETUP packet.
5921:              
5922:                              // Update the count of bytes tranferred.  (If there was an error, this count will be 0.)
5923:                              // The Byte Count is NOT 0 if a NAK occurs.  Therefore, we can only update the
5924:                              // count when an ACK, DATA0, or DATA1 is received.
5925:                              packetSize                  = pBDT->count;
0060A8  203FF0     MOV #0x3FF, W0
0060AA  600112     AND W0, [W2], W2
5926:                              pCurrentEndpoint->dataCount += packetSize;
0060AC  900804     MOV [W4+16], W0
0060AE  900894     MOV [W4+18], W1
0060B0  400002     ADD W0, W2, W0
0060B2  4880E0     ADDC W1, #0x0, W1
0060B4  980A00     MOV W0, [W4+16]
0060B6  980A11     MOV W1, [W4+18]
5927:              
5928:                              // Set the NAK retries for the next transaction;
5929:                              pCurrentEndpoint->countNAKs = 0;
0060B8  EB0000     CLR W0
0060BA  980A70     MOV W0, [W4+30]
5930:              
5931:                              // Toggle DTS for the next transfer.
5932:                              pCurrentEndpoint->status.bfNextDATA01 ^= 0x01;
0060BC  904034     MOV.B [W4+3], W0
0060BE  DE0043     LSR W0, #3, W0
0060C0  600061     AND W0, #0x1, W0
0060C2  A20400     BTG.B W0, #0
0060C4  DD0043     SL W0, #3, W0
0060C6  9040B4     MOV.B [W4+3], W1
0060C8  A13401     BCLR.B W1, #3
0060CA  70C080     IOR.B W1, W0, W1
0060CC  984231     MOV.B W1, [W4+3]
5933:              
5934:                              if ((pCurrentEndpoint->transferState == (TSTATE_CONTROL_NO_DATA | TSUBSTATE_CONTROL_NO_DATA_SETUP)) ||
0060CE  905804     MOV.B [W4+24], W0
0060D0  504FF0     SUB.B W0, #0x10, [W15]
0060D2  320008     BRA Z, 0x60E4
0060D4  905884     MOV.B [W4+24], W1
0060D6  B3C200     MOV #0x20, W0
0060D8  50CF80     SUB.B W1, W0, [W15]
0060DA  320004     BRA Z, 0x60E4
0060DC  905884     MOV.B [W4+24], W1
0060DE  404070     ADD.B W0, #0x10, W0
0060E0  50CF80     SUB.B W1, W0, [W15]
0060E2  3A0032     BRA NZ, 0x6148
5935:                                  (pCurrentEndpoint->transferState == (TSTATE_CONTROL_READ    | TSUBSTATE_CONTROL_READ_SETUP)) ||
5936:                                  (pCurrentEndpoint->transferState == (TSTATE_CONTROL_WRITE   | TSUBSTATE_CONTROL_WRITE_SETUP)))
5937:                              {
5938:                                  // We are doing SETUP transfers. See if we are done with the SETUP portion.
5939:                                  if (pCurrentEndpoint->dataCount >= pCurrentEndpoint->dataCountMaxSETUP)
0060E4  900904     MOV [W4+16], W2
0060E6  900994     MOV [W4+18], W3
0060E8  900074     MOV [W4+14], W0
0060EA  200001     MOV #0x0, W1
0060EC  510F80     SUB W2, W0, [W15]
0060EE  598F81     SUBB W3, W1, [W15]
0060F0  39007E     BRA NC, 0x61EE
5940:                                  {
5941:                                      // We are done with the SETUP.  Reset the byte count and
5942:                                      // proceed to the next token.
5943:                                      pCurrentEndpoint->dataCount = 0;
0060F2  B80060     MUL.UU W0, #0, W0
0060F4  980A00     MOV W0, [W4+16]
0060F6  980A11     MOV W1, [W4+18]
0060F8  37000A     BRA 0x610E
5944:                                      _USB_SetNextTransferState();
5945:                                  }
5946:                              }
5947:                              else
5948:                              {
5949:                                  // We are doing OUT transfers.  See if we've written all the data.
5950:                                  // We've written all the data when we send a short packet or we have
5951:                                  // transferred all the data.  If it's an isochronous transfer, this
5952:                                  // portion is complete, so go to the next state, so we can tell the
5953:                                  // next higher layer that a batch of data has been transferred.
5954:                                  if ((pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS) ||
0060FA  900904     MOV [W4+16], W2
0060FC  900994     MOV [W4+18], W3
0060FE  900054     MOV [W4+10], W0
006100  9000E4     MOV [W4+12], W1
006102  510F80     SUB W2, W0, [W15]
006104  598F81     SUBB W3, W1, [W15]
006106  390073     BRA NC, 0x61EE
5955:                                      (packetSize < pCurrentEndpoint->wMaxPacketSize) ||
5956:                                      (pCurrentEndpoint->dataCount >= pCurrentEndpoint->dataCountMax))
5957:                                  {
5958:                                      // We've written all the data. Proceed to the next step.
5959:                                      pCurrentEndpoint->status.bfTransferSuccessful = 1;
006108  904034     MOV.B [W4+3], W0
00610A  A00400     BSET.B W0, #0
00610C  984230     MOV.B W0, [W4+3]
5960:                                      _USB_SetNextTransferState();
00610E  905804     MOV.B [W4+24], W0
006110  E84000     INC.B W0, W0
006112  985A00     MOV.B W0, [W4+24]
006114  37006C     BRA 0x61EE
5961:                                  }
5962:                                  else
5963:                                  {
5964:                                      // We need to process more data.  Keep this endpoint in its current
5965:                                      // transfer state.
5966:                                  }
5967:                              }
5968:                          }
5969:                          else if ((pBDT->STAT.PID == PID_DATA0) || (pBDT->STAT.PID == PID_DATA1))
006116  20C000     MOV #0xC00, W0
006118  508F80     SUB W1, W0, [W15]
00611A  320003     BRA Z, 0x6122
00611C  22C000     MOV #0x2C00, W0
00611E  508F80     SUB W1, W0, [W15]
006120  3A001B     BRA NZ, 0x6158
5970:                          {
5971:                              // We will only get these PID's from an IN packet.
5972:                              
5973:                              // Update the count of bytes tranferred.  (If there was an error, this count will be 0.)
5974:                              // The Byte Count is NOT 0 if a NAK occurs.  Therefore, we can only update the
5975:                              // count when an ACK, DATA0, or DATA1 is received.
5976:                              packetSize                  = pBDT->count;
006122  203FF0     MOV #0x3FF, W0
006124  600112     AND W0, [W2], W2
5977:                              pCurrentEndpoint->dataCount += packetSize;
006126  900804     MOV [W4+16], W0
006128  900894     MOV [W4+18], W1
00612A  400002     ADD W0, W2, W0
00612C  4880E0     ADDC W1, #0x0, W1
00612E  980A00     MOV W0, [W4+16]
006130  980A11     MOV W1, [W4+18]
5978:              
5979:                              // Set the NAK retries for the next transaction;
5980:                              pCurrentEndpoint->countNAKs = 0;
006132  EB0000     CLR W0
006134  980A70     MOV W0, [W4+30]
5981:              
5982:                              // Toggle DTS for the next transfer.
5983:                              pCurrentEndpoint->status.bfNextDATA01 ^= 0x01;
006136  904034     MOV.B [W4+3], W0
006138  DE0043     LSR W0, #3, W0
00613A  600061     AND W0, #0x1, W0
00613C  A20400     BTG.B W0, #0
00613E  DD0043     SL W0, #3, W0
006140  9040B4     MOV.B [W4+3], W1
006142  A13401     BCLR.B W1, #3
006144  70C080     IOR.B W1, W0, W1
006146  984231     MOV.B W1, [W4+3]
5984:              
5985:                              // We are doing IN transfers.  See if we've received all the data.
5986:                              // We've received all the data if it's an isochronous transfer, or when we receive a
5987:                              // short packet or we have transferred all the data.
5988:                              if ((pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS) ||
006148  905834     MOV.B [W4+27], W0
00614A  604063     AND.B W0, #0x3, W0
00614C  504FE1     SUB.B W0, #0x1, [W15]
00614E  32FFDC     BRA Z, 0x6108
006150  900044     MOV [W4+8], W0
006152  510F80     SUB W2, W0, [W15]
006154  39FFD9     BRA NC, 0x6108
006156  37FFD1     BRA 0x60FA
5989:                                  (packetSize < pCurrentEndpoint->wMaxPacketSize) ||
5990:                                  (pCurrentEndpoint->dataCount >= pCurrentEndpoint->dataCountMax))
5991:                              {
5992:                                  // If we've received all the data, stop the transfer.  We've received all the
5993:                                  // data when we receive a short or zero-length packet.  If the data length is a
5994:                                  // multiple of wMaxPacketSize, we will get a 0-length packet.
5995:                                  pCurrentEndpoint->status.bfTransferSuccessful = 1;
5996:                                  _USB_SetNextTransferState();
5997:                              }
5998:                              else
5999:                              {
6000:                                  // We need to process more data.  Keep this endpoint in its current
6001:                                  // transfer state.
6002:                              }
6003:                          }
6004:                          else if (pBDT->STAT.PID == PID_NAK)
006158  228000     MOV #0x2800, W0
00615A  508F80     SUB W1, W0, [W15]
00615C  3A0021     BRA NZ, 0x61A0
6005:                          {
6006:                              #ifndef ALLOW_MULTIPLE_NAKS_PER_FRAME
6007:                                  pCurrentEndpoint->status.bfLastTransferNAKd = 1;
00615E  904034     MOV.B [W4+3], W0
006160  A04400     BSET.B W0, #4
006162  984230     MOV.B W0, [W4+3]
6008:                              #endif
6009:              
6010:                              pCurrentEndpoint->countNAKs ++;
006164  900874     MOV [W4+30], W0
006166  E80000     INC W0, W0
006168  980A70     MOV W0, [W4+30]
6011:              
6012:                              switch( pCurrentEndpoint->bmAttributes.bfTransferType )
00616A  905834     MOV.B [W4+27], W0
00616C  600063     AND W0, #0x3, W0
00616E  500FE1     SUB W0, #0x1, [W15]
006170  32FFCB     BRA Z, 0x6108
006172  3C0003     BRA GT, 0x617A
006174  E00000     CP0 W0
006176  320008     BRA Z, 0x6188
006178  37003A     BRA 0x61EE
00617A  500FE2     SUB W0, #0x2, [W15]
00617C  320005     BRA Z, 0x6188
00617E  500FE3     SUB W0, #0x3, [W15]
006180  3A0036     BRA NZ, 0x61EE
6013:                              {
6014:                                  case USB_TRANSFER_TYPE_BULK:
6015:                                      // Bulk IN and OUT transfers are allowed to retry NAK'd
6016:                                      // transactions until a timeout (if enabled) or indefinitely
6017:                                          // (if NAK timeouts disabled).
6018:                                      if (pCurrentEndpoint->status.bfNAKTimeoutEnabled &&
6019:                                          (pCurrentEndpoint->countNAKs > pCurrentEndpoint->timeoutNAKs))
6020:                                      {
6021:                                          pCurrentEndpoint->status.bfError    = 1;
6022:                                          pCurrentEndpoint->bErrorCode        = USB_ENDPOINT_NAK_TIMEOUT;
6023:                                          _USB_SetTransferErrorState( pCurrentEndpoint );
6024:                                      }
6025:                                      break;
6026:              
6027:                                  case USB_TRANSFER_TYPE_CONTROL:
6028:                                      // Devices should not NAK the SETUP portion.  If they NAK
6029:                                      // the DATA portion, they are allowed to retry a fixed
6030:                                      // number of times.
6031:                                      if (pCurrentEndpoint->status.bfNAKTimeoutEnabled &&
6032:                                          (pCurrentEndpoint->countNAKs > pCurrentEndpoint->timeoutNAKs))
6033:                                      {
6034:                                          pCurrentEndpoint->status.bfError    = 1;
6035:                                          pCurrentEndpoint->bErrorCode        = USB_ENDPOINT_NAK_TIMEOUT;
6036:                                          _USB_SetTransferErrorState( pCurrentEndpoint );
6037:                                      }
6038:                                      break;
6039:              
6040:                                  case USB_TRANSFER_TYPE_INTERRUPT:
6041:                                      if ((pCurrentEndpoint->bEndpointAddress & 0x80) == 0x00)
006182  905824     MOV.B [W4+26], W0
006184  E00400     CP0.B W0
006186  35FFC0     BRA LT, 0x6108
6042:                                      {
6043:                                          // Interrupt OUT transfers are allowed to retry NAK'd
6044:                                          // transactions until a timeout (if enabled) or indefinitely
6045:                                          // (if NAK timeouts disabled).
6046:                                          if (pCurrentEndpoint->status.bfNAKTimeoutEnabled &&
006188  904034     MOV.B [W4+3], W0
00618A  A35800     BTST.Z W0, #5
00618C  320030     BRA Z, 0x61EE
00618E  9008F4     MOV [W4+30], W1
006190  901004     MOV [W4+32], W0
006192  508F80     SUB W1, W0, [W15]
006194  36002C     BRA LEU, 0x61EE
6047:                                              (pCurrentEndpoint->countNAKs > pCurrentEndpoint->timeoutNAKs))
6048:                                          {
6049:                                              pCurrentEndpoint->status.bfError    = 1;
006196  904024     MOV.B [W4+2], W0
006198  A06400     BSET.B W0, #6
00619A  984220     MOV.B W0, [W4+2]
6050:                                              pCurrentEndpoint->bErrorCode        = USB_ENDPOINT_NAK_TIMEOUT;
00619C  B3C170     MOV #0x17, W0
00619E  370007     BRA 0x61AE
6051:                                              _USB_SetTransferErrorState( pCurrentEndpoint );
6052:                                          }
6053:                                      }
6054:                                      else
6055:                                      {
6056:                                          // Interrupt IN transfers terminate with no error.
6057:                                          pCurrentEndpoint->status.bfTransferSuccessful = 1;
6058:                                          _USB_SetNextTransferState();
6059:                                      }
6060:                                      break;
6061:              
6062:                                  case USB_TRANSFER_TYPE_ISOCHRONOUS:
6063:                                      // Isochronous transfers terminate with no error.
6064:                                      pCurrentEndpoint->status.bfTransferSuccessful = 1;
6065:                                      _USB_SetNextTransferState();
6066:                                      break;
6067:                              }
6068:                          }
6069:                          else if (pBDT->STAT.PID == PID_STALL)
0061A0  238000     MOV #0x3800, W0
0061A2  508F80     SUB W1, W0, [W15]
0061A4  3A000A     BRA NZ, 0x61BA
6070:                          {
6071:                              // Device is stalled.  Stop the transfer, and indicate the stall.
6072:                              // The application must clear this if not a control endpoint.
6073:                              // A stall on a control endpoint does not indicate that the
6074:                              // endpoint is halted.
6075:                              #ifdef DEBUG_MODE
6076:                                  UART2PutChar( '^' );
6077:                              #endif
6078:                              pCurrentEndpoint->status.bfStalled = 1;
0061A6  904024     MOV.B [W4+2], W0
0061A8  A05400     BSET.B W0, #5
0061AA  984220     MOV.B W0, [W4+2]
6079:                              pCurrentEndpoint->bErrorCode       = USB_ENDPOINT_STALLED;
0061AC  B3C110     MOV #0x11, W0
0061AE  985A40     MOV.B W0, [W4+28]
6080:                              _USB_SetTransferErrorState( pCurrentEndpoint );
0061B0  905804     MOV.B [W4+24], W0
0061B2  B3CF01     MOV #0xF0, W1
0061B4  604001     AND.B W0, W1, W0
0061B6  B340F0     IOR.B #0xF, W0
0061B8  37FFAC     BRA 0x6112
6081:                          }
6082:                          else
6083:                          {
6084:                              // Module-defined PID - Bus Timeout (0x0) or Data Error (0x0F).  Increment the error count.
6085:                              // NOTE: If DTS is enabled and the packet has the wrong DTS value, a PID of 0x0F is
6086:                              // returned.  The hardware, however, acknowledges the packet, so the device thinks
6087:                              // that the host has received it.  But the data is not actually received, and the application
6088:                              // layer is not informed of the packet.
6089:                              pCurrentEndpoint->status.bfErrorCount++;
0061BA  9040A4     MOV.B [W4+2], W1
0061BC  E84081     INC.B W1, W1
0061BE  60C0FF     AND.B W1, #0x1F, W1
0061C0  904024     MOV.B [W4+2], W0
0061C2  B3CE02     MOV #0xE0, W2
0061C4  604002     AND.B W0, W2, W0
0061C6  704001     IOR.B W0, W1, W0
0061C8  984220     MOV.B W0, [W4+2]
6090:              
6091:                              if (pCurrentEndpoint->status.bfErrorCount >= USB_TRANSACTION_RETRY_ATTEMPTS)
0061CA  904024     MOV.B [W4+2], W0
0061CC  60007F     AND W0, #0x1F, W0
0061CE  500FF3     SUB W0, #0x13, [W15]
0061D0  34000E     BRA LE, 0x61EE
6092:                              {
6093:                                  // We have too many errors.
6094:              
6095:                                  // Stop the transfer and indicate an error.
6096:                                  // The application must clear this.
6097:                                  pCurrentEndpoint->status.bfError    = 1;
0061D2  904024     MOV.B [W4+2], W0
0061D4  A06400     BSET.B W0, #6
0061D6  984220     MOV.B W0, [W4+2]
6098:                                  pCurrentEndpoint->bErrorCode        = USB_ENDPOINT_ERROR_ILLEGAL_PID;
0061D8  B3C130     MOV #0x13, W0
0061DA  985A40     MOV.B W0, [W4+28]
6099:                                  _USB_SetTransferErrorState( pCurrentEndpoint );
0061DC  905804     MOV.B [W4+24], W0
0061DE  B3CF01     MOV #0xF0, W1
0061E0  604001     AND.B W0, W1, W0
0061E2  B340F0     IOR.B #0xF, W0
0061E4  985A00     MOV.B W0, [W4+24]
6100:              
6101:                                  // Avoid the error interrupt code, because we are going to
6102:                                  // find another token to send.
6103:                                  U1EIR = 0xFF;
0061E6  200FF0     MOV #0xFF, W0
0061E8  882470     MOV W0, U1EIR
6104:                                  U1IR  = USB_INTERRUPT_ERROR;
0061EA  200020     MOV #0x2, W0
0061EC  882450     MOV W0, U1IR
6105:                              }
6106:                              else
6107:                              {
6108:                                  // Fall through.  This will automatically cause the transfer
6109:                                  // to be retried.
6110:                              }
6111:                          }
6112:                      }
6113:                      else
6114:                      {
6115:                          // We have a mismatch between the endpoint we were expecting and the one that we got.
6116:                          // The user may be trying to select a new configuration.  Discard the transaction.
6117:                      }
6118:              
6119:                      _USB_FindNextToken();
0061EE  02167E     CALL _USB_FindNextToken
0061F0  000001     NOP
6120:                  } // U1IRbits.TRNIF
6121:              
6122:              
6123:                  // -------------------------------------------------------------------------
6124:                  // Start-of-Frame ISR
6125:              
6126:                  if (U1IEbits.SOFIE && U1IRbits.SOFIF)
0061F2  BFC48C     MOV.B U1IE, WREG
0061F4  A32800     BTST.Z W0, #2
0061F6  32002C     BRA Z, 0x6250
0061F8  BFC48A     MOV.B U1IR, WREG
0061FA  A32800     BTST.Z W0, #2
0061FC  320029     BRA Z, 0x6250
6127:                  {
6128:                      USB_ENDPOINT_INFO           *pEndpoint;
6129:                      USB_INTERFACE_INFO          *pInterface;
6130:              
6131:                      #if defined(USB_ENABLE_SOF_EVENT) && defined(USB_HOST_APP_DATA_EVENT_HANDLER)
6132:                          //Notify ping all client drivers of SOF event (address, event, data, sizeof_data)
6133:                          _USB_NotifyDataClients(0, EVENT_SOF, NULL, 0);
6134:                      #endif
6135:              
6136:                      #ifdef DEBUG_MODE
6137:              //            UART2PutChar( '$' );
6138:                      #endif
6139:                      U1IR = USB_INTERRUPT_SOF; // Clear the interrupt by writing a '1' to the flag.
0061FE  200040     MOV #0x4, W0
006200  882450     MOV W0, U1IR
6140:              
6141:                      pInterface = usbDeviceInfo.pInterfaceList;
006202  838322     MOV 0x7064, W2
006204  37001A     BRA 0x623A
6142:                      while (pInterface)
00623A  E00002     CP0 W2
00623C  3AFFE4     BRA NZ, 0x6206
6143:                      {
6144:                          if (pInterface->pCurrentSetting)
006206  900022     MOV [W2+4], W0
006208  E00000     CP0 W0
00620A  320016     BRA Z, 0x6238
6145:                          {
6146:                              pEndpoint = pInterface->pCurrentSetting->pEndpointList;
00620C  9000A0     MOV [W0+4], W1
00620E  203004     MOV #0x300, W4
006210  201003     MOV #0x100, W3
006212  370010     BRA 0x6234
6147:                              while (pEndpoint)
006234  E00001     CP0 W1
006236  3AFFEE     BRA NZ, 0x6214
6148:                              {
6149:                                  // Decrement the interval count of all active interrupt and isochronous endpoints.
6150:                                  if ((pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_INTERRUPT) ||
006214  900851     MOV [W1+26], W0
006216  B23000     AND #0x300, W0
006218  500F84     SUB W0, W4, [W15]
00621A  320002     BRA Z, 0x6220
00621C  500F83     SUB W0, W3, [W15]
00621E  3A0006     BRA NZ, 0x622C
6151:                                      (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS))
6152:                                  {
6153:                                      if (pEndpoint->wIntervalCount != 0)
006220  900031     MOV [W1+6], W0
006222  E00000     CP0 W0
006224  320003     BRA Z, 0x622C
6154:                                      {
6155:                                          pEndpoint->wIntervalCount--;
006226  900031     MOV [W1+6], W0
006228  E90000     DEC W0, W0
00622A  9800B0     MOV W0, [W1+6]
6156:                                      }
6157:                                  }
6158:                  
6159:                                  #ifndef ALLOW_MULTIPLE_NAKS_PER_FRAME
6160:                                      pEndpoint->status.bfLastTransferNAKd = 0;
00622C  904031     MOV.B [W1+3], W0
00622E  A14400     BCLR.B W0, #4
006230  9840B0     MOV.B W0, [W1+3]
6161:                                  #endif
6162:                  
6163:                                  pEndpoint = pEndpoint->next;
006232  780091     MOV [W1], W1
6164:                              }
6165:                          }
6166:                          
6167:                          pInterface = pInterface->next;
006238  780112     MOV [W2], W2
6168:                      }
6169:              
6170:                      usbBusInfo.flags.bfControlTransfersDone     = 0;
00623E  2706A0     MOV #0x706A, W0
006240  A10410     BCLR.B [W0], #0
6171:                      usbBusInfo.flags.bfInterruptTransfersDone   = 0;
006242  A11410     BCLR.B [W0], #1
6172:                      usbBusInfo.flags.bfIsochronousTransfersDone = 0;
006244  A12410     BCLR.B [W0], #2
6173:                      usbBusInfo.flags.bfBulkTransfersDone        = 0;
006246  A13410     BCLR.B [W0], #3
6174:                      //usbBusInfo.dBytesSentInFrame                = 0;
6175:                      usbBusInfo.lastBulkTransaction              = 0;
006248  2706C0     MOV #0x706C, W0
00624A  784802     MOV.B W2, [W0]
6176:              
6177:                      _USB_FindNextToken();
00624C  02167E     CALL _USB_FindNextToken
00624E  000001     NOP
6178:                  }
6179:              
6180:                  // -------------------------------------------------------------------------
6181:                  // USB Error ISR
6182:              
6183:                  if (U1IEbits.UERRIE && U1IRbits.UERRIF)
006250  BFC48C     MOV.B U1IE, WREG
006252  A31800     BTST.Z W0, #1
006254  320044     BRA Z, 0x62DE
006256  BFC48A     MOV.B U1IR, WREG
006258  A31800     BTST.Z W0, #1
00625A  320041     BRA Z, 0x62DE
6184:                  {
6185:                      #ifdef DEBUG_MODE
6186:                          UART2PutChar('#');
6187:                          UART2PutHex( U1EIR );
6188:                      #endif
6189:              
6190:                      // The previous token has finished, so clear the way for writing a new one.
6191:                      usbBusInfo.flags.bfTokenAlreadyWritten = 0;
00625C  2706A0     MOV #0x706A, W0
00625E  A14410     BCLR.B [W0], #4
6192:              
6193:                      // If we are doing isochronous transfers, ignore the error.
6194:                      if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
006260  838383     MOV pCurrentEndpoint, W3
006262  905833     MOV.B [W3+27], W0
006264  604063     AND.B W0, #0x3, W0
006266  504FE1     SUB.B W0, #0x1, [W15]
006268  320036     BRA Z, 0x62D6
6195:                      {
6196:              //            pCurrentEndpoint->status.bfTransferSuccessful = 1;
6197:              //            _USB_SetNextTransferState();
6198:                      }
6199:                      else
6200:                      {
6201:                          // Increment the error count.
6202:                          pCurrentEndpoint->status.bfErrorCount++;
00626A  9040A3     MOV.B [W3+2], W1
00626C  E84081     INC.B W1, W1
00626E  60C0FF     AND.B W1, #0x1F, W1
006270  904023     MOV.B [W3+2], W0
006272  B3CE02     MOV #0xE0, W2
006274  604002     AND.B W0, W2, W0
006276  704001     IOR.B W0, W1, W0
006278  9841A0     MOV.B W0, [W3+2]
6203:              
6204:                          if (pCurrentEndpoint->status.bfErrorCount >= USB_TRANSACTION_RETRY_ATTEMPTS)
00627A  904023     MOV.B [W3+2], W0
00627C  60007F     AND W0, #0x1F, W0
00627E  500FF3     SUB W0, #0x13, [W15]
006280  34002A     BRA LE, 0x62D6
6205:                          {
6206:                              // We have too many errors.
6207:              
6208:                              // Check U1EIR for the appropriate error codes to return
6209:                              if (U1EIRbits.BTSEF)
006282  E2448E     CP0.B U1EIR
006284  3D0002     BRA GE, 0x628A
6210:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_BIT_STUFF;
006286  B3C200     MOV #0x20, W0
006288  9859C0     MOV.B W0, [W3+28]
6211:                              if (U1EIRbits.DMAEF)
00628A  BFC48E     MOV.B U1EIR, WREG
00628C  A35800     BTST.Z W0, #5
00628E  320002     BRA Z, 0x6294
6212:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_DMA;
006290  B3C210     MOV #0x21, W0
006292  9859C0     MOV.B W0, [W3+28]
6213:                              if (U1EIRbits.BTOEF)
006294  BFC48E     MOV.B U1EIR, WREG
006296  A34800     BTST.Z W0, #4
006298  320002     BRA Z, 0x629E
6214:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_TIMEOUT;
00629A  B3C220     MOV #0x22, W0
00629C  9859C0     MOV.B W0, [W3+28]
6215:                              if (U1EIRbits.DFN8EF)
00629E  BFC48E     MOV.B U1EIR, WREG
0062A0  A33800     BTST.Z W0, #3
0062A2  320002     BRA Z, 0x62A8
6216:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_DATA_FIELD;
0062A4  B3C230     MOV #0x23, W0
0062A6  9859C0     MOV.B W0, [W3+28]
6217:                              if (U1EIRbits.CRC16EF)
0062A8  BFC48E     MOV.B U1EIR, WREG
0062AA  A32800     BTST.Z W0, #2
0062AC  320002     BRA Z, 0x62B2
6218:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_CRC16;
0062AE  B3C240     MOV #0x24, W0
0062B0  9859C0     MOV.B W0, [W3+28]
6219:                              if (U1EIRbits.EOFEF)
0062B2  BFC48E     MOV.B U1EIR, WREG
0062B4  A31800     BTST.Z W0, #1
0062B6  320002     BRA Z, 0x62BC
6220:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_END_OF_FRAME;
0062B8  B3C250     MOV #0x25, W0
0062BA  9859C0     MOV.B W0, [W3+28]
6221:                              if (U1EIRbits.PIDEF)
0062BC  BFC48E     MOV.B U1EIR, WREG
0062BE  A30800     BTST.Z W0, #0
0062C0  320002     BRA Z, 0x62C6
6222:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_PID_CHECK;
0062C2  B3C260     MOV #0x26, W0
0062C4  9859C0     MOV.B W0, [W3+28]
6223:                              #if defined(__PIC32MX__)
6224:                              if (U1EIRbits.BMXEF)
6225:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_BMX;
6226:                              #endif
6227:              
6228:                              pCurrentEndpoint->status.bfError    = 1;
0062C6  904023     MOV.B [W3+2], W0
0062C8  A06400     BSET.B W0, #6
0062CA  9841A0     MOV.B W0, [W3+2]
6229:              
6230:                              _USB_SetTransferErrorState( pCurrentEndpoint );
0062CC  905803     MOV.B [W3+24], W0
0062CE  B3CF01     MOV #0xF0, W1
0062D0  604001     AND.B W0, W1, W0
0062D2  B340F0     IOR.B #0xF, W0
0062D4  985980     MOV.B W0, [W3+24]
6231:                          }
6232:                      }
6233:              
6234:                      U1EIR = 0xFF;   // Clear the interrupts by writing '1' to the flags.
0062D6  200FF0     MOV #0xFF, W0
0062D8  882470     MOV W0, U1EIR
6235:                      U1IR = USB_INTERRUPT_ERROR; // Clear the interrupt by writing a '1' to the flag.
0062DA  200020     MOV #0x2, W0
0062DC  882450     MOV W0, U1IR
6236:                  }
6237:              }
6238:              
6239:              
6240:              /*************************************************************************
6241:               * EOF usb_host.c
6242:               */
6243:              
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/microchip/common/uart2.c  
1:                 /*
2:                 
3:                 UART2 Driver File for PIC24.
4:                 
5:                 ********************************************************************************
6:                  FileName:        uart2.c
7:                  Dependencies:    HardwareProfile.h
8:                  Processor:       PIC24
9:                  Compiler:        MPLAB C30
10:                 Linker:          MPLAB LINK30
11:                 Company:         Microchip Technology Incorporated
12:                
13:                Author                Date      Comment
14:                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
15:                KO                 12-Feb-2008  Modified to use HardwareProfile.h
16:                KO                 11-Oct-2006  v1.0
17:                Anton Alkhimenok   18-Oct-2005
18:                Anton Alkhimenok   17-Feb-2009  Added UART2Char2Hex(), UART2Hex2Char(), 
19:                									  UART2ClearError(), UART2DataReceived()
20:                PAT				   27-Jan-2010  Added UART2GetBaudError() for dynamic checking
21:                								of baud rate percentage error.
22:                
23:                ********************************************************************************
24:                Software License Agreement
25:                
26:                Microchip Technology Inc. ("Microchip") licenses to you the right to use, copy,
27:                modify and distribute the software - including source code - only for use with
28:                Microchip microcontrollers or Microchip digital signal controllers; provided
29:                that no open source or free software is incorporated into the Source Code
30:                without Microchip?s prior written consent in each instance.
31:                
32:                The software is owned by Microchip and its licensors, and is protected under
33:                applicable copyright laws.  All rights reserved.
34:                
35:                SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT OR
42:                CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING
44:                BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                
46:                ********************************************************************************
47:                */
48:                
49:                #include "Compiler.h"
50:                #include "HardwareProfile.h"
51:                #include "uart2.h"
52:                
53:                //******************************************************************************
54:                // Constants
55:                //******************************************************************************
56:                
57:                //U2BRG register value and baudrate mistake calculation
58:                
59:                #if defined (__C30__)
60:                    #if defined (__dsPIC33E__) || defined (__PIC24E__)
61:                    #define BAUDRATEREG2        (((GetSystemClock())/(BRG_DIV2 * BAUDRATE2)) - 1)
62:                    #else
63:                    #define BAUDRATEREG2        (((GetSystemClock()/2)+(BRG_DIV2/2*BAUDRATE2))/BRG_DIV2/BAUDRATE2-1)
64:                    #endif
65:                #elif defined (__PIC32MX__)
66:                    #define BAUDRATEREG2        ((GetPeripheralClock()+(BRG_DIV2/2*BAUDRATE2))/BRG_DIV2/BAUDRATE2-1)
67:                #else
68:                    #error Cannot calculate BRG value
69:                #endif    
70:                
71:                #if defined (__C30__)
72:                    #if defined (__dsPIC33EP512MU810__)|| defined (__PIC24EP512GU810__)
73:                    #define BAUD_ACTUAL         ((GetSystemClock())/(BRG_DIV2 * (BAUDRATEREG2+1)))
74:                    #else
75:                    #define BAUD_ACTUAL         ((GetSystemClock()/2)/BRG_DIV2/(BAUDRATEREG2+1))
76:                    #endif
77:                #elif defined (__PIC32MX__)
78:                    #define BAUD_ACTUAL         (GetPeripheralClock()/BRG_DIV2/(BAUDRATEREG2+1))
79:                #else
80:                    #error Cannot calculate actual baud rate
81:                #endif    
82:                
83:                
84:                	#define BAUD_ERROR              ((BAUD_ACTUAL > BAUDRATE2) ? BAUD_ACTUAL-BAUDRATE2 : BAUDRATE2-BAUD_ACTUAL)
85:                	#define BAUD_ERROR_PERCENT      ((BAUD_ERROR*100+BAUDRATE2/2)/BAUDRATE2)
86:                	
87:                #if defined (__C30__)
88:                
89:                	#if (BAUD_ERROR_PERCENT > 3)
90:                	    #error UART frequency error is worse than 3%
91:                	#elif (BAUD_ERROR_PERCENT > 2)
92:                	    #warning UART frequency error is worse than 2%
93:                	#endif
94:                
95:                #endif // #if defined (__C30__)
96:                
97:                /*******************************************************************************
98:                Function: UART2GetBaudError()
99:                
100:               Precondition:
101:                   None.
102:               
103:               Overview:
104:                   This routine checks the UART baud rate error percentage and returns it.
105:               
106:               Input: None.
107:               
108:               Output: Returns the baud rate error in percent.
109:               
110:               *******************************************************************************/
111:               char UART2GetBaudError()
112:               {
113:                   unsigned int errorPercent = 0;
114:               
115:               	errorPercent = ((BAUD_ERROR*100+BAUDRATE2/2)/BAUDRATE2);
116:                   return (char)errorPercent;
117:               }
118:               
119:               
120:               /*******************************************************************************
121:               Function: UART2GetChar()
122:               
123:               Precondition:
124:                   UART2Init must be called prior to calling this routine.
125:               
126:               Overview:
127:                   This routine waits for a byte to be received.  It then returns that byte.
128:               
129:               Input: None.
130:               
131:               Output: Byte received.
132:               
133:               *******************************************************************************/
134:               char UART2GetChar()
135:               {
136:                   char Temp;
137:               
138:                   while(IFS1bits.U2RXIF == 0);
0108C6  BFC087     MOV.B 0x87, WREG
0108C8  A36800     BTST.Z W0, #6
0108CA  32FFFD     BRA Z, UART2GetChar
139:               
140:                   Temp = U2RXREG;
0108CC  8011B0     MOV U2RXREG, W0
141:                   IFS1bits.U2RXIF = 0;
0108CE  A9C087     BCLR 0x87, #6
0108D0  FB0000     SE W0, W0
142:                   return Temp;
143:               }
144:               
145:               /*******************************************************************************
146:               Function: UART2Init()
147:               
148:               Precondition: None.
149:               
150:               Overview:
151:                   This routine sets up the UART2 module.
152:               
153:               Input: None.
154:               
155:               Output: None.
156:               
157:               Notes:
158:                   Allow the peripheral to set the I/O pin directions.  If we set the TRIS
159:                   bits manually, then when we disable the UART, the shape of the stop bit
160:                   changes, and some terminal programs have problems.
161:               *******************************************************************************/
162:               void UART2Init()
163:               {
164:                   U2BRG = BAUDRATEREG2;
0108D4  200220     MOV #0x22, W0
0108D6  8811C0     MOV W0, U2BRG
165:                   U2MODE = 0;
0108D8  EB0000     CLR W0
0108DA  881180     MOV W0, U2MODE
166:                   U2MODEbits.BRGH = BRGH2;
0108DC  A86230     BSET U2MODE, #3
167:                   U2STA = 0;
0108DE  881190     MOV W0, U2STA
168:                   U2MODEbits.UARTEN = 1;
0108E0  A8E231     BSET 0x231, #7
169:                   U2STAbits.UTXEN = 1;
0108E2  A84233     BSET 0x233, #2
170:                   IFS1bits.U2RXIF = 0;
0108E4  A9C087     BCLR 0x87, #6
171:                   
172:                   #if defined (__PIC32MX__)
173:                       U2STAbits.URXEN = 1;
174:                   #endif
175:               }
176:               
177:               /*******************************************************************************
178:               Function: UART2IsPressed()
179:               
180:               Precondition:
181:                   UART2Init must be called prior to calling this routine.
182:               
183:               Overview:
184:                   This routine checks to see if there is a new byte in UART reception buffer.
185:               
186:               Input: None.
187:               
188:               Output:
189:                   0 : No new data received.
190:                   1 : Data is in the receive buffer
191:               
192:               *******************************************************************************/
193:               char UART2IsPressed()
194:               {
195:                   if(IFS1bits.U2RXIF == 1)
0108E8  BFC087     MOV.B 0x87, WREG
0108EA  DE0046     LSR W0, #6, W0
0108EC  600061     AND W0, #0x1, W0
196:                       return 1;
197:                   return 0;
198:               }
199:               
200:               /*******************************************************************************
201:               Function: UART2PrintString( char *str )
202:               
203:               Precondition:
204:                   UART2Init must be called prior to calling this routine.
205:               
206:               Overview:
207:                   This function prints a string of characters to the UART.
208:               
209:               Input: Pointer to a null terminated character string.
210:               
211:               Output: None.
212:               
213:               *******************************************************************************/
214:               void UART2PrintString( char *str )
215:               {
216:                   unsigned char c;
217:               
218:                   while( (c = *str++) )
01095C  784031     MOV.B [W1++], W0
01095E  E00400     CP0.B W0
010960  32000A     BRA Z, 0x10976
219:                       UART2PutChar(c);
220:               }
010978  784180     MOV.B W0, W3
221:               
222:               /*******************************************************************************
223:               Function: UART2PutChar( char ch )
224:               
225:               Precondition:
226:                   UART2Init must be called prior to calling this routine.
227:               
228:               Overview:
229:                   This routine writes a character to the transmit FIFO, and then waits for the
230:                   transmit FIFO to be empty.
231:               
232:               Input: Byte to be sent.
233:               
234:               Output: None.
235:               
236:               *******************************************************************************/
237:               void UART2PutChar( char ch )
238:               {
239:                   U2TXREG = ch;
0108F0  FB0000     SE W0, W0
0108F2  8811A0     MOV W0, U2TXREG
010962  FB0000     SE W0, W0
010964  8811A0     MOV W0, U2TXREG
0109A6  784001     MOV.B W1, W0
0109A8  B3C0A2     MOV #0xA, W2
0109AA  BC4004     MUL.B WREG2
0109AC  51C102     SUB.B W3, W2, W2
0109AE  B04302     ADD.B #0x30, W2
0109B0  FB0102     SE W2, W2
0109B2  8811A2     MOV W2, U2TXREG
0109C8  B3C302     MOV #0x30, W2
0109CA  404002     ADD.B W0, W2, W0
0109CC  FB0000     SE W0, W0
0109CE  8811A0     MOV W0, U2TXREG
0109EA  B3C302     MOV #0x30, W2
0109EC  404002     ADD.B W0, W2, W0
0109EE  FB0000     SE W0, W0
0109F0  8811A0     MOV W0, U2TXREG
010A00  DE8044     ASR W0, #4, W0
010A02  60006F     AND W0, #0xF, W0
010A04  2EE5A2     MOV #0xEE5A, W2
010A06  784062     MOV.B [W2+W0], W0
010A08  FB0000     SE W0, W0
010A0A  8811A0     MOV W0, U2TXREG
010A14  60806F     AND W1, #0xF, W0
010A16  784062     MOV.B [W2+W0], W0
010A18  FB0000     SE W0, W0
010A1A  8811A0     MOV W0, U2TXREG
010A28  DE004C     LSR W0, #12, W0
010A2A  2EE5A2     MOV #0xEE5A, W2
010A2C  784062     MOV.B [W2+W0], W0
010A2E  FB0000     SE W0, W0
010A30  8811A0     MOV W0, U2TXREG
010A3A  DE0848     LSR W1, #8, W0
010A3C  60006F     AND W0, #0xF, W0
010A3E  784062     MOV.B [W2+W0], W0
010A40  FB0000     SE W0, W0
010A42  8811A0     MOV W0, U2TXREG
010A4C  DE0844     LSR W1, #4, W0
010A4E  60006F     AND W0, #0xF, W0
010A50  784062     MOV.B [W2+W0], W0
010A52  FB0000     SE W0, W0
010A54  8811A0     MOV W0, U2TXREG
010A5E  60806F     AND W1, #0xF, W0
010A60  784062     MOV.B [W2+W0], W0
010A62  FB0000     SE W0, W0
010A64  8811A0     MOV W0, U2TXREG
010A72  DE084C     LSR W1, #12, W0
010A74  60006F     AND W0, #0xF, W0
010A76  2EE5A4     MOV #0xEE5A, W4
010A78  784064     MOV.B [W4+W0], W0
010A7A  FB0000     SE W0, W0
010A7C  8811A0     MOV W0, U2TXREG
010A86  DE1848     LSR W3, #8, W0
010A88  200001     MOV #0x0, W1
010A8A  60006F     AND W0, #0xF, W0
010A8C  784064     MOV.B [W4+W0], W0
010A8E  FB0000     SE W0, W0
010A90  8811A0     MOV W0, U2TXREG
010A9A  DE1844     LSR W3, #4, W0
010A9C  200001     MOV #0x0, W1
010A9E  60006F     AND W0, #0xF, W0
010AA0  784064     MOV.B [W4+W0], W0
010AA2  FB0000     SE W0, W0
010AA4  8811A0     MOV W0, U2TXREG
010AAE  DE1840     LSR W3, #0, W0
010AB0  200001     MOV #0x0, W1
010AB2  60006F     AND W0, #0xF, W0
010AB4  784064     MOV.B [W4+W0], W0
010AB6  FB0000     SE W0, W0
010AB8  8811A0     MOV W0, U2TXREG
010AC2  DD1AC4     SL W3, #4, W5
010AC4  DE104C     LSR W2, #12, W0
010AC6  728000     IOR W5, W0, W0
010AC8  DE18CC     LSR W3, #12, W1
010ACA  60006F     AND W0, #0xF, W0
010ACC  784064     MOV.B [W4+W0], W0
010ACE  FB0000     SE W0, W0
010AD0  8811A0     MOV W0, U2TXREG
010ADA  DD1AC8     SL W3, #8, W5
010ADC  DE1048     LSR W2, #8, W0
010ADE  728000     IOR W5, W0, W0
010AE0  DE18C8     LSR W3, #8, W1
010AE2  60006F     AND W0, #0xF, W0
010AE4  784064     MOV.B [W4+W0], W0
010AE6  FB0000     SE W0, W0
010AE8  8811A0     MOV W0, U2TXREG
010AF2  DD1ACC     SL W3, #12, W5
010AF4  DE1044     LSR W2, #4, W0
010AF6  728000     IOR W5, W0, W0
010AF8  DE18C4     LSR W3, #4, W1
010AFA  60006F     AND W0, #0xF, W0
010AFC  784064     MOV.B [W4+W0], W0
010AFE  FB0000     SE W0, W0
010B00  8811A0     MOV W0, U2TXREG
010B0A  61006F     AND W2, #0xF, W0
010B0C  784064     MOV.B [W4+W0], W0
010B0E  FB0000     SE W0, W0
010B10  8811A0     MOV W0, U2TXREG
240:                   #if !defined(__PIC32MX__)
241:                       Nop();
0108F4  000000     NOP
010966  000000     NOP
0109B4  000000     NOP
0109D0  000000     NOP
0109F2  000000     NOP
010A0C  000000     NOP
010A1C  000000     NOP
010A32  000000     NOP
010A44  000000     NOP
010A56  000000     NOP
010A66  000000     NOP
010A7E  000000     NOP
010A92  000000     NOP
010AA6  000000     NOP
010ABA  000000     NOP
010AD2  000000     NOP
010AEA  000000     NOP
010B02  000000     NOP
010B12  000000     NOP
242:                   #endif
243:                   while(U2STAbits.TRMT == 0);
0108F6  BFC233     MOV.B 0x233, WREG
0108F8  A30800     BTST.Z W0, #0
0108FA  32FFFD     BRA Z, 0x108F6
010968  BFC233     MOV.B 0x233, WREG
01096A  A30800     BTST.Z W0, #0
01096C  3AFFF7     BRA NZ, 0x1095C
01096E  BFC233     MOV.B 0x233, WREG
010970  A30800     BTST.Z W0, #0
010972  32FFFA     BRA Z, 0x10968
010974  37FFF3     BRA 0x1095C
0109B6  BFC233     MOV.B 0x233, WREG
0109B8  A30800     BTST.Z W0, #0
0109BA  32FFFD     BRA Z, 0x109B6
0109D2  BFC233     MOV.B 0x233, WREG
0109D4  A30800     BTST.Z W0, #0
0109D6  3AFFE7     BRA NZ, 0x109A6
0109D8  BFC233     MOV.B 0x233, WREG
0109DA  A30800     BTST.Z W0, #0
0109DC  32FFFA     BRA Z, 0x109D2
0109DE  37FFE3     BRA 0x109A6
0109FE  780080     MOV W0, W1
010A0E  BFC233     MOV.B 0x233, WREG
010A10  A30800     BTST.Z W0, #0
010A12  32FFFD     BRA Z, 0x10A0E
010A1E  BFC233     MOV.B 0x233, WREG
010A20  A30800     BTST.Z W0, #0
010A22  32FFFD     BRA Z, 0x10A1E
010A34  BFC233     MOV.B 0x233, WREG
010A36  A30800     BTST.Z W0, #0
010A38  32FFFD     BRA Z, 0x10A34
010A46  BFC233     MOV.B 0x233, WREG
010A48  A30800     BTST.Z W0, #0
010A4A  32FFFD     BRA Z, 0x10A46
010A58  BFC233     MOV.B 0x233, WREG
010A5A  A30800     BTST.Z W0, #0
010A5C  32FFFD     BRA Z, 0x10A58
010A68  BFC233     MOV.B 0x233, WREG
010A6A  A30800     BTST.Z W0, #0
010A6C  32FFFD     BRA Z, 0x10A68
010A80  BFC233     MOV.B 0x233, WREG
010A82  A30800     BTST.Z W0, #0
010A84  32FFFD     BRA Z, 0x10A80
010A94  BFC233     MOV.B 0x233, WREG
010A96  A30800     BTST.Z W0, #0
010A98  32FFFD     BRA Z, 0x10A94
010AA8  BFC233     MOV.B 0x233, WREG
010AAA  A30800     BTST.Z W0, #0
010AAC  32FFFD     BRA Z, 0x10AA8
010ABC  BFC233     MOV.B 0x233, WREG
010ABE  A30800     BTST.Z W0, #0
010AC0  32FFFD     BRA Z, 0x10ABC
010AD4  BFC233     MOV.B 0x233, WREG
010AD6  A30800     BTST.Z W0, #0
010AD8  32FFFD     BRA Z, 0x10AD4
010AEC  BFC233     MOV.B 0x233, WREG
010AEE  A30800     BTST.Z W0, #0
010AF0  32FFFD     BRA Z, 0x10AEC
010B04  BFC233     MOV.B 0x233, WREG
010B06  A30800     BTST.Z W0, #0
010B08  32FFFD     BRA Z, 0x10B04
010B14  BFC233     MOV.B 0x233, WREG
010B16  A30800     BTST.Z W0, #0
010B18  32FFFD     BRA Z, 0x10B14
244:               }
0108FE  784080     MOV.B W0, W1
245:               
246:               /*******************************************************************************
247:               Function: UART2PutDec(unsigned char dec)
248:               
249:               Precondition:
250:                   UART2Init must be called prior to calling this routine.
251:               
252:               Overview:
253:                   This function converts decimal data into a string and outputs it to UART.
254:               
255:               Input: Binary data.
256:               
257:               Output: None.
258:               
259:               *******************************************************************************/
260:               void  UART2PutDec(unsigned char dec)
261:               {
262:                   unsigned char res;
263:                   unsigned char printed_already = 0;
264:               
265:                   res = dec;
266:               
267:                   if (res/100)
01097A  B3C630     MOV #0x63, W0
01097C  51CF80     SUB.B W3, W0, [W15]
01097E  3E0030     BRA GTU, 0x109E0
010980  FB8003     ZE W3, W0
010982  200642     MOV #0x64, W2
010984  090011     REPEAT #0x11
010986  D88002     DIV.UW W0, W2
010988  784080     MOV.B W0, W1
01098A  EB4200     CLR.B W4
268:                   {
269:                       UART2PutChar( res/100 + '0' );
0109E0  FB8003     ZE W3, W0
0109E2  200642     MOV #0x64, W2
0109E4  090011     REPEAT #0x11
0109E6  D88002     DIV.UW W0, W2
0109E8  784080     MOV.B W0, W1
270:                       printed_already = 1;
271:                   }
272:                   res = res - (res/100)*100;
01098C  FB8001     ZE W1, W0
01098E  200642     MOV #0x64, W2
010990  B98002     MUL.SS W0, W2, W0
010992  51C180     SUB.B W3, W0, W3
273:               
274:                   if ((res/10) || (printed_already == 1))
010994  51CFE9     SUB.B W3, #0x9, [W15]
010996  3E0013     BRA GTU, 0x109BE
010998  524FE1     SUB.B W4, #0x1, [W15]
01099A  320011     BRA Z, 0x109BE
01099C  FB8003     ZE W3, W0
01099E  2000A2     MOV #0xA, W2
0109A0  090011     REPEAT #0x11
0109A2  D88002     DIV.UW W0, W2
0109A4  784080     MOV.B W0, W1
275:                   {
276:                       UART2PutChar( res/10 + '0' );
0109BE  FB8003     ZE W3, W0
0109C0  2000A2     MOV #0xA, W2
0109C2  090011     REPEAT #0x11
0109C4  D88002     DIV.UW W0, W2
0109C6  784080     MOV.B W0, W1
277:                   }
278:                   res = res - (res/10)*10;
279:               
280:                   UART2PutChar( res + '0' );
281:               }
0109BC  060000     RETURN
282:               
283:               /*******************************************************************************
284:               Function: UART2PutHex
285:               
286:               Precondition:
287:                   UART2Init must be called prior to calling this routine.
288:               
289:               Overview:
290:                   This function converts hex data into a string and outputs it to UART.
291:               
292:               Input: Binary data.
293:               
294:               Output: None.
295:               
296:               *******************************************************************************/
297:               
298:               const unsigned char CharacterArray[]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
299:               
300:               void UART2PutHex( int toPrint )
301:               {
302:                   int printVar;
303:               
304:                   printVar = toPrint;
305:                   toPrint = (toPrint>>4) & 0x0F;
306:                   UART2PutChar( CharacterArray[toPrint] );
307:               
308:                   toPrint = printVar & 0x0F;
309:                   UART2PutChar( CharacterArray[toPrint] );
310:               
311:                   return;
312:               }
010A26  780080     MOV W0, W1
313:               
314:               /*******************************************************************************
315:               Function: UART2PutHexWord(unsigned int toPrint)
316:               
317:               Precondition:
318:                   UART2Init must be called prior to calling this routine.
319:               
320:               Overview:
321:                   This function converts hex data into a string and outputs it to UART.
322:               
323:               Input: Binary data.
324:               
325:               Output: None.
326:               
327:               *******************************************************************************/
328:               #if defined( __C30__ ) || defined( __PIC32MX__ )
329:               void UART2PutHexWord( unsigned int toPrint )
330:               {
331:                   unsigned int printVar;
332:               
333:                   printVar = (toPrint>>12) & 0x0F;
334:                   UART2PutChar( CharacterArray[printVar] );
335:               
336:                   printVar = (toPrint>>8) & 0x0F;
337:                   UART2PutChar( CharacterArray[printVar] );
338:               
339:                   printVar = (toPrint>>4) & 0x0F;
340:                   UART2PutChar( CharacterArray[printVar] );
341:               
342:                   printVar = toPrint & 0x0F;
343:                   UART2PutChar( CharacterArray[printVar] );
344:               
345:                   return;
346:               }
010A70  BE0100     MOV.D W0, W2
347:               
348:               void UART2PutHexDWord( unsigned long toPrint )
349:               {
350:                   unsigned long printVar;
351:               
352:                   printVar = (toPrint>>28) & 0x0F;
353:                   UART2PutChar( CharacterArray[printVar] );
354:               
355:                   printVar = (toPrint>>24) & 0x0F;
356:                   UART2PutChar( CharacterArray[printVar] );
357:               
358:                   printVar = (toPrint>>20) & 0x0F;
359:                   UART2PutChar( CharacterArray[printVar] );
360:               
361:                   printVar = (toPrint>>16) & 0x0F;
362:                   UART2PutChar( CharacterArray[printVar] );
363:               
364:                   printVar = (toPrint>>12) & 0x0F;
365:                   UART2PutChar( CharacterArray[printVar] );
366:               
367:                   printVar = (toPrint>>8) & 0x0F;
368:                   UART2PutChar( CharacterArray[printVar] );
369:               
370:                   printVar = (toPrint>>4) & 0x0F;
371:                   UART2PutChar( CharacterArray[printVar] );
372:               
373:                   printVar = toPrint & 0x0F;
374:                   UART2PutChar( CharacterArray[printVar] );
375:               
376:                   return;
377:               }
378:               
379:               #endif
380:               
381:               /*********************************************************************
382:               Function: char UART2Char2Hex(char ch)
383:               
384:               PreCondition: none
385:               
386:               Input: ASCII to be converted
387:               
388:               Output: number
389:               
390:               Side Effects: none
391:               
392:               Overview: converts ASCII coded digit into number
393:               
394:               Note: none
395:               
396:               ********************************************************************/
397:               char UART2Char2Hex(char ch){
398:                 // Wrong char
399:                 if(ch > 102)
010900  B3C660     MOV #0x66, W0
010902  50CF80     SUB.B W1, W0, [W15]
010904  3C0013     BRA GT, 0x1092C
400:                   return 0;  
401:                 
402:                 // From a to f     
403:                 if(ch > 96)
010906  504066     SUB.B W0, #0x6, W0
010908  50CF80     SUB.B W1, W0, [W15]
01090A  3C0011     BRA GT, 0x1092E
404:                   return (ch-87);
01092E  B3CA90     MOV #0xA9, W0
010930  40C000     ADD.B W1, W0, W0
010932  FB0000     SE W0, W0
010934  060000     RETURN
405:                   
406:                 // Wrong char    
407:                 if(ch > 70)
01090C  B3C460     MOV #0x46, W0
01090E  50CF80     SUB.B W1, W0, [W15]
010910  3C000D     BRA GT, 0x1092C
408:                   return 0;
409:                 
410:                 // From A to F    
411:                 if(ch > 64)
010912  504066     SUB.B W0, #0x6, W0
010914  50CF80     SUB.B W1, W0, [W15]
010916  3C000F     BRA GT, 0x10936
412:                   return (ch-55);
413:               
414:                 // Wrong char  
415:                 if(ch > 57)
010918  B3C390     MOV #0x39, W0
01091A  50CF80     SUB.B W1, W0, [W15]
01091C  3C0007     BRA GT, 0x1092C
416:                   return 0;
417:                 
418:                 // From 0 - 9
419:                 if(ch > 47)
01091E  50406A     SUB.B W0, #0xA, W0
010920  50CF80     SUB.B W1, W0, [W15]
010922  340004     BRA LE, 0x1092C
420:                   return(ch-48);
010924  B3CD00     MOV #0xD0, W0
010926  40C000     ADD.B W1, W0, W0
010928  FB0000     SE W0, W0
01092A  060000     RETURN
01092C  050000     RETLW #0x0, W0
421:                 else
422:                 // Wrong char
423:                   return 0;
424:               }
425:               
426:               /*********************************************************************
427:               Function: char UART2Hex2Char(char hex)
428:               
429:               PreCondition: none
430:               
431:               Input: number
432:               
433:               Output: ASCII code
434:               
435:               Side Effects: none
436:               
437:               Overview: converts low nibble into ASCII coded digit
438:               
439:               Note: none
440:               
441:               ********************************************************************/
442:               char UART2Hex2Char(char hex){
443:               char h;
444:                 h = hex&0x0f;
01093E  60406F     AND.B W0, #0xF, W0
445:                 // From 0xa to 0xf
446:                 if(h>9)
010940  504FE9     SUB.B W0, #0x9, [W15]
010942  340003     BRA LE, 0x1094A
447:                   return (h+55);
010944  B04370     ADD.B #0x37, W0
010946  FB0000     SE W0, W0
010948  060000     RETURN
448:                 else
449:                   return (h+48);
01094A  B04300     ADD.B #0x30, W0
01094C  FB0000     SE W0, W0
450:               }
451:               
452:               /*********************************************************************
453:               Function: void UART2ClrError(void)
454:               
455:               PreCondition: none
456:               
457:               Input: none
458:               
459:               Output: character received
460:               
461:               Side Effects: none
462:               
463:               Overview: wait for character
464:               
465:               Note: none
466:               
467:               ********************************************************************/
468:               void UART2ClrError(void){
469:                   // Clear error flag
470:                   if(U2STAbits.OERR)
010950  BFC232     MOV.B U2STA, WREG
010952  A31800     BTST.Z W0, #1
010954  320001     BRA Z, 0x10958
471:               		U2STAbits.OERR = 0;
01095A  780080     MOV W0, W1
472:               }
473:               
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libusb/usb_host_bluetooth.c
013136  BE9F88     MOV.D W8, [W15++]
013138  781F8A     MOV W10, [W15++]
01313A  784400     MOV.B W0, W8
01313C  784481     MOV.B W1, W9
01313E  780504     MOV W4, W10
0131F8  FA0006     LNK #0x6
0131FA  781F88     MOV W8, [W15++]
01486E  BE9F88     MOV.D W8, [W15++]
014870  780400     MOV W0, W8
014872  780301     MOV W1, W6
0157A4  780181     MOV W1, W3
0158B6  BE9F88     MOV.D W8, [W15++]
0158B8  780400     MOV W0, W8
01656A  780080     MOV W0, W1
016576  780080     MOV W0, W1
016582  780080     MOV W0, W1
01658E  780080     MOV W0, W1
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                #include <stdlib.h>
30:                #include <string.h>
31:                #include <assert.h>
32:                
33:                #include "GenericTypeDefs.h"
34:                #include "USB/usb.h"
35:                #include "usb_config.h"
36:                #include "usb_host_bluetooth.h"
37:                #include "logging.h"
38:                
39:                BLUETOOTH_DEVICE gc_BluetoothDevData;
40:                
41:                #define FOUND_BULK_IN   0x01
42:                #define FOUND_BULK_OUT  0x02
43:                #define FOUND_INTERRUPT 0x04
44:                #define FOUND_ALL       0x07
45:                
46:                BOOL USBHostBluetoothInit(BYTE address,
47:                                          DWORD flags,
48:                                          BYTE clientDriverID,
49:                                          USB_DEVICE_INFO *pDevInfo,
50:                                          USB_INTERFACE_INFO *pIntInfo) {
51:                  USB_DEVICE_DESCRIPTOR *pDev;
52:                  USB_ENDPOINT_INFO *pEndpoint;
53:                
54:                  log_printf("USBHostBluetoothInit(0x%x, 0x%lx, 0x%x)", address, flags, clientDriverID);
55:                
56:                  // Initialize state
57:                  memset(&gc_BluetoothDevData, 0, sizeof gc_BluetoothDevData);
013140  200222     MOV #0x22, W2
013142  EB0080     CLR W1
013144  26E3C0     MOV #0x6E3C, W0
013146  025720     CALL memset
013148  000000     NOP
58:                  
59:                  // Save device the address, VID, & PID
60:                  gc_BluetoothDevData.ID.deviceAddress = address;
01314A  26E400     MOV #0x6E40, W0
01314C  784808     MOV.B W8, [W0]
61:                  pDev = (USB_DEVICE_DESCRIPTOR *) USBHostGetDeviceDescriptor(address);
01314E  838892     MOV pDeviceDescriptor, W2
62:                  gc_BluetoothDevData.ID.vid  =  pDev->idVendor;
013150  904882     MOV.B [W2+8], W1
013152  FB8081     ZE W1, W1
013154  904812     MOV.B [W2+9], W0
013156  DD0048     SL W0, #8, W0
013158  700001     IOR W0, W1, W0
01315A  8B71E0     MOV W0, gc_BluetoothDevData
63:                  gc_BluetoothDevData.ID.pid  =  pDev->idProduct;
01315C  9048A2     MOV.B [W2+10], W1
01315E  FB8081     ZE W1, W1
013160  904832     MOV.B [W2+11], W0
013162  DD0048     SL W0, #8, W0
013164  700001     IOR W0, W1, W0
013166  8B71F0     MOV W0, 0x6E3E
64:                  gc_BluetoothDevData.driverID = clientDriverID;
013168  26E440     MOV #0x6E44, W0
01316A  784809     MOV.B W9, [W0]
65:                
66:                  // We're looking for an interface with:
67:                  // - class 0xe0 subclass 0x01 protocol 0x01
68:                  // - one bulk in, one bulk out, and one interrupt endpoints.
69:                  // When found, save the endpoint addresses for the interfaces
70:                  for (pIntInfo = pDevInfo->pInterfaceList; pIntInfo; pIntInfo = pIntInfo->next) {
01316C  9001FA     MOV [W10+14], W3
01316E  370032     BRA 0x131D4
0131D2  780193     MOV [W3], W3
0131D4  E00003     CP0 W3
0131D6  3AFFCC     BRA NZ, 0x13170
0131D8  780003     MOV W3, W0
0131DA  37000B     BRA 0x131F2
71:                    log_printf("Encoutered interface %d, class 0x%x, subclass 0x%x, protocol, 0x%x",
72:                        pIntInfo->interface, pIntInfo->type.cls, pIntInfo->type.subcls, pIntInfo->type.proto);
73:                
74:                    if (pIntInfo->type.cls != 0xE0
013170  9000C3     MOV [W3+8], W1
013172  201E00     MOV #0x1E0, W0
013174  508F80     SUB W1, W0, [W15]
013176  3A002D     BRA NZ, 0x131D2
013178  904823     MOV.B [W3+10], W0
01317A  504FE1     SUB.B W0, #0x1, [W15]
01317C  3A002A     BRA NZ, 0x131D2
75:                        || pIntInfo->type.subcls != 0x01
76:                        || pIntInfo->type.proto != 0x01) continue;
77:                
78:                    unsigned int found = 0;
79:                
80:                    for (pEndpoint = pIntInfo->pCurrentSetting->pEndpointList;
01317E  900023     MOV [W3+4], W0
013180  9002A0     MOV [W0+4], W5
013182  EB0200     CLR W4
013184  202006     MOV #0x200, W6
013186  26E469     MOV #0x6E46, W9
013188  26E528     MOV #0x6E52, W8
01318A  26E4C7     MOV #0x6E4C, W7
01318C  37001D     BRA 0x131C8
01318E  900855     MOV [W5+26], W0
81:                         pEndpoint;
0131C8  E00005     CP0 W5
0131CA  3AFFE1     BRA NZ, 0x1318E
82:                         pEndpoint = pEndpoint->next) {
0131C6  780295     MOV [W5], W5
83:                      if (pEndpoint->bEndpointAddress & 0x80
013190  905925     MOV.B [W5+26], W2
013192  E00402     CP0.B W2
013194  3D0009     BRA GE, 0x131A8
013196  780080     MOV W0, W1
013198  B23001     AND #0x300, W1
01319A  508F86     SUB W1, W6, [W15]
01319C  3A000D     BRA NZ, 0x131B8
01319E  A30804     BTST.Z W4, #0
0131A0  3A0015     BRA NZ, 0x131CC
84:                          && pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_BULK
85:                          && !(found & FOUND_BULK_IN)) {
86:                        // found bulk input
87:                        gc_BluetoothDevData.bulkIn.address = pEndpoint->bEndpointAddress;
0131A2  784C82     MOV.B W2, [W9]
88:                        found |= FOUND_BULK_IN;
0131A4  A00004     BSET W4, #0
0131A6  37000F     BRA 0x131C6
89:                      } else if (!(pEndpoint->bEndpointAddress & 0x80)
0131A8  B23000     AND #0x300, W0
0131AA  500F86     SUB W0, W6, [W15]
0131AC  3A000F     BRA NZ, 0x131CC
0131AE  A31804     BTST.Z W4, #1
0131B0  3A000D     BRA NZ, 0x131CC
90:                          && pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_BULK
91:                          && !(found & FOUND_BULK_OUT)) {
92:                        // found bulk input
93:                        gc_BluetoothDevData.bulkOut.address = pEndpoint->bEndpointAddress;
0131B2  784C02     MOV.B W2, [W8]
94:                        found |= FOUND_BULK_OUT;
0131B4  A01004     BSET W4, #1
0131B6  370007     BRA 0x131C6
95:                      } else if (pEndpoint->bEndpointAddress & 0x80
0131B8  203000     MOV #0x300, W0
0131BA  508F80     SUB W1, W0, [W15]
0131BC  3A0007     BRA NZ, 0x131CC
0131BE  A32804     BTST.Z W4, #2
0131C0  3A0005     BRA NZ, 0x131CC
96:                          && pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_INTERRUPT
97:                          && !(found & FOUND_INTERRUPT)) {
98:                        // found bulk input
99:                        gc_BluetoothDevData.intIn.address = pEndpoint->bEndpointAddress;
0131C2  784B82     MOV.B W2, [W7]
100:                       found |= FOUND_INTERRUPT;
0131C4  A02004     BSET W4, #2
101:                     } else {
102:                       break;
103:                     }
104:                   }
105:                   if ((found & FOUND_ALL) == FOUND_ALL) {
0131CC  620067     AND W4, #0x7, W0
0131CE  500FE7     SUB W0, #0x7, [W15]
0131D0  320005     BRA Z, 0x131DC
106:                     gc_BluetoothDevData.interface = pIntInfo->interface;
0131DC  26E450     MOV #0x6E45, W0
0131DE  9041E3     MOV.B [W3+6], W3
0131E0  784803     MOV.B W3, [W0]
107:                     goto good;
108:                   }
109:                 }
110:                 // if we got here, a matching interface was not found
111:                 log_printf("Could not find a matching interface");
112:                 return FALSE;
113:               
114:               good:
115:                 gc_BluetoothDevData.initialized = 1;
0131E2  200018     MOV #0x1, W8
0131E4  8B7218     MOV W8, 0x6E42
116:                 log_printf("Bluetooth Client Initalized: flags=0x%lx address=%d VID=0x%x PID=0x%x",
117:                     flags, address, gc_BluetoothDevData.ID.vid, gc_BluetoothDevData.ID.pid);
118:               
119:                 USBHostBluetoothCallback(BLUETOOTH_EVENT_ATTACHED, USB_SUCCESS, NULL, 0);
0131E6  B82260     MUL.UU W4, #0, W4
0131E8  EB0100     CLR W2
0131EA  B80060     MUL.UU W0, #0, W0
0131EC  0244B0     CALL USBHostBluetoothCallback
0131EE  000001     NOP
0131F0  780008     MOV W8, W0
120:                 return TRUE;
121:               }
122:                 
123:               
124:               BOOL USBHostBluetoothEventHandler(BYTE address, USB_EVENT event, void *data, DWORD size) {
125:                 // Make sure it was for our device
126:                 if (address != gc_BluetoothDevData.ID.deviceAddress) return FALSE;
0157A6  EB0100     CLR W2
0157A8  26E401     MOV #0x6E40, W1
0157AA  504F91     SUB.B W0, [W1], [W15]
0157AC  3A0010     BRA NZ, 0x157CE
127:               
128:                 // Handle specific events.
129:                 switch (event) {
0157AE  200012     MOV #0x1, W2
0157B0  200710     MOV #0x71, W0
0157B2  518F80     SUB W3, W0, [W15]
0157B4  3A000C     BRA NZ, 0x157CE
130:                  case EVENT_DETACH:
131:                   memset(&gc_BluetoothDevData, 0, sizeof gc_BluetoothDevData);
0157B6  200222     MOV #0x22, W2
0157B8  EB0080     CLR W1
0157BA  26E3C0     MOV #0x6E3C, W0
0157BC  025720     CALL memset
0157BE  000000     NOP
132:                   log_printf("Bluetooth Client Device Detached: address=0x%x", address);
133:                   USBHostBluetoothCallback(BLUETOOTH_EVENT_DETACHED, USB_SUCCESS, NULL, 0);
0157C0  B82260     MUL.UU W4, #0, W4
0157C2  EB0100     CLR W2
0157C4  EB0080     CLR W1
0157C6  200010     MOV #0x1, W0
0157C8  0244B0     CALL USBHostBluetoothCallback
0157CA  000001     NOP
0157CC  EB0100     CLR W2
134:                   break;
135:               
136:               #ifdef USB_ENABLE_TRANSFER_EVENT
137:                  case EVENT_BUS_ERROR:
138:                  case EVENT_TRANSFER:
139:                   if ((data != NULL) && (size == sizeof(HOST_TRANSFER_DATA))) {
140:                     DWORD dataCount = ((HOST_TRANSFER_DATA *)data)->dataCount;
141:                     BYTE errorCode = ((HOST_TRANSFER_DATA *)data)->bErrorCode;
142:                     BYTE endPoint = ((HOST_TRANSFER_DATA *)data)->bEndpointAddress;
143:                     BYTE *userData = ((HOST_TRANSFER_DATA *)data)->pUserData;
144:               
145:                     if (endPoint == gc_BluetoothDevData.intIn.address) {
146:                       // if (dataCount) {
147:                       //   log_printf("Received interrupt with error code 0x%x, %ld bytes: ", errorCode, dataCount);
148:                       //   log_print_buf(userData, dataCount);
149:                       // }
150:                       USBHostBluetoothCallback(BLUETOOTH_EVENT_READ_INTERRUPT_DONE,
151:                                                errorCode,
152:                                                userData, dataCount);
153:                       gc_BluetoothDevData.intIn.busy = 0;
154:                       return TRUE;
155:                     }
156:                     if (endPoint == gc_BluetoothDevData.bulkIn.address) {
157:                       // if (dataCount) {
158:                       //   log_printf("Received message with %ld bytes: ", dataCount);
159:                       //   log_print_buf(userData, dataCount);
160:                       // }
161:                       USBHostBluetoothCallback(BLUETOOTH_EVENT_READ_BULK_DONE,
162:                                                errorCode,
163:                                                userData, dataCount);
164:                       gc_BluetoothDevData.bulkIn.busy = 0;
165:                       return TRUE;
166:                     }
167:                     if (endPoint == gc_BluetoothDevData.bulkOut.address) {
168:                       // log_printf("bulk out done: %d", ((HOST_TRANSFER_DATA *)data)->bErrorCode);
169:                       USBHostBluetoothCallback(BLUETOOTH_EVENT_WRITE_BULK_DONE,
170:                                                errorCode,
171:                                                NULL, 0);
172:                       gc_BluetoothDevData.bulkOut.busy = 0;
173:                       return TRUE;
174:                     }
175:                     if (endPoint == gc_BluetoothDevData.ctrlOut.address) {
176:                       // log_printf("ctrl out done: %d", ((HOST_TRANSFER_DATA *)data)->bErrorCode);
177:                       USBHostBluetoothCallback(BLUETOOTH_EVENT_WRITE_CONTROL_DONE,
178:                                                errorCode,
179:                                                NULL, 0);
180:                       gc_BluetoothDevData.ctrlOut.busy = 0;
181:                       return TRUE;
182:                     }
183:                   }
184:                   return FALSE;
185:               #endif
186:               
187:                  case EVENT_SUSPEND:
188:                  case EVENT_RESUME:
189:                  default:
190:                   return TRUE;
191:                 }
192:                 return FALSE;
193:               }
194:               
195:               
196:               void USBHostBluetoothGetDeviceId(USB_DEVICE_ID *pDevID) {
197:                 assert(gc_BluetoothDevData.initialized);
198:                 assert(pDevID != NULL);
199:                 *pDevID = gc_BluetoothDevData.ID;
01655E  8371E2     MOV gc_BluetoothDevData, W2
016560  8371F3     MOV 0x6E3E, W3
016562  BE8802     MOV.D W2, [W0]
016564  837203     MOV 0x6E40, W3
016566  980023     MOV W3, [W0+4]
200:               }
201:               
202:               
203:               void USBHostBluetoothReset() {
204:                 assert(USBHostBluetoothIsDeviceAttached());
205:                 USBHostResetDevice(gc_BluetoothDevData.ID.deviceAddress);
016488  26E400     MOV #0x6E40, W0
01648A  784010     MOV.B [W0], W0
01648C  025FB4     CALL USBHostResetDevice
01648E  000001     NOP
206:                 memset(&gc_BluetoothDevData, 0, sizeof gc_BluetoothDevData);
016490  200222     MOV #0x22, W2
016492  EB0080     CLR W1
016494  26E3C0     MOV #0x6E3C, W0
016496  045720     GOTO memset
016498  000000     NOP
207:               }
208:               
209:               static BYTE USBHostBluetoothRead(BLUETOOTH_ENDPOINT *ep, void *buffer, DWORD length) {
210:                 BYTE RetVal;
211:               
212:                 // Validate the call
213:                 assert(gc_BluetoothDevData.initialized);
214:                 if (ep->busy) return USB_BUSY;
0158BA  900490     MOV [W0+2], W9
0158BC  200020     MOV #0x2, W0
0158BE  E00009     CP0 W9
0158C0  3A000E     BRA NZ, 0x158DE
215:               
216:                 //log_printf("Requested read of %u bytes", (unsigned) length);
217:               
218:                 // Set the busy flag, clear the count and start a new IN transfer.
219:                 ep->busy = 1;
0158C2  200010     MOV #0x1, W0
0158C4  980410     MOV W0, [W8+2]
220:                 ep->data = buffer;
0158C6  980421     MOV W1, [W8+4]
221:                 RetVal = USBHostRead(gc_BluetoothDevData.ID.deviceAddress,
0158C8  BE0202     MOV.D W2, W4
0158CA  780101     MOV W1, W2
0158CC  784098     MOV.B [W8], W1
0158CE  26E400     MOV #0x6E40, W0
0158D0  784010     MOV.B [W0], W0
0158D2  023F00     CALL USBHostRead
0158D4  000001     NOP
222:                                      ep->address,
223:                                      (BYTE *)buffer,
224:                                      length);
225:                 if (RetVal != USB_SUCCESS) {
0158D6  E00400     CP0.B W0
0158D8  320001     BRA Z, 0x158DC
226:                  ep->busy = 0;    // Clear flag to allow re-try
0158DA  980419     MOV W9, [W8+2]
227:                 }
228:                 return RetVal;
0158DC  FB8000     ZE W0, W0
229:               }
230:               
231:               BYTE USBHostBluetoothReadBulk(void *buffer, DWORD length) {
232:                 return USBHostBluetoothRead(&gc_BluetoothDevData.bulkIn, buffer, length);
01656C  26E460     MOV #0x6E46, W0
01656E  0258B6     CALL USBHostBluetoothRead
016570  000001     NOP
016572  FB8000     ZE W0, W0
233:               }
234:               
235:               BYTE USBHostBluetoothReadInt(void *buffer, DWORD length) {
236:                 return USBHostBluetoothRead(&gc_BluetoothDevData.intIn, buffer, length);
016578  26E4C0     MOV #0x6E4C, W0
01657A  0258B6     CALL USBHostBluetoothRead
01657C  000001     NOP
01657E  FB8000     ZE W0, W0
237:               }
238:               
239:               #ifndef USB_ENABLE_TRANSFER_EVENT
240:               void USBHostBluetoothTasks(void) {
241:                 DWORD   byteCount;
242:                 BYTE    errorCode;
243:               
244:                 if (gc_BluetoothDevData.ID.deviceAddress && gc_BluetoothDevData.initialized) {
0131FC  26E400     MOV #0x6E40, W0
0131FE  784210     MOV.B [W0], W4
013200  E00404     CP0.B W4
013202  320058     BRA Z, 0x132B4
013204  26E420     MOV #0x6E42, W0
013206  E00010     CP0 [W0]
013208  320055     BRA Z, 0x132B4
245:                   if (gc_BluetoothDevData.intIn.busy) {
01320A  26E4E8     MOV #0x6E4E, W8
01320C  E00018     CP0 [W8]
01320E  320012     BRA Z, 0x13234
246:                     if (USBHostTransferIsComplete(gc_BluetoothDevData.ID.deviceAddress,
013210  5781E6     SUB W15, #0x6, W3
013212  578168     SUB W15, #0x8, W2
013214  26E4C0     MOV #0x6E4C, W0
013216  784090     MOV.B [W0], W1
013218  784004     MOV.B W4, W0
01321A  02422A     CALL USBHostTransferIsComplete
01321C  000001     NOP
01321E  E00000     CP0 W0
013220  320009     BRA Z, 0x13234
247:                                                   gc_BluetoothDevData.intIn.address,
248:                                                   &errorCode,
249:                                                   &byteCount)) {
250:               //        if (byteCount) {
251:               //          log_printf("Received interrupt with error code 0x%x, %ld bytes: ",
252:               //                     errorCode, byteCount);
253:               //          log_print_buf(gc_BluetoothDevData.intIn.data, byteCount);
254:               //        }
255:                       gc_BluetoothDevData.intIn.busy = 0;
013222  EB0C00     CLR [W8]
256:                       USBHostBluetoothCallback(BLUETOOTH_EVENT_READ_INTERRUPT_DONE,
013224  97F80F     MOV.B [W15-8], W0
013226  FB8080     ZE W0, W1
013228  97BA5F     MOV [W15-6], W4
01322A  97BAEF     MOV [W15-4], W5
01322C  837282     MOV 0x6E50, W2
01322E  200030     MOV #0x3, W0
013230  0244B0     CALL USBHostBluetoothCallback
013232  000001     NOP
257:                                                errorCode,
258:                                                gc_BluetoothDevData.intIn.data, byteCount);
259:                     }
260:                   }
261:               
262:                   if (gc_BluetoothDevData.bulkIn.busy) {
013234  26E488     MOV #0x6E48, W8
013236  E00018     CP0 [W8]
013238  320013     BRA Z, 0x13260
263:                     if (USBHostTransferIsComplete(gc_BluetoothDevData.ID.deviceAddress,
01323A  5781E6     SUB W15, #0x6, W3
01323C  578168     SUB W15, #0x8, W2
01323E  26E460     MOV #0x6E46, W0
013240  784090     MOV.B [W0], W1
013242  26E400     MOV #0x6E40, W0
013244  784010     MOV.B [W0], W0
013246  02422A     CALL USBHostTransferIsComplete
013248  000001     NOP
01324A  E00000     CP0 W0
01324C  320009     BRA Z, 0x13260
264:                                                   gc_BluetoothDevData.bulkIn.address,
265:                                                   &errorCode,
266:                                                   &byteCount)) {
267:               //        if (byteCount) {
268:               //          log_printf("Received bulk with error code 0x%x, %ld bytes: ",
269:               //                     errorCode, byteCount);
270:               //          log_print_buf(gc_BluetoothDevData.bulkIn.data, byteCount);
271:               //        }
272:                       gc_BluetoothDevData.bulkIn.busy = 0;
01324E  EB0C00     CLR [W8]
273:                       USBHostBluetoothCallback(BLUETOOTH_EVENT_READ_BULK_DONE,
013250  97F80F     MOV.B [W15-8], W0
013252  FB8080     ZE W0, W1
013254  97BA5F     MOV [W15-6], W4
013256  97BAEF     MOV [W15-4], W5
013258  837252     MOV 0x6E4A, W2
01325A  200020     MOV #0x2, W0
01325C  0244B0     CALL USBHostBluetoothCallback
01325E  000001     NOP
274:                                                errorCode,
275:                                                gc_BluetoothDevData.bulkIn.data, byteCount);
276:                     }
277:                   }
278:               
279:                   if (gc_BluetoothDevData.bulkOut.busy) {
013260  26E548     MOV #0x6E54, W8
013262  E00018     CP0 [W8]
013264  320012     BRA Z, 0x1328A
280:                     if (USBHostTransferIsComplete(gc_BluetoothDevData.ID.deviceAddress,
013266  5781E6     SUB W15, #0x6, W3
013268  578168     SUB W15, #0x8, W2
01326A  26E520     MOV #0x6E52, W0
01326C  784090     MOV.B [W0], W1
01326E  26E400     MOV #0x6E40, W0
013270  784010     MOV.B [W0], W0
013272  02422A     CALL USBHostTransferIsComplete
013274  000001     NOP
013276  E00000     CP0 W0
013278  320008     BRA Z, 0x1328A
281:                                                   gc_BluetoothDevData.bulkOut.address,
282:                                                   &errorCode,
283:                                                   &byteCount)) {
284:                       gc_BluetoothDevData.bulkOut.busy = 0;
01327A  EB0C00     CLR [W8]
285:                       USBHostBluetoothCallback(BLUETOOTH_EVENT_WRITE_BULK_DONE,
01327C  97F80F     MOV.B [W15-8], W0
01327E  FB8080     ZE W0, W1
013280  B82260     MUL.UU W4, #0, W4
013282  EB0100     CLR W2
013284  200040     MOV #0x4, W0
013286  0244B0     CALL USBHostBluetoothCallback
013288  000001     NOP
286:                                                errorCode,
287:                                                NULL, 0);
288:                     }
289:                   }
290:               
291:                   if (gc_BluetoothDevData.ctrlOut.busy) {
01328A  26E5A8     MOV #0x6E5A, W8
01328C  E00018     CP0 [W8]
01328E  320012     BRA Z, 0x132B4
292:                     if (USBHostTransferIsComplete(gc_BluetoothDevData.ID.deviceAddress,
013290  5781E6     SUB W15, #0x6, W3
013292  578168     SUB W15, #0x8, W2
013294  26E580     MOV #0x6E58, W0
013296  784090     MOV.B [W0], W1
013298  26E400     MOV #0x6E40, W0
01329A  784010     MOV.B [W0], W0
01329C  02422A     CALL USBHostTransferIsComplete
01329E  000001     NOP
0132A0  E00000     CP0 W0
0132A2  320008     BRA Z, 0x132B4
293:                                                   gc_BluetoothDevData.ctrlOut.address,
294:                                                   &errorCode,
295:                                                   &byteCount)) {
296:                       gc_BluetoothDevData.ctrlOut.busy = 0;
0132A4  EB0C00     CLR [W8]
297:                       USBHostBluetoothCallback(BLUETOOTH_EVENT_WRITE_CONTROL_DONE,
0132A6  97F80F     MOV.B [W15-8], W0
0132A8  FB8080     ZE W0, W1
0132AA  B82260     MUL.UU W4, #0, W4
0132AC  EB0100     CLR W2
0132AE  200050     MOV #0x5, W0
0132B0  0244B0     CALL USBHostBluetoothCallback
0132B2  000001     NOP
298:                                                errorCode,
299:                                                NULL, 0);
300:                     }
301:                   }
302:               }
303:               }
304:               #endif  // USB_ENABLE_TRANSFER_EVENT
305:               
306:               static BYTE USBHostBluetoothWrite(BLUETOOTH_ENDPOINT *ep, const void *buffer, DWORD length) {
307:                 BYTE RetVal;
308:               
309:                 // Validate the call
310:                 assert(gc_BluetoothDevData.initialized);
311:                 if (ep->busy) return USB_BUSY;
014874  900210     MOV [W0+2], W4
014876  200020     MOV #0x2, W0
014878  E00004     CP0 W4
01487A  3A0020     BRA NZ, 0x148BC
01487C  26E409     MOV #0x6E40, W9
312:               
313:               //  log_printf("Sending message with %u bytes to endpoint 0x%x: ",
314:               //             (unsigned) length,
315:               //             ep->address);
316:               //  log_print_buf(buffer, length);
317:               
318:                 // Set the busy flag and start a new OUT transfer.
319:                 ep->busy = 1;
01487E  200010     MOV #0x1, W0
014880  980410     MOV W0, [W8+2]
320:               
321:                 if (ep->address == 0) {
014882  784098     MOV.B [W8], W1
014884  E00401     CP0.B W1
014886  3A000F     BRA NZ, 0x148A6
322:                   RetVal = USBHostIssueDeviceRequest(gc_BluetoothDevData.ID.deviceAddress,
014888  E8878F     INC2 W15, W15
01488A  26E440     MOV #0x6E44, W0
01488C  784010     MOV.B [W0], W0
01488E  9FFFE0     MOV.B W0, [W15-2]
014890  784384     MOV.B W4, W7
014892  780282     MOV W2, W5
014894  780184     MOV W4, W3
014896  784104     MOV.B W4, W2
014898  B3C201     MOV #0x20, W1
01489A  784019     MOV.B [W9], W0
01489C  022F80     CALL USBHostIssueDeviceRequest
01489E  000001     NOP
0148A0  784080     MOV.B W0, W1
0148A2  E9878F     DEC2 W15, W15
0148A4  370006     BRA 0x148B2
323:                                                      0x20, 0, 0,
324:                                                      0,//gc_BluetoothDevData.interface,
325:                                                      length, (BYTE *) buffer,
326:                                                      USB_DEVICE_REQUEST_SET,
327:                                                      gc_BluetoothDevData.driverID);
328:                 } else {
329:                   RetVal = USBHostWrite(gc_BluetoothDevData.ID.deviceAddress,
0148A6  BE0202     MOV.D W2, W4
0148A8  780106     MOV W6, W2
0148AA  784019     MOV.B [W9], W0
0148AC  023F6A     CALL USBHostWrite
0148AE  000001     NOP
0148B0  784080     MOV.B W0, W1
330:                                         ep->address,
331:                                         (BYTE *)buffer,
332:                                         length);
333:                 }
334:               
335:                 if (RetVal != USB_SUCCESS) {
0148B2  E00401     CP0.B W1
0148B4  320002     BRA Z, 0x148BA
336:                   log_printf("Write failed");
337:                   ep->busy = 0;    // Clear flag to allow re-try
0148B6  EB0000     CLR W0
0148B8  980410     MOV W0, [W8+2]
338:                 }
339:                 return RetVal;
0148BA  FB8001     ZE W1, W0
340:               }
341:               
342:               BYTE USBHostBluetoothWriteBulk(const void *buffer, DWORD length) {
343:                 return USBHostBluetoothWrite(&gc_BluetoothDevData.bulkOut, buffer, length);
016584  26E520     MOV #0x6E52, W0
016586  02486E     CALL USBHostBluetoothWrite
016588  000001     NOP
01658A  FB8000     ZE W0, W0
344:               }
345:               
346:               BYTE USBHostBluetoothWriteControl(const void *buffer, DWORD length) {
347:                 return USBHostBluetoothWrite(&gc_BluetoothDevData.ctrlOut, buffer, length);
016590  26E580     MOV #0x6E58, W0
016592  02486E     CALL USBHostBluetoothWrite
016594  000001     NOP
016596  FB8000     ZE W0, W0
348:               }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libusb/usb_host_android.c  
01403C  FA0006     LNK #0x6
01403E  BE9F88     MOV.D W8, [W15++]
0141CA  784380     MOV.B W0, W7
015138  781F88     MOV W8, [W15++]
01513A  780300     MOV W0, W6
01533A  BE9F88     MOV.D W8, [W15++]
01533C  781F8A     MOV W10, [W15++]
01533E  784500     MOV.B W0, W10
015340  780484     MOV W4, W9
015370  781F88     MOV W8, [W15++]
015372  780300     MOV W0, W6
015CAA  780181     MOV W1, W3
015EE2  780200     MOV W0, W4
016136  780200     MOV W0, W4
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include <stdlib.h>
31:                #include <string.h>
32:                #include <assert.h>
33:                #include "GenericTypeDefs.h"
34:                #include "USB/usb.h"
35:                #include "usb_host_android.h"
36:                
37:                #include "logging.h"
38:                
39:                #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
40:                
41:                ANDROID_DEVICE gc_DevData;
42:                
43:                BOOL USBHostAndroidInitInterface(BYTE address,
44:                                                 DWORD iid,
45:                                                 BYTE clientDriverID,
46:                                                 USB_DEVICE_INFO *pDevInfo,
47:                                                 USB_INTERFACE_INFO *pIntInfo) {
48:                  USB_DEVICE_DESCRIPTOR *pDev = (USB_DEVICE_DESCRIPTOR *) USBHostGetDeviceDescriptor(address);
0141CC  838896     MOV pDeviceDescriptor, W6
49:                  USB_ENDPOINT_INFO *pFirstEpInfo;
50:                  USB_ENDPOINT_INFO *pSecondEpInfo;
51:                  ANDROID_INTERFACE *pInterface;
52:                  log_printf("USBHostAndroidInitInterface(0x%x, 0x%lx, 0x%x)", address, iid, clientDriverID);
53:                  assert(iid < ANDROID_INTERFACE_MAX);
54:                
55:                  pInterface = &gc_DevData.interfaces[iid];
0141CE  B9116A     MUL.SU W2, #10, W2
0141D0  2709E0     MOV #0x709E, W0
0141D2  400182     ADD W0, W2, W3
56:                  pFirstEpInfo = pIntInfo->pCurrentSetting->pEndpointList;
0141D4  900025     MOV [W5+4], W0
0141D6  900120     MOV [W0+4], W2
57:                  if (!pFirstEpInfo) { log_printf("No end-points"); return FALSE; }
0141D8  E00002     CP0 W2
0141DA  320026     BRA Z, 0x14228
58:                  pSecondEpInfo = pFirstEpInfo->next;
0141DC  780092     MOV [W2], W1
59:                  if (!pSecondEpInfo) { log_printf("Only one end-point"); return FALSE; }
0141DE  E00001     CP0 W1
0141E0  320023     BRA Z, 0x14228
60:                  if (pSecondEpInfo->next) { log_printf("Too many end-points"); return FALSE; }
0141E2  E00011     CP0 [W1]
0141E4  3A0021     BRA NZ, 0x14228
0141E6  905821     MOV.B [W1+26], W0
61:                
62:                  if (pFirstEpInfo->bEndpointAddress & 0x80) {
0141E8  905A22     MOV.B [W2+26], W4
0141EA  E00404     CP0.B W4
0141EC  3D0006     BRA GE, 0x141FA
63:                      if (pSecondEpInfo->bEndpointAddress & 0x80) {
0141EE  E00400     CP0.B W0
0141F0  35001B     BRA LT, 0x14228
64:                        log_printf("Need one input and one output end-point");
65:                        return FALSE;
66:                      }
67:                      pInterface->inEndpoint = pFirstEpInfo->bEndpointAddress;
0141F2  9841C4     MOV.B W4, [W3+4]
68:                      pInterface->outEndpoint = pSecondEpInfo->bEndpointAddress;
0141F4  9058A1     MOV.B [W1+26], W1
0141F6  9841D1     MOV.B W1, [W3+5]
0141F8  370005     BRA 0x14204
69:                  } else {
70:                      if (!(pSecondEpInfo->bEndpointAddress & 0x80)) {
0141FA  E00400     CP0.B W0
0141FC  3D0015     BRA GE, 0x14228
71:                        log_printf("Need one input and one output end-point");
72:                        return FALSE;
73:                      }
74:                      pInterface->inEndpoint = pSecondEpInfo->bEndpointAddress;
0141FE  9841C0     MOV.B W0, [W3+4]
75:                      pInterface->outEndpoint = pFirstEpInfo->bEndpointAddress;
014200  905922     MOV.B [W2+26], W2
014202  9841D2     MOV.B W2, [W3+5]
76:                  }
77:                  pInterface->flags.initialized = 1;
014204  900043     MOV [W3+8], W0
014206  A00000     BSET W0, #0
014208  9801C0     MOV W0, [W3+8]
78:                  log_printf("Successfully initialized Android inteface %ld. IN_EP=0x%x OUT_EP=0x%x",
79:                             iid, pInterface->inEndpoint, pInterface->outEndpoint);
80:                
81:                  // Save device the address, VID, & PID
82:                  gc_DevData.ID.deviceAddress = address;
01420A  2709C0     MOV #0x709C, W0
01420C  784807     MOV.B W7, [W0]
83:                  gc_DevData.ID.vid  =  pDev->idVendor;
01420E  904886     MOV.B [W6+8], W1
014210  FB8081     ZE W1, W1
014212  904816     MOV.B [W6+9], W0
014214  DD0048     SL W0, #8, W0
014216  700001     IOR W0, W1, W0
014218  8B84C0     MOV W0, gc_DevData
84:                  gc_DevData.ID.pid  =  pDev->idProduct;
01421A  9048A6     MOV.B [W6+10], W1
01421C  FB8081     ZE W1, W1
01421E  904836     MOV.B [W6+11], W0
014220  DD0048     SL W0, #8, W0
014222  700001     IOR W0, W1, W0
014224  8B84D0     MOV W0, 0x709A
014226  050010     RETLW #0x1, W0
85:                
86:                  return TRUE;
87:                }
88:                
89:                BOOL USBHostAndroidInitDevice(BYTE address,
90:                                              DWORD iid,
91:                                              BYTE clientDriverID,
92:                                              USB_DEVICE_INFO *pDevInfo,
93:                                              USB_INTERFACE_INFO *pIntInfo) {
94:                  log_printf("USBHostAndroidInitDevice(0x%x, 0x%lx, 0x%x)", address, iid, clientDriverID);
95:                
96:                  // Initialize state
97:                  memset(&gc_DevData, 0, sizeof gc_DevData);
015342  2001A2     MOV #0x1A, W2
015344  EB0080     CLR W1
015346  270980     MOV #0x7098, W0
015348  025720     CALL memset
01534A  000000     NOP
98:                  
99:                  for (pIntInfo = pDevInfo->pInterfaceList; pIntInfo; pIntInfo = pIntInfo->next) {
01534C  900479     MOV [W9+14], W8
01534E  37000A     BRA 0x15364
015362  780418     MOV [W8], W8
015364  E00008     CP0 W8
015366  3AFFF4     BRA NZ, 0x15350
100:                   log_printf("Encoutered interface %d, class 0x%x, subclass 0x%x, protocol, 0x%x",
101:                       pIntInfo->interface, pIntInfo->type.cls, pIntInfo->type.subcls, pIntInfo->type.proto);
102:                   // initialize according to the interface number
103:                   USBHostAndroidInitInterface(address, pIntInfo->interface, 0, pDevInfo, pIntInfo);
015350  904168     MOV.B [W8+6], W2
015352  FB8102     ZE W2, W2
015354  200003     MOV #0x0, W3
015356  780288     MOV W8, W5
015358  780209     MOV W9, W4
01535A  EB4080     CLR.B W1
01535C  78400A     MOV.B W10, W0
01535E  0241CA     CALL USBHostAndroidInitInterface
015360  000001     NOP
104:                 }
105:               
106:                 log_printf("Android device initalized: address=%d VID=0x%x PID=0x%x",
107:                            address, gc_DevData.ID.vid, gc_DevData.ID.pid);
108:                 
109:                 return TRUE;
110:               } //  USBHostAndroidInit
111:                 
112:               
113:               BOOL USBHostAndroidEventHandler(BYTE address, USB_EVENT event, void *data, DWORD size) {
114:                 // Make sure it was for our device
115:                 if (address != gc_DevData.ID.deviceAddress) return FALSE;
015CAC  EB0100     CLR W2
015CAE  2709C1     MOV #0x709C, W1
015CB0  504F91     SUB.B W0, [W1], [W15]
015CB2  3A000A     BRA NZ, 0x15CC8
116:               
117:                 // Handle specific events.
118:                 switch (event) {
015CB4  200012     MOV #0x1, W2
015CB6  200710     MOV #0x71, W0
015CB8  518F80     SUB W3, W0, [W15]
015CBA  3A0006     BRA NZ, 0x15CC8
119:                  case EVENT_DETACH:
120:                   memset(&gc_DevData, 0, sizeof gc_DevData);
015CBC  2001A2     MOV #0x1A, W2
015CBE  EB0080     CLR W1
015CC0  270980     MOV #0x7098, W0
015CC2  025720     CALL memset
015CC4  000000     NOP
015CC6  EB0100     CLR W2
121:               
122:                   log_printf("Android Client Device Detached: address=0x%x", address);
123:                   break;
124:               
125:               #ifdef USB_ENABLE_TRANSFER_EVENT
126:                  case EVENT_BUS_ERROR:
127:                  case EVENT_TRANSFER:
128:                   if ((data != NULL) && (size == sizeof(HOST_TRANSFER_DATA))) {
129:                     int i;
130:                     DWORD dataCount = ((HOST_TRANSFER_DATA *)data)->dataCount;
131:               
132:                     for (i = 0; i < ANDROID_INTERFACE_MAX; ++i) {
133:                       ANDROID_INTERFACE *pInterface = &gc_DevData.interfaces[i];
134:                       if (((HOST_TRANSFER_DATA *)data)->bEndpointAddress == pInterface->inEndpoint) {
135:                         pInterface->flags.rxBusy = 0;
136:                         pInterface->rxLength = dataCount;
137:                         pInterface->rxErrorCode = ((HOST_TRANSFER_DATA *)data)->bErrorCode;
138:                         log_printf("Received message with %ld bytes: ", ((HOST_TRANSFER_DATA *)data)->dataCount);
139:                         log_print_buf(((HOST_TRANSFER_DATA *)data)->pUserData, ((HOST_TRANSFER_DATA *)data)->dataCount);
140:                         return TRUE;
141:                       }
142:                       if (((HOST_TRANSFER_DATA *)data)->bEndpointAddress == pInterface->outEndpoint) {
143:                         pInterface->flags.txBusy = 0;
144:                         pInterface->txErrorCode = ((HOST_TRANSFER_DATA *)data)->bErrorCode;
145:                         return TRUE;
146:                       }
147:                     }
148:                   }
149:                   return FALSE;
150:               #endif
151:               
152:                  case EVENT_SUSPEND:
153:                  case EVENT_RESUME:
154:                  default:
155:                   return TRUE;
156:                 }
157:                 return FALSE;
158:               }  // USBHostAndroidEventHandler
159:               
160:               
161:               //void USBHostAndroidGetDeviceId(USB_DEVICE_ID *pDevID) {
162:               //  assert(pDevID != NULL);
163:               //  *pDevID = gc_DevData.ID;
164:               //}  // USBHostAndroidGetDeviceId
165:               
166:               
167:               void USBHostAndroidReset() {
168:                 assert(gc_DevData.ID.deviceAddress != 0);
169:                 USBHostResetDevice(gc_DevData.ID.deviceAddress);
016476  2709C0     MOV #0x709C, W0
016478  784010     MOV.B [W0], W0
01647A  025FB4     CALL USBHostResetDevice
01647C  000001     NOP
170:                 memset(&gc_DevData, 0, sizeof gc_DevData);
01647E  2001A2     MOV #0x1A, W2
016480  EB0080     CLR W1
016482  270980     MOV #0x7098, W0
016484  045720     GOTO memset
016486  000000     NOP
171:               }
172:               
173:               BYTE USBHostAndroidRead(void *buffer, DWORD length, ANDROID_INTERFACE_ID iid) {
174:                 BYTE RetVal;
175:                 ANDROID_INTERFACE *pInterface = &gc_DevData.interfaces[iid];
01513C  B90A6A     MUL.SU W1, #10, W4
01513E  2709E0     MOV #0x709E, W0
015140  400404     ADD W0, W4, W8
176:               
177:                 // Validate the call
178:                 assert(pInterface->flags.initialized);
179:                 if (pInterface->flags.rxBusy) return USB_BUSY;
015142  9000C8     MOV [W8+8], W1
015144  200020     MOV #0x2, W0
015146  A32801     BTST.Z W1, #2
015148  3A0012     BRA NZ, 0x1516E
180:               
181:                 log_printf("Requested read of %u bytes", (unsigned) length);
182:               
183:                 // Set the busy flag, clear the count and start a new IN transfer.
184:                 pInterface->flags.rxBusy = 1;
01514A  A02001     BSET W1, #2
01514C  980441     MOV W1, [W8+8]
185:                 pInterface->rxLength = 0;
01514E  EB0C00     CLR [W8]
015150  781438     MOV [W8++], [W8--]
186:                 RetVal = USBHostRead(gc_DevData.ID.deviceAddress, pInterface->inEndpoint, (BYTE *)buffer, length);
015152  9040C8     MOV.B [W8+4], W1
015154  BE0202     MOV.D W2, W4
015156  780106     MOV W6, W2
015158  2709C0     MOV #0x709C, W0
01515A  784010     MOV.B [W0], W0
01515C  023F00     CALL USBHostRead
01515E  000001     NOP
015160  784080     MOV.B W0, W1
187:                 if (RetVal != USB_SUCCESS) {
015162  E00400     CP0.B W0
015164  320003     BRA Z, 0x1516C
188:                   pInterface->flags.rxBusy = 0;    // Clear flag to allow re-try
015166  900048     MOV [W8+8], W0
015168  A12000     BCLR W0, #2
01516A  980440     MOV W0, [W8+8]
189:                 }
190:                 return RetVal;
01516C  FB8001     ZE W1, W0
191:               }  // USBHostAndroidRead
192:               
193:               BOOL USBHostAndroidRxIsComplete(BYTE *errorCode, DWORD *byteCount, ANDROID_INTERFACE_ID iid) {
194:                 ANDROID_INTERFACE *pInterface = &gc_DevData.interfaces[iid];
015EE4  B9116A     MUL.SU W2, #10, W2
015EE6  2709E0     MOV #0x709E, W0
015EE8  400102     ADD W0, W2, W2
195:               
196:                 if (pInterface->flags.rxBusy) {
015EEA  900042     MOV [W2+8], W0
015EEC  EB0180     CLR W3
015EEE  A32800     BTST.Z W0, #2
015EF0  3A0005     BRA NZ, 0x15EFC
197:                   return FALSE;
198:                 } else {
199:                   *byteCount = pInterface->rxLength;
015EF2  BE0312     MOV.D [W2], W6
015EF4  BE8886     MOV.D W6, [W1]
200:                   *errorCode = pInterface->rxErrorCode;
015EF6  904162     MOV.B [W2+6], W2
015EF8  784A02     MOV.B W2, [W4]
015EFA  200013     MOV #0x1, W3
201:                   return TRUE;
202:                 }
203:               }  // USBHostAndroidRxIsComplete
204:               
205:               #ifndef USB_ENABLE_TRANSFER_EVENT
206:               void USBHostAndroidTasks(void) {
014040  270A68     MOV #0x70A6, W8
014042  780488     MOV W8, W9
207:                 DWORD   byteCount;
208:                 BYTE    errorCode;
209:                 int iid;
210:               
211:                 for (iid = 0; iid < ANDROID_INTERFACE_MAX; ++iid) {
014094  270BA0     MOV #0x70BA, W0
014096  540F80     SUB W8, W0, [W15]
014098  3AFFD5     BRA NZ, 0x14044
212:                   ANDROID_INTERFACE *pInterface = &gc_DevData.interfaces[iid];
213:               
214:                   if (gc_DevData.ID.deviceAddress && pInterface->flags.initialized) {
014044  2709C0     MOV #0x709C, W0
014046  784010     MOV.B [W0], W0
014048  E00400     CP0.B W0
01404A  320022     BRA Z, 0x14090
01404C  780098     MOV [W8], W1
01404E  A30801     BTST.Z W1, #0
014050  32001F     BRA Z, 0x14090
215:                     if (pInterface->flags.rxBusy) {
014052  A32801     BTST.Z W1, #2
014054  32000E     BRA Z, 0x14072
216:                       if (USBHostTransferIsComplete(gc_DevData.ID.deviceAddress, pInterface->inEndpoint, &errorCode, &byteCount)) {
014056  97F8C8     MOV.B [W8-4], W1
014058  5781E8     SUB W15, #0x8, W3
01405A  57816A     SUB W15, #0xA, W2
01405C  02422A     CALL USBHostTransferIsComplete
01405E  000001     NOP
014060  E00000     CP0 W0
014062  320007     BRA Z, 0x14072
217:                         pInterface->flags.rxBusy = 0;
014064  A12019     BCLR [W9], #2
218:                         pInterface->rxLength     = byteCount;
014066  97B84F     MOV [W15-8], W0
014068  97B8DF     MOV [W15-6], W1
01406A  9FBC40     MOV W0, [W8-8]
01406C  9FBC51     MOV W1, [W8-6]
219:                         pInterface->rxErrorCode  = errorCode;
01406E  97F0EF     MOV.B [W15-10], W1
014070  9FFC61     MOV.B W1, [W8-2]
220:                         log_printf("Received message with %ld bytes on endpoint 0x%x", byteCount, pInterface->inEndpoint);
221:                       }
222:                     }
223:               
224:                     if (pInterface->flags.txBusy) {
014072  780098     MOV [W8], W1
014074  608062     AND W1, #0x2, W0
014076  32000C     BRA Z, 0x14090
225:                       if (USBHostTransferIsComplete(gc_DevData.ID.deviceAddress, pInterface->outEndpoint, &errorCode, &byteCount)) {
014078  97F8D8     MOV.B [W8-3], W1
01407A  5781E8     SUB W15, #0x8, W3
01407C  57816A     SUB W15, #0xA, W2
01407E  2709C0     MOV #0x709C, W0
014080  784010     MOV.B [W0], W0
014082  02422A     CALL USBHostTransferIsComplete
014084  000001     NOP
014086  E00000     CP0 W0
014088  320003     BRA Z, 0x14090
226:                         pInterface->flags.txBusy = 0;
01408A  A11019     BCLR [W9], #1
227:                         pInterface->txErrorCode  = errorCode;
01408C  97F06F     MOV.B [W15-10], W0
01408E  9FFC70     MOV.B W0, [W8-1]
014090  4484EA     ADD W9, #0xA, W9
014092  44046A     ADD W8, #0xA, W8
228:                       }
229:                     }
230:                   }
231:                 }
232:               }  // USBHostAndroidTasks
233:               #endif  // USB_ENABLE_TRANSFER_EVENT
234:               
235:               BOOL USBHostAndroidTxIsComplete(BYTE *errorCode, ANDROID_INTERFACE_ID iid) {
236:                 ANDROID_INTERFACE *pInterface = &gc_DevData.interfaces[iid];
016138  B9096A     MUL.SU W1, #10, W2
01613A  2709E0     MOV #0x709E, W0
01613C  400082     ADD W0, W2, W1
237:               
238:                 if ( pInterface->flags.txBusy) {
01613E  900041     MOV [W1+8], W0
016140  EB0100     CLR W2
016142  A31800     BTST.Z W0, #1
016144  3A0003     BRA NZ, 0x1614C
239:                   return FALSE;
240:                 } else {
241:                   *errorCode =  pInterface->txErrorCode;
016146  9040F1     MOV.B [W1+7], W1
016148  784A01     MOV.B W1, [W4]
01614A  200012     MOV #0x1, W2
242:                   return TRUE;
243:                 }
244:               }  // USBHostAndroidTxIsComplete
245:               
246:               
247:               BYTE USBHostAndroidWrite(const void *buffer, DWORD length, ANDROID_INTERFACE_ID iid) {
248:                 BYTE RetVal;
249:                 ANDROID_INTERFACE *pInterface = &gc_DevData.interfaces[iid];
015374  B90A6A     MUL.SU W1, #10, W4
015376  2709E0     MOV #0x709E, W0
015378  400404     ADD W0, W4, W8
250:               
251:                 // Validate the call
252:                 assert(pInterface->flags.initialized);
253:                 if (pInterface->flags.txBusy) return USB_BUSY;
01537A  9000C8     MOV [W8+8], W1
01537C  200020     MOV #0x2, W0
01537E  A31801     BTST.Z W1, #1
015380  3A0010     BRA NZ, 0x153A2
254:               
255:                 log_printf("Sending message with %u bytes to endpoint 0x%x: ",
256:                            (unsigned) length,
257:                            pInterface->outEndpoint);
258:                 log_print_buf(buffer, length);
259:               
260:                 // Set the busy flag and start a new OUT transfer.
261:                 pInterface->flags.txBusy = 1;
015382  A01001     BSET W1, #1
015384  980441     MOV W1, [W8+8]
262:                 RetVal = USBHostWrite(gc_DevData.ID.deviceAddress, pInterface->outEndpoint, (BYTE *)buffer, length);
015386  9040D8     MOV.B [W8+5], W1
015388  BE0202     MOV.D W2, W4
01538A  780106     MOV W6, W2
01538C  2709C0     MOV #0x709C, W0
01538E  784010     MOV.B [W0], W0
015390  023F6A     CALL USBHostWrite
015392  000001     NOP
015394  784080     MOV.B W0, W1
263:                 if (RetVal != USB_SUCCESS) {
015396  E00400     CP0.B W0
015398  320003     BRA Z, 0x153A0
264:                   pInterface->flags.txBusy = 0;    // Clear flag to allow re-try
01539A  900048     MOV [W8+8], W0
01539C  A11000     BCLR W0, #1
01539E  980440     MOV W0, [W8+8]
265:                 }
266:                 return RetVal;
0153A0  FB8001     ZE W1, W0
267:               }  // USBHostAndroidWrite
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libsdcard.X/src/SD-SPI.c  
1:                 /******************************************************************************
2:                  *
3:                  *               Microchip Memory Disk Drive File System
4:                  *
5:                  ******************************************************************************
6:                  * FileName:        SD-SPI.c
7:                  * Dependencies:    SD-SPI.h
8:                  *                  string.h
9:                  *                  FSIO.h
10:                 *                  FSDefs.h
11:                 * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32
12:                 * Compiler:        C18/C30/C32
13:                 * Company:         Microchip Technology, Inc.
14:                 *
15:                 * Software License Agreement
16:                 *
17:                 * The software supplied herewith by Microchip Technology Incorporated
18:                 * (the "Company") for its PICmicro¨ Microcontroller is intended and
19:                 * supplied to you, the Company?s customer, for use solely and
20:                 * exclusively on Microchip PICmicro Microcontroller products. The
21:                 * software is owned by the Company and/or its supplier, and is
22:                 * protected under applicable copyright laws. All rights are reserved.
23:                 * Any use in violation of the foregoing restrictions may subject the
24:                 * user to criminal sanctions under applicable laws, as well as to
25:                 * civil liability for the breach of the terms and conditions of this
26:                 * license.
27:                 *
28:                 * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
29:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                 *
35:                *****************************************************************************
36:                 File Description:
37:                
38:                 Change History:
39:                  Rev     Description
40:                  -----   -----------
41:                  1.2.5   Fixed bug in the calculation of the capacity for v1.0 devices
42:                  1.3.0   Improved media initialization sequence, for better card compatibility
43:                          (especially with SDHC cards).
44:                          Implemented SPI optimizations for data transfer rate improvement.
45:                          Added new MDD_SDSPI_AsyncReadTasks() and MDD_SDSPI_AsyncWriteTasks() 
46:                          API functions.  These are non-blocking, state machine based read/write
47:                          handlers capable of considerably improved data throughput, particularly
48:                          for multi-block reads and multi-block writes.
49:                  1.3.2   Modified MDD_SDSPI_AsyncWriteTasks() so pre-erase command only gets
50:                          used for multi-block write scenarios.   
51:                  1.3.4   1) Added support for dsPIC33E & PIC24E controllers.
52:                          2) #include "HardwareProfile.h" is moved up in the order.
53:                          3) "SPI_INTERRUPT_FLAG_ASM" macro has to be defined in "HardwareProfile.h" file
54:                             for PIC18 microcontrollers.Or else an error is generated while building
55:                             the code.
56:                                       "#define SPI_INTERRUPT_FLAG_ASM  PIR1, 3" is removed from SD-SPI.c
57:                          4) Replaced "__C30" usage with "__C30__" .
58:                  1.3.6   1) Modified "FSConfig.h" to "FSconfig.h" in '#include' directive.
59:                          2) Moved 'spiconvalue' variable definition to only C30 usage, as C32
60:                             is not using it.
61:                          3) Modified 'MDD_SDSPI_MediaDetect' function to ensure that CMD0 is sent freshly
62:                             after CS is asserted low. This minimizes the risk of SPI clock pulse master/slave
63:                             syncronization problems.
64:                
65:                ********************************************************************/
66:                
67:                #include "Compiler.h"
68:                #include "GenericTypeDefs.h"
69:                #include "HardwareProfile.h"
70:                #include "FSIO.h"
71:                #include "FSDefs.h"
72:                #include "SD-SPI.h"
73:                #include <string.h>
74:                #include "FSconfig.h"
75:                
76:                /******************************************************************************
77:                 * Global Variables
78:                 *****************************************************************************/
79:                
80:                // Description:  Used for the mass-storage library to determine capacity
81:                DWORD MDD_SDSPI_finalLBA;
82:                WORD gMediaSectorSize;
83:                BYTE gSDMode;
84:                static MEDIA_INFORMATION mediaInformation;
85:                static ASYNC_IO ioInfo; //Declared global context, for fast/code efficient access
86:                
87:                
88:                #ifdef __18CXX
89:                    // Summary: Table of SD card commands and parameters
90:                    // Description: The sdmmc_cmdtable contains an array of SD card commands, the corresponding CRC code, the
91:                    //              response type that the card will return, and a parameter indicating whether to expect
92:                    //              additional data from the card.
93:                    const rom typMMC_CMD sdmmc_cmdtable[] =
94:                #else
95:                    const typMMC_CMD sdmmc_cmdtable[] =
96:                #endif
97:                {
98:                    // cmd                      crc     response
99:                    {cmdGO_IDLE_STATE,          0x95,   R1,     NODATA},
100:                   {cmdSEND_OP_COND,           0xF9,   R1,     NODATA},
101:                   {cmdSEND_IF_COND,      		0x87,   R7,     NODATA},
102:                   {cmdSEND_CSD,               0xAF,   R1,     MOREDATA},
103:                   {cmdSEND_CID,               0x1B,   R1,     MOREDATA},
104:                   {cmdSTOP_TRANSMISSION,      0xC3,   R1b,    NODATA},
105:                   {cmdSEND_STATUS,            0xAF,   R2,     NODATA},
106:                   {cmdSET_BLOCKLEN,           0xFF,   R1,     NODATA},
107:                   {cmdREAD_SINGLE_BLOCK,      0xFF,   R1,     MOREDATA},
108:                   {cmdREAD_MULTI_BLOCK,       0xFF,   R1,     MOREDATA},
109:                   {cmdWRITE_SINGLE_BLOCK,     0xFF,   R1,     MOREDATA},
110:                   {cmdWRITE_MULTI_BLOCK,      0xFF,   R1,     MOREDATA}, 
111:                   {cmdTAG_SECTOR_START,       0xFF,   R1,     NODATA},
112:                   {cmdTAG_SECTOR_END,         0xFF,   R1,     NODATA},
113:                   {cmdERASE,                  0xDF,   R1b,    NODATA},
114:                   {cmdAPP_CMD,                0x73,   R1,     NODATA},
115:                   {cmdREAD_OCR,               0x25,   R7,     NODATA},
116:                   {cmdCRC_ON_OFF,             0x25,   R1,     NODATA},
117:                   {cmdSD_SEND_OP_COND,        0xFF,   R7,     NODATA}, //Actual response is R3, but has same number of bytes as R7.
118:                   {cmdSET_WR_BLK_ERASE_COUNT, 0xFF,   R1,     NODATA}
119:               };
120:               
121:               
122:               
123:               
124:               /******************************************************************************
125:                * Prototypes
126:                *****************************************************************************/
127:               extern void Delayms(BYTE milliseconds);
128:               BYTE MDD_SDSPI_ReadMedia(void);
129:               MEDIA_INFORMATION * MDD_SDSPI_MediaInitialize(void);
130:               MMC_RESPONSE SendMMCCmd(BYTE cmd, DWORD address);
131:               
132:               #if defined __C30__ || defined __C32__
133:                   void OpenSPIM ( unsigned int sync_mode);
134:                   void CloseSPIM( void );
135:                   unsigned char WriteSPIM( unsigned char data_out );
136:               #elif defined __18CXX
137:                   void OpenSPIM ( unsigned char sync_mode);
138:                   void CloseSPIM( void );
139:                   unsigned char WriteSPIM( unsigned char data_out );
140:               
141:                   unsigned char WriteSPIManual(unsigned char data_out);
142:                   BYTE ReadMediaManual (void);
143:                   MMC_RESPONSE SendMMCCmdManual(BYTE cmd, DWORD address);
144:               #endif
145:               void InitSPISlowMode(void);
146:               
147:               #if defined __18CXX
148:               //Private function prototypes
149:               static void PIC18_Optimized_SPI_Write_Packet(void);
150:               static void PIC18_Optimized_SPI_Read_Packet(void);
151:               #endif
152:               
153:               //-------------Function name redirects------------------------------------------
154:               //During the media initialization sequence, it is
155:               //necessary to clock the media at no more than 400kHz SPI speeds, since some
156:               //media types power up in open drain output mode and cannot run fast initially.
157:               //On PIC18 devices, when the CPU is run at full frequency, the standard SPI 
158:               //prescalars cannot reach a low enough SPI frequency.  Therefore, we initialize
159:               //the card at low speed using bit-banged SPI on PIC18 devices.  On 
160:               //PIC32/PIC24/dsPIC devices, the SPI module is flexible enough to reach <400kHz
161:               //speeds regardless of CPU frequency, and therefore bit-banged code is not 
162:               //necessary.  Therefore, we use function redirects where necessary, to point to
163:               //the proper SPI related code, given the processor type.
164:               
165:               #if defined __18CXX
166:                   #define SendMediaSlowCmd    SendMMCCmdManual
167:                   #define WriteSPISlow        WriteSPIManual
168:               #else
169:                   #define SendMediaSlowCmd    SendMMCCmd
170:                   #define WriteSPISlow        WriteSPIM
171:               #endif
172:               //------------------------------------------------------------------------------
173:               
174:               
175:               #ifdef __PIC32MX__
176:               /*********************************************************
177:                 Function:
178:                   static inline __attribute__((always_inline)) unsigned char SPICacutateBRG (unsigned int pb_clk, unsigned int spi_clk)
179:                 Summary:
180:                   Calculate the PIC32 SPI BRG value
181:                 Conditions:
182:                   None
183:                 Input:
184:                   pb_clk -  The value of the PIC32 peripheral clock
185:                   spi_clk - The desired baud rate
186:                 Return:
187:                   The corresponding BRG register value.
188:                 Side Effects:
189:                   None.
190:                 Description:
191:                   The SPICalutateBRG function is used to determine an appropriate BRG register value for the PIC32 SPI module.
192:                 Remarks:
193:                   None                                                  
194:                 *********************************************************/
195:               
196:               static inline __attribute__((always_inline)) unsigned char SPICalutateBRG(unsigned int pb_clk, unsigned int spi_clk)
197:               {
198:                   unsigned int brg;
199:               
200:                   brg = pb_clk / (2 * spi_clk);
201:               
202:                   if(pb_clk % (2 * spi_clk))
203:                       brg++;
204:               
205:                   if(brg > 0x100)
206:                       brg = 0x100;
207:               
208:                   if(brg)
209:                       brg--;
210:               
211:                   return (unsigned char) brg;
212:               }
213:               #endif
214:               
215:               
216:               /*********************************************************
217:                 Function:
218:                   BYTE MDD_SDSPI_MediaDetect
219:                 Summary:
220:                   Determines whether an SD card is present
221:                 Conditions:
222:                   The MDD_MediaDetect function pointer must be configured
223:                   to point to this function in FSconfig.h
224:                 Input:
225:                   None
226:                 Return Values:
227:                   TRUE -  Card detected
228:                   FALSE - No card detected
229:                 Side Effects:
230:                   None.
231:                 Description:
232:                   The MDD_SDSPI_MediaDetect function determine if an SD card is connected to 
233:                   the microcontroller.
234:                   If the MEDIA_SOFT_DETECT is not defined, the detection is done by polling
235:                   the SD card detect pin.
236:                   The MicroSD connector does not have a card detect pin, and therefore a
237:                   software mechanism must be used. To do this, the SEND_STATUS command is sent 
238:                   to the card. If the card is not answering with 0x00, the card is either not 
239:                   present, not configured, or in an error state. If this is the case, we try
240:                   to reconfigure the card. If the configuration fails, we consider the card not 
241:                   present (it still may be present, but malfunctioning). In order to use the 
242:                   software card detect mechanism, the MEDIA_SOFT_DETECT macro must be defined.
243:                   
244:                 Remarks:
245:                   None                                                  
246:                 *********************************************************/
247:               
248:               BYTE MDD_SDSPI_MediaDetect (void)
249:               {
250:               #ifndef MEDIA_SOFT_DETECT
251:                   return(!SD_CD);
00D268  BFC2EA     MOV.B PORTF, WREG
00D26A  A20400     BTG.B W0, #0
00D26C  600061     AND W0, #0x1, W0
252:               #else
253:               	MMC_RESPONSE    response;
254:               
255:                   //First check if SPI module is enabled or not.
256:               	if (SPIENABLE == 0)
257:               	{
258:                       unsigned char timeout;
259:               
260:               		//If the SPI module is not enabled, then the media has evidently not
261:               		//been initialized.  Try to send CMD0 and CMD13 to reset the device and
262:               		//get it into SPI mode (if present), and then request the status of
263:               		//the media.  If this times out, then the card is presumably not physically
264:               		//present.
265:               		
266:               		InitSPISlowMode();
267:               		
268:                       //Send CMD0 to reset the media
269:               	    //If the card is physically present, then we should get a valid response.
270:                       timeout = 4;
271:                       do
272:                       {
273:                           //Toggle chip select, to make media abandon whatever it may have been doing
274:                           //before.  This ensures the CMD0 is sent freshly after CS is asserted low,
275:                           //minimizing risk of SPI clock pulse master/slave syncronization problems, 
276:                           //due to possible application noise on the SCK line.
277:                           SD_CS = 1;
278:                           WriteSPISlow(0xFF);   //Send some "extraneous" clock pulses.  If a previous
279:                                                 //command was terminated before it completed normally,
280:                                                 //the card might not have received the required clocking
281:                                                 //following the transfer.
282:                           SD_CS = 0;
283:                           timeout--;
284:                   
285:                           //Send CMD0 to software reset the device
286:                           response = SendMediaSlowCmd(GO_IDLE_STATE, 0x0);
287:                       } while((response.r1._byte != 0x01) && (timeout != 0));
288:               
289:               	    //Check if response was invalid (R1 response byte should be = 0x01 after GO_IDLE_STATE)
290:               	    if(response.r1._byte != 0x01)
291:               	    {
292:               	        CloseSPIM();
293:               	        return FALSE;
294:               	    }    
295:               	    else
296:               	    {
297:                   	    //Card is presumably present.  The SDI pin should have a pull up resistor on
298:                   	    //it, so the odds of SDI "floating" to 0x01 after sending CMD0 is very
299:                   	    //remote, unless the media is genuinely present.  Therefore, we should
300:                   	    //try to perform a full card initialization sequence now.
301:                   		MDD_SDSPI_MediaInitialize();    //Can block and take a long time to execute.
302:                   		if(mediaInformation.errorCode == MEDIA_NO_ERROR)
303:                   		{
304:                   			/* if the card was initialized correctly, it means it is present */
305:                   			return TRUE;
306:                   		}
307:                   		else 
308:                   		{
309:                       		CloseSPIM();
310:                   			return FALSE;
311:                   		}		
312:               
313:                   	}    
314:               	}//if (SPIENABLE == 0)
315:               	else
316:               	{
317:                   	//The SPI module was already enabled.  This most likely means the media is
318:                   	//present and has already been initialized.  However, it is possible that
319:                   	//the user could have unplugged the media, in which case it is no longer
320:                   	//present.  We should send it a command, to check the status.
321:                   	response = SendMMCCmd(SEND_STATUS,0x0);
322:                   	if((response.r2._word & 0xEC0C) != 0x0000)
323:               	    {
324:                   	    //The card didn't respond with the expected result.  This probably
325:                   	    //means it is no longer present.  We can try to re-initialized it,
326:                   	    //just to be doubly sure.
327:                   		CloseSPIM();
328:                   		MDD_SDSPI_MediaInitialize();    //Can block and take a long time to execute.
329:                   		if(mediaInformation.errorCode == MEDIA_NO_ERROR)
330:                   		{
331:                   			/* if the card was initialized correctly, it means it is present */
332:                   			return TRUE;
333:                   		}
334:                   		else 
335:                   		{
336:                       		CloseSPIM();
337:                   			return FALSE;
338:                   		}
339:                   	}
340:                   	else
341:                   	{
342:                       	//The CMD13 response to SEND_STATUS was valid.  This presumably
343:                       	//means the card is present and working normally.
344:                       	return TRUE;
345:                       }   	    
346:               
347:               	}
348:               
349:                   //Should theoretically never execute to here.  All pathways should have 
350:                   //already returned with the status.
351:                   return TRUE;
352:               
353:               #endif
354:               
355:               }//end MediaDetect
356:               
357:               
358:               
359:               /*********************************************************
360:                 Function:
361:                   WORD MDD_SDSPI_ReadSectorSize (void)
362:                 Summary:
363:                   Determines the current sector size on the SD card
364:                 Conditions:
365:                   MDD_MediaInitialize() is complete
366:                 Input:
367:                   None
368:                 Return:
369:                   The size of the sectors for the physical media
370:                 Side Effects:
371:                   None.
372:                 Description:
373:                   The MDD_SDSPI_ReadSectorSize function is used by the
374:                   USB mass storage class to return the card's sector
375:                   size to the PC on request.
376:                 Remarks:
377:                   None
378:                 *********************************************************/
379:               
380:               WORD MDD_SDSPI_ReadSectorSize(void)
381:               {
00D270  838190     MOV gMediaSectorSize, W0
382:                   return gMediaSectorSize;
383:               }
384:               
385:               
386:               /*********************************************************
387:                 Function:
388:                   DWORD MDD_SDSPI_ReadCapacity (void)
389:                 Summary:
390:                   Determines the current capacity of the SD card
391:                 Conditions:
392:                   MDD_MediaInitialize() is complete
393:                 Input:
394:                   None
395:                 Return:
396:                   The capacity of the device
397:                 Side Effects:
398:                   None.
399:                 Description:
400:                   The MDD_SDSPI_ReadCapacity function is used by the
401:                   USB mass storage class to return the total number
402:                   of sectors on the card.
403:                 Remarks:
404:                   None
405:                 *********************************************************/
406:               DWORD MDD_SDSPI_ReadCapacity(void)
407:               {
408:                   return (MDD_SDSPI_finalLBA);
409:               }
410:               
411:               
412:               /*********************************************************
413:                 Function:
414:                   WORD MDD_SDSPI_InitIO (void)
415:                 Summary:
416:                   Initializes the I/O lines connected to the card
417:                 Conditions:
418:                   MDD_MediaInitialize() is complete.  The MDD_InitIO
419:                   function pointer is pointing to this function.
420:                 Input:
421:                   None
422:                 Return:
423:                   None
424:                 Side Effects:
425:                   None.
426:                 Description:
427:                   The MDD_SDSPI_InitIO function initializes the I/O
428:                   pins connected to the SD card.
429:                 Remarks:
430:                   None
431:                 *********************************************************/
432:               
433:               void MDD_SDSPI_InitIO (void)
434:               {
435:                   // Turn off the card
436:               //    SD_CD_TRIS = INPUT;            //Card Detect - input
437:                   SD_CS = 1;                     //Initialize Chip Select line
00D27A  A8C2D5     BSET 0x2D5, #6
438:                   SD_CS_TRIS = OUTPUT;           //Card Select - output
00D27C  A9C2D1     BCLR 0x2D1, #6
439:               //    SD_WE_TRIS = INPUT;            //Write Protect - input
440:               
441:               #if defined	(__dsPIC33E__) || defined (__PIC24E__)
442:                   SD_CS_ANSEL = 0;
443:                   SD_SCK_ANSEL = 0;
444:                   SD_SDI_ANSEL = 0;
445:                   SD_SDO_ANSEL = 0;
446:               #endif    
447:               }
448:               
449:               
450:               
451:               /*********************************************************
452:                 Function:
453:                   BYTE MDD_SDSPI_ShutdownMedia (void)
454:                 Summary:
455:                   Disables the SD card
456:                 Conditions:
457:                   The MDD_ShutdownMedia function pointer is pointing 
458:                   towards this function.
459:                 Input:
460:                   None
461:                 Return:
462:                   None
463:                 Side Effects:
464:                   None.
465:                 Description:
466:                   This function will disable the SPI port and deselect
467:                   the SD card.
468:                 Remarks:
469:                   None
470:                 *********************************************************/
471:               
472:               BYTE MDD_SDSPI_ShutdownMedia(void)
473:               {
474:                   // close the spi bus
475:                   CloseSPIM();
476:                   
477:                   // deselect the device
478:                   SD_CS = 1;
00DA12  A8C2D5     BSET 0x2D5, #6
479:               
480:                   return 0;
481:               }
482:               
483:               
484:               /*****************************************************************************
485:                 Function:
486:                   MMC_RESPONSE SendMMCCmd (BYTE cmd, DWORD address)
487:                 Summary:
488:                   Sends a command packet to the SD card.
489:                 Conditions:
490:                   None.
491:                 Input:
492:                   None.
493:                 Return Values:
494:                   MMC_RESPONSE    - The response from the card
495:                                   - Bit 0 - Idle state
496:                                   - Bit 1 - Erase Reset
497:                                   - Bit 2 - Illegal Command
498:                                   - Bit 3 - Command CRC Error
499:                                   - Bit 4 - Erase Sequence Error
500:                                   - Bit 5 - Address Error
501:                                   - Bit 6 - Parameter Error
502:                                   - Bit 7 - Unused. Always 0.
503:                 Side Effects:
504:                   None.
505:                 Description:
506:                   SendMMCCmd prepares a command packet and sends it out over the SPI interface.
507:                   Response data of type 'R1' (as indicated by the SD/MMC product manual is returned.
508:                 Remarks:
509:                   None.
510:                 *****************************************************************************/
511:               
512:               MMC_RESPONSE SendMMCCmd(BYTE cmd, DWORD address)
513:               {
514:                   MMC_RESPONSE    response;
515:                   CMD_PACKET  CmdPacket;
516:                   WORD timeout;
517:                   DWORD longTimeout;
518:                   
519:                   SD_CS = 0;                           //Select card
00D2AE  A9C2D5     BCLR 0x2D5, #6
520:                   
521:                   // Copy over data
522:                   CmdPacket.cmd        = sdmmc_cmdtable[cmd].CmdCode;
00D2B0  5784F0     SUB W15, #0x10, W9
00D2B2  FB8581     ZE W1, W11
00D2B4  784001     MOV.B W1, W0
00D2B6  B3C062     MOV #0x6, W2
00D2B8  BC4004     MUL.B WREG2
00D2BA  2ECC80     MOV #0xECC8, W0
00D2BC  410000     ADD W2, W0, W0
00D2BE  784090     MOV.B [W0], W1
00D2C0  9FF7E1     MOV.B W1, [W15-10]
523:                   CmdPacket.address    = address;
00D2C2  9FBF94     MOV W4, [W15-14]
00D2C4  9FBFA5     MOV W5, [W15-12]
524:                   CmdPacket.crc        = sdmmc_cmdtable[cmd].CRC;       // Calc CRC here
00D2C6  904010     MOV.B [W0+1], W0
00D2C8  784C80     MOV.B W0, [W9]
525:                   
526:                   CmdPacket.TRANSMIT_BIT = 1;             //Set Tranmission bit
00D2CA  97B83F     MOV [W15-10], W0
00D2CC  A06000     BSET W0, #6
00D2CE  9FBFB0     MOV W0, [W15-10]
527:                   
528:                   WriteSPIM(CmdPacket.cmd);                //Send Command
00D2D0  97F06F     MOV.B [W15-10], W0
00D2D2  07FFD8     RCALL WriteSPIM
529:                   WriteSPIM(CmdPacket.addr3);              //Most Significant Byte
00D2D4  97F05F     MOV.B [W15-11], W0
00D2D6  07FFD6     RCALL WriteSPIM
530:                   WriteSPIM(CmdPacket.addr2);
00D2D8  97F04F     MOV.B [W15-12], W0
00D2DA  07FFD4     RCALL WriteSPIM
531:                   WriteSPIM(CmdPacket.addr1);
00D2DC  97F03F     MOV.B [W15-13], W0
00D2DE  07FFD2     RCALL WriteSPIM
532:                   WriteSPIM(CmdPacket.addr0);              //Least Significant Byte
00D2E0  97F02F     MOV.B [W15-14], W0
00D2E2  07FFD0     RCALL WriteSPIM
533:                   WriteSPIM(CmdPacket.crc);                //Send CRC
00D2E4  784019     MOV.B [W9], W0
00D2E6  07FFCE     RCALL WriteSPIM
534:               
535:                   //Special handling for CMD12 (STOP_TRANSMISSION).  The very first byte after
536:                   //sending the command packet may contain bogus non-0xFF data.  This 
537:                   //"residual data" byte should not be interpreted as the R1 response byte.
538:                   if(cmd == STOP_TRANSMISSION)
00D2E8  544FE5     SUB.B W8, #0x5, [W15]
00D2EA  3A0001     BRA NZ, 0xD2EE
539:                   {
540:                       MDD_SDSPI_ReadMedia(); //Perform dummy read to fetch the residual non R1 byte
00D2EC  07FFD2     RCALL MDD_SDSPI_ReadMedia
00D2EE  200148     MOV #0x14, W8
541:                   } 
542:               
543:                   //Loop until we get a response from the media.  Delay (NCR) could be up 
544:                   //to 8 SPI byte times.  First byte of response is always the equivalent of 
545:                   //the R1 byte, even for R1b, R2, R3, R7 responses.
546:                   timeout = NCR_TIMEOUT;
547:                   do
548:                   {
549:                       response.r1._byte = MDD_SDSPI_ReadMedia();
00D2F0  07FFD0     RCALL MDD_SDSPI_ReadMedia
00D2F2  784180     MOV.B W0, W3
550:                       timeout--;
00D2F4  E90408     DEC W8, W8
551:                   }while((response.r1._byte == MMC_FLOATING_BUS) && (timeout != 0));
00D2F6  404FE1     ADD.B W0, #0x1, [W15]
00D2F8  3A0002     BRA NZ, 0xD2FE
00D2FA  E00008     CP0 W8
00D2FC  3AFFF9     BRA NZ, 0xD2F0
00D2FE  9FEFA3     MOV.B W3, [W15-22]
552:                   
553:                   //Check if we should read more bytes, depending upon the response type expected.  
554:                   if(sdmmc_cmdtable[cmd].responsetype == R2)
00D300  B95866     MUL.SU W11, #6, W0
00D302  E88000     INC2 W0, W0
00D304  2ECC82     MOV #0xECC8, W2
00D306  780062     MOV [W2+W0], W0
00D308  500FE2     SUB W0, #0x2, [W15]
00D30A  3A0004     BRA NZ, 0xD314
555:                   {
556:                       response.r2._byte1 = response.r1._byte; //We already received the first byte, just make sure it is in the correct location in the struct.
00D30C  9FEFB3     MOV.B W3, [W15-21]
557:                       response.r2._byte0 = MDD_SDSPI_ReadMedia(); //Fetch the second byte of the response.
00D30E  07FFC1     RCALL MDD_SDSPI_ReadMedia
00D310  9FEFA0     MOV.B W0, [W15-22]
00D312  370019     BRA 0xD346
558:                   }
559:                   else if(sdmmc_cmdtable[cmd].responsetype == R1b)
00D314  500FE1     SUB W0, #0x1, [W15]
00D316  3A000D     BRA NZ, 0xD332
00D318  200008     MOV #0x0, W8
00D31A  2000A9     MOV #0xA, W9
560:                   {
561:                       //Keep trying to read from the media, until it signals it is no longer
562:                       //busy.  It will continuously send 0x00 bytes until it is not busy.
563:                       //A non-zero value means it is ready for the next command.
564:                       //The R1b response is received after a CMD12 STOP_TRANSMISSION
565:                       //command, where the media card may be busy writing its internal buffer
566:                       //to the flash memory.  This can typically take a few milliseconds, 
567:                       //with a recommended maximum timeout of 250ms or longer for SD cards.
568:                       longTimeout = WRITE_TIMEOUT;
569:                       do
570:                       {
571:                           response.r1._byte = MDD_SDSPI_ReadMedia();
00D31C  07FFBA     RCALL MDD_SDSPI_ReadMedia
572:                           longTimeout--;
00D31E  540461     SUB W8, #0x1, W8
00D320  5C84E0     SUBB W9, #0x0, W9
573:                       }while((response.r1._byte == 0x00) && (longTimeout != 0));
00D322  E00400     CP0.B W0
00D324  3A0003     BRA NZ, 0xD32C
00D326  540FE0     SUB W8, #0x0, [W15]
00D328  5C8FE0     SUBB W9, #0x0, [W15]
00D32A  3AFFF8     BRA NZ, 0xD31C
574:               
575:                       response.r1._byte = 0x00;
00D32C  EB4100     CLR.B W2
00D32E  9FEFA2     MOV.B W2, [W15-22]
00D330  37000A     BRA 0xD346
576:                   }
577:                   else if (sdmmc_cmdtable[cmd].responsetype == R7) //also used for response R3 type
00D332  500FE4     SUB W0, #0x4, [W15]
00D334  3A0008     BRA NZ, 0xD346
578:                   {
579:                       //Fetch the other four bytes of the R3 or R7 response.
580:                       //Note: The SD card argument response field is 32-bit, big endian format.
581:                       //However, the C compiler stores 32-bit values in little endian in RAM.
582:                       //When writing to the _returnVal/argument bytes, make sure the order it 
583:                       //gets stored in is correct.      
584:                       response.r7.bytewise.argument._byte3 = MDD_SDSPI_ReadMedia();
00D336  07FFAD     RCALL MDD_SDSPI_ReadMedia
00D338  9FEFF0     MOV.B W0, [W15-17]
585:                       response.r7.bytewise.argument._byte2 = MDD_SDSPI_ReadMedia();
00D33A  07FFAB     RCALL MDD_SDSPI_ReadMedia
00D33C  9FEFE0     MOV.B W0, [W15-18]
586:                       response.r7.bytewise.argument._byte1 = MDD_SDSPI_ReadMedia();
00D33E  07FFA9     RCALL MDD_SDSPI_ReadMedia
00D340  9FEFD0     MOV.B W0, [W15-19]
587:                       response.r7.bytewise.argument._byte0 = MDD_SDSPI_ReadMedia();
00D342  07FFA7     RCALL MDD_SDSPI_ReadMedia
00D344  9FEFC0     MOV.B W0, [W15-20]
588:                   }
589:               
590:                   WriteSPIM(0xFF);    //Device requires at least 8 clock pulses after 
00D346  EBC000     SETM.B W0
00D348  07FF9D     RCALL WriteSPIM
591:                                            //the response has been sent, before if can process
592:                                            //the next command.  CS may be high or low.
593:               
594:                   // see if we are expecting more data or not
595:                   if(!(sdmmc_cmdtable[cmd].moredataexpected))
00D34A  B95866     MUL.SU W11, #6, W0
00D34C  2ECCC2     MOV #0xECCC, W2
00D34E  400002     ADD W0, W2, W0
00D350  E00410     CP0.B [W0]
00D352  3A0001     BRA NZ, 0xD356
596:                       SD_CS = 1;
00D354  A8C2D5     BSET 0x2D5, #6
597:               
598:                   return(response);
00D356  97B05F     MOV [W15-22], W0
00D358  97B0EF     MOV [W15-20], W1
00D35A  BE8D00     MOV.D W0, [W10]
00D35C  97B0FF     MOV [W15-18], W1
00D35E  980521     MOV W1, [W10+4]
599:               }
00D36A  FA001E     LNK #0x1E
00D36C  BE9F88     MOV.D W8, [W15++]
00D36E  780480     MOV W0, W9
600:               
601:               #ifdef __18CXX
602:               /*****************************************************************************
603:                 Function:
604:                   MMC_RESPONSE SendMMCCmdManual (BYTE cmd, DWORD address)
605:                 Summary:
606:                   Sends a command packet to the SD card with bit-bang SPI.
607:                 Conditions:
608:                   None.
609:                 Input:
610:                   Need input cmd index into a rom table of implemented commands.
611:                   Also needs 4 bytes of data as address for some commands (also used for
612:                   other purposes in other commands).
613:                 Return Values:
614:                   Assuming an "R1" type of response, each bit will be set depending upon status:
615:                   MMC_RESPONSE    - The response from the card
616:                                   - Bit 0 - Idle state
617:                                   - Bit 1 - Erase Reset
618:                                   - Bit 2 - Illegal Command
619:                                   - Bit 3 - Command CRC Error
620:                                   - Bit 4 - Erase Sequence Error
621:                                   - Bit 5 - Address Error
622:                                   - Bit 6 - Parameter Error
623:                                   - Bit 7 - Unused. Always 0.
624:                   Other response types (ex: R3/R7) have up to 5 bytes of response.  The first
625:                   byte is always the same as the R1 response.  The contents of the other bytes 
626:                   depends on the command.
627:                 Side Effects:
628:                   None.
629:                 Description:
630:                   SendMMCCmd prepares a command packet and sends it out over the SPI interface.
631:                   Response data of type 'R1' (as indicated by the SD/MMC product manual is returned.
632:                   This function is intended to be used when the clock speed of a PIC18 device is
633:                   so high that the maximum SPI divider can't reduce the clock below the maximum
634:                   SD card initialization sequence speed.
635:                 Remarks:
636:                   None.
637:                 ***************************************************************************************/
638:               MMC_RESPONSE SendMMCCmdManual(BYTE cmd, DWORD address)
639:               {
640:                   BYTE index;
641:                   MMC_RESPONSE    response;
642:                   CMD_PACKET  CmdPacket;
643:                   WORD timeout;
644:                   
645:                   SD_CS = 0;                           //Select card
646:                   
647:                   // Copy over data
648:                   CmdPacket.cmd        = sdmmc_cmdtable[cmd].CmdCode;
649:                   CmdPacket.address    = address;
650:                   CmdPacket.crc        = sdmmc_cmdtable[cmd].CRC;       // Calc CRC here
651:                   
652:                   CmdPacket.TRANSMIT_BIT = 1;             //Set Tranmission bit
653:                   
654:                   WriteSPIManual(CmdPacket.cmd);                //Send Command
655:                   WriteSPIManual(CmdPacket.addr3);              //Most Significant Byte
656:                   WriteSPIManual(CmdPacket.addr2);
657:                   WriteSPIManual(CmdPacket.addr1);
658:                   WriteSPIManual(CmdPacket.addr0);              //Least Significant Byte
659:                   WriteSPIManual(CmdPacket.crc);                //Send CRC
660:               
661:                   //Special handling for CMD12 (STOP_TRANSMISSION).  The very first byte after
662:                   //sending the command packet may contain bogus non-0xFF data.  This 
663:                   //"residual data" byte should not be interpreted as the R1 response byte.
664:                   if(cmd == STOP_TRANSMISSION)
665:                   {
666:                       ReadMediaManual(); //Perform dummy read to fetch the residual non R1 byte
667:                   } 
668:               
669:                   //Loop until we get a response from the media.  Delay (NCR) could be up 
670:                   //to 8 SPI byte times.  First byte of response is always the equivalent of 
671:                   //the R1 byte, even for R1b, R2, R3, R7 responses.
672:                   timeout = NCR_TIMEOUT;
673:                   do
674:                   {
675:                       response.r1._byte = ReadMediaManual();
676:                       timeout--;
677:                   }while((response.r1._byte == MMC_FLOATING_BUS) && (timeout != 0));
678:                   
679:                   
680:                   //Check if we should read more bytes, depending upon the response type expected.  
681:                   if(sdmmc_cmdtable[cmd].responsetype == R2)
682:                   {
683:                       response.r2._byte1 = response.r1._byte; //We already received the first byte, just make sure it is in the correct location in the struct.
684:                       response.r2._byte0 = ReadMediaManual(); //Fetch the second byte of the response.
685:                   }
686:                   else if(sdmmc_cmdtable[cmd].responsetype == R1b)
687:                   {
688:                       //Keep trying to read from the media, until it signals it is no longer
689:                       //busy.  It will continuously send 0x00 bytes until it is not busy.
690:                       //A non-zero value means it is ready for the next command.
691:                       timeout = 0xFFFF;
692:                       do
693:                       {
694:                           response.r1._byte = ReadMediaManual();
695:                           timeout--;
696:                       }while((response.r1._byte == 0x00) && (timeout != 0));
697:               
698:                       response.r1._byte = 0x00;
699:                   }
700:                   else if (sdmmc_cmdtable[cmd].responsetype == R7) //also used for response R3 type
701:                   {
702:                       //Fetch the other four bytes of the R3 or R7 response.
703:                       //Note: The SD card argument response field is 32-bit, big endian format.
704:                       //However, the C compiler stores 32-bit values in little endian in RAM.
705:                       //When writing to the _returnVal/argument bytes, make sure the order it 
706:                       //gets stored in is correct.      
707:                       response.r7.bytewise.argument._byte3 = ReadMediaManual();
708:                       response.r7.bytewise.argument._byte2 = ReadMediaManual();
709:                       response.r7.bytewise.argument._byte1 = ReadMediaManual();
710:                       response.r7.bytewise.argument._byte0 = ReadMediaManual();
711:                   }
712:               
713:                   WriteSPIManual(0xFF);    //Device requires at least 8 clock pulses after 
714:                                            //the response has been sent, before if can process
715:                                            //the next command.  CS may be high or low.
716:               
717:                   // see if we are expecting more data or not
718:                   if(!(sdmmc_cmdtable[cmd].moredataexpected))
719:                       SD_CS = 1;
720:               
721:                   return(response);
722:               }
723:               #endif
724:               
725:               
726:               
727:               /*****************************************************************************
728:                 Function:
729:                   BYTE MDD_SDSPI_SectorRead (DWORD sector_addr, BYTE * buffer)
730:                 Summary:
731:                   Reads a sector of data from an SD card.
732:                 Conditions:
733:                   The MDD_SectorRead function pointer must be pointing towards this function.
734:                 Input:
735:                   sector_addr - The address of the sector on the card.
736:                   buffer -      The buffer where the retrieved data will be stored.  If
737:                                 buffer is NULL, do not store the data anywhere.
738:                 Return Values:
739:                   TRUE -  The sector was read successfully
740:                   FALSE - The sector could not be read
741:                 Side Effects:
742:                   None
743:                 Description:
744:                   The MDD_SDSPI_SectorRead function reads a sector of data bytes (512 bytes) 
745:                   of data from the SD card starting at the sector address and stores them in 
746:                   the location pointed to by 'buffer.'
747:                 Remarks:
748:                   The card expects the address field in the command packet to be a byte address.
749:                   The sector_addr value is converted to a byte address by shifting it left nine
750:                   times (multiplying by 512).
751:                   
752:                   This function performs a synchronous read operation.  In other words, this
753:                   function is a blocking function, and will not return until either the data
754:                   has fully been read, or, a timeout or other error occurred.
755:                 ***************************************************************************************/
756:               BYTE MDD_SDSPI_SectorRead(DWORD sector_addr, BYTE* buffer)
757:               {
758:                   ASYNC_IO info;
759:                   BYTE status;
760:                   
761:                   //Initialize info structure for using the MDD_SDSPI_AsyncReadTasks() function.
762:                   info.wNumBytes = 512;
00D4E4  202003     MOV #0x200, W3
00D4E6  9FBF93     MOV W3, [W15-14]
763:                   info.dwBytesRemaining = 512;
00D4E8  202004     MOV #0x200, W4
00D4EA  200005     MOV #0x0, W5
00D4EC  9FBFA4     MOV W4, [W15-12]
00D4EE  9FBFB5     MOV W5, [W15-10]
764:                   info.pBuffer = buffer;
00D4F0  9FBFC2     MOV W2, [W15-8]
765:                   info.dwAddress = sector_addr;
00D4F2  9FBFD0     MOV W0, [W15-6]
00D4F4  9FBFE1     MOV W1, [W15-4]
766:                   info.bStateVariable = ASYNC_READ_QUEUED;
00D4F6  B3C010     MOV #0x1, W0
00D4F8  9FFFE0     MOV.B W0, [W15-2]
767:                   
768:                   //Blocking loop, until the state machine finishes reading the sector,
769:                   //or a timeout or other error occurs.  MDD_SDSPI_AsyncReadTasks() will always
770:                   //return either ASYNC_READ_COMPLETE or ASYNC_READ_FAILED eventually 
771:                   //(could take awhile in the case of timeout), so this won't be a totally
772:                   //infinite blocking loop.
773:                   while(1)
774:                   {
775:                       status = MDD_SDSPI_AsyncReadTasks(&info);
00D4FA  57806E     SUB W15, #0xE, W0
00D4FC  07FF36     RCALL MDD_SDSPI_AsyncReadTasks
776:                       if(status == ASYNC_READ_COMPLETE)
00D4FE  E00400     CP0.B W0
00D500  3A0002     BRA NZ, 0xD506
00D502  200010     MOV #0x1, W0
00D504  370003     BRA 0xD50C
777:                       {
778:                           return TRUE;
779:                       }
780:                       else if(status == ASYNC_READ_ERROR)
00D506  404FE1     ADD.B W0, #0x1, [W15]
00D508  3AFFF8     BRA NZ, 0xD4FA
00D50A  EB0000     CLR W0
781:                       {
782:                           return FALSE;
783:                       } 
784:                   }       
785:               
786:                   //Impossible to get here, but we will return a value anyay to avoid possible 
787:                   //compiler warnings.
788:                   return FALSE;
789:               }    
00D510  FA001E     LNK #0x1E
00D512  BE9F88     MOV.D W8, [W15++]
00D514  BE9F8A     MOV.D W10, [W15++]
00D516  780480     MOV W0, W9
790:               
791:                
792:               
793:               
794:               
795:               
796:               /*****************************************************************************
797:                 Function:
798:                   BYTE MDD_SDSPI_AsyncReadTasks(ASYNC_IO* info)
799:                 Summary:
800:                   Speed optimized, non-blocking, state machine based read function that reads 
801:                   data packets from the media, and copies them to a user specified RAM buffer.
802:                 Pre-Conditions:
803:                   The ASYNC_IO structure must be initialized correctly, prior to calling
804:                   this function for the first time.  Certain parameters, such as the user
805:                   data buffer pointer (pBuffer) in the ASYNC_IO struct are allowed to be changed
806:                   by the application firmware, in between each call to MDD_SDSPI_AsyncReadTasks().
807:                   Additionally, the media and microcontroller SPI module should have already 
808:                   been initalized before using this function.  This function is mutually
809:                   exclusive with the MDD_SDSPI_AsyncWriteTasks() function.  Only one operation
810:                   (either one read or one write) is allowed to be in progress at a time, as
811:                   both functions share statically allocated resources and monopolize the SPI bus.
812:                 Input:
813:                   ASYNC_IO* info -        A pointer to a ASYNC_IO structure.  The 
814:                                           structure contains information about how to complete
815:                                           the read operation (ex: number of total bytes to read,
816:                                           where to copy them once read, maximum number of bytes
817:                                           to return for each call to MDD_SDSPI_AsyncReadTasks(), etc.).
818:                 Return Values:
819:                   BYTE - Returns a status byte indicating the current state of the read 
820:                           operation. The possible return values are:
821:                           
822:                           ASYNC_READ_BUSY - Returned when the state machine is busy waiting for
823:                                            a data start token from the media.  The media has a
824:                                            random access time, which can often be quite long
825:                                            (<= ~3ms typ, with maximum of 100ms).  No data
826:                                            has been copied yet in this case, and the application
827:                                            should keep calling MDD_SDSPI_AsyncReadTasks() until either
828:                                            an error/timeout occurs, or ASYNC_READ_NEW_PACKET_READY
829:                                            is returned.
830:                           ASYNC_READ_NEW_PACKET_READY -   Returned after a single packet, of
831:                                                           the specified size (in info->numBytes),
832:                                                           is ready to be read from the 
833:                                                           media and copied to the user 
834:                                                           specified data buffer.  Often, after
835:                                                           receiving this return value, the 
836:                                                           application firmware would want to
837:                                                           update the info->pReceiveBuffer pointer
838:                                                           before calling MDD_SDSPI_AsyncReadTasks()
839:                                                           again.  This way, the application can
840:                                                           begin fetching the next packet worth
841:                                                           of data, while still using/consuming
842:                                                           the previous packet of data.
843:                           ASYNC_READ_COMPLETE - Returned when all data bytes in the read 
844:                                                operation have been read and returned successfully,
845:                                                and the media is now ready for the next operation.
846:                           ASYNC_READ_ERROR - Returned when some failure occurs.  This could be
847:                                              either due to a media timeout, or due to some other
848:                                              unknown type of error.  In this case, the 
849:                                              MDD_SDSPI_AsyncReadTasks() handler will terminate
850:                                              the read attempt and will try to put the media 
851:                                              back in a default state, ready for a new command.  
852:                                              The application firmware may then retry the read
853:                                              attempt (if desired) by re-initializing the 
854:                                              ASYNC_IO structure and setting the 
855:                                              bStateVariable = ASYNC_READ_QUEUED.
856:               
857:                           
858:                 Side Effects:
859:                   Uses the SPI bus and the media.  The media and SPI bus should not be
860:                   used by any other function until the read operation has either completed
861:                   successfully, or returned with the ASYNC_READ_ERROR condition.
862:                 Description:
863:                   Speed optimized, non-blocking, state machine based read function that reads 
864:                   data packets from the media, and copies them to a user specified RAM buffer.
865:                   This function uses the multi-block read command (and stop transmission command) 
866:                   to perform fast reads of data.  The total amount of data that will be returned 
867:                   on any given call to MDD_SDSPI_AsyncReadTasks() will be the info->numBytes parameter.
868:                   However, if the function is called repeatedly, with info->bytesRemaining set
869:                   to a large number, this function can successfully fetch data sizes >> than
870:                   the block size (theoretically anything up to ~4GB, since bytesRemaining is 
871:                   a 32-bit DWORD).  The application firmware should continue calling 
872:                   MDD_SDSPI_AsyncReadTasks(), until the ASYNC_READ_COMPLETE value is returned 
873:                   (or ASYNC_READ_ERROR), even if it has already received all of the data expected.
874:                   This is necessary, so the state machine can issue the CMD12 (STOP_TRANMISSION) 
875:                   to terminate the multi-block read operation, once the total expected number 
876:                   of bytes have been read.  This puts the media back into the default state 
877:                   ready for a new command.
878:                   
879:                   During normal/successful operations, calls to MDD_SDSPI_AsyncReadTasks() 
880:                   would typically return:
881:                   1. ASYNC_READ_BUSY - repeatedly up to several milliseconds, then 
882:                   2. ASYNC_READ_NEW_PACKET_READY - repeatedly, until 512 bytes [media read 
883:                       block size] is received, then 
884:                   3. Back to ASYNC_READ_BUSY (for awhile, may be short), then
885:                   4. Back to ASYNC_READ_NEW_PACKET_READY (repeatedly, until the next 512 byte
886:                      boundary, then back to #3, etc.
887:                   5. After all data is received successfully, then the function will return 
888:                      ASYNC_READ_COMPLETE, for all subsequent calls (until a new read operation
889:                      is started, by re-initializing the ASYNC_IO structure, and re-calling
890:                      the function).
891:                   
892:                 Remarks:
893:                   This function will monopolize the SPI module during the operation.  Do not
894:                   use the SPI module for any other purpose, while a fetch operation is in
895:                   progress.  Additionally, the ASYNC_IO structure must not be modified
896:                   in a different context, while the MDD_SDSPI_AsyncReadTasks() function is executing.
897:                   In between calls to MDD_SDSPI_AsyncReadTasks(), certain parameters, namely the
898:                   info->numBytes and info->pReceiveBuffer are allowed to change however.
899:                   
900:                   The bytesRemaining value must always be an exact integer multiple of numBytes 
901:                   for the function to operate correctly.  Additionally, it is recommended, although
902:                   not essential, for the bytesRemaining to be an integer multiple of the media
903:                   read block size.
904:                   
905:                   When starting a read operation, the info->stateVariable must be initalized to
906:                   ASYNC_READ_QUEUED.  All other fields in the info structure should also be
907:                   initialized correctly.
908:                   
909:                   The info->wNumBytes must always be less than or equal to the media block size,
910:                   (which is 512 bytes).  Additionally, info->wNumBytes must always be an exact 
911:                   integer factor of the media block size (unless info->dwBytesRemaining is less
912:                   than the media block size).  Example values that are allowed for info->wNumBytes
913:                   are: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512.
914:                 *****************************************************************************/
915:               
916:               BYTE MDD_SDSPI_AsyncReadTasks(ASYNC_IO* info)
917:               {
918:                   BYTE bData;
919:                   MMC_RESPONSE response;
920:                   static WORD blockCounter;
921:                   static DWORD longTimeoutCounter;
922:                   static BOOL SingleBlockRead;
923:                   
924:                   //Check what state we are in, to decide what to do.
925:                   switch(info->bStateVariable)
00D370  9048C0     MOV.B [W0+12], W1
00D372  50CFE2     SUB.B W1, #0x2, [W15]
00D374  32005F     BRA Z, 0xD434
00D376  3E0006     BRA GTU, 0xD384
00D378  EB0000     CLR W0
00D37A  E00401     CP0.B W1
00D37C  3200AF     BRA Z, 0xD4DC
00D37E  50CFE1     SUB.B W1, #0x1, [W15]
00D380  3A00A9     BRA NZ, 0xD4D4
00D382  370005     BRA 0xD38E
00D384  50CFE3     SUB.B W1, #0x3, [W15]
00D386  320040     BRA Z, 0xD408
00D388  40CFE2     ADD.B W1, #0x2, [W15]
00D38A  3A00A4     BRA NZ, 0xD4D4
00D38C  370097     BRA 0xD4BC
926:                   {
927:                       case ASYNC_READ_COMPLETE:
928:                           return ASYNC_READ_COMPLETE;
929:                       case ASYNC_READ_QUEUED:
930:                           //Start the read request.  
931:                           
932:                           //Initialize some variables we will use later.
933:                           blockCounter = MEDIA_BLOCK_SIZE; //Counter will be used later for block boundary tracking
00D38E  202000     MOV #0x200, W0
00D390  8B80B0     MOV W0, blockCounter
934:                           ioInfo = *info; //Get local copy of structure, for quicker access with less code size
00D392  270380     MOV #0x7038, W0
00D394  090006     REPEAT #0x6
00D396  781839     MOV [W9++], [W0++]
00D398  B100E9     SUB #0xE, W9
935:               
936:                           //SDHC cards are addressed on a 512 byte block basis.  This is 1:1 equivalent
937:                           //to LBA addressing.  For standard capacity media, the media is expecting
938:                           //a complete byte address.  Therefore, to convert from the LBA address to the
939:                           //byte address, we need to multiply by 512.
940:                           if (gSDMode == SD_MODE_NORMAL)
00D39A  270300     MOV #0x7030, W0
00D39C  E00410     CP0.B [W0]
00D39E  3A0008     BRA NZ, 0xD3B0
941:                           {
942:                               ioInfo.dwAddress <<= 9; //Equivalent to multiply by 512
00D3A0  838200     MOV 0x7040, W0
00D3A2  838211     MOV 0x7042, W1
00D3A4  DD0949     SL W1, #9, W2
00D3A6  DE00C7     LSR W0, #7, W1
00D3A8  710081     IOR W2, W1, W1
00D3AA  DD0049     SL W0, #9, W0
00D3AC  8B8200     MOV W0, 0x7040
00D3AE  8B8211     MOV W1, 0x7042
943:                           }  
944:                           if(ioInfo.dwBytesRemaining <= MEDIA_BLOCK_SIZE)
00D3B0  2703A2     MOV #0x703A, W2
00D3B2  202000     MOV #0x200, W0
00D3B4  200001     MOV #0x0, W1
00D3B6  100FB2     SUBR W0, [W2++], [W15]
00D3B8  188FA2     SUBBR W1, [W2--], [W15]
00D3BA  3E000E     BRA GTU, 0xD3D8
945:                           {
946:                               SingleBlockRead = TRUE;
00D3BC  200010     MOV #0x1, W0
00D3BE  8B8080     MOV W0, SingleBlockRead
947:                               response = SendMMCCmd(READ_SINGLE_BLOCK, ioInfo.dwAddress);
00D3C0  57847C     SUB W15, #0x1C, W8
00D3C2  838202     MOV 0x7040, W2
00D3C4  838213     MOV 0x7042, W3
00D3C6  B3C081     MOV #0x8, W1
00D3C8  780008     MOV W8, W0
00D3CA  07FF6B     RCALL SendMMCCmd
00D3CC  BE0218     MOV.D [W8], W4
00D3CE  9FAFF4     MOV W4, [W15-34]
00D3D0  9FB785     MOV W5, [W15-32]
00D3D2  97B2CF     MOV [W15-24], W5
00D3D4  9FB795     MOV W5, [W15-30]
00D3D6  37000D     BRA 0xD3F2
948:                           }    
949:                           else
950:                           {
951:                               SingleBlockRead = FALSE;
00D3D8  EB0000     CLR W0
00D3DA  8B8080     MOV W0, SingleBlockRead
952:                               response = SendMMCCmd(READ_MULTI_BLOCK, ioInfo.dwAddress);
00D3DC  578476     SUB W15, #0x16, W8
00D3DE  838202     MOV 0x7040, W2
00D3E0  838213     MOV 0x7042, W3
00D3E2  B3C091     MOV #0x9, W1
00D3E4  780008     MOV W8, W0
00D3E6  07FF5D     RCALL SendMMCCmd
00D3E8  BE0018     MOV.D [W8], W0
00D3EA  9FAFF0     MOV W0, [W15-34]
00D3EC  9FB781     MOV W1, [W15-32]
00D3EE  97B0FF     MOV [W15-18], W1
00D3F0  9FB791     MOV W1, [W15-30]
953:                           }    
954:                           //Note: SendMMCmd() sends 8 SPI clock cycles after getting the
955:                           //response.  This meets the NAC min timing paramemter, so we don't
956:                           //need additional clocking here.
957:                           
958:                           // Make sure the command was accepted successfully
959:                           if(response.r1._byte != 0x00)
00D3F2  97D96F     MOV.B [W15-34], W2
00D3F4  E00402     CP0.B W2
00D3F6  3A001C     BRA NZ, 0xD430
960:                           {
961:                               //Perhaps the card isn't initialized or present.
962:                               info->bStateVariable = ASYNC_READ_ABORT;
963:                               return ASYNC_READ_BUSY; 
964:                           }
965:                           
966:                           //We successfully sent the READ_MULTI_BLOCK command to the media.
967:                           //We now need to keep polling the media until it sends us the data
968:                           //start token byte.
969:                           longTimeoutCounter = NAC_TIMEOUT; //prepare timeout counter for next state
00D3F8  200000     MOV #0x0, W0
00D3FA  200041     MOV #0x4, W1
00D3FC  8B8090     MOV W0, longTimeoutCounter
00D3FE  8B80A1     MOV W1, 0x7014
970:                           info->bStateVariable = ASYNC_READ_WAIT_START_TOKEN;
00D400  B3C030     MOV #0x3, W0
00D402  984CC0     MOV.B W0, [W9+12]
00D404  200010     MOV #0x1, W0
00D406  37006A     BRA 0xD4DC
971:                           return ASYNC_READ_BUSY;
972:                       case ASYNC_READ_WAIT_START_TOKEN:
973:                           //In this case, we have already issued the READ_MULTI_BLOCK command
974:                           //to the media, and we need to keep polling the media until it sends
975:                           //us the data start token byte.  This could typically take a 
976:                           //couple/few milliseconds, up to a maximum of 100ms.
977:                           if(longTimeoutCounter != 0x00000000)
00D408  838090     MOV longTimeoutCounter, W0
00D40A  8380A1     MOV 0x7014, W1
00D40C  500FE0     SUB W0, #0x0, [W15]
00D40E  588FE0     SUBB W1, #0x0, [W15]
00D410  32000F     BRA Z, 0xD430
978:                           {
979:                               longTimeoutCounter--;
00D412  500061     SUB W0, #0x1, W0
00D414  5880E0     SUBB W1, #0x0, W1
00D416  8B8090     MOV W0, longTimeoutCounter
00D418  8B80A1     MOV W1, 0x7014
980:                               bData = MDD_SDSPI_ReadMedia();
00D41A  07FF3B     RCALL MDD_SDSPI_ReadMedia
00D41C  784080     MOV.B W0, W1
981:                               
982:                               if(bData != MMC_FLOATING_BUS)
00D41E  200010     MOV #0x1, W0
00D420  40CFE1     ADD.B W1, #0x1, [W15]
00D422  32005C     BRA Z, 0xD4DC
983:                               {
984:                                   if(bData == DATA_START_TOKEN)
00D424  40CFE2     ADD.B W1, #0x2, [W15]
00D426  3A0004     BRA NZ, 0xD430
985:                                   {   
986:                                       //We got the start token.  Ready to receive the data
987:                                       //block now.
988:                                       info->bStateVariable = ASYNC_READ_NEW_PACKET_READY;
00D428  B3C020     MOV #0x2, W0
00D42A  984CC0     MOV.B W0, [W9+12]
00D42C  200020     MOV #0x2, W0
00D42E  370056     BRA 0xD4DC
989:                                       return ASYNC_READ_NEW_PACKET_READY;
990:                                   }
991:                                   else
992:                                   {
993:                                       //We got an unexpected non-0xFF, non-start token byte back?
994:                                       //Some kind of error must have occurred. 
995:                                       info->bStateVariable = ASYNC_READ_ABORT; 
996:                                       return ASYNC_READ_BUSY;
997:                                   }        
998:                               }
999:                               else
1000:                              {
1001:                                  //Media is still busy.  Start token not received yet.
1002:                                  return ASYNC_READ_BUSY;
1003:                              }                    
1004:                          } 
1005:                          else
1006:                          {
1007:                              //The media didn't respond with the start data token in the timeout
1008:                              //interval allowed.  Operation failed.  Abort the operation.
1009:                              info->bStateVariable = ASYNC_READ_ABORT; 
00D430  B3CFE0     MOV #0xFE, W0
00D432  37FFE7     BRA 0xD402
1010:                              return ASYNC_READ_BUSY;                
1011:                          }       
1012:                          //Should never execute to here
1013:                          
1014:                      case ASYNC_READ_NEW_PACKET_READY:
1015:                          //We have sent the READ_MULTI_BLOCK command and have successfully
1016:                          //received the data start token byte.  Therefore, we are ready
1017:                          //to receive raw data bytes from the media.
1018:                          if(ioInfo.dwBytesRemaining != 0x00000000)
00D434  8381D2     MOV 0x703A, W2
00D436  8381E3     MOV 0x703C, W3
00D438  510FE0     SUB W2, #0x0, [W15]
00D43A  598FE0     SUBB W3, #0x0, [W15]
00D43C  320032     BRA Z, 0xD4A2
1019:                          {
1020:                              //Re-update local copy of pointer and number of bytes to read in this
1021:                              //call.  These parameters are allowed to change between packets.
1022:                              ioInfo.wNumBytes = info->wNumBytes;
00D43E  780210     MOV [W0], W4
00D440  8B81C4     MOV W4, ioInfo
1023:                         	    ioInfo.pBuffer = info->pBuffer;
00D442  9002B0     MOV [W0+6], W5
00D444  8B81F5     MOV W5, 0x703E
1024:                         	    
1025:                         	    //Update counters for state tracking and loop exit condition tracking.
1026:                              ioInfo.dwBytesRemaining -= ioInfo.wNumBytes;
00D446  780184     MOV W4, W3
00D448  B82061     MUL.UU W4, #1, W0
00D44A  2703A2     MOV #0x703A, W2
00D44C  100232     SUBR W0, [W2++], W4
00D44E  1882A2     SUBBR W1, [W2--], W5
00D450  8B81D4     MOV W4, 0x703A
00D452  8B81E5     MOV W5, 0x703C
1027:                              blockCounter -= ioInfo.wNumBytes;
00D454  8380B0     MOV blockCounter, W0
00D456  500203     SUB W0, W3, W4
00D458  8B80B4     MOV W4, blockCounter
1028:              
1029:                              //Now read a ioInfo.wNumBytes packet worth of SPI bytes, 
1030:                              //and place the received bytes in the user specified pBuffer.
1031:                              //This operation directly dictates data thoroughput in the 
1032:                              //application, therefore optimized code should be used for each 
1033:                              //processor type.
1034:                          	#if defined __C30__ || defined __C32__
1035:                              {
1036:                                  //PIC24/dsPIC/PIC32 architecture is efficient with pointers.
1037:                                  //Therefore, this code can provide good SPI bus utilization, 
1038:                                  //provided the compiler optimization level is 's' or '3'.
1039:                                  BYTE* localPointer = ioInfo.pBuffer;
00D45A  8381F0     MOV 0x703E, W0
1040:                                  WORD localCounter = ioInfo.wNumBytes;
1041:                                  
1042:                                  if(localCounter != 0x0000)
00D45C  E00003     CP0 W3
00D45E  320012     BRA Z, 0xD484
1043:                                  {
1044:                                      localPointer--;
00D460  E90100     DEC W0, W2
00D462  200FF5     MOV #0xFF, W5
00D464  410083     ADD W2, W3, W1
1045:                                      while(1)
1046:                                      {
1047:                                          SPIBUF = 0xFF;
00D466  881245     MOV W5, SPI1BUF
1048:                                          localPointer++;
00D468  E80102     INC W2, W2
1049:                                          if((--localCounter) == 0x0000)
00D46A  510F81     SUB W2, W1, [W15]
00D46C  320006     BRA Z, 0xD47A
1050:                                          {
1051:                                             break; 
1052:                                          } 
1053:                                          while(!SPISTAT_RBF);
00D46E  BFC240     MOV.B SPI1STAT, WREG
00D470  A30800     BTST.Z W0, #0
00D472  32FFFD     BRA Z, 0xD46E
1054:                                          *localPointer = (BYTE)SPIBUF;
00D474  801240     MOV SPI1BUF, W0
00D476  784900     MOV.B W0, [W2]
00D478  37FFF6     BRA 0xD466
1055:                                      }
1056:                                      while(!SPISTAT_RBF);
00D47A  BFC240     MOV.B SPI1STAT, WREG
00D47C  A30800     BTST.Z W0, #0
00D47E  32FFFD     BRA Z, 0xD47A
1057:                                      *localPointer = (BYTE)SPIBUF;  
00D480  801240     MOV SPI1BUF, W0
00D482  784900     MOV.B W0, [W2]
1058:                                  }  
1059:                              }    
1060:                              #elif defined __18CXX
1061:                                  PIC18_Optimized_SPI_Read_Packet();
1062:                          	#endif   
1063:              
1064:                              //Check if we have received a multiple of the media block 
1065:                              //size (ex: 512 bytes).  If so, the next two bytes are going to 
1066:                              //be CRC values, rather than data bytes.  
1067:                              if(blockCounter == 0)
00D484  200020     MOV #0x2, W0
00D486  E00004     CP0 W4
00D488  3A0029     BRA NZ, 0xD4DC
1068:                              {
1069:                                  //Read two bytes to receive the CRC-16 value on the data block.
1070:                                  MDD_SDSPI_ReadMedia();
00D48A  07FF03     RCALL MDD_SDSPI_ReadMedia
1071:                                  MDD_SDSPI_ReadMedia();
00D48C  07FF02     RCALL MDD_SDSPI_ReadMedia
1072:                                  //Following sending of the CRC-16 value, the media may still
1073:                                  //need more access time to internally fetch the next block.
1074:                                  //Therefore, it will send back 0xFF idle value, until it is
1075:                                  //ready.  Then it will send a new data start token, followed
1076:                                  //by the next block of useful data.
1077:                                  if(ioInfo.dwBytesRemaining != 0x00000000)
00D48E  8381D0     MOV 0x703A, W0
00D490  8381E1     MOV 0x703C, W1
00D492  500FE0     SUB W0, #0x0, [W15]
00D494  588FE0     SUBB W1, #0x0, [W15]
00D496  320002     BRA Z, 0xD49C
1078:                                  {
1079:                                      info->bStateVariable = ASYNC_READ_WAIT_START_TOKEN;
00D498  B3C030     MOV #0x3, W0
00D49A  984CC0     MOV.B W0, [W9+12]
1080:                                  }
1081:                                  blockCounter = MEDIA_BLOCK_SIZE;
00D49C  202000     MOV #0x200, W0
00D49E  8B80B0     MOV W0, blockCounter
00D4A0  37FFB1     BRA 0xD404
1082:                                  return ASYNC_READ_BUSY;
1083:                              }
1084:                                  
1085:                              return ASYNC_READ_NEW_PACKET_READY;
1086:                          }//if(ioInfo.dwBytesRemaining != 0x00000000)
1087:                          else
1088:                          {
1089:                              //We completed the read operation successfully and have returned
1090:                              //all data bytes requested.
1091:                              //Send CMD12 to let the media know we are finished reading
1092:                              //blocks from it, if we sent a multi-block read request earlier.
1093:                              if(SingleBlockRead == FALSE)
00D4A2  838080     MOV SingleBlockRead, W0
00D4A4  E00000     CP0 W0
00D4A6  3A0003     BRA NZ, 0xD4AE
1094:                              {
1095:                                  SendMMCCmd(STOP_TRANSMISSION, 0x00000000);
00D4A8  B3C051     MOV #0x5, W1
00D4AA  578070     SUB W15, #0x10, W0
00D4AC  07FEFA     RCALL SendMMCCmd
1096:                              }    
1097:                              SD_CS = 1;  //De-select media
00D4AE  A8C2D5     BSET 0x2D5, #6
1098:                              mSend8ClkCycles();  
00D4B0  EBC000     SETM.B W0
00D4B2  07FEE8     RCALL WriteSPIM
1099:                              info->bStateVariable = ASYNC_READ_COMPLETE;
00D4B4  EB4000     CLR.B W0
00D4B6  984CC0     MOV.B W0, [W9+12]
00D4B8  EB0000     CLR W0
00D4BA  370010     BRA 0xD4DC
1100:                              return ASYNC_READ_COMPLETE;
1101:                          }
1102:                      case ASYNC_READ_ABORT:
1103:                          //If the application firmware wants to cancel a read request.
1104:                          info->bStateVariable = ASYNC_READ_ERROR;
00D4BC  EBC000     SETM.B W0
00D4BE  984CC0     MOV.B W0, [W9+12]
1105:                          //Send CMD12 to terminate the multi-block read request.
1106:                          response = SendMMCCmd(STOP_TRANSMISSION, 0x00000000);
00D4C0  57846A     SUB W15, #0xA, W8
00D4C2  B81160     MUL.UU W2, #0, W2
00D4C4  B3C051     MOV #0x5, W1
00D4C6  780008     MOV W8, W0
00D4C8  07FEEC     RCALL SendMMCCmd
00D4CA  BE0018     MOV.D [W8], W0
00D4CC  9FAFF0     MOV W0, [W15-34]
00D4CE  9FB781     MOV W1, [W15-32]
00D4D0  97B8DF     MOV [W15-6], W1
00D4D2  9FB791     MOV W1, [W15-30]
1107:                          //Fall through to ASYNC_READ_ERROR/default case.
1108:                      case ASYNC_READ_ERROR:
1109:                      default:
1110:                          //Some error must have happened.
1111:                          SD_CS = 1;  //De-select media
00D4D4  A8C2D5     BSET 0x2D5, #6
1112:                          mSend8ClkCycles();  
00D4D6  EBC000     SETM.B W0
00D4D8  07FED5     RCALL WriteSPIM
00D4DA  200FF0     MOV #0xFF, W0
1113:                          return ASYNC_READ_ERROR; 
1114:                  }//switch(info->stateVariable)    
1115:                  
1116:                  //Should never get to here.  All pathways should have already returned.
1117:                  return ASYNC_READ_ERROR;
1118:              }    
00D4E2  FA000E     LNK #0xE
1119:              
1120:              
1121:              
1122:              
1123:              #ifdef __18CXX
1124:              /*****************************************************************************
1125:                Function:
1126:                  static void PIC18_Optimized_SPI_Read_Packet(void)
1127:                Summary:
1128:                  A private function intended for use internal to the SD-SPI.c file.
1129:                  This function reads a specified number of bytes from the SPI module,
1130:                  at high speed for optimum thoroughput, and copies them into the user
1131:                  specified RAM buffer.
1132:                  This function is only implemented and used on PIC18 devices.
1133:                Pre-Conditions:
1134:                  The ioInfo.wNumBytes must be pre-initialized prior to calling 
1135:                  PIC18_Optimized_SPI_Read_Packet().
1136:                  Additionally, the ioInfo.pBuffer must also be pre-initialized, prior
1137:                  to calling PIC18_Optimized_SPI_Read_Packet().
1138:                Input:
1139:                  ioInfo.wNumBytes global variable, initialized to the number of bytes to read.
1140:                  ioInfo.pBuffer global variable, initialize to point to the RAM location that
1141:                      the read data should be copied to.
1142:                Return Values:
1143:                  None (although the ioInfo.pBuffer RAM specified will contain new contents)
1144:                Side Effects:
1145:                  None
1146:                Description:
1147:                  A private function intended for use internal to the SD-SPI.c file.
1148:                  This function reads a specified number of bytes from the SPI module,
1149:                  at high speed for optimum thoroughput, and copies them into the user
1150:                  specified RAM buffer.
1151:                  This function is only implemented and used on PIC18 devices.
1152:                Remarks:
1153:                  This function is speed optimized, using inline assembly language code, and
1154:                  makes use of C compiler managed resources.  It is currently written to work
1155:                  with the Microchip MPLAB C18 compiler, and may need modification is built
1156:                  with a different PIC18 compiler.
1157:                *****************************************************************************/
1158:              static void PIC18_Optimized_SPI_Read_Packet(void)
1159:              {
1160:                  static WORD FSR0Save;
1161:                  static WORD PRODSave;
1162:              
1163:                  //Make sure the SPI_INTERRUPT_FLAG_ASM has been correctly defined, for the SPI
1164:                  //module that is actually being used in the hardware.
1165:                  #ifndef SPI_INTERRUPT_FLAG_ASM
1166:                      #error "Please define SPI_INTERRUPT_FLAG_ASM.  Double click this message for more info."
1167:                      //In the HardwareProfile - [platform name].h file for your project, please
1168:                      //add a "#define SPI_INTERRUPT_FLAG_ASM  PIRx, y" definition, where
1169:                      //PIRx is the PIR register holding the SSPxIF flag for the SPI module being used
1170:                      //to interface with the SD/MMC card, and y is the bit number for the SSPxIF bit (ex: 0-7).
1171:                  #endif
1172:              
1173:                  //Make sure at least one byte needs to be read.
1174:                  if(ioInfo.wNumBytes == 0)
1175:                  {
1176:                      return;
1177:                  }
1178:              
1179:                  //Context save C compiler managed registers that we will modify in this function.
1180:                  FSR0Save = FSR0;    
1181:                  PRODSave = PROD;    
1182:                  
1183:                  //Using PRODH and PRODL as convenient 16-bit access bank counter
1184:                  PROD = ioInfo.wNumBytes;    //ioInfo.wNumBytes holds the total number of bytes
1185:                                              //this function will read from SPI.
1186:                  //Going to use the FSR0 directly.  This is non-conventional, but delivers
1187:                  //better performance than using a normal C managed software RAM pointer.
1188:                  FSR0 = (WORD)ioInfo.pBuffer;
1189:              
1190:                  //Initiate the first SPI operation
1191:                  WREG = SPIBUF;
1192:                  SPI_INTERRUPT_FLAG = 0;
1193:                  SPIBUF = 0xFF;
1194:              
1195:                  //Highly speed efficient SPI read loop, written in inline assembly
1196:                  //language for best performance.  Total number of bytes that will be fetched
1197:                  //is exactly == the value of ioInfo.wNumBytes prior to calling this function.
1198:                  _asm
1199:                      bra     ASMSPIReadLoopEntryPoint
1200:                  
1201:              ASMSPIReadLoop:
1202:                      //Wait until last hardware SPI transaction is complete
1203:                      btfss   SPI_INTERRUPT_FLAG_ASM, 0
1204:                      bra     -2
1205:                      bcf     SPI_INTERRUPT_FLAG_ASM, 0
1206:              
1207:                      //Save received byte and start the next transfer
1208:                      movf    SPIBUF, 0, 0    //Copy SPIBUF byte into WREG
1209:                      setf    SPIBUF, 0       //Write 0xFF to SPIBUF, to start a SPI transaction
1210:                      movwf   POSTINC0, 0     //Write the last received byte to the user's RAM buffer
1211:                  
1212:              ASMSPIReadLoopEntryPoint:
1213:                      //Now decrement 16-bit counter for loop exit test condition
1214:                      movlw   0x00
1215:                      decf    PRODL, 1, 0     //Decrement LSB
1216:                      subwfb  PRODH, 1, 0     //Decrement MSB, only if borrow from LSB decrement
1217:                      //Check if anymore bytes remain to be sent
1218:                      movf    PRODL, 0, 0     //copy PRODL to WREG
1219:                      iorwf   PRODH, 0, 0     //Z bit will be set if both PRODL and PRODH == 0x00
1220:                      bnz     ASMSPIReadLoop  //Go back and loop if our counter isn't = 0x0000.
1221:              
1222:                      //Wait until the very last SPI transaction is complete and save the byte
1223:                      btfss   SPI_INTERRUPT_FLAG_ASM, 0
1224:                      bra     -2
1225:                      movff   SPIBUF, POSTINC0
1226:                  _endasm
1227:              
1228:                  SPI_INTERRUPT_FLAG = 0;	 
1229:              
1230:                  //Context restore C compiler managed registers
1231:                  PROD = PRODSave;
1232:                  FSR0 = FSR0Save;    
1233:              }    
1234:              #endif
1235:              
1236:              
1237:              
1238:              
1239:              
1240:              /*****************************************************************************
1241:                Function:
1242:                  BYTE MDD_SDSPI_AsyncWriteTasks(ASYNC_IO* info)
1243:                Summary:
1244:                  Speed optimized, non-blocking, state machine based write function that writes
1245:                  data from the user specified buffer, onto the media, at the specified 
1246:                  media block address.
1247:                Pre-Conditions:
1248:                  The ASYNC_IO structure must be initialized correctly, prior to calling
1249:                  this function for the first time.  Certain parameters, such as the user
1250:                  data buffer pointer (pBuffer) in the ASYNC_IO struct are allowed to be changed
1251:                  by the application firmware, in between each call to MDD_SDSPI_AsyncWriteTasks().
1252:                  Additionally, the media and microcontroller SPI module should have already 
1253:                  been initalized before using this function.  This function is mutually
1254:                  exclusive with the MDD_SDSPI_AsyncReadTasks() function.  Only one operation
1255:                  (either one read or one write) is allowed to be in progress at a time, as
1256:                  both functions share statically allocated resources and monopolize the SPI bus.
1257:                Input:
1258:                  ASYNC_IO* info -        A pointer to a ASYNC_IO structure.  The 
1259:                                          structure contains information about how to complete
1260:                                          the write operation (ex: number of total bytes to write,
1261:                                          where to obtain the bytes from, number of bytes
1262:                                          to write for each call to MDD_SDSPI_AsyncWriteTasks(), etc.).
1263:                Return Values:
1264:                  BYTE - Returns a status byte indicating the current state of the write 
1265:                          operation. The possible return values are:
1266:                          
1267:                          ASYNC_WRITE_BUSY - Returned when the state machine is busy waiting for
1268:                                           the media to become ready to accept new data.  The 
1269:                                           media has write time, which can often be quite long
1270:                                           (a few ms typ, with maximum of 250ms).  The application
1271:                                           should keep calling MDD_SDSPI_AsyncWriteTasks() until either
1272:                                           an error/timeout occurs, ASYNC_WRITE_SEND_PACKET
1273:                                           is returned, or ASYNC_WRITE_COMPLETE is returned.
1274:                          ASYNC_WRITE_SEND_PACKET -   Returned when the MDD_SDSPI_AsyncWriteTasks()
1275:                                                      handler is ready to consume data and send
1276:                                                      it to the media.  After ASYNC_WRITE_SEND_PACKET
1277:                                                      is returned, the application should make certain
1278:                                                      that the info->wNumBytes and pBuffer parameters
1279:                                                      are correct, prior to calling 
1280:                                                      MDD_SDSPI_AsyncWriteTasks() again.  After
1281:                                                      the function returns, the application is
1282:                                                      then free to write new data into the pBuffer
1283:                                                      RAM location. 
1284:                          ASYNC_WRITE_COMPLETE - Returned when all data bytes in the write
1285:                                               operation have been written to the media successfully,
1286:                                               and the media is now ready for the next operation.
1287:                          ASYNC_WRITE_ERROR - Returned when some failure occurs.  This could be
1288:                                             either due to a media timeout, or due to some other
1289:                                             unknown type of error.  In this case, the 
1290:                                             MDD_SDSPI_AsyncWriteTasks() handler will terminate
1291:                                             the write attempt and will try to put the media 
1292:                                             back in a default state, ready for a new command.  
1293:                                             The application firmware may then retry the write
1294:                                             attempt (if desired) by re-initializing the 
1295:                                             ASYNC_IO structure and setting the 
1296:                                             bStateVariable = ASYNC_WRITE_QUEUED.
1297:              
1298:                          
1299:                Side Effects:
1300:                  Uses the SPI bus and the media.  The media and SPI bus should not be
1301:                  used by any other function until the read operation has either completed
1302:                  successfully, or returned with the ASYNC_WRITE_ERROR condition.
1303:                Description:
1304:                  Speed optimized, non-blocking, state machine based write function that writes 
1305:                  data packets to the media, from a user specified RAM buffer.
1306:                  This function uses either the single block or multi-block write command 
1307:                  to perform fast writes of the data.  The total amount of data that will be 
1308:                  written on any given call to MDD_SDSPI_AsyncWriteTasks() will be the 
1309:                  info->numBytes parameter.
1310:                  However, if the function is called repeatedly, with info->dwBytesRemaining
1311:                  set to a large number, this function can successfully write data sizes >> than
1312:                  the block size (theoretically anything up to ~4GB, since dwBytesRemaining is 
1313:                  a 32-bit DWORD).  The application firmware should continue calling 
1314:                  MDD_SDSPI_AsyncWriteTasks(), until the ASYNC_WRITE_COMPLETE value is returned 
1315:                  (or ASYNC_WRITE_ERROR), even if it has already sent all of the data expected.
1316:                  This is necessary, so the state machine can finish the write process and 
1317:                  terminate the multi-block write operation, once the total expected number 
1318:                  of bytes have been written.  This puts the media back into the default state 
1319:                  ready for a new command.
1320:                  
1321:                  During normal/successful operations, calls to MDD_SDSPI_AsyncWriteTasks() 
1322:                  would typically return:
1323:                  1. ASYNC_WRITE_SEND_PACKET - repeatedly, until 512 bytes [media read 
1324:                      block size] is received, then 
1325:                  2. ASYNC_WRITE_BUSY (for awhile, could be a long time, many milliseconds), then
1326:                  3. Back to ASYNC_WRITE_SEND_PACKET (repeatedly, until the next 512 byte
1327:                     boundary, then back to #2, etc.
1328:                  4. After all data is copied successfully, then the function will return 
1329:                     ASYNC_WRITE_COMPLETE, for all subsequent calls (until a new write operation
1330:                     is started, by re-initializing the ASYNC_IO structure, and re-calling
1331:                     the function).
1332:                  
1333:                Remarks:
1334:                  When starting a read operation, the info->stateVariable must be initalized to
1335:                  ASYNC_WRITE_QUEUED.  All other fields in the info structure should also be
1336:                  initialized correctly.
1337:              
1338:                  This function will monopolize the SPI module during the operation.  Do not
1339:                  use the SPI module for any other purpose, while a write operation is in
1340:                  progress.  Additionally, the ASYNC_IO structure must not be modified
1341:                  in a different context, while the MDD_SDSPI_AsyncReadTasks() function is 
1342:                  actively executing.
1343:                  In between calls to MDD_SDSPI_AsyncWriteTasks(), certain parameters, namely the
1344:                  info->wNumBytes and info->pBuffer are allowed to change however.
1345:                  
1346:                  The dwBytesRemaining value must always be an exact integer multiple of wNumBytes 
1347:                  for the function to operate correctly.  Additionally, it is required that
1348:                  the wNumBytes parameter, must always be less than or equal to the media block size,
1349:                  (which is 512 bytes).  Additionally, info->wNumBytes must always be an exact 
1350:                  integer factor of the media block size.  Example values that are allowed for
1351:                  info->wNumBytes are: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512.
1352:                *****************************************************************************/
1353:              BYTE MDD_SDSPI_AsyncWriteTasks(ASYNC_IO* info)
1354:              {
1355:                  static BYTE data_byte;
1356:                  static WORD blockCounter;
1357:                  static DWORD WriteTimeout;
1358:                  static BYTE command;
1359:                  DWORD preEraseBlockCount;
1360:                  MMC_RESPONSE response;
1361:              
1362:                  
1363:                  //Check what state we are in, to decide what to do.
1364:                  switch(info->bStateVariable)
00D518  9048C0     MOV.B [W0+12], W1
00D51A  50CFE2     SUB.B W1, #0x2, [W15]
00D51C  320058     BRA Z, 0xD5CE
00D51E  3E0006     BRA GTU, 0xD52C
00D520  EB0000     CLR W0
00D522  E00401     CP0.B W1
00D524  3200D6     BRA Z, 0xD6D2
00D526  50CFE1     SUB.B W1, #0x1, [W15]
00D528  3A0050     BRA NZ, 0xD5CA
00D52A  370006     BRA 0xD538
00D52C  50CFE4     SUB.B W1, #0x4, [W15]
00D52E  3200B3     BRA Z, 0xD696
00D530  390088     BRA NC, 0xD642
00D532  40CFE2     ADD.B W1, #0x2, [W15]
00D534  3200C5     BRA Z, 0xD6C0
00D536  370049     BRA 0xD5CA
1365:                  {
1366:                      case ASYNC_WRITE_COMPLETE:
1367:                          return ASYNC_WRITE_COMPLETE;
1368:                      case ASYNC_WRITE_QUEUED:
1369:                          //Initiate the write sequence.
1370:                          blockCounter = MEDIA_BLOCK_SIZE;    //Initialize counter.  Will be used later for block boundary tracking.
00D538  202000     MOV #0x200, W0
00D53A  8B80F0     MOV W0, blockCounter
1371:              
1372:                          //Copy input structure into a statically allocated global instance 
1373:                          //of the structure, for faster local access of the parameters with 
1374:                          //smaller code size.
1375:                          ioInfo = *info;
00D53C  270380     MOV #0x7038, W0
00D53E  090006     REPEAT #0x6
00D540  781839     MOV [W9++], [W0++]
00D542  B100E9     SUB #0xE, W9
1376:              
1377:                          //Check if we are writing only a single block worth of data, or 
1378:                          //multiple blocks worth of data.
1379:                          if(ioInfo.dwBytesRemaining <= MEDIA_BLOCK_SIZE)
00D544  8381D2     MOV 0x703A, W2
00D546  8381E3     MOV 0x703C, W3
00D548  270181     MOV #0x7018, W1
00D54A  202004     MOV #0x200, W4
00D54C  510F84     SUB W2, W4, [W15]
00D54E  598FE0     SUBB W3, #0x0, [W15]
00D550  3E0003     BRA GTU, 0xD558
1380:                          {
1381:                              command = WRITE_SINGLE_BLOCK;
00D552  B3C0A0     MOV #0xA, W0
00D554  784880     MOV.B W0, [W1]
00D556  37001D     BRA 0xD592
1382:                          }    
1383:                          else
1384:                          {
1385:                              command = WRITE_MULTI_BLOCK;
00D558  B3C0B0     MOV #0xB, W0
00D55A  784880     MOV.B W0, [W1]
1386:                              
1387:                              //Compute the number of blocks that we are going to be writing in this multi-block write operation.
1388:                              preEraseBlockCount = (ioInfo.dwBytesRemaining >> 9); //Divide by 512 to get the number of blocks to write
00D55C  DE1DC9     LSR W3, #9, W11
00D55E  DD1AC7     SL W3, #7, W5
00D560  DE1549     LSR W2, #9, W10
00D562  72850A     IOR W5, W10, W10
1389:                              //Always need to erase at least one block.
1390:                              if(preEraseBlockCount == 0)
00D564  550FE0     SUB W10, #0x0, [W15]
00D566  5D8FE0     SUBB W11, #0x0, [W15]
00D568  3A0002     BRA NZ, 0xD56E
00D56A  20001A     MOV #0x1, W10
00D56C  20000B     MOV #0x0, W11
1391:                              {
1392:                                  preEraseBlockCount++;   
1393:                              } 
1394:                  
1395:                              //Should send CMD55/ACMD23 to let the media know how many blocks it should 
1396:                              //pre-erase.  This isn't essential, but it allows for faster multi-block 
1397:                              //writes, and probably also reduces flash wear on the media.
1398:                              response = SendMMCCmd(APP_CMD, 0x00000000);    //Send CMD55
00D56E  2FFE00     MOV #0xFFE0, W0
00D570  478400     ADD W15, W0, W8
00D572  B81160     MUL.UU W2, #0, W2
00D574  B3C0F1     MOV #0xF, W1
00D576  780008     MOV W8, W0
00D578  07FE94     RCALL SendMMCCmd
00D57A  BE0218     MOV.D [W8], W4
00D57C  9FAFD4     MOV W4, [W15-38]
00D57E  9FAFE5     MOV W5, [W15-36]
00D580  97B2AF     MOV [W15-28], W5
00D582  9FAFF5     MOV W5, [W15-34]
1399:                              if(response.r1._byte == 0x00)   //Check if successful.
00D584  97D82F     MOV.B [W15-38], W0
00D586  E00400     CP0.B W0
00D588  3A0004     BRA NZ, 0xD592
1400:                              {
1401:                                  SendMMCCmd(SET_WR_BLK_ERASE_COUNT , preEraseBlockCount);    //Send ACMD23        
00D58A  BE010A     MOV.D W10, W2
00D58C  B3C131     MOV #0x13, W1
00D58E  57807A     SUB W15, #0x1A, W0
00D590  07FE88     RCALL SendMMCCmd
1402:                              }
1403:                          }    
1404:              
1405:                          //The info->dwAddress parameter is the block address.
1406:                          //For standard capacity SD cards, the card expects a complete byte address.
1407:                          //To convert the block address into a byte address, we multiply by the block size (512).
1408:                          //For SDHC (high capacity) cards, the card expects a block address already, so no
1409:                          //address cconversion is needed
1410:                          if (gSDMode == SD_MODE_NORMAL)  
00D592  270300     MOV #0x7030, W0
00D594  E00410     CP0.B [W0]
00D596  3A0008     BRA NZ, 0xD5A8
1411:                          {
1412:                              ioInfo.dwAddress <<= 9;   //<< 9 multiplies by 512
00D598  838200     MOV 0x7040, W0
00D59A  838211     MOV 0x7042, W1
00D59C  DD0949     SL W1, #9, W2
00D59E  DE00C7     LSR W0, #7, W1
00D5A0  710081     IOR W2, W1, W1
00D5A2  DD0049     SL W0, #9, W0
00D5A4  8B8200     MOV W0, 0x7040
00D5A6  8B8211     MOV W1, 0x7042
1413:                          }    
1414:              
1415:                          //Send the write single or write multi command, with the LBA or byte 
1416:                          //address (depeding upon SDHC or standard capacity card)
1417:                          response = SendMMCCmd(command, ioInfo.dwAddress);    
00D5A8  578474     SUB W15, #0x14, W8
00D5AA  838202     MOV 0x7040, W2
00D5AC  838213     MOV 0x7042, W3
00D5AE  270180     MOV #0x7018, W0
00D5B0  784090     MOV.B [W0], W1
00D5B2  780008     MOV W8, W0
00D5B4  07FE76     RCALL SendMMCCmd
00D5B6  BE0218     MOV.D [W8], W4
00D5B8  9FAFD4     MOV W4, [W15-38]
00D5BA  9FAFE5     MOV W5, [W15-36]
00D5BC  97BA8F     MOV [W15-16], W5
00D5BE  9FAFF5     MOV W5, [W15-34]
1418:              
1419:                          //See if it was accepted
1420:                          if(response.r1._byte != 0x00)
00D5C0  97D82F     MOV.B [W15-38], W0
00D5C2  E00400     CP0.B W0
00D5C4  320061     BRA Z, 0xD688
1421:                          {
1422:                              //Perhaps the card isn't initialized or present.
1423:                              info->bStateVariable = ASYNC_WRITE_ERROR;
00D5C6  EBC000     SETM.B W0
00D5C8  984CC0     MOV.B W0, [W9+12]
00D5CA  200FF0     MOV #0xFF, W0
00D5CC  370082     BRA 0xD6D2
1424:                              return ASYNC_WRITE_ERROR; 
1425:                          }    
1426:                          else
1427:                          {
1428:                              //Card is ready to receive start token and data bytes.
1429:                              info->bStateVariable = ASYNC_WRITE_TRANSMIT_PACKET;
1430:                          } 
1431:                          return ASYNC_WRITE_SEND_PACKET;   
1432:              
1433:                      case ASYNC_WRITE_TRANSMIT_PACKET:
1434:                          //Check if we just finished programming a block, or we are starting
1435:                          //for the first time.  In this case, we need to send the data start token.
1436:                          if(blockCounter == MEDIA_BLOCK_SIZE)
00D5CE  8380F1     MOV blockCounter, W1
00D5D0  202000     MOV #0x200, W0
00D5D2  508F80     SUB W1, W0, [W15]
00D5D4  3A0008     BRA NZ, 0xD5E6
1437:                          {
1438:                              //Send the correct data start token, based on the type of write we are doing
1439:                              if(command == WRITE_MULTI_BLOCK)
00D5D6  270180     MOV #0x7018, W0
00D5D8  B3C0B1     MOV #0xB, W1
00D5DA  10CF90     SUBR.B W1, [W0], [W15]
00D5DC  3A0002     BRA NZ, 0xD5E2
1440:                              {
1441:                                  WriteSPIM(DATA_START_MULTI_BLOCK_TOKEN);   
00D5DE  B3CFC0     MOV #0xFC, W0
00D5E0  370001     BRA 0xD5E4
1442:                              }
1443:                              else
1444:                              {
1445:                                  //Else must be a single block write
1446:                                  WriteSPIM(DATA_START_TOKEN);   
00D5E2  B3CFE0     MOV #0xFE, W0
00D5E4  07FE4F     RCALL WriteSPIM
1447:                              }        
1448:                          } 
1449:                             
1450:                          //Update local copy of pointer and byte count.  Application firmware
1451:                          //is alllowed to change these between calls to this handler function.
1452:                          ioInfo.wNumBytes = info->wNumBytes;
00D5E6  780119     MOV [W9], W2
00D5E8  8B81C2     MOV W2, ioInfo
1453:                          ioInfo.pBuffer = info->pBuffer;
00D5EA  900239     MOV [W9+6], W4
00D5EC  8B81F4     MOV W4, 0x703E
1454:                          
1455:                          //Keep track of variables for loop/state exit conditions.
1456:                          ioInfo.dwBytesRemaining -= ioInfo.wNumBytes;
00D5EE  780182     MOV W2, W3
00D5F0  B81061     MUL.UU W2, #1, W0
00D5F2  2703A2     MOV #0x703A, W2
00D5F4  100232     SUBR W0, [W2++], W4
00D5F6  1882A2     SUBBR W1, [W2--], W5
00D5F8  8B81D4     MOV W4, 0x703A
00D5FA  8B81E5     MOV W5, 0x703C
1457:                          blockCounter -= ioInfo.wNumBytes;
00D5FC  8380F0     MOV blockCounter, W0
00D5FE  500203     SUB W0, W3, W4
00D600  8B80F4     MOV W4, blockCounter
1458:                          
1459:                          //Now send a packet of raw data bytes to the media, over SPI.
1460:                          //This code directly impacts data thoroughput in a significant way.  
1461:                          //Special care should be used to make sure this code is speed optimized.
1462:                      	#if defined __C30__ || defined __C32__
1463:                          {
1464:                              //PIC24/dsPIC/PIC32 architecture is efficient with pointers and 
1465:                              //local variables due to the large number of WREGs available.
1466:                              //Therefore, this code gives good SPI bus utilization, provided
1467:                              //the compiler optimization level is 's' or '3'.
1468:                              BYTE* localPointer = ioInfo.pBuffer;    
00D602  8381F1     MOV 0x703E, W1
00D604  408183     ADD W1, W3, W3
1469:                              WORD localCounter = ioInfo.wNumBytes;
1470:                              do
1471:                              {
1472:                                  SPIBUF = *localPointer++;
00D606  FB8031     ZE [W1++], W0
00D608  881240     MOV W0, SPI1BUF
1473:                                  localCounter--;
1474:                                  while(!SPISTAT_RBF);
00D60A  BFC240     MOV.B SPI1STAT, WREG
00D60C  A30800     BTST.Z W0, #0
00D60E  32FFFD     BRA Z, 0xD60A
1475:                                  data_byte = SPIBUF; //Dummy read to clear SPISTAT_RBF
00D610  801242     MOV SPI1BUF, W2
1476:                              }while(localCounter);         
00D612  508F83     SUB W1, W3, [W15]
00D614  3AFFF8     BRA NZ, 0xD606
00D616  270200     MOV #0x7020, W0
00D618  784802     MOV.B W2, [W0]
1477:                          }                	    
1478:                          #elif defined __18CXX   
1479:                              PIC18_Optimized_SPI_Write_Packet();
1480:                          #endif
1481:               
1482:                          //Check if we have finshed sending a 512 byte block.  If so,
1483:                          //need to receive 16-bit CRC, and retrieve the data_response token
1484:                          if(blockCounter == 0)
00D61A  200020     MOV #0x2, W0
00D61C  E00004     CP0 W4
00D61E  3A0059     BRA NZ, 0xD6D2
1485:                          {
1486:                              blockCounter = MEDIA_BLOCK_SIZE;    //Re-initialize counter
00D620  202000     MOV #0x200, W0
00D622  8B80F0     MOV W0, blockCounter
1487:                              
1488:                              //Add code to compute CRC, if using CRC. By default, the media 
1489:                              //doesn't use CRC unless it is enabled manually during the card 
1490:                              //initialization sequence.
1491:                              mSendCRC();  //Send 16-bit CRC for the data block just sent
00D624  EBC000     SETM.B W0
00D626  07FE2E     RCALL WriteSPIM
00D628  EBC000     SETM.B W0
00D62A  07FE2C     RCALL WriteSPIM
1492:                              
1493:                              //Read response token byte from media, mask out top three don't 
1494:                              //care bits, and check if there was an error
1495:                              if((MDD_SDSPI_ReadMedia() & WRITE_RESPONSE_TOKEN_MASK) != DATA_ACCEPTED)
00D62C  07FE32     RCALL MDD_SDSPI_ReadMedia
00D62E  60007F     AND W0, #0x1F, W0
00D630  500FE5     SUB W0, #0x5, [W15]
00D632  3A002E     BRA NZ, 0xD690
1496:                              {
1497:                                  //Something went wrong.  Try and terminate as gracefully as 
1498:                                  //possible, so as allow possible recovery.
1499:                                  info->bStateVariable = ASYNC_WRITE_ABORT; 
1500:                                  return ASYNC_WRITE_BUSY;
1501:                              }
1502:                              
1503:                              //The media will now send busy token (0x00) bytes until
1504:                              //it is internally ready again (after the block is successfully
1505:                              //writen and the card is ready to accept a new block.
1506:                              info->bStateVariable = ASYNC_WRITE_MEDIA_BUSY;
00D634  B3C030     MOV #0x3, W0
00D636  984CC0     MOV.B W0, [W9+12]
1507:                              WriteTimeout = WRITE_TIMEOUT;       //Initialize timeout counter
00D638  200000     MOV #0x0, W0
00D63A  2000A1     MOV #0xA, W1
00D63C  8B80D0     MOV W0, WriteTimeout
00D63E  8B80E1     MOV W1, 0x701C
00D640  370047     BRA 0xD6D0
1508:                              return ASYNC_WRITE_BUSY;
1509:                          }//if(blockCounter == 0)
1510:                          
1511:                          //If we get to here, we haven't reached a block boundary yet.  Keep 
1512:                          //on requesting packets of data from the application.
1513:                          return ASYNC_WRITE_SEND_PACKET;   
1514:              
1515:                      case ASYNC_WRITE_MEDIA_BUSY:
1516:                          if(WriteTimeout != 0)
00D642  8380D0     MOV WriteTimeout, W0
00D644  8380E1     MOV 0x701C, W1
00D646  500FE0     SUB W0, #0x0, [W15]
00D648  588FE0     SUBB W1, #0x0, [W15]
00D64A  320022     BRA Z, 0xD690
1517:                          {
1518:                              WriteTimeout--;
00D64C  500061     SUB W0, #0x1, W0
00D64E  5880E0     SUBB W1, #0x0, W1
00D650  8B80D0     MOV W0, WriteTimeout
00D652  8B80E1     MOV W1, 0x701C
1519:                              mSend8ClkCycles();  //Dummy read to gobble up a byte (ex: to ensure we meet NBR timing parameter)
00D654  EBC000     SETM.B W0
00D656  07FE16     RCALL WriteSPIM
1520:                              data_byte = MDD_SDSPI_ReadMedia();  //Poll the media.  Will return 0x00 if still busy.  Will return non-0x00 is ready for next data block.
00D658  07FE1C     RCALL MDD_SDSPI_ReadMedia
00D65A  270201     MOV #0x7020, W1
00D65C  784880     MOV.B W0, [W1]
1521:                              if(data_byte != 0x00)
00D65E  E00400     CP0.B W0
00D660  320037     BRA Z, 0xD6D0
1522:                              {
1523:                                  //The media is done and is no longer busy.  Go ahead and
1524:                                  //either send the next packet of data to the media, or the stop
1525:                                  //token if we are finshed.
1526:                                  if(ioInfo.dwBytesRemaining == 0)
00D662  8381D0     MOV 0x703A, W0
00D664  8381E1     MOV 0x703C, W1
00D666  500FE0     SUB W0, #0x0, [W15]
00D668  588FE0     SUBB W1, #0x0, [W15]
00D66A  3A000E     BRA NZ, 0xD688
1527:                                  {
1528:                                      WriteTimeout = WRITE_TIMEOUT;
00D66C  200000     MOV #0x0, W0
00D66E  2000A1     MOV #0xA, W1
00D670  8B80D0     MOV W0, WriteTimeout
00D672  8B80E1     MOV W1, 0x701C
1529:                                      if(command == WRITE_MULTI_BLOCK)
00D674  270180     MOV #0x7018, W0
00D676  B3C0B5     MOV #0xB, W5
00D678  12CF90     SUBR.B W5, [W0], [W15]
00D67A  3A001B     BRA NZ, 0xD6B2
1530:                                      {
1531:                                          //We finished sending all bytes of data.  Send the stop token byte.
1532:                                          WriteSPIM(DATA_STOP_TRAN_TOKEN);
00D67C  B3CFD0     MOV #0xFD, W0
00D67E  07FE02     RCALL WriteSPIM
1533:                                          //After sending the stop transmission token, we need to
1534:                                          //gobble up one byte before checking for media busy (0x00).
1535:                                          //This is to meet the NBR timing parameter.  During the NBR
1536:                                          //interval the SD card may not respond with the busy signal, even
1537:                                          //though it is internally busy.
1538:                                          mSend8ClkCycles();
00D680  EBC000     SETM.B W0
00D682  07FE00     RCALL WriteSPIM
1539:                                                              
1540:                                          //The media still needs to finish internally writing.
1541:                                          info->bStateVariable = ASYNC_STOP_TOKEN_SENT_WAIT_BUSY;
00D684  B3C040     MOV #0x4, W0
00D686  370005     BRA 0xD692
1542:                                          return ASYNC_WRITE_BUSY;
1543:                                      }
1544:                                      else
1545:                                      {
1546:                                          //In this case we were doing a single block write,
1547:                                          //so no stop token is necessary.  In this case we are
1548:                                          //now fully complete with the write operation.
1549:                                          SD_CS = 1;          //De-select media
1550:                                          mSend8ClkCycles();  
1551:                                          info->bStateVariable = ASYNC_WRITE_COMPLETE;
1552:                                          return ASYNC_WRITE_COMPLETE;                            
1553:                                      }                            
1554:                                      
1555:                                  }
1556:                                  //Else we have more data to write in the multi-block write.    
1557:                                  info->bStateVariable = ASYNC_WRITE_TRANSMIT_PACKET;  
00D688  B3C020     MOV #0x2, W0
00D68A  984CC0     MOV.B W0, [W9+12]
00D68C  200020     MOV #0x2, W0
00D68E  370021     BRA 0xD6D2
1558:                                  return ASYNC_WRITE_SEND_PACKET;                    
1559:                              }    
1560:                              else
1561:                              {
1562:                                  //The media is still busy.
1563:                                  return ASYNC_WRITE_BUSY;
1564:                              }    
1565:                          }
1566:                          else
1567:                          {
1568:                              //Timeout occurred.  Something went wrong.  The media should not 
1569:                              //have taken this long to finish the write.
1570:                              info->bStateVariable = ASYNC_WRITE_ABORT;
00D690  B3CFE0     MOV #0xFE, W0
00D692  984CC0     MOV.B W0, [W9+12]
00D694  37001D     BRA 0xD6D0
1571:                              return ASYNC_WRITE_BUSY;
1572:                          }        
1573:                      
1574:                      case ASYNC_STOP_TOKEN_SENT_WAIT_BUSY:
1575:                          //We already sent the stop transmit token for the multi-block write 
1576:                          //operation.  Now all we need to do, is keep waiting until the card
1577:                          //signals it is no longer busy.  Card will keep sending 0x00 bytes
1578:                          //until it is no longer busy.
1579:                          if(WriteTimeout != 0)
00D696  8380D0     MOV WriteTimeout, W0
00D698  8380E1     MOV 0x701C, W1
00D69A  500FE0     SUB W0, #0x0, [W15]
00D69C  588FE0     SUBB W1, #0x0, [W15]
00D69E  320010     BRA Z, 0xD6C0
1580:                          {
1581:                              WriteTimeout--;
00D6A0  500061     SUB W0, #0x1, W0
00D6A2  5880E0     SUBB W1, #0x0, W1
00D6A4  8B80D0     MOV W0, WriteTimeout
00D6A6  8B80E1     MOV W1, 0x701C
1582:                              data_byte = MDD_SDSPI_ReadMedia();
00D6A8  07FDF4     RCALL MDD_SDSPI_ReadMedia
00D6AA  270201     MOV #0x7020, W1
00D6AC  784880     MOV.B W0, [W1]
1583:                              //Check if card is no longer busy.  
1584:                              if(data_byte != 0x00)
00D6AE  E00400     CP0.B W0
00D6B0  32000F     BRA Z, 0xD6D0
1585:                              {
1586:                                  //If we get to here, multi-block write operation is fully
1587:                                  //complete now.  
1588:              
1589:                                  //Should send CMD13 (SEND_STATUS) after a programming sequence, 
1590:                                  //to confirm if it was successful or not inside the media.
1591:                                              
1592:                                  //Prepare to receive the next command.
1593:                                  SD_CS = 1;          //De-select media
00D6B2  A8C2D5     BSET 0x2D5, #6
1594:                                  mSend8ClkCycles();  //NEC timing parameter clocking
00D6B4  EBC000     SETM.B W0
00D6B6  07FDE6     RCALL WriteSPIM
1595:                                  info->bStateVariable = ASYNC_WRITE_COMPLETE;
00D6B8  EB4000     CLR.B W0
00D6BA  984CC0     MOV.B W0, [W9+12]
00D6BC  EB0000     CLR W0
00D6BE  370009     BRA 0xD6D2
1596:                                  return ASYNC_WRITE_COMPLETE;
1597:                              }
1598:                              //If we get to here, the media is still busy with the write.
1599:                              return ASYNC_WRITE_BUSY;    
1600:                          }    
1601:                          //Timeout occurred.  Something went wrong.  Fall through to ASYNC_WRITE_ABORT.
1602:                      case ASYNC_WRITE_ABORT:
1603:                          //An error occurred, and we need to stop the write sequence so as to try and allow
1604:                          //for recovery/re-attempt later.
1605:                          SendMMCCmd(STOP_TRANSMISSION, 0x00000000);
00D6C0  B81160     MUL.UU W2, #0, W2
00D6C2  B3C051     MOV #0x5, W1
00D6C4  57806E     SUB W15, #0xE, W0
00D6C6  07FDED     RCALL SendMMCCmd
1606:                          SD_CS = 1;  //deselect media
00D6C8  A8C2D5     BSET 0x2D5, #6
1607:                          mSend8ClkCycles();  //After raising CS pin, media may not tri-state data out for 1 bit time.
00D6CA  EBC000     SETM.B W0
00D6CC  07FDDB     RCALL WriteSPIM
00D6CE  37FF7B     BRA 0xD5C6
1608:                          info->bStateVariable = ASYNC_WRITE_ERROR; 
00D6D0  200030     MOV #0x3, W0
1609:                          //Fall through to default case.
1610:                      default:
1611:                          //Used for ASYNC_WRITE_ERROR case.
1612:                          return ASYNC_WRITE_ERROR; 
1613:                  }//switch(info->stateVariable)    
1614:                  
1615:              
1616:                  //Should never execute to here.  All pathways should have a hit a return already.
1617:                  info->bStateVariable = ASYNC_WRITE_ABORT;
1618:                  return ASYNC_WRITE_BUSY;
1619:              } 
00D6DA  BE0200     MOV.D W0, W4
1620:              
1621:              
1622:              #ifdef __18CXX   
1623:              /*****************************************************************************
1624:                Function:
1625:                  static void PIC18_Optimized_SPI_Write_Packet(void)
1626:                Summary:
1627:                  A private function intended for use internal to the SD-SPI.c file.
1628:                  This function writes a specified number of bytes to the SPI module,
1629:                  at high speed for optimum throughput, copied from the user specified RAM
1630:                  buffer.
1631:                  This function is only implemented and used on PIC18 devices.
1632:                Pre-Conditions:
1633:                  The ioInfo.wNumBytes must be pre-initialized prior to calling 
1634:                  PIC18_Optimized_SPI_Write_Packet().
1635:                  Additionally, the ioInfo.pBuffer must also be pre-initialized, prior
1636:                  to calling PIC18_Optimized_SPI_Write_Packet().
1637:                Input:
1638:                  ioInfo.wNumBytes global variable, initialized to the number of bytes to send
1639:                  ioInfo.pBuffer global variable, initialized to point to the RAM location that
1640:                      contains the data to send out the SPI port
1641:                Return Values:
1642:                  None
1643:                Side Effects:
1644:                  None
1645:                Description:
1646:                  A private function intended for use internal to the SD-SPI.c file.
1647:                  This function writes a specified number of bytes to the SPI module,
1648:                  at high speed for optimum throughput, copied from the user specified RAM
1649:                  buffer.
1650:                  This function is only implemented and used on PIC18 devices.
1651:                Remarks:
1652:                  This function is speed optimized, using inline assembly language code, and
1653:                  makes use of C compiler managed resources.  It is currently written to work
1654:                  with the Microchip MPLAB C18 compiler, and may need modification if built
1655:                  with a different PIC18 compiler.
1656:                *****************************************************************************/
1657:              static void PIC18_Optimized_SPI_Write_Packet(void)
1658:              {
1659:                  static BYTE bData;
1660:                  static WORD FSR0Save;
1661:                  static WORD PRODSave;
1662:              
1663:                  //Make sure the SPI_INTERRUPT_FLAG_ASM has been correctly defined, for the SPI
1664:                  //module that is actually being used in the hardware.
1665:                  #ifndef SPI_INTERRUPT_FLAG_ASM
1666:                      #error Please add "#define SPI_INTERRUPT_FLAG_ASM  PIRx, Y" to your hardware profile.  Replace x and Y with appropriate numbers for your SPI module interrupt flag.
1667:                  #endif
1668:                  
1669:                  //Make sure at least one byte needs copying.
1670:                  if(ioInfo.wNumBytes == 0)
1671:                  {
1672:                      return;
1673:                  }    
1674:              
1675:                  //Context save C compiler managed registers.
1676:                  FSR0Save = FSR0; 
1677:                  PRODSave = PROD;
1678:                  
1679:                  //Using PRODH and PRODL as 16 bit loop counter.  These are convenient since
1680:                  //they are always in the access bank.
1681:                  PROD = ioInfo.wNumBytes;
1682:                  //Using FSR0 directly, for optimal SPI loop speed.
1683:                  FSR0 = (WORD)ioInfo.pBuffer; 
1684:                                            
1685:                  _asm
1686:                      movf    POSTINC0, 0, 0  //Fetch next byte to send and store in WREG
1687:                      bra     ASMSPIXmitLoopEntryPoint
1688:              ASMSPIXmitLoop:    
1689:                      movf    POSTINC0, 0, 0  //Pre-Fetch next byte to send and temporarily store in WREG
1690:                      //Wait until last hardware SPI transaction is complete
1691:                      btfss   SPI_INTERRUPT_FLAG_ASM, 0
1692:                      bra     -2
1693:                      
1694:              ASMSPIXmitLoopEntryPoint:
1695:                      //Start the next SPI transaction
1696:                      bcf     SPI_INTERRUPT_FLAG_ASM, 0   //Clear interrupt flag
1697:                      movwf   SPIBUF, 0       //Write next byte to transmit to SSPBUF
1698:                      
1699:                      //Now decrement byte counter for loop exit condition
1700:                      movlw   0x00
1701:                      decf    PRODL, 1, 0     //Decrement LSB
1702:                      subwfb  PRODH, 1, 0     //Decrement MSB, only if borrow from LSB decrement
1703:                      //Check if anymore bytes remain to be sent
1704:                      movf    PRODL, 0, 0     //copy PRODL to WREG
1705:                      iorwf   PRODH, 0, 0     //Z bit will be set if both PRODL and PRODH == 0x00
1706:                      bnz     ASMSPIXmitLoop  //Go back and loop if our counter isn't = 0x0000.
1707:                  _endasm
1708:              
1709:                  //Wait until the last SPI transaction is really complete.  
1710:                  //Above loop jumps out after the last byte is started, but not finished yet.
1711:                  while(!SPI_INTERRUPT_FLAG);
1712:              
1713:                  //Leave SPI module in a "clean" state, ready for next transaction.
1714:                  bData = SPIBUF;         //Dummy read to clear BF flag.
1715:                  SPI_INTERRUPT_FLAG = 0; //Clear interrupt flag.
1716:                  //Restore C compiler managed registers that we modified
1717:                  PROD = PRODSave;
1718:                  FSR0 = FSR0Save;
1719:              }    
1720:              #endif    
1721:              
1722:              
1723:              
1724:              
1725:              
1726:              /*****************************************************************************
1727:                Function:
1728:                  BYTE MDD_SDSPI_SectorWrite (DWORD sector_addr, BYTE * buffer, BYTE allowWriteToZero)
1729:                Summary:
1730:                  Writes a sector of data to an SD card.
1731:                Conditions:
1732:                  The MDD_SectorWrite function pointer must be pointing to this function.
1733:                Input:
1734:                  sector_addr -      The address of the sector on the card.
1735:                  buffer -           The buffer with the data to write.
1736:                  allowWriteToZero -
1737:                                   - TRUE -  Writes to the 0 sector (MBR) are allowed
1738:                                   - FALSE - Any write to the 0 sector will fail.
1739:                Return Values:
1740:                  TRUE -  The sector was written successfully.
1741:                  FALSE - The sector could not be written.
1742:                Side Effects:
1743:                  None.
1744:                Description:
1745:                  The MDD_SDSPI_SectorWrite function writes one sector of data (512 bytes) 
1746:                  of data from the location pointed to by 'buffer' to the specified sector of 
1747:                  the SD card.
1748:                Remarks:
1749:                  The card expects the address field in the command packet to be a byte address.
1750:                  The sector_addr value is ocnverted to a byte address by shifting it left nine
1751:                  times (multiplying by 512).
1752:                ***************************************************************************************/
1753:              BYTE MDD_SDSPI_SectorWrite(DWORD sector_addr, BYTE* buffer, BYTE allowWriteToZero)
1754:              {
1755:                  static ASYNC_IO info;
1756:                  BYTE status;
1757:                  
1758:                  if(allowWriteToZero == FALSE)
00D6DC  E00403     CP0.B W3
00D6DE  3A0003     BRA NZ, 0xD6E6
1759:                  {
1760:                      if(sector_addr == 0x00000000)
00D6E0  500FE0     SUB W0, #0x0, [W15]
00D6E2  588FE0     SUBB W1, #0x0, [W15]
00D6E4  320013     BRA Z, 0xD70C
1761:                      {
1762:                          return FALSE;
1763:                      }    
1764:                  }    
1765:                  
1766:                  //Initialize structure so we write a single sector worth of data.
1767:                  info.wNumBytes = 512;
00D6E6  202000     MOV #0x200, W0
00D6E8  8B8110     MOV W0, info
1768:                  info.dwBytesRemaining = 512;
00D6EA  202000     MOV #0x200, W0
00D6EC  200001     MOV #0x0, W1
00D6EE  8B8120     MOV W0, 0x7024
00D6F0  8B8131     MOV W1, 0x7026
1769:                  info.pBuffer = buffer;
00D6F2  8B8142     MOV W2, 0x7028
1770:                  info.dwAddress = sector_addr;
00D6F4  8B8154     MOV W4, 0x702A
00D6F6  8B8165     MOV W5, 0x702C
1771:                  info.bStateVariable = ASYNC_WRITE_QUEUED;
00D6F8  B3C011     MOV #0x1, W1
00D6FA  2702E0     MOV #0x702E, W0
00D6FC  784801     MOV.B W1, [W0]
1772:                  
1773:                  //Repeatedly call the write handler until the operation is complete (or a
1774:                  //failure/timeout occurred).
1775:                  while(1)
1776:                  {
1777:                      status = MDD_SDSPI_AsyncWriteTasks(&info);
00D6FE  270220     MOV #0x7022, W0
00D700  07FF07     RCALL MDD_SDSPI_AsyncWriteTasks
1778:                      if(status == ASYNC_WRITE_COMPLETE)
00D702  E00400     CP0.B W0
00D704  3A0001     BRA NZ, 0xD708
00D706  050010     RETLW #0x1, W0
1779:                      {
1780:                          return TRUE;
1781:                      }    
1782:                      else if(status == ASYNC_WRITE_ERROR)
1783:                      {
1784:                          return FALSE;
1785:                      }
1786:                  }    
1787:                  return TRUE;
1788:              }    
1789:              
1790:              
1791:              
1792:              
1793:              /*******************************************************************************
1794:                Function:
1795:                  BYTE MDD_SDSPI_WriteProtectState
1796:                Summary:
1797:                  Indicates whether the card is write-protected.
1798:                Conditions:
1799:                  The MDD_WriteProtectState function pointer must be pointing to this function.
1800:                Input:
1801:                  None.
1802:                Return Values:
1803:                  TRUE -  The card is write-protected
1804:                  FALSE - The card is not write-protected
1805:                Side Effects:
1806:                  None.
1807:                Description:
1808:                  The MDD_SDSPI_WriteProtectState function will determine if the SD card is
1809:                  write protected by checking the electrical signal that corresponds to the
1810:                  physical write-protect switch.
1811:                Remarks:
1812:                  None
1813:              *******************************************************************************/
1814:              
1815:              BYTE MDD_SDSPI_WriteProtectState(void)
1816:              {
1817:                  return FALSE;
1818:              }
00D710  EBC080     SETM.B W1
00D712  370007     BRA 0xD722
1819:              
1820:              
1821:              /*******************************************************************************
1822:                Function:
1823:                  void Delayms (BYTE milliseconds)
1824:                Summary:
1825:                  Delay.
1826:                Conditions:
1827:                  None.
1828:                Input:
1829:                  BYTE milliseconds - Number of ms to delay
1830:                Return:
1831:                  None.
1832:                Side Effects:
1833:                  None.
1834:                Description:
1835:                  The Delayms function will delay a specified number of milliseconds.  Used for SPI
1836:                  timing.
1837:                Remarks:
1838:                  Depending on compiler revisions, this function may not delay for the exact 
1839:                  time specified.  This shouldn't create a significant problem.
1840:              *******************************************************************************/
1841:              
1842:              void Delayms(BYTE milliseconds)
1843:              {
1844:                  BYTE    ms;
1845:                  DWORD   count;
1846:                  
1847:                  ms = milliseconds;
1848:                  while (ms--)
00D714  207CB2     MOV #0x7CB, W2
00D716  200003     MOV #0x0, W3
00D722  E94000     DEC.B W0, W0
00D724  504F81     SUB.B W0, W1, [W15]
00D726  3AFFF6     BRA NZ, 0xD714
1849:                  {
1850:                      count = MILLISECDELAY;
1851:                      while (count--);
00D718  510161     SUB W2, #0x1, W2
00D71A  5981E0     SUBB W3, #0x0, W3
00D71C  410FE1     ADD W2, #0x1, [W15]
00D71E  498FE0     ADDC W3, #0x0, [W15]
00D720  3AFFFB     BRA NZ, 0xD718
1852:                  }
1853:                  Nop();
00D728  000000     NOP
1854:                  return;
1855:              }
1856:              
1857:              
1858:              /*******************************************************************************
1859:                Function:
1860:                  void CloseSPIM (void)
1861:                Summary:
1862:                  Disables the SPI module.
1863:                Conditions:
1864:                  None.
1865:                Input:
1866:                  None.
1867:                Return:
1868:                  None.
1869:                Side Effects:
1870:                  None.
1871:                Description:
1872:                  Disables the SPI module.
1873:                Remarks:
1874:                  None.
1875:              *******************************************************************************/
1876:              
1877:              void CloseSPIM (void)
1878:              {
1879:              #if defined __C30__ || defined __C32__
1880:              
1881:                  SPISTAT &= 0x7FFF;
00D280  A9E241     BCLR 0x241, #7
00DA10  A9E241     BCLR 0x241, #7
1882:              
1883:              #elif defined __18CXX
1884:              
1885:                  SPICON1 &= 0xDF;
1886:              
1887:              #endif
1888:              }
1889:              
1890:              
1891:              
1892:              /*****************************************************************************
1893:                Function:
1894:                  unsigned char WriteSPIM (unsigned char data_out)
1895:                Summary:
1896:                  Writes data to the SD card.
1897:                Conditions:
1898:                  None.
1899:                Input:
1900:                  data_out - The data to write.
1901:                Return:
1902:                  0.
1903:                Side Effects:
1904:                  None.
1905:                Description:
1906:                  The WriteSPIM function will write a byte of data from the microcontroller to the
1907:                  SD card.
1908:                Remarks:
1909:                  None.
1910:                ***************************************************************************************/
1911:              
1912:              unsigned char WriteSPIM( unsigned char data_out )
1913:              {
1914:              #ifdef __PIC32MX__
1915:                  BYTE   clear;
1916:                  putcSPI((BYTE)data_out);
1917:                  clear = getcSPI();
1918:                  return ( 0 );                // return non-negative#
1919:              #elif defined __18CXX
1920:                  BYTE clear;
1921:                  clear = SPIBUF;
1922:                  SPI_INTERRUPT_FLAG = 0;
1923:                  SPIBUF = data_out;
1924:                  if (SPICON1 & 0x80)
1925:                      return -1;
1926:                  else
1927:                      while (!SPI_INTERRUPT_FLAG);
1928:                  return 0;
1929:              #else
1930:                  BYTE   clear;
1931:                  SPIBUF = data_out;          // write byte to SSP1BUF register
00D284  FB8000     ZE W0, W0
00D286  881240     MOV W0, SPI1BUF
1932:                  while( !SPISTAT_RBF ); // wait until bus cycle complete
00D288  BFC240     MOV.B SPI1STAT, WREG
00D28A  A30800     BTST.Z W0, #0
00D28C  32FFFD     BRA Z, 0xD288
1933:                  clear = SPIBUF;
00D28E  801240     MOV SPI1BUF, W0
1934:                  return ( 0 );                // return non-negative#
1935:              #endif
1936:              }
1937:              
1938:              
1939:              
1940:              /*****************************************************************************
1941:                Function:
1942:                  BYTE MDD_SDSPI_ReadMedia (void)
1943:                Summary:
1944:                  Reads a byte of data from the SD card.
1945:                Conditions:
1946:                  None.
1947:                Input:
1948:                  None.
1949:                Return:
1950:                  The byte read.
1951:                Side Effects:
1952:                  None.
1953:                Description:
1954:                  The MDD_SDSPI_ReadMedia function will read one byte from the SPI port.
1955:                Remarks:
1956:                  This function replaces ReadSPI, since some implementations of that function
1957:                  will initialize SSPBUF/SPIBUF to 0x00 when reading.  The card expects 0xFF.
1958:                ***************************************************************************************/
1959:              BYTE MDD_SDSPI_ReadMedia(void)
1960:              {
1961:              
1962:              #ifdef __C32__
1963:              
1964:                  putcSPI((BYTE)0xFF);
1965:                  return (BYTE)getcSPI();
1966:              
1967:              #elif defined __18CXX
1968:              
1969:                  BYTE clear;
1970:                  clear = SPIBUF;
1971:                  SPI_INTERRUPT_FLAG = 0;
1972:                  SPIBUF = 0xFF;
1973:                  while (!SPI_INTERRUPT_FLAG);
1974:                  return SPIBUF;
1975:              
1976:              #else
1977:                  SPIBUF = 0xFF;                              //Data Out - Logic ones
00D292  200FF0     MOV #0xFF, W0
00D294  881240     MOV W0, SPI1BUF
1978:                  while(!SPISTAT_RBF);                     //Wait until cycle complete
00D296  BFC240     MOV.B SPI1STAT, WREG
00D298  A30800     BTST.Z W0, #0
00D29A  32FFFD     BRA Z, 0xD296
1979:                  return(SPIBUF);                             //Return with byte read
00D29C  801240     MOV SPI1BUF, W0
00D29E  FB8000     ZE W0, W0
1980:              #endif
1981:              }
00D2A2  FA000E     LNK #0xE
00D2A4  BE9F88     MOV.D W8, [W15++]
00D2A6  BE9F8A     MOV.D W10, [W15++]
00D2A8  780500     MOV W0, W10
00D2AA  784401     MOV.B W1, W8
00D2AC  BE0202     MOV.D W2, W4
1982:              
1983:              /*****************************************************************************
1984:                Function:
1985:                  void OpenSPIM (unsigned int sync_mode)
1986:                Summary:
1987:                  Initializes the SPI module
1988:                Conditions:
1989:                  None.
1990:                Input:
1991:                  sync_mode - Input parameter that sets the SPI mode/speed.
1992:                Return:
1993:                  None.
1994:                Side Effects:
1995:                  None.
1996:                Description:
1997:                  The OpenSPIM function will enable and configure the SPI module.
1998:                Remarks:
1999:                  None.
2000:                ***************************************************************************************/
2001:              
2002:              #ifdef __18CXX
2003:              void OpenSPIM (unsigned char sync_mode)
2004:              #else
2005:              void OpenSPIM( unsigned int sync_mode)
2006:              #endif
2007:              {
2008:                  SPISTAT = 0x0000;               // power on state 
00D72C  EB0080     CLR W1
00D72E  881201     MOV W1, SPI1STAT
2009:              
2010:                  //SPI module initilization depends on processor type
2011:                  #ifdef __PIC32MX__
2012:                      #if (GetSystemClock() <= 20000000)
2013:                          SPIBRG = SPICalutateBRG(GetPeripheralClock(), 10000);
2014:                      #else
2015:                          SPIBRG = SPICalutateBRG(GetPeripheralClock(), SPI_FREQUENCY);
2016:                      #endif
2017:                      SPICON1bits.CKP = 1;
2018:                      SPICON1bits.CKE = 0;
2019:                  #elif defined __C30__ //must be PIC24 or dsPIC device
2020:                      SPICON1 = 0x0000;              // power on state
00D730  881211     MOV W1, SPI1CON1
2021:                      SPICON1 |= sync_mode;          // select serial mode 
00D732  B72242     IOR SPI1CON1
2022:                      SPICON1bits.CKP = 1;
00D734  A8C242     BSET SPI1CON1, #6
2023:                      SPICON1bits.CKE = 0;
00D736  A90243     BCLR 0x243, #0
2024:                  #else   //must be __18CXX (PIC18 processor)
2025:                      SPICON1 = 0x00;         
2026:                      SPICON1 |= sync_mode;   
2027:                      SPISTATbits.CKE = 1;
2028:                  #endif
2029:              
2030:                      // MISO <- RP20
2031:                      _SDI1R = 20;
00D738  BFC6A8     MOV.B RPINR20, WREG
00D73A  B3CC01     MOV #0xC0, W1
00D73C  604001     AND.B W0, W1, W0
00D73E  B34140     IOR.B #0x14, W0
00D740  B7E6A8     MOV.B WREG, RPINR20
2032:                      // RP22 <- MOSI
2033:                      _RP22R = 7;
00D742  BFC6D6     MOV.B RPOR11, WREG
00D744  604001     AND.B W0, W1, W0
00D746  B34070     IOR.B #0x7, W0
00D748  B7E6D6     MOV.B WREG, RPOR11
2034:                      // RP25 <- SCLK
2035:                      _RP25R = 8;
00D74A  BFC6D9     MOV.B 0x6D9, WREG
00D74C  604001     AND.B W0, W1, W0
00D74E  A03400     BSET.B W0, #3
00D750  B7E6D9     MOV.B WREG, 0x6D9
2036:              //    SPICLOCK = 0;
2037:              //    SPIOUT = 0;                  // define SDO1 as output (master or slave)
2038:              //    SPIIN = 1;                  // define SDI1 as input (master or slave)
2039:                  SPIENABLE = 1;             // enable synchronous serial port
00D752  A8E241     BSET 0x241, #7
2040:              }
2041:              
2042:              
2043:              #ifdef __18CXX
2044:              // Description: Delay value for the manual SPI clock
2045:              #define MANUAL_SPI_CLOCK_VALUE             1
2046:              /*****************************************************************************
2047:                Function:
2048:                  unsigned char WriteSPIManual (unsigned char data_out)
2049:                Summary:
2050:                  Write a character to the SD card with bit-bang SPI.
2051:                Conditions:
2052:                  Make sure the SDI pin is pre-configured as a digital pin, if it is 
2053:                  multiplexed with analog functionality.
2054:                Input:
2055:                  data_out - Data to send.
2056:                Return:
2057:                  0.
2058:                Side Effects:
2059:                  None.
2060:                Description:
2061:                  Writes a character to the SD card.
2062:                Remarks:
2063:                  The WriteSPIManual function is for use on a PIC18 when the clock speed is so
2064:                  high that the maximum SPI clock divider cannot reduce the SPI clock speed below
2065:                  the maximum SD card initialization speed.
2066:                ***************************************************************************************/
2067:              unsigned char WriteSPIManual(unsigned char data_out)
2068:              {
2069:                  unsigned char i;
2070:                  unsigned char clock;
2071:              
2072:                  SPICLOCKLAT = 0;
2073:                  SPIOUTLAT = 1;
2074:                  SPICLOCK = OUTPUT;
2075:                  SPIOUT = OUTPUT;
2076:              
2077:              	//Loop to send out 8 bits of SDO data and associated SCK clock.
2078:              	for(i = 0; i < 8; i++)
2079:              	{
2080:              		SPICLOCKLAT = 0;
2081:              		if(data_out & 0x80)
2082:              			SPIOUTLAT = 1;
2083:              		else
2084:              			SPIOUTLAT = 0;
2085:              		data_out = data_out << 1;				//Bit shift, so next bit to send is in MSb position
2086:                  	clock = MANUAL_SPI_CLOCK_VALUE;
2087:                  	while (clock--);
2088:                  	SPICLOCKLAT = 1;
2089:                  	clock = MANUAL_SPI_CLOCK_VALUE;
2090:                  	while (clock--);    			
2091:              	}	
2092:                  SPICLOCKLAT = 0;
2093:              
2094:                  return 0; 
2095:              }
2096:              
2097:              
2098:              /*****************************************************************************
2099:                Function:
2100:                  BYTE ReadMediaManual (void)
2101:                Summary:
2102:                  Reads a byte of data from the SD card.
2103:                Conditions:
2104:                  None.
2105:                Input:
2106:                  None.
2107:                Return:
2108:                  The byte read.
2109:                Side Effects:
2110:                  None.
2111:                Description:
2112:                  The MDD_SDSPI_ReadMedia function will read one byte from the SPI port.
2113:                Remarks:
2114:                  This function replaces ReadSPI, since some implementations of that function
2115:                  will initialize SSPBUF/SPIBUF to 0x00 when reading.  The card expects 0xFF.
2116:                  This function is for use on a PIC18 when the clock speed is so high that the
2117:                  maximum SPI clock prescaler cannot reduce the SPI clock below the maximum SD card
2118:                  initialization speed.
2119:                ***************************************************************************************/
2120:              BYTE ReadMediaManual (void)
2121:              {
2122:                  unsigned char i;
2123:                  unsigned char clock;
2124:                  unsigned char result = 0x00;
2125:              
2126:                  SPIOUTLAT = 1;
2127:                  SPIOUT = OUTPUT;
2128:                  SPIIN = INPUT;
2129:                  SPICLOCKLAT = 0;
2130:                  SPICLOCK = OUTPUT;
2131:               
2132:               	//Loop to send 8 clock pulses and read in the returned bits of data. Data "sent" will be = 0xFF
2133:              	for(i = 0; i < 8u; i++)
2134:              	{
2135:              		SPICLOCKLAT = 0;
2136:                  	clock = MANUAL_SPI_CLOCK_VALUE;
2137:                  	while (clock--);
2138:                  	SPICLOCKLAT = 1;
2139:                  	clock = MANUAL_SPI_CLOCK_VALUE;
2140:                  	while (clock--);
2141:              		result = result << 1;	//Bit shift the previous result.  We receive the byte MSb first. This operation makes LSb = 0.  
2142:                  	if(SPIINPORT)
2143:                  		result++;			//Set the LSb if we detected a '1' on the SPIINPORT pin, otherwise leave as 0.
2144:              	}	
2145:                  SPICLOCKLAT = 0;
2146:              
2147:                  return result;
2148:              }//end ReadMedia
2149:              #endif      // End __18CXX
2150:              
2151:              /*****************************************************************************
2152:                Function:
2153:                  void InitSPISlowMode(void)
2154:                Summary:
2155:                  Initializes the SPI module to operate at low SPI frequency <= 400kHz.
2156:                Conditions:
2157:                  Processor type and GetSystemClock() macro have to be defined correctly
2158:                  to get the correct SPI frequency.
2159:                Input:
2160:                  Uses GetSystemClock() macro value.  Should be #define in the hardwareprofile.
2161:                Return Values:
2162:                  None.  Initializes the hardware SPI module (except on PIC18).  On PIC18,
2163:                  The SPI is bit banged to achieve low frequencies, but this function still
2164:                  initializes the I/O pins. 
2165:                Side Effects:
2166:                  None.
2167:                Description:
2168:                  This function initalizes and enables the SPI module, configured for low 
2169:                  SPI frequency, so as to be compatible with media cards which require <400kHz
2170:                  SPI frequency during initialization.
2171:                Remarks:
2172:                  None.
2173:                ***************************************************************************************/
2174:              void InitSPISlowMode(void)
2175:              {
00D756  200501     MOV #0x50, W1
00D758  200032     MOV #0x3, W2
00D75A  370002     BRA 0xD760
2176:                  #if defined __C30__ || defined __C32__
2177:                  	#ifdef __PIC32MX__
2178:                  		OpenSPI(SPI_START_CFG_1, SPI_START_CFG_2);
2179:                  	    SPIBRG = SPICalutateBRG(GetPeripheralClock(), 400000);
2180:                  	#else //else C30 = PIC24/dsPIC devices
2181:                  		WORD spiconvalue = 0x0003;
2182:                          WORD timeout;
2183:                  	    // Calculate the prescaler needed for the clock
2184:                  	    timeout = GetSystemClock() / 400000;
2185:                  	    // if timeout is less than 400k and greater than 100k use a 1:1 prescaler
2186:                  	    if (timeout == 0)
2187:                  	    {
2188:                  	        OpenSPIM (MASTER_ENABLE_ON | PRI_PRESCAL_1_1 | SEC_PRESCAL_1_1);
2189:                  	    }
2190:                  	    else
2191:                  	    {
2192:                  	        while (timeout != 0)
00D76A  3AFFF8     BRA NZ, 0xD75C
2193:                  	        {
2194:                  	            if (timeout > 8)
00D75C  508FE8     SUB W1, #0x8, [W15]
00D75E  360006     BRA LEU, 0xD76C
2195:                  	            {
2196:                  	                spiconvalue--;
00D760  E90102     DEC W2, W2
2197:                  	                // round up
2198:                  	                if ((timeout % 4) != 0)
00D762  608063     AND W1, #0x3, W0
00D764  320001     BRA Z, 0xD768
2199:                  	                    timeout += 4;
00D766  4080E4     ADD W1, #0x4, W1
2200:                  	                timeout /= 4;
00D768  DE08C2     LSR W1, #2, W1
2201:                  	            }
2202:                  	            else
2203:                  	            {
2204:                  	                break;
2205:                  	            }
2206:                  	        }
2207:                  	        
2208:                  	        timeout--;
2209:                  	    
2210:                  	        OpenSPIM (MASTER_ENABLE_ON | spiconvalue | ((~(timeout << 2)) & 0x1C));
00D76C  E90001     DEC W1, W0
00D76E  DD0042     SL W0, #2, W0
00D770  EA8000     COM W0, W0
00D772  60007C     AND W0, #0x1C, W0
00D774  710000     IOR W2, W0, W0
00D776  A05000     BSET W0, #5
00D778  37FFD9     BRA OpenSPIM
2211:                  	    }
2212:                  	#endif   //#ifdef __PIC32MX__ (and corresponding #else)    
2213:                  #else //must be PIC18 device
2214:                      //Make sure the SPI module doesn't control the bus, will use 
2215:                      //bit-banged SPI instead, for slow mode initialization operation
2216:                      SPICON1 = 0x00;
2217:                      SPICLOCKLAT = 0;
2218:                      SPIOUTLAT = 1;
2219:                      SPICLOCK = OUTPUT;
2220:                      SPIOUT = OUTPUT;
2221:                  #endif //#if defined __C30__ || defined __C32__
2222:              }    
00D77A  FA0062     LNK #0x62
00D77C  BE9F88     MOV.D W8, [W15++]
2223:              
2224:              
2225:              
2226:              /*****************************************************************************
2227:                Function:
2228:                  MEDIA_INFORMATION *  MDD_SDSPI_MediaInitialize (void)
2229:                Summary:
2230:                  Initializes the SD card.
2231:                Conditions:
2232:                  The MDD_MediaInitialize function pointer must be pointing to this function.
2233:                Input:
2234:                  None.
2235:                Return Values:
2236:                  The function returns a pointer to the MEDIA_INFORMATION structure.  The
2237:                  errorCode member may contain the following values:
2238:                      * MEDIA_NO_ERROR - The media initialized successfully
2239:                      * MEDIA_CANNOT_INITIALIZE - Cannot initialize the media.  
2240:                Side Effects:
2241:                  None.
2242:                Description:
2243:                  This function will send initialization commands to and SD card.
2244:                Remarks:
2245:                  Psuedo code flow for the media initialization process is as follows:
2246:              
2247:              -------------------------------------------------------------------------------------------
2248:              SD Card SPI Initialization Sequence (for physical layer v1.x or v2.0 device) is as follows:
2249:              -------------------------------------------------------------------------------------------
2250:              0.  Power up tasks
2251:                  a.  Initialize microcontroller SPI module to no more than 400kbps rate so as to support MMC devices.
2252:                  b.  Add delay for SD card power up, prior to sending it any commands.  It wants the 
2253:                      longer of: 1ms, the Vdd ramp time (time from 2.7V to Vdd stable), and 74+ clock pulses.
2254:              1.  Send CMD0 (GO_IDLE_STATE) with CS = 0.  This puts the media in SPI mode and software resets the SD/MMC card.
2255:              2.  Send CMD8 (SEND_IF_COND).  This requests what voltage the card wants to run at. 
2256:                  Note: Some cards will not support this command.
2257:                  a.  If illegal command response is received, this implies either a v1.x physical spec device, or not an SD card (ex: MMC).
2258:                  b.  If normal response is received, then it must be a v2.0 or later SD memory card.
2259:              
2260:              If v1.x device:
2261:              -----------------
2262:              3.  Send CMD1 repeatedly, until initialization complete (indicated by R1 response byte/idle bit == 0)
2263:              4.  Basic initialization is complete.  May now switch to higher SPI frequencies.
2264:              5.  Send CMD9 to read the CSD structure.  This will tell us the total flash size and other info which will be useful later.
2265:              6.  Parse CSD structure bits (based on v1.x structure format) and extract useful information about the media.
2266:              7.  The card is now ready to perform application data transfers.
2267:              
2268:              If v2.0+ device:
2269:              -----------------
2270:              3.  Verify the voltage range is feasible.  If not, unusable card, should notify user that the card is incompatible with this host.
2271:              4.  Send CMD58 (Read OCR).
2272:              5.  Send CMD55, then ACMD41 (SD_SEND_OP_COND, with HCS = 1).
2273:                  a.  Loop CMD55/ACMD41 until R1 response byte == 0x00 (indicating the card is no longer busy/no longer in idle state).  
2274:              6.  Send CMD58 (Get CCS).
2275:                  a.  If CCS = 1 --> SDHC card.
2276:                  b.  If CCS = 0 --> Standard capacity SD card (which is v2.0+).
2277:              7.  Basic initialization is complete.  May now switch to higher SPI frequencies.
2278:              8.  Send CMD9 to read the CSD structure.  This will tell us the total flash size and other info which will be useful later.
2279:              9.  Parse CSD structure bits (based on v2.0 structure format) and extract useful information about the media.
2280:              10. The card is now ready to perform application data transfers.
2281:              --------------------------------------------------------------------------------
2282:              ********************************************************************************/
2283:              
2284:              MEDIA_INFORMATION *  MDD_SDSPI_MediaInitialize(void)
2285:              {
2286:                  WORD timeout;
2287:                  MMC_RESPONSE response;
2288:              	BYTE CSDResponse[20];
2289:              	BYTE count, index;
2290:              	DWORD c_size;
2291:              	BYTE c_size_mult;
2292:              	BYTE block_len;
2293:              	
2294:              	#ifdef __DEBUG_UART
2295:              	InitUART();
2296:              	#endif
2297:               
2298:                  //Initialize global variables.  Will get updated later with valid data once
2299:                  //the data is known.
2300:                  mediaInformation.errorCode = MEDIA_NO_ERROR;
00D77E  270460     MOV #0x7046, W0
00D780  EB4800     CLR.B [W0]
2301:                  mediaInformation.validityFlags.value = 0;
00D782  270470     MOV #0x7047, W0
00D784  EB4800     CLR.B [W0]
2302:                  MDD_SDSPI_finalLBA = 0x00000000;	//Will compute a valid size later, from the CSD register values we get from the card
00D786  B80060     MUL.UU W0, #0, W0
00D788  8B81A0     MOV W0, MDD_SDSPI_finalLBA
00D78A  8B81B1     MOV W1, 0x7036
2303:                  gSDMode = SD_MODE_NORMAL;           //Will get updated later with real value, once we know based on initialization flow.
00D78C  270300     MOV #0x7030, W0
00D78E  EB4800     CLR.B [W0]
2304:              
2305:                  SD_CS = 1;               //Initialize Chip Select line (1 = card not selected)
00D790  A8C2D5     BSET 0x2D5, #6
2306:              
2307:                  //MMC media powers up in the open-drain mode and cannot handle a clock faster
2308:                  //than 400kHz. Initialize SPI port to <= 400kHz
2309:                  InitSPISlowMode();    
00D792  07FFE1     RCALL InitSPISlowMode
2310:                  
2311:                  #ifdef __DEBUG_UART  
2312:                  PrintROMASCIIStringUART("\r\n\r\nInitializing Media\r\n"); 
2313:                  #endif
2314:              
2315:                  //Media wants the longer of: Vdd ramp time, 1 ms fixed delay, or 74+ clock pulses.
2316:                  //According to spec, CS should be high during the 74+ clock pulses.
2317:                  //In practice it is preferrable to wait much longer than 1ms, in case of
2318:                  //contact bounce, or incomplete mechanical insertion (by the time we start
2319:                  //accessing the media). 
2320:                  Delayms(30);
00D794  B3C1E0     MOV #0x1E, W0
00D796  07FFBC     RCALL Delayms
2321:                  SD_CS = 1;
00D798  A8C2D5     BSET 0x2D5, #6
00D79A  2000A8     MOV #0xA, W8
2322:                  //Generate 80 clock pulses.
2323:                  for(timeout=0; timeout<10u; timeout++)
00D7A2  3AFFFC     BRA NZ, 0xD79C
00D7A4  200649     MOV #0x64, W9
2324:                      WriteSPISlow(0xFF);
00D79C  EBC000     SETM.B W0
00D79E  07FD72     RCALL WriteSPIM
00D7A0  E90408     DEC W8, W8
2325:              
2326:              
2327:                  // Send CMD0 (with CS = 0) to reset the media and put SD cards into SPI mode.
2328:                  timeout = 100;
2329:                  do
2330:                  {
2331:                      //Toggle chip select, to make media abandon whatever it may have been doing
2332:                      //before.  This ensures the CMD0 is sent freshly after CS is asserted low,
2333:                      //minimizing risk of SPI clock pulse master/slave syncronization problems, 
2334:                      //due to possible application noise on the SCK line.
2335:                      SD_CS = 1;
00D7A6  A8C2D5     BSET 0x2D5, #6
2336:                      WriteSPISlow(0xFF);   //Send some "extraneous" clock pulses.  If a previous
00D7A8  EBC000     SETM.B W0
00D7AA  07FD6C     RCALL WriteSPIM
2337:                                            //command was terminated before it completed normally,
2338:                                            //the card might not have received the required clocking
2339:                                            //following the transfer.
2340:                      SD_CS = 0;
00D7AC  A9C2D5     BCLR 0x2D5, #6
2341:                      timeout--;
00D7AE  E90489     DEC W9, W9
2342:              
2343:                      //Send CMD0 to software reset the device
2344:                      response = SendMediaSlowCmd(GO_IDLE_STATE, 0x0);
00D7B0  2FFB40     MOV #0xFFB4, W0
00D7B2  478400     ADD W15, W0, W8
00D7B4  B81160     MUL.UU W2, #0, W2
00D7B6  EB4080     CLR.B W1
00D7B8  780008     MOV W8, W0
00D7BA  07FD73     RCALL SendMMCCmd
00D7BC  BE0018     MOV.D [W8], W0
00D7BE  9F8FD0     MOV W0, [W15-102]
00D7C0  9F8FE1     MOV W1, [W15-100]
00D7C2  9798CF     MOV [W15-72], W1
00D7C4  9F8FF1     MOV W1, [W15-98]
2345:                  }while((response.r1._byte != 0x01) && (timeout != 0));
00D7C6  97592F     MOV.B [W15-102], W2
00D7C8  514FE1     SUB.B W2, #0x1, [W15]
00D7CA  320003     BRA Z, 0xD7D2
00D7CC  E00009     CP0 W9
00D7CE  320003     BRA Z, 0xD7D6
00D7D0  37FFEA     BRA 0xD7A6
2346:                  //Check if all attempts failed and we timed out.  Normally, this won't happen,
2347:                  //unless maybe the SD card was busy, because it was previously performing a
2348:                  //read or write operation, when it was interrupted by the microcontroller getting
2349:                  //reset or power cycled, without also resetting or power cycling the SD card.
2350:                  //In this case, the SD card may still be busy (ex: trying to respond with the 
2351:                  //read request data), and may not be ready to process CMD0.  In this case,
2352:                  //we can try to recover by issuing CMD12 (STOP_TRANSMISSION).
2353:                  if(timeout == 0)
00D7D2  E00009     CP0 W9
00D7D4  3A0021     BRA NZ, 0xD818
2354:                  {
2355:                      #ifdef __DEBUG_UART  
2356:                      PrintROMASCIIStringUART("Media failed CMD0 too many times. R1 response byte = ");
2357:                      PrintRAMBytesUART(((unsigned char*)&response + 1), 1);
2358:                      UARTSendLineFeedCarriageReturn();
2359:                      PrintROMASCIIStringUART("Trying CMD12 to recover.\r\n");
2360:                      #endif
2361:              
2362:                      SD_CS = 1;
00D7D6  A8C2D5     BSET 0x2D5, #6
2363:                      WriteSPISlow(0xFF);       //Send some "extraneous" clock pulses.  If a previous
00D7D8  EBC000     SETM.B W0
00D7DA  07FD54     RCALL WriteSPIM
2364:                                                //command was terminated before it completed normally,
2365:                                                //the card might not have received the required clocking
2366:                                                //following the transfer.
2367:                      SD_CS = 0;
00D7DC  A9C2D5     BCLR 0x2D5, #6
2368:              
2369:                      //Send CMD12, to stop any read/write transaction that may have been in progress
2370:                      response = SendMediaSlowCmd(STOP_TRANSMISSION, 0x0);    //Blocks until SD card signals non-busy
00D7DE  2FFBA8     MOV #0xFFBA, W8
00D7E0  478408     ADD W15, W8, W8
00D7E2  B81160     MUL.UU W2, #0, W2
00D7E4  B3C051     MOV #0x5, W1
00D7E6  780008     MOV W8, W0
00D7E8  07FD5C     RCALL SendMMCCmd
00D7EA  BE0018     MOV.D [W8], W0
00D7EC  9F8FD0     MOV W0, [W15-102]
00D7EE  9F8FE1     MOV W1, [W15-100]
00D7F0  9798FF     MOV [W15-66], W1
00D7F2  9F8FF1     MOV W1, [W15-98]
2371:                      //Now retry to send send CMD0 to perform software reset on the media
2372:                      response = SendMediaSlowCmd(GO_IDLE_STATE, 0x0);        
00D7F4  2FFC08     MOV #0xFFC0, W8
00D7F6  478408     ADD W15, W8, W8
00D7F8  B81160     MUL.UU W2, #0, W2
00D7FA  EB4080     CLR.B W1
00D7FC  780008     MOV W8, W0
00D7FE  07FD51     RCALL SendMMCCmd
00D800  BE0018     MOV.D [W8], W0
00D802  9F8FD0     MOV W0, [W15-102]
00D804  9F8FE1     MOV W1, [W15-100]
00D806  97A0AF     MOV [W15-60], W1
00D808  9F8FF1     MOV W1, [W15-98]
2373:                      if(response.r1._byte != 0x01) //Check if card in idle state now.
00D80A  97592F     MOV.B [W15-102], W2
00D80C  514FE1     SUB.B W2, #0x1, [W15]
00D80E  320004     BRA Z, 0xD818
2374:                      {
2375:                          //Card failed to process CMD0 yet again.  At this point, the proper thing
2376:                          //to do would be to power cycle the card and retry, if the host 
2377:                          //circuitry supports disconnecting the SD card power.  Since the
2378:                          //SD/MMC PICtail+ doesn't support software controlled power removal
2379:                          //of the SD card, there is nothing that can be done with this hardware.
2380:                          //Therefore, we just give up now.  The user needs to physically 
2381:                          //power cycle the media and/or the whole board.
2382:                          #ifdef __DEBUG_UART  
2383:                          PrintROMASCIIStringUART("Media still failed CMD0. Cannot initialize card, returning.\r\n");
2384:                          #endif   
2385:                          mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE;
00D810  B3C021     MOV #0x2, W1
00D812  270460     MOV #0x7046, W0
00D814  784801     MOV.B W1, [W0]
00D816  3700F8     BRA 0xDA08
2386:                          return &mediaInformation;
2387:                      }            
2388:                      else
2389:                      {
2390:                          //Card successfully processed CMD0 and is now in the idle state.
2391:                          #ifdef __DEBUG_UART  
2392:                          PrintROMASCIIStringUART("Media successfully processed CMD0 after CMD12.\r\n");
2393:                          #endif        
2394:                      }    
2395:                  }//if(timeout == 0) [for the CMD0 transmit loop]
2396:                  else
2397:                  {
2398:                      #ifdef __DEBUG_UART  
2399:                      PrintROMASCIIStringUART("Media successfully processed CMD0.\r\n");
2400:                      #endif        
2401:                  }       
2402:                  
2403:              
2404:                  //Send CMD8 (SEND_IF_COND) to specify/request the SD card interface condition (ex: indicate what voltage the host runs at).
2405:                  //0x000001AA --> VHS = 0001b = 2.7V to 3.6V.  The 0xAA LSB is the check pattern, and is arbitrary, but 0xAA is recommended (good blend of 0's and '1's).
2406:                  //The SD card has to echo back the check pattern correctly however, in the R7 response.
2407:                  //If the SD card doesn't support the operating voltage range of the host, then it may not respond.
2408:                  //If it does support the range, it will respond with a type R7 reponse packet (6 bytes/48 bits).	        
2409:                  //Additionally, if the SD card is MMC or SD card v1.x spec device, then it may respond with
2410:                  //invalid command.  If it is a v2.0 spec SD card, then it is mandatory that the card respond
2411:                  //to CMD8.
2412:                  response = SendMediaSlowCmd(SEND_IF_COND, 0x1AA);   //Note: If changing "0x1AA", CRC value in table must also change.
00D818  2FFC68     MOV #0xFFC6, W8
00D81A  478408     ADD W15, W8, W8
00D81C  201AA2     MOV #0x1AA, W2
00D81E  200003     MOV #0x0, W3
00D820  B3C021     MOV #0x2, W1
00D822  780008     MOV W8, W0
00D824  07FD3E     RCALL SendMMCCmd
00D826  BE0018     MOV.D [W8], W0
00D828  9F8FD0     MOV W0, [W15-102]
00D82A  9F8FE1     MOV W1, [W15-100]
00D82C  97A0DF     MOV [W15-54], W1
00D82E  9F8FF1     MOV W1, [W15-98]
2413:                  if(((response.r7.bytewise.argument._returnVal & 0xFFF) == 0x1AA) && (!response.r7.bitwise.bits.ILLEGAL_CMD))
00D830  97886F     MOV [W15-100], W0
00D832  20FFF2     MOV #0xFFF, W2
00D834  600002     AND W0, W2, W0
00D836  200001     MOV #0x0, W1
00D838  201AA2     MOV #0x1AA, W2
00D83A  500F82     SUB W0, W2, [W15]
00D83C  588FE0     SUBB W1, #0x0, [W15]
00D83E  3A0039     BRA NZ, 0xD8B2
00D840  9788DF     MOV [W15-102], W1
00D842  608064     AND W1, #0x4, W0
00D844  3A0036     BRA NZ, 0xD8B2
2414:                 	{
2415:                      //If we get to here, the device supported the CMD8 command and didn't complain about our host
2416:                      //voltage range.
2417:                      //Most likely this means it is either a v2.0 spec standard or high capacity SD card (SDHC)
2418:                      #ifdef __DEBUG_UART  
2419:                      PrintROMASCIIStringUART("Media successfully processed CMD8. Response = ");
2420:                      PrintRAMBytesUART(((unsigned char*)&response + 1), 4);
2421:                      UARTSendLineFeedCarriageReturn();
2422:                      #endif
2423:              
2424:              		//Send CMD58 (Read OCR [operating conditions register]).  Reponse type is R3, which has 5 bytes.
2425:              		//Byte 4 = normal R1 response byte, Bytes 3-0 are = OCR register value.
2426:                      #ifdef __DEBUG_UART  
2427:                      PrintROMASCIIStringUART("Sending CMD58.\r\n");
2428:                      #endif
2429:                      response = SendMediaSlowCmd(READ_OCR, 0x0);
00D846  2FFCC8     MOV #0xFFCC, W8
00D848  478408     ADD W15, W8, W8
00D84A  B81160     MUL.UU W2, #0, W2
00D84C  B3C101     MOV #0x10, W1
00D84E  780008     MOV W8, W0
00D850  07FD28     RCALL SendMMCCmd
00D852  BE0018     MOV.D [W8], W0
00D854  9F8FD0     MOV W0, [W15-102]
00D856  9F8FE1     MOV W1, [W15-100]
00D858  97A88F     MOV [W15-48], W1
00D85A  9F8FF1     MOV W1, [W15-98]
00D85C  EB8480     SETM W9
2430:                      //Now that we have the OCR register value in the reponse packet, we could parse
2431:                      //the register contents and learn what voltage the SD card wants to run at.
2432:                      //If our host circuitry has variable power supply capability, it could 
2433:                      //theoretically adjust the SD card Vdd to the minimum of the OCR to save power.
2434:              		
2435:              		//Now send CMD55/ACMD41 in a loop, until the card is finished with its internal initialization.
2436:              		//Note: SD card specs recommend >= 1 second timeout while waiting for ACMD41 to signal non-busy.
2437:              		for(timeout = 0; timeout < 0xFFFF; timeout++)
00D888  3200BB     BRA Z, 0xDA00
00D88A  37FFE9     BRA 0xD85E
00D88C  270309     MOV #0x7030, W9
2438:              		{				
2439:              			//Send CMD55 (lets SD card know that the next command is application specific (going to be ACMD41)).
2440:              			SendMediaSlowCmd(APP_CMD, 0x00000000);
00D85E  B81160     MUL.UU W2, #0, W2
00D860  B3C0F1     MOV #0xF, W1
00D862  2FFD20     MOV #0xFFD2, W0
00D864  478000     ADD W15, W0, W0
00D866  07FD1D     RCALL SendMMCCmd
2441:              			
2442:              			//Send ACMD41.  This is to check if the SD card is finished booting up/ready for full frequency and all
2443:              			//further commands.  Response is R3 type (6 bytes/48 bits, middle four bytes contain potentially useful data).
2444:                          //Note: When sending ACMD41, the HCS bit is bit 30, and must be = 1 to tell SD card the host supports SDHC
2445:              			response = SendMediaSlowCmd(SD_SEND_OP_COND,0x40000000); //bit 30 set
00D868  2FFD88     MOV #0xFFD8, W8
00D86A  478408     ADD W15, W8, W8
00D86C  200002     MOV #0x0, W2
00D86E  240003     MOV #0x4000, W3
00D870  B3C121     MOV #0x12, W1
00D872  780008     MOV W8, W0
00D874  07FD16     RCALL SendMMCCmd
00D876  BE0018     MOV.D [W8], W0
00D878  9F8FD0     MOV W0, [W15-102]
00D87A  9F8FE1     MOV W1, [W15-100]
00D87C  97A8EF     MOV [W15-36], W1
00D87E  9F8FF1     MOV W1, [W15-98]
2446:              			
2447:              			//The R1 response should be = 0x00, meaning the card is now in the "standby" state, instead of
2448:              			//the "idle" state (which is the default initialization state after CMD0 reset is issued).  Once
2449:              			//in the "standby" state, the SD card is finished with basic intitialization and is ready 
2450:              			//for read/write and other commands.
2451:              			if(response.r1._byte == 0)
00D880  97592F     MOV.B [W15-102], W2
00D882  E00402     CP0.B W2
00D884  320003     BRA Z, 0xD88C
2452:              			{
2453:                  		    #ifdef __DEBUG_UART  
2454:                              PrintROMASCIIStringUART("Media successfully processed CMD55/ACMD41 and is no longer busy.\r\n");
2455:              				#endif
2456:              				break;  //Break out of for() loop.  Card is finished initializing.
00D886  E90489     DEC W9, W9
2457:                          }				
2458:              		}		
2459:              		if(timeout >= 0xFFFF)
2460:              		{
2461:                          #ifdef __DEBUG_UART  
2462:                          PrintROMASCIIStringUART("Media Timeout on CMD55/ACMD41.\r\n");
2463:                          #endif
2464:                  		mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE;
00DA00  B3C021     MOV #0x2, W1
00DA02  270460     MOV #0x7046, W0
00DA04  784801     MOV.B W1, [W0]
00DA06  37FF42     BRA 0xD88C
2465:                      }				
2466:              		
2467:              		
2468:                      //Now send CMD58 (Read OCR register).  The OCR register contains important
2469:                      //info we will want to know about the card (ex: standard capacity vs. SDHC).
2470:                      response = SendMediaSlowCmd(READ_OCR, 0x0); 
00D88E  2FFDE8     MOV #0xFFDE, W8
00D890  478408     ADD W15, W8, W8
00D892  B81160     MUL.UU W2, #0, W2
00D894  B3C101     MOV #0x10, W1
00D896  780008     MOV W8, W0
00D898  07FD04     RCALL SendMMCCmd
00D89A  BE0018     MOV.D [W8], W0
00D89C  9F8FD0     MOV W0, [W15-102]
00D89E  9F8FE1     MOV W1, [W15-100]
00D8A0  97B09F     MOV [W15-30], W1
00D8A2  9F8FF1     MOV W1, [W15-98]
2471:              
2472:              		//Now check the CCS bit (OCR bit 30) in the OCR register, which is in our response packet.
2473:              		//This will tell us if it is a SD high capacity (SDHC) or standard capacity device.
2474:              		if(response.r7.bytewise.argument._returnVal & 0x40000000)    //Note the HCS bit is only valid when the busy bit is also set (indicating device ready).
00D8A4  A3E801     BTST.Z W1, #14
00D8A6  320003     BRA Z, 0xD8AE
2475:              		{
2476:              			gSDMode = SD_MODE_HC;
00D8A8  B3C010     MOV #0x1, W0
00D8AA  784C80     MOV.B W0, [W9]
00D8AC  370020     BRA 0xD8EE
2477:              			
2478:              		    #ifdef __DEBUG_UART  
2479:                          PrintROMASCIIStringUART("Media successfully processed CMD58: SD card is SDHC v2.0 (or later) physical spec type.\r\n");
2480:                          #endif
2481:                      }				
2482:                      else
2483:                      {
2484:                          gSDMode = SD_MODE_NORMAL;
00D8AE  EB4C80     CLR.B [W9]
00D8B0  37001E     BRA 0xD8EE
2485:              
2486:                          #ifdef __DEBUG_UART  
2487:                          PrintROMASCIIStringUART("Media successfully processed CMD58: SD card is standard capacity v2.0 (or later) spec.\r\n");
2488:                          #endif
2489:                      } 
2490:                      //SD Card should now be finished with initialization sequence.  Device should be ready
2491:                      //for read/write commands.
2492:              
2493:              	}//if(((response.r7.bytewise._returnVal & 0xFFF) == 0x1AA) && (!response.r7.bitwise.bits.ILLEGAL_CMD))
2494:                  else
2495:              	{
2496:                      //The CMD8 wasn't supported.  This means the card is not a v2.0 card.
2497:                      //Presumably the card is v1.x device, standard capacity (not SDHC).
2498:              
2499:                      #ifdef __DEBUG_UART  
2500:                      PrintROMASCIIStringUART("CMD8 Unsupported: Media is most likely MMC or SD 1.x device.\r\n");
2501:                      #endif
2502:              
2503:              
2504:                      SD_CS = 1;                              // deselect the devices
00D8B2  A8C2D5     BSET 0x2D5, #6
2505:                      Delayms(1);
00D8B4  B3C010     MOV #0x1, W0
00D8B6  07FF2C     RCALL Delayms
2506:                      SD_CS = 0;                              // select the device
00D8B8  A9C2D5     BCLR 0x2D5, #6
2507:              
2508:                      //The CMD8 wasn't supported.  This means the card is definitely not a v2.0 SDHC card.
2509:                      gSDMode = SD_MODE_NORMAL;
00D8BA  270300     MOV #0x7030, W0
00D8BC  EB4800     CLR.B [W0]
00D8BE  21FFF9     MOV #0x1FFF, W9
2510:                  	// According to the spec CMD1 must be repeated until the card is fully initialized
2511:                  	timeout = 0x1FFF;
2512:                      do
2513:                      {
2514:                          //Send CMD1 to initialize the media.
2515:                          response = SendMediaSlowCmd(SEND_OP_COND, 0x00000000);    //When argument is 0x00000000, this queries MMC cards for operating voltage range
00D8C0  57847C     SUB W15, #0x1C, W8
00D8C2  B81160     MUL.UU W2, #0, W2
00D8C4  B3C011     MOV #0x1, W1
00D8C6  780008     MOV W8, W0
00D8C8  07FCEC     RCALL SendMMCCmd
00D8CA  BE0018     MOV.D [W8], W0
00D8CC  9F8FD0     MOV W0, [W15-102]
00D8CE  9F8FE1     MOV W1, [W15-100]
00D8D0  97B0CF     MOV [W15-24], W1
00D8D2  9F8FF1     MOV W1, [W15-98]
2516:                          timeout--;
00D8D4  E90489     DEC W9, W9
2517:                      }while((response.r1._byte != 0x00) && (timeout != 0));
00D8D6  97592F     MOV.B [W15-102], W2
00D8D8  E00402     CP0.B W2
00D8DA  320003     BRA Z, 0xD8E2
00D8DC  E00009     CP0 W9
00D8DE  320003     BRA Z, 0xD8E6
00D8E0  37FFEF     BRA 0xD8C0
2518:                      // see if it failed
2519:                      if(timeout == 0)
00D8E2  E00009     CP0 W9
00D8E4  3A0004     BRA NZ, 0xD8EE
2520:                      {
2521:                          #ifdef __DEBUG_UART  
2522:                          PrintROMASCIIStringUART("CMD1 failed.\r\n");
2523:                          #endif
2524:              
2525:                          mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE;
00D8E6  B3C021     MOV #0x2, W1
00D8E8  270460     MOV #0x7046, W0
00D8EA  784801     MOV.B W1, [W0]
2526:                          SD_CS = 1;                              // deselect the devices
00D8EC  A8C2D5     BSET 0x2D5, #6
2527:                      }
2528:                      else
2529:                      {
2530:                          #ifdef __DEBUG_UART  
2531:                          PrintROMASCIIStringUART("CMD1 Successfully processed, media is no longer busy.\r\n");
2532:                          #endif
2533:                          
2534:                          //Set read/write block length to 512 bytes.  Note: commented out since
2535:                          //this theoretically isn't necessary, since all cards v1 and v2 are 
2536:                          //required to support 512 byte block size, and this is supposed to be
2537:                          //the default size selected on cards that support other sizes as well.
2538:                          //response = SendMediaSlowCmd(SET_BLOCKLEN, 0x00000200);    //Set read/write block length to 512 bytes
2539:                      }
2540:                     
2541:              	}
2542:              
2543:              
2544:                  //Temporarily deselect device
2545:                  SD_CS = 1;
00D8EE  A8C2D5     BSET 0x2D5, #6
2546:                  
2547:                  //Basic initialization of media is now complete.  The card will now use push/pull
2548:                  //outputs with fast drivers.  Therefore, we can now increase SPI speed to 
2549:                  //either the maximum of the microcontroller or maximum of media, whichever 
2550:                  //is slower.  MMC media is typically good for at least 20Mbps SPI speeds.  
2551:                  //SD cards would typically operate at up to 25Mbps or higher SPI speeds.
2552:                  OpenSPIM(SYNC_MODE_FAST);
00D8F0  2003E0     MOV #0x3E, W0
00D8F2  07FF1C     RCALL OpenSPIM
2553:              
2554:              	SD_CS = 0;
00D8F4  A9C2D5     BCLR 0x2D5, #6
00D8F6  200149     MOV #0x14, W9
2555:              
2556:              	/* Send the CMD9 to read the CSD register */
2557:                  timeout = NCR_TIMEOUT;
2558:                  do
2559:                  {
2560:                      //Send CMD9: Read CSD data structure.
2561:              		response = SendMMCCmd(SEND_CSD, 0x00);
00D8F8  578476     SUB W15, #0x16, W8
00D8FA  B81160     MUL.UU W2, #0, W2
00D8FC  B3C031     MOV #0x3, W1
00D8FE  780008     MOV W8, W0
00D900  07FCD0     RCALL SendMMCCmd
00D902  BE0018     MOV.D [W8], W0
00D904  9F8FD0     MOV W0, [W15-102]
00D906  9F8FE1     MOV W1, [W15-100]
00D908  97B0FF     MOV [W15-18], W1
00D90A  9F8FF1     MOV W1, [W15-98]
2562:                      timeout--;
00D90C  E90489     DEC W9, W9
2563:                  }while((response.r1._byte != 0x00) && (timeout != 0));
00D90E  97592F     MOV.B [W15-102], W2
00D910  E00402     CP0.B W2
00D912  320003     BRA Z, 0xD91A
00D914  E00009     CP0 W9
00D916  320003     BRA Z, 0xD91E
00D918  37FFEF     BRA 0xD8F8
2564:                  if(timeout != 0x00)
00D91A  E00009     CP0 W9
00D91C  3A0004     BRA NZ, 0xD926
2565:                  {
2566:                      #ifdef __DEBUG_UART  
2567:                      PrintROMASCIIStringUART("CMD9 Successfully processed: Read CSD register.\r\n");
2568:                      PrintROMASCIIStringUART("CMD9 response R1 byte = ");
2569:                      PrintRAMBytesUART((unsigned char*)&response, 1); 
2570:                      UARTSendLineFeedCarriageReturn();
2571:                      #endif
2572:                  }    
2573:                  else
2574:                  {
2575:                      //Media failed to respond to the read CSD register operation.
2576:                      #ifdef __DEBUG_UART  
2577:                      PrintROMASCIIStringUART("Timeout occurred while processing CMD9 to read CSD register.\r\n");
2578:                      #endif
2579:                      
2580:                      mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE;
00D91E  B3C021     MOV #0x2, W1
00D920  270460     MOV #0x7046, W0
00D922  784801     MOV.B W1, [W0]
00D924  37006B     BRA 0xD9FC
2581:                      SD_CS = 1;
2582:                      return &mediaInformation;
00D926  EB4480     CLR.B W9
00D928  EB0400     CLR W8
2583:                  }    
2584:              
2585:              	/* According to the simplified spec, section 7.2.6, the card will respond
2586:              	with a standard response token, followed by a data block of 16 bytes
2587:              	suffixed with a 16-bit CRC.*/
2588:              	index = 0;
2589:              	for (count = 0; count < 20u; count ++)
00D944  540FF4     SUB W8, #0x14, [W15]
00D946  3AFFF1     BRA NZ, 0xD92A
2590:              	{
2591:              		CSDResponse[index] = MDD_SDSPI_ReadMedia();
00D92A  07FCB3     RCALL MDD_SDSPI_ReadMedia
00D92C  2FFA01     MOV #0xFFA0, W1
00D92E  478101     ADD W15, W1, W2
00D930  FB8089     ZE W9, W1
00D932  78F100     MOV.B W0, [W2+W1]
2592:              		index++;			
00D934  E84489     INC.B W9, W9
2593:              		/* Hopefully the first byte is the datatoken, however, some cards do
2594:              		not send the response token before the CSD register.*/
2595:              		if((count == 0) && (CSDResponse[0] == DATA_START_TOKEN))
00D936  E00408     CP0.B W8
00D938  3A0004     BRA NZ, 0xD942
00D93A  B3CFE0     MOV #0xFE, W0
00D93C  104F92     SUBR.B W0, [W2], [W15]
00D93E  3A0001     BRA NZ, 0xD942
00D940  784488     MOV.B W8, W9
00D942  E80408     INC W8, W8
2596:              		{
2597:              			/* As the first byte was the datatoken, we can drop it. */
2598:              			index = 0;
2599:              		}
2600:              	}
2601:              
2602:                  #ifdef __DEBUG_UART  
2603:                  PrintROMASCIIStringUART("CSD data structure contains: ");
2604:                  PrintRAMBytesUART((unsigned char*)&CSDResponse, 20); 
2605:                  UARTSendLineFeedCarriageReturn();
2606:                  #endif
2607:                  
2608:              
2609:              
2610:              	//Extract some fields from the response for computing the card capacity.
2611:              	//Note: The structure format depends on if it is a CSD V1 or V2 device.
2612:              	//Therefore, need to first determine version of the specs that the card 
2613:              	//is designed for, before interpreting the individual fields.
2614:              
2615:              	//-------------------------------------------------------------
2616:              	//READ_BL_LEN: CSD Structure v1 cards always support 512 byte
2617:              	//read and write block lengths.  Some v1 cards may optionally report
2618:              	//READ_BL_LEN = 1024 or 2048 bytes (and therefore WRITE_BL_LEN also 
2619:              	//1024 or 2048).  However, even on these cards, 512 byte partial reads
2620:              	//and 512 byte write are required to be supported.
2621:              	//On CSD structure v2 cards, it is always required that READ_BL_LEN 
2622:              	//(and therefore WRITE_BL_LEN) be 512 bytes, and partial reads and
2623:              	//writes are not allowed.
2624:              	//Therefore, all cards support 512 byte reads/writes, but only a subset
2625:              	//of cards support other sizes.  For best compatibility with all cards,
2626:              	//and the simplest firmware design, it is therefore preferrable to 
2627:              	//simply ignore the READ_BL_LEN and WRITE_BL_LEN values altogether,
2628:              	//and simply hardcode the read/write block size as 512 bytes.
2629:              	//-------------------------------------------------------------
2630:              	gMediaSectorSize = 512u;
00D948  202000     MOV #0x200, W0
00D94A  8B8190     MOV W0, gMediaSectorSize
2631:              	//mediaInformation.sectorSize = gMediaSectorSize;
2632:              	mediaInformation.sectorSize = 512u;
00D94C  8B8240     MOV W0, 0x7048
2633:              	mediaInformation.validityFlags.bits.sectorSize = TRUE;
00D94E  838230     MOV mediaInformation, W0
00D950  A08000     BSET W0, #8
00D952  8B8230     MOV W0, mediaInformation
00D954  976A9F     MOV.B [W15-87], W5
00D956  976A0F     MOV.B [W15-88], W4
00D958  9760FF     MOV.B [W15-89], W1
2634:              	//-------------------------------------------------------------
2635:              
2636:              	//Calculate the MDD_SDSPI_finalLBA (see SD card physical layer simplified spec 2.0, section 5.3.2).
2637:              	//In USB mass storage applications, we will need this information to 
2638:              	//correctly respond to SCSI get capacity requests.  Note: method of computing 
2639:              	//MDD_SDSPI_finalLBA depends on CSD structure spec version (either v1 or v2).
2640:              	if(CSDResponse[0] & 0xC0)	//Check CSD_STRUCTURE field for v2+ struct device
00D95A  2FFA02     MOV #0xFFA0, W2
00D95C  478002     ADD W15, W2, W0
00D95E  FB8010     ZE [W0], W0
00D960  B20C00     AND #0xC0, W0
00D962  320014     BRA Z, 0xD98C
2641:              	{
2642:              		//Must be a v2 device (or a reserved higher version, that doesn't currently exist)
2643:              
2644:              		//Extract the C_SIZE field from the response.  It is a 22-bit number in bit position 69:48.  This is different from v1.  
2645:              		//It spans bytes 7, 8, and 9 of the response.
2646:              		c_size = (((DWORD)CSDResponse[7] & 0x3F) << 16) | ((WORD)CSDResponse[8] << 8) | CSDResponse[9];
2647:              		
2648:              		MDD_SDSPI_finalLBA = ((DWORD)(c_size + 1) * (WORD)(1024u)) - 1; //-1 on end is correction factor, since LBA = 0 is valid.
00D964  780001     MOV W1, W0
00D966  B203F0     AND #0x3F, W0
00D968  200001     MOV #0x0, W1
00D96A  DD00C0     SL W0, #0, W1
00D96C  200000     MOV #0x0, W0
00D96E  DD2148     SL W4, #8, W2
00D970  200003     MOV #0x0, W3
00D972  700002     IOR W0, W2, W0
00D974  708083     IOR W1, W3, W1
00D976  FB8105     ZE W5, W2
00D978  200003     MOV #0x0, W3
00D97A  700002     IOR W0, W2, W0
00D97C  708083     IOR W1, W3, W1
00D97E  DD094A     SL W1, #10, W2
00D980  DE00C6     LSR W0, #6, W1
00D982  710081     IOR W2, W1, W1
00D984  DD004A     SL W0, #10, W0
00D986  B03FF0     ADD #0x3FF, W0
00D988  B08001     ADDC #0x0, W1
00D98A  37002D     BRA 0xD9E6
2649:              	}
2650:              	else //if(CSDResponse[0] & 0xC0)	//Check CSD_STRUCTURE field for v1 struct device
2651:              	{
2652:              		//Must be a v1 device.
2653:              		//Extract the C_SIZE field from the response.  It is a 12-bit number in bit position 73:62.  
2654:              		//Although it is only a 12-bit number, it spans bytes 6, 7, and 8, since it isn't byte aligned.
2655:              		c_size = ((DWORD)CSDResponse[6] << 16) | ((WORD)CSDResponse[7] << 8) | CSDResponse[8];	//Get the bytes in the correct positions
00D98C  97616F     MOV.B [W15-90], W2
00D98E  FB8182     ZE W2, W3
00D990  200002     MOV #0x0, W2
00D992  DD0848     SL W1, #8, W0
00D994  200001     MOV #0x0, W1
00D996  710100     IOR W2, W0, W2
00D998  718181     IOR W3, W1, W3
00D99A  FB8004     ZE W4, W0
00D99C  200001     MOV #0x0, W1
00D99E  710100     IOR W2, W0, W2
00D9A0  718181     IOR W3, W1, W3
2656:              		c_size &= 0x0003FFC0;	//Clear all bits that aren't part of the C_SIZE
00D9A2  2FFC00     MOV #0xFFC0, W0
00D9A4  200031     MOV #0x3, W1
00D9A6  600202     AND W0, W2, W4
00D9A8  608003     AND W1, W3, W0
00D9AA  780180     MOV W0, W3
00D9AC  780104     MOV W4, W2
00D9AE  BE0002     MOV.D W2, W0
2657:              		c_size = c_size >> 6;	//Shift value down, so the 12-bit C_SIZE is properly right justified in the DWORD.
2658:              		
2659:              		//Extract the C_SIZE_MULT field from the response.  It is a 3-bit number in bit position 49:47.
2660:              		c_size_mult = ((WORD)((CSDResponse[9] & 0x03) << 1)) | ((WORD)((CSDResponse[10] & 0x80) >> 7));
2661:              
2662:                      //Extract the BLOCK_LEN field from the response. It is a 4-bit number in bit position 83:80.
2663:                      block_len = CSDResponse[5] & 0x0F;
2664:              
2665:                      block_len = 1 << (block_len - 9); //-9 because we report the size in sectors of 512 bytes each
2666:              		
2667:              		//Calculate the MDD_SDSPI_finalLBA (see SD card physical layer simplified spec 2.0, section 5.3.2).
2668:              		//In USB mass storage applications, we will need this information to 
2669:              		//correctly respond to SCSI get capacity requests (which will cause MDD_SDSPI_ReadCapacity() to get called).
2670:              		MDD_SDSPI_finalLBA = ((DWORD)(c_size + 1) * (WORD)((WORD)1 << (c_size_mult + 2)) * block_len) - 1;	//-1 on end is correction factor, since LBA = 0 is valid.		
00D9B0  DD094A     SL W1, #10, W2
00D9B2  DE0046     LSR W0, #6, W0
00D9B4  710000     IOR W2, W0, W0
00D9B6  DE08C6     LSR W1, #6, W1
00D9B8  400061     ADD W0, #0x1, W0
00D9BA  4880E0     ADDC W1, #0x0, W1
00D9BC  62C163     AND.B W5, #0x3, W2
00D9BE  414102     ADD.B W2, W2, W2
00D9C0  976A2F     MOV.B [W15-86], W4
00D9C2  B20804     AND #0x80, W4
00D9C4  DEA247     ASR W4, #7, W4
00D9C6  714104     IOR.B W2, W4, W2
00D9C8  FB8102     ZE W2, W2
00D9CA  E88102     INC2 W2, W2
00D9CC  200018     MOV #0x1, W8
00D9CE  DD4102     SL W8, W2, W2
00D9D0  200003     MOV #0x0, W3
00D9D2  07BCF7     RCALL __mulp32eds3
00D9D4  97615F     MOV.B [W15-91], W2
00D9D6  61016F     AND W2, #0xF, W2
00D9D8  510169     SUB W2, #0x9, W2
00D9DA  DD4102     SL W8, W2, W2
00D9DC  FB8102     ZE W2, W2
00D9DE  200003     MOV #0x0, W3
00D9E0  07BCF0     RCALL __mulp32eds3
00D9E2  500061     SUB W0, #0x1, W0
00D9E4  5880E0     SUBB W1, #0x0, W1
00D9E6  8B81A0     MOV W0, MDD_SDSPI_finalLBA
00D9E8  8B81B1     MOV W1, 0x7036
2671:              	}	
2672:              
2673:                  //Turn off CRC7 if we can, might be an invalid cmd on some cards (CMD59)
2674:                  //Note: POR default for the media is normally with CRC checking off in SPI 
2675:                  //mode anyway, so this is typically redundant.
2676:                  SendMMCCmd(CRC_ON_OFF,0x0);
00D9EA  B81160     MUL.UU W2, #0, W2
00D9EC  B3C111     MOV #0x11, W1
00D9EE  578070     SUB W15, #0x10, W0
00D9F0  07FC58     RCALL SendMMCCmd
2677:              
2678:                  //Now set the block length to media sector size. It should be already set to this.
2679:                  SendMMCCmd(SET_BLOCKLEN,gMediaSectorSize);
00D9F2  838192     MOV gMediaSectorSize, W2
00D9F4  200003     MOV #0x0, W3
00D9F6  B3C071     MOV #0x7, W1
00D9F8  57806A     SUB W15, #0xA, W0
00D9FA  07FC53     RCALL SendMMCCmd
2680:              
2681:                  //Deselect media while not actively accessing the card.
2682:                  SD_CS = 1;
00D9FC  A8C2D5     BSET 0x2D5, #6
00D9FE  370004     BRA 0xDA08
2683:              
2684:                  #ifdef __DEBUG_UART  
2685:                  PrintROMASCIIStringUART("Returning from MediaInitialize() function.\r\n");
2686:                  #endif
2687:              
2688:              
2689:                  return &mediaInformation;
2690:              }//end MediaInitialize
2691:              
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libsdcard.X/src/FSIO.c  --
006E86  781F88     MOV W8, [W15++]
006E88  780400     MOV W0, W8
006E8A  BE0202     MOV.D W2, W4
1:                 /******************************************************************************
2:                 *
3:                 *               Microchip Memory Disk Drive File System
4:                 *
5:                 ******************************************************************************
6:                 * FileName:           FSIO.c
7:                 * Dependencies:       GenericTypeDefs.h
8:                 *                     FSIO.h
9:                 *                     Physical interface include file (SD-SPI.h, CF-PMP.h, ...)
10:                *                     string.h
11:                *                     stdlib.h
12:                *                     FSDefs.h
13:                *                     ctype.h
14:                *                     salloc.h
15:                * Processor:          PIC18/PIC24/dsPIC30/dsPIC33/PIC32
16:                * Compiler:           C18/C30/C32
17:                * Company:            Microchip Technology, Inc.
18:                *
19:                * Software License Agreement
20:                *
21:                * The software supplied herewith by Microchip Technology Incorporated
22:                * (the •À?Company•À?) for its PICmicro•À? Microcontroller is intended and
23:                * supplied to you, the Company•À?s customer, for use solely and
24:                * exclusively on Microchip PICmicro Microcontroller products. The
25:                * software is owned by the Company and/or its supplier, and is
26:                * protected under applicable copyright laws. All rights are reserved.
27:                * Any use in violation of the foregoing restrictions may subject the
28:                * user to criminal sanctions under applicable laws, as well as to
29:                * civil liability for the breach of the terms and conditions of this
30:                * license.
31:                *
32:                * THIS SOFTWARE IS PROVIDED IN AN •À?AS IS•À? CONDITION. NO WARRANTIES,
33:                * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
34:                * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
35:                * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
36:                * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
37:                * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
38:                *
39:                ********************************************************************
40:                 File Description:
41:                
42:                 Change History:
43:                  Rev     Description
44:                  -----   -----------
45:                  1.2.5   Fixed bug that prevented writes to alternate FAT tables
46:                          Fixed bug that prevented FAT being updated when media is re-inserted
47:                
48:                  1.2.6   Fixed bug that resulted in a bus error when attempts to read a invalid memory region
49:                          Fixed bug that prevented the Windows Explorer to show the Date Creation field for directories
50:                
51:                  x.x.x   Fixed issue on some USB drives where the information written
52:                            to the drive is cached in a RAM for 500ms before it is 
53:                            written to the flash unless the sector is accessed again.
54:                          Add some error recovery for FAT32 systems when there is
55:                            corruption in the boot sector.
56:                
57:                  1.3.0   Modified to support Long File Name(LFN) format
58:                  1.3.4   1) Initialized some of the local variables to default values
59:                             to remove non-critical compiler warnings for code sanitation.
60:                          2) The sector size of the media device is obtained from the MBR of media.So, 
61:                             instead of using the hard coded macro "DIRENTRIES_PER_SECTOR", the variables
62:                             "dirEntriesPerSector" & "disk->sectorSize" are used in the code. Refer 
63:                             "Cache_File_Entry","EraseCluster" & "writeDotEntries" fucntions to see 
64:                             the change.
65:                  1.3.6   1) The function "FILEget_next_cluster" is made public.
66:                          2) Modified "FILEfind" function such that when using 8.3 format
67:                             the file searches are not considered as case sensitive.
68:                          3) In function 'CacheTime', the variables 'ptr1' & 'ptr0' are not used
69:                             when compiled for PIC32. So there definitions were removed for PIC32.
70:                          4) Modified "rmdirhelper", "FormatDirName" & "writeDotEntries" functions
71:                             to remove non-critical warnings during compilation.
72:                          5) Updated comments in most of the function header blocks.
73:                  1.4.0   1) While creating files in LFN format with file name length as 13,26,39,52...etc(multiples of 13),
74:                             MDD library was creating incorrect directory entries. To fix this issue,
75:                             functions "FILEfind", "CreateFileEntry", "Alias_LFN_Object", "FormatFileName", 
76:                             "FormatDirName", "FSgetcwd", "GetPreviousEntry" & "rmdirhelper" were modified.
77:                             Now "utf16LFNlength" variable part of "FSFILE" structure, indicates LFN length
78:                             excluding the NULL word at the last.
79:                          2) When creating large number of files in LFN format, some files were not getting created in disk.
80:                             To fix this issue,function "FILEfind" was modified.
81:                          3) Modified "FSformat" function to initialize "disk->sectorSize" to default value.
82:                          4) Modified "CreateFileEntry" & "FindEmptyEntries" functions to remove unnecessary
83:                             assignments & optimize the code.
84:                          5) Modified "FSfopen" function to prevent creating an empty file in the directory, when SD card
85:                             is write protected.
86:                          6) Variable "entry" in "writeDotEntries" function is made volatile & properly typecasted
87:                             in it's usage.
88:                          7) Modified "FSFopen" function so that when you try to open a file that doesn't exist on the disk,
89:                             variable "FSerrno" is assigned to CE_FILE_NOT_FOUND.
90:                  1.4.2   1) Minor Modification in "CreateFileEntry" function to fix a bug for file name lengths of
91:                             26,39....characters (multiples of 13)
92:                          2) Fixed the LoadMBR() function to scan all of the MBR entries and return success on the first
93:                             supported drive or fail after the 4 table entries.
94:                  1.4.4   1) Cleared the "read" flag and set the file pointer to NULL in FSfclose() function to prevent the
95:                             unintentional acess to a closed file.
96:                          2) Modified "FSfopen()" function so that in "ReadPlus(r+)" mode the FAT table is read from media
97:                             & the latest FAT contents are present in cache of RAM.
98:                          3) Modified "FILEget_next_cluster" function so that: if the last two clusters of the data region
99:                             are allocated to a file,then that file can be traversed using "FILEget_next_cluster" function.
100:               ********************************************************************/
101:               
102:               #include "Compiler.h"
103:               #include "FSIO.h"
104:               #include "GenericTypeDefs.h"
105:               #include "string.h"
106:               #include "stdlib.h"
107:               #include "ctype.h"
108:               #include "FSDefs.h"
109:               //#include "/ho"
110:               
111:               
112:               #ifdef ALLOW_FSFPRINTF
113:               #include "stdarg.h"
114:               #endif
115:               
116:               #ifdef FS_DYNAMIC_MEM
117:                  #ifdef __18CXX
118:                     #include "salloc.h"
119:                  #endif
120:               #endif
121:               
122:               #ifndef ALLOW_WRITES
123:                  #ifdef ALLOW_FORMATS
124:                     #error Write functions must be enabled to use the format function
125:                  #endif
126:                  #ifdef ALLOW_FSFPRINTF
127:                     #error Write functions must be enabled to use the FSfprintf function
128:                  #endif
129:               #endif
130:               
131:               #ifdef USEREALTIMECLOCK
132:                   #ifdef USERDEFINEDCLOCK
133:                       #error Please select only one timestamp clocking mode in FSconfig.h
134:                   #endif
135:                   #ifdef INCREMENTTIMESTAMP
136:                       #error Please select only one timestamp clocking mode in FSconfig.h
137:                   #endif
138:               #elif defined USERDEFINEDCLOCK
139:                   #ifdef INCREMENTTIMESTAMP
140:                       #error Please select only one timestamp clocking mode in FSconfig.h
141:                   #endif
142:               #endif
143:               /*****************************************************************************/
144:               /*                         Global Variables                                  */
145:               /*****************************************************************************/
146:               
147:               #ifndef FS_DYNAMIC_MEM
148:                   FSFILE  gFileArray[FS_MAX_FILES_OPEN];      // Array that contains file information (static allocation)
149:                   BYTE    gFileSlotOpen[FS_MAX_FILES_OPEN];   // Array that indicates which elements of gFileArray are available for use
150:               	#ifdef SUPPORT_LFN
151:               		// Array that stores long file name (static allocation)
152:               		unsigned short int lfnData[FS_MAX_FILES_OPEN][257];
153:               	#endif
154:               #endif
155:               
156:               #ifdef SUPPORT_LFN
157:               	#ifdef ALLOW_FILESEARCH
158:               		// Array that stores long file name for File Search operation (static allocation)
159:               		unsigned short int recordSearchName[257];
160:               		unsigned short int recordFoundName[257];
161:               		unsigned short int recordSearchLength;
162:               	#endif
163:               	unsigned short int fileFoundString[261];
164:               #endif
165:               
166:               #if defined(USEREALTIMECLOCK) || defined(USERDEFINEDCLOCK)
167:               // Timing variables
168:               BYTE    gTimeCrtMS;     // Global time variable (for timestamps) used to indicate create time (milliseconds)
169:               WORD    gTimeCrtTime;   // Global time variable (for timestamps) used to indicate create time
170:               WORD    gTimeCrtDate;   // Global time variable (for timestamps) used to indicate create date
171:               WORD    gTimeAccDate;   // Global time variable (for timestamps) used to indicate last access date
172:               WORD    gTimeWrtTime;   // Global time variable (for timestamps) used to indicate last update time
173:               WORD    gTimeWrtDate;   // Global time variable (for timestamps) used to indicate last update date
174:               #endif
175:               
176:               DWORD       gLastFATSectorRead = 0xFFFFFFFF;    // Global variable indicating which FAT sector was read last
177:               BYTE        gNeedFATWrite = FALSE;              // Global variable indicating that there is information that needs to be written to the FAT
178:               FSFILE  *   gBufferOwner = NULL;                // Global variable indicating which file is using the data buffer
179:               DWORD       gLastDataSectorRead = 0xFFFFFFFF;   // Global variable indicating which data sector was read last
180:               BYTE        gNeedDataWrite = FALSE;             // Global variable indicating that there is information that needs to be written to the data section
181:               BYTE        nextClusterIsLast = FALSE;          // Global variable indicating that the entries in a directory align with a cluster boundary
182:               
183:               BYTE    gBufferZeroed = FALSE;      // Global variable indicating that the data buffer contains all zeros
184:               
185:               DWORD   FatRootDirClusterValue;     // Global variable containing the cluster number of the root dir (0 for FAT12/16)
186:               
187:               BYTE    FSerrno;                    // Global error variable.  Set to one of many error codes after each function call.
188:               
189:               DWORD   TempClusterCalc;            // Global variable used to store the calculated value of the cluster of a specified sector.
190:               BYTE    dirCleared;                 // Global variable used by the "recursive" FSrmdir function to indicate that all subdirectories and files have been deleted from the target directory.
191:               BYTE    recache = FALSE;            // Global variable used by the "recursive" FSrmdir function to indicate that additional cache reads are needed.
192:               FSFILE  tempCWDobj;                 // Global variable used to preserve the current working directory information.
193:               FSFILE  gFileTemp;                  // Global variable used for file operations.
194:               
195:               FSFILE   cwd;               // Global current working directory
196:               FSFILE * cwdptr = &cwd;     // Pointer to the current working directory
197:               
198:               #ifdef __18CXX
199:                   #pragma udata dataBuffer = DATA_BUFFER_ADDRESS
200:                   BYTE gDataBuffer[MEDIA_SECTOR_SIZE];    // The global data sector buffer
201:                   #pragma udata FATBuffer = FAT_BUFFER_ADDRESS
202:                   BYTE gFATBuffer[MEDIA_SECTOR_SIZE];     // The global FAT sector buffer
203:                   #pragma udata
204:               #endif
205:               
206:               #if defined (__C30__) || defined (__PIC32MX__)
207:                   BYTE __attribute__ ((aligned(4)))   gDataBuffer[MEDIA_SECTOR_SIZE];     // The global data sector buffer
208:                   BYTE __attribute__ ((aligned(4)))   gFATBuffer[MEDIA_SECTOR_SIZE];      // The global FAT sector buffer
209:               #endif
210:               
211:               DISK gDiskData;         // Global structure containing device information.
212:               
213:               /* Global Variables to handle ASCII & UTF16 file operations */
214:               char *asciiFilename;
215:               unsigned short int fileNameLength;
216:               #ifdef SUPPORT_LFN
217:               	unsigned short int *utf16Filename;
218:               	BOOL	utfModeFileName = FALSE;
219:               	BOOL	twoByteMode = FALSE;
220:               #endif
221:               /************************************************************************/
222:               /*                        Structures and defines                        */
223:               /************************************************************************/
224:               
225:               // Directory entry structure
226:               typedef struct
227:               {
228:                   char      DIR_Name[DIR_NAMESIZE];           // File name
229:                   char      DIR_Extension[DIR_EXTENSION];     // File extension
230:                   BYTE      DIR_Attr;                         // File attributes
231:                   BYTE      DIR_NTRes;                        // Reserved byte
232:                   BYTE      DIR_CrtTimeTenth;                 // Create time (millisecond field)
233:                   WORD      DIR_CrtTime;                      // Create time (second, minute, hour field)
234:                   WORD      DIR_CrtDate;                      // Create date
235:                   WORD      DIR_LstAccDate;                   // Last access date
236:                   WORD      DIR_FstClusHI;                    // High word of the entry's first cluster number
237:                   WORD      DIR_WrtTime;                      // Last update time
238:                   WORD      DIR_WrtDate;                      // Last update date
239:                   WORD      DIR_FstClusLO;                    // Low word of the entry's first cluster number
240:                   DWORD     DIR_FileSize;                     // The 32-bit file size
241:               }_DIRENTRY;
242:               
243:               typedef _DIRENTRY * DIRENTRY;                   // A pointer to a directory entry structure
244:               
245:               #define DIRECTORY 0x12          // Value indicating that the CreateFileEntry function will be creating a directory
246:               
247:               #define DIRENTRIES_PER_SECTOR   (MEDIA_SECTOR_SIZE / 32)        // The number of directory entries in a sector
248:               
249:               // Maximum number of UTF16 words in single Root directory entry
250:               #define MAX_UTF16_CHARS_IN_LFN_ENTRY      (BYTE)13
251:               
252:               // Long File Name Entry
253:               typedef struct
254:               {
255:                  BYTE LFN_SequenceNo;   // Sequence number,
256:                  BYTE LFN_Part1[10];    // File name part 1
257:                  BYTE LFN_Attribute;    // File attribute
258:                  BYTE LFN_Type;		// LFN Type
259:                  BYTE LFN_Checksum;     // Checksum
260:                  unsigned short int LFN_Part2[6];    // File name part 2
261:                  unsigned short int LFN_Reserved2;	// Reserved for future use
262:                  unsigned short int LFN_Part3[2];     // File name part 3
263:               }LFN_ENTRY;
264:               
265:               /* Summary: Possible type of file or directory name.
266:               ** Description: See the FormatFileName() & FormatDirName() function for more information.
267:               */
268:               typedef enum
269:               {
270:                   NAME_8P3_ASCII_CAPS_TYPE,
271:                   NAME_8P3_ASCII_MIXED_TYPE,
272:                   NAME_8P3_UTF16_TYPE, // SUBTYPES OF 8P3 UTF16 TYPE
273:               	    NAME_8P3_UTF16_ASCII_CAPS_TYPE,
274:               	    NAME_8P3_UTF16_ASCII_MIXED_TYPE,
275:               	    NAME_8P3_UTF16_NONASCII_TYPE,
276:                   NAME_LFN_TYPE,
277:                   NAME_ERROR
278:               } FILE_DIR_NAME_TYPE;
279:               
280:               // internal errors
281:               #define CE_FAT_EOF            60   // Error that indicates an attempt to read FAT entries beyond the end of the file
282:               #define CE_EOF                61   // Error that indicates that the end of the file has been reached
283:               
284:               typedef FSFILE   * FILEOBJ;         // Pointer to an FSFILE object
285:               
286:               #ifdef ALLOW_FSFPRINTF
287:               
288:               #define _FLAG_MINUS 0x1             // FSfprintf minus flag indicator
289:               #define _FLAG_PLUS  0x2             // FSfprintf plus flag indicator
290:               #define _FLAG_SPACE 0x4             // FSfprintf space flag indicator
291:               #define _FLAG_OCTO  0x8             // FSfprintf octothorpe (hash mark) flag indicator
292:               #define _FLAG_ZERO  0x10            // FSfprintf zero flag indicator
293:               #define _FLAG_SIGNED 0x80           // FSfprintf signed flag indicator
294:               
295:               #ifdef __18CXX
296:                   #define _FMT_UNSPECIFIED 0      // FSfprintf unspecified argument size flag
297:                   #define _FMT_LONG 1             // FSfprintf 32-bit argument size flag
298:                   #define _FMT_SHRTLONG 2         // FSfprintf 24-bit argument size flag
299:                   #define _FMT_BYTE   3           // FSfprintf 8-bit argument size flag
300:               #else
301:                   #define _FMT_UNSPECIFIED 0      // FSfprintf unspecified argument size flag
302:                   #define _FMT_LONGLONG 1         // FSfprintf 64-bit argument size flag
303:                   #define _FMT_LONG 2             // FSfprintf 32-bit argument size flag
304:                   #define _FMT_BYTE 3             // FSfprintf 8-bit argument size flag
305:               #endif
306:               
307:               #ifdef __18CXX
308:                   static const rom char s_digits[] = "0123456789abcdef";      // FSfprintf table of conversion digits
309:               #else
310:                   static const char s_digits[] = "0123456789abcdef";          // FSfprintf table of conversion digits
311:               #endif
312:               
313:               #endif
314:               
315:               /************************************************************************************/
316:               /*                               Prototypes                                         */
317:               /************************************************************************************/
318:               
319:               DWORD ReadFAT (DISK *dsk, DWORD ccls);
320:               DIRENTRY Cache_File_Entry( FILEOBJ fo, WORD * curEntry, BYTE ForceRead);
321:               BYTE Fill_File_Object(FILEOBJ fo, WORD *fHandle);
322:               DWORD Cluster2Sector(DISK * disk, DWORD cluster);
323:               DIRENTRY LoadDirAttrib(FILEOBJ fo, WORD *fHandle);
324:               #ifdef INCREMENTTIMESTAMP
325:                   void IncrementTimeStamp(DIRENTRY dir);
326:               #elif defined USEREALTIMECLOCK
327:                   void CacheTime (void);
328:               #endif
329:               
330:               #if defined (__C30__) || defined (__PIC32MX__)
331:                   BYTE ReadByte( BYTE* pBuffer, WORD index );
332:                   WORD ReadWord( BYTE* pBuffer, WORD index );
333:                   DWORD ReadDWord( BYTE* pBuffer, WORD index );
334:               #endif
335:               
336:               void FileObjectCopy(FILEOBJ foDest,FILEOBJ foSource);
337:               FILE_DIR_NAME_TYPE ValidateChars(BYTE mode);
338:               BYTE FormatFileName( const char* fileName, FILEOBJ fptr, BYTE mode);
339:               CETYPE FILEfind( FILEOBJ foDest, FILEOBJ foCompareTo, BYTE cmd, BYTE mode);
340:               CETYPE FILEopen (FILEOBJ fo, WORD *fHandle, char type);
341:               #if defined(SUPPORT_LFN)
342:               BOOL Alias_LFN_Object(FILEOBJ fo);
343:               BYTE Fill_LFN_Object(FILEOBJ fo, LFN_ENTRY *lfno, WORD *fHandle);
344:               #endif
345:               
346:               // Write functions
347:               #ifdef ALLOW_WRITES
348:                   BYTE Write_File_Entry( FILEOBJ fo, WORD * curEntry);
349:                   BYTE flushData (void);
350:                   CETYPE FILEerase( FILEOBJ fo, WORD *fHandle, BYTE EraseClusters);
351:                   BYTE FILEallocate_new_cluster( FILEOBJ fo, BYTE mode);
352:                   BYTE FAT_erase_cluster_chain (DWORD cluster, DISK * dsk);
353:                   DWORD FATfindEmptyCluster(FILEOBJ fo);
354:                   BYTE FindEmptyEntries(FILEOBJ fo, WORD *fHandle);
355:                   BYTE PopulateEntries(FILEOBJ fo, WORD *fHandle, BYTE mode);
356:                   CETYPE FILECreateHeadCluster( FILEOBJ fo, DWORD *cluster);
357:                   BYTE EraseCluster(DISK *disk, DWORD cluster);
358:                   CETYPE CreateFirstCluster(FILEOBJ fo);
359:                   DWORD WriteFAT (DISK *dsk, DWORD ccls, DWORD value, BYTE forceWrite);
360:                   CETYPE CreateFileEntry(FILEOBJ fo, WORD *fHandle, BYTE mode, BOOL createFirstCluster);
361:               #endif
362:               
363:               // Directory functions
364:               #ifdef ALLOW_DIRS
365:                   BYTE GetPreviousEntry (FSFILE * fo);
366:                   BYTE FormatDirName (char * string,FILEOBJ fptr, BYTE mode);
367:                   int CreateDIR (char * path);
368:                   BYTE writeDotEntries (DISK * dsk, DWORD dotAddress, DWORD dotdotAddress);
369:                   int eraseDir (char * path);
370:               #ifdef ALLOW_PGMFUNCTIONS
371:                   #ifdef ALLOW_WRITES
372:                       int mkdirhelper (BYTE mode, char * ramptr, const rom char * romptr);
373:                       int rmdirhelper (BYTE mode, char * ramptr, const rom char * romptr, unsigned char rmsubdirs);
374:                   #endif
375:               int chdirhelper (BYTE mode, char * ramptr, const rom char * romptr);
376:               #else
377:                   #ifdef ALLOW_WRITES
378:                       int mkdirhelper (BYTE mode, char * ramptr, char * romptr);
379:                       int rmdirhelper (BYTE mode, char * ramptr, char * romptr, unsigned char rmsubdirs);
380:                   #endif
381:                   int chdirhelper (BYTE mode, char * ramptr, char * romptr);
382:               #endif
383:               #endif
384:               
385:               #ifdef ALLOW_FSFPRINTF
386:                   #ifdef __18CXX
387:                       int FSvfprintf (auto FSFILE *handle, auto const rom char *formatString, auto va_list ap);
388:                   #else
389:                       int FSvfprintf (FSFILE *handle, const char *formatString, va_list ap);
390:                   #endif
391:                   int FSputc (char c, FSFILE * file);
392:                   unsigned char str_put_n_chars (FSFILE * handle, unsigned char n, char c);
393:               #endif
394:               
395:               BYTE DISKmount( DISK *dsk);
396:               BYTE LoadMBR(DISK *dsk);
397:               BYTE LoadBootSector(DISK *dsk);
398:               DWORD GetFullClusterNumber(DIRENTRY entry);
399:               
400:               
401:               /*************************************************************************
402:                 Function:
403:                   int FSInit(void)
404:                 Summary:
405:                   Function to initialize the device.
406:                 Conditions:
407:                   The physical device should be connected to the microcontroller.
408:                 Input:
409:                   None
410:                 Return Values:
411:                   TRUE -  Initialization successful
412:                   FALSE - Initialization unsuccessful
413:                 Side Effects:
414:                   The FSerrno variable will be changed.
415:                 Description:
416:                   This function initializes the file system stack & the interfacing device.
417:                   Initializes the static or dynamic memory slots for holding file
418:                   structures. Initializes the device with the DISKmount function. Loads 
419:                   MBR and boot sector information. Initializes the current working
420:                   directory to the root directory for the device if directory support
421:                   is enabled.
422:                 Remarks:
423:                   None
424:                 *************************************************************************/
425:               
426:               int FSInit(void)
427:               {
008F16  2535E0     MOV #0x535E, W0
008F18  B3C012     MOV #0x1, W2
008F1A  253601     MOV #0x5360, W1
428:                   int fIndex;
429:               #ifndef FS_DYNAMIC_MEM
430:                   for( fIndex = 0; fIndex < FS_MAX_FILES_OPEN; fIndex++ )
008F1E  500F81     SUB W0, W1, [W15]
008F20  3AFFFD     BRA NZ, 0x8F1C
431:                       gFileSlotOpen[fIndex] = TRUE;
008F1C  785802     MOV.B W2, [W0++]
432:               #else
433:                   #ifdef __18CXX
434:                       SRAMInitHeap();
435:                   #endif
436:               #endif
437:               
438:                   gBufferZeroed = FALSE;
008F22  270B90     MOV #0x70B9, W0
008F24  EB4800     CLR.B [W0]
439:                   gNeedFATWrite = FALSE;             
008F26  270C20     MOV #0x70C2, W0
008F28  EB4800     CLR.B [W0]
440:                   gLastFATSectorRead = 0xFFFFFFFF;       
008F2A  EB8000     SETM W0
008F2C  EB8080     SETM W1
008F2E  8B8620     MOV W0, gLastFATSectorRead
008F30  8B8631     MOV W1, 0x70C6
441:                   gLastDataSectorRead = 0xFFFFFFFF;  
008F32  8B85E0     MOV W0, gLastDataSectorRead
008F34  8B85F1     MOV W1, 0x70BE
442:               
443:                   MDD_InitIO();
008F36  0721A1     RCALL MDD_SDSPI_InitIO
444:               
445:                   if(DISKmount(&gDiskData) == CE_GOOD)
008F38  2485A0     MOV #0x485A, W0
008F3A  07FFBB     RCALL DISKmount
008F3C  EB0080     CLR W1
008F3E  E00400     CP0.B W0
008F40  3A0028     BRA NZ, 0x8F92
446:                   {
447:                   // Initialize the current working directory to the root
448:               #ifdef ALLOW_DIRS
449:                       cwdptr->dsk = &gDiskData;
008F42  8385B2     MOV cwdptr, W2
008F44  2485A0     MOV #0x485A, W0
008F46  780900     MOV W0, [W2]
450:                       cwdptr->sec = 0;
008F48  EB0000     CLR W0
008F4A  980150     MOV W0, [W2+10]
451:                       cwdptr->pos = 0;
008F4C  980160     MOV W0, [W2+12]
452:                       cwdptr->seek = 0;
008F4E  B80060     MUL.UU W0, #0, W0
008F50  980170     MOV W0, [W2+14]
008F52  980901     MOV W1, [W2+16]
453:                       cwdptr->size = 0;
008F54  980910     MOV W0, [W2+18]
008F56  980921     MOV W1, [W2+20]
454:                       cwdptr->name[0] = '\\';
008F58  B3C5C0     MOV #0x5C, W0
008F5A  985940     MOV.B W0, [W2+28]
008F5C  200012     MOV #0x1, W2
008F5E  B3C203     MOV #0x20, W3
455:                       for (fIndex = 1; fIndex < 11; fIndex++)
008F66  E80102     INC W2, W2
008F68  510FEB     SUB W2, #0xB, [W15]
008F6A  3AFFFA     BRA NZ, 0x8F60
456:                       {
457:                           cwdptr->name[fIndex] = 0x20;
008F60  4100FC     ADD W2, #0x1C, W1
008F62  8385B0     MOV cwdptr, W0
008F64  78F003     MOV.B W3, [W0+W1]
458:                       }
459:                       cwdptr->entry = 0;
008F6C  8385B1     MOV cwdptr, W1
008F6E  EB0100     CLR W2
008F70  9810F2     MOV W2, [W1+46]
460:                       cwdptr->attributes = ATTR_DIRECTORY;
008F72  200100     MOV #0x10, W0
008F74  981890     MOV W0, [W1+50]
461:                       // "FatRootDirClusterValue" indicates the root
462:                       cwdptr->dirclus = FatRootDirClusterValue;
008F76  8249D4     MOV FatRootDirClusterValue, W4
008F78  8249E5     MOV 0x493C, W5
008F7A  9818A4     MOV W4, [W1+52]
008F7C  9818B5     MOV W5, [W1+54]
463:                       cwdptr->dirccls = FatRootDirClusterValue;
008F7E  8249D4     MOV FatRootDirClusterValue, W4
008F80  8249E5     MOV 0x493C, W5
008F82  9818C4     MOV W4, [W1+56]
008F84  9818D5     MOV W5, [W1+58]
464:               	#if defined(SUPPORT_LFN)
465:               		// Initialize default values for LFN support
466:                       cwdptr->AsciiEncodingType = TRUE;
008F86  200013     MOV #0x1, W3
008F88  9810C3     MOV W3, [W1+40]
467:                       cwdptr->utf16LFNlength = 0x0000;
008F8A  9810E2     MOV W2, [W1+44]
468:               	#endif
469:               #endif
470:               
471:                       FSerrno = 0;
008F8C  249380     MOV #0x4938, W0
008F8E  784802     MOV.B W2, [W0]
008F90  780083     MOV W3, W1
472:                       return TRUE;
473:                   }
474:               
475:                   return FALSE;
476:               }
008F96  B003AF     ADD #0x3A, W15
008F98  BE9F88     MOV.D W8, [W15++]
008F9A  BE9F8A     MOV.D W10, [W15++]
008F9C  BE9F8C     MOV.D W12, [W15++]
008F9E  781F8E     MOV W14, [W15++]
008FA0  784400     MOV.B W0, W8
008FA2  BE0602     MOV.D W2, W12
008FA4  9FAFF1     MOV W1, [W15-34]
477:               
478:               
479:               /********************************************************************************
480:                 Function:
481:                   CETYPE FILEfind (FILEOBJ foDest, FILEOBJ foCompareTo, BYTE cmd, BYTE mode)
482:                 Summary
483:                   Finds a file on the device
484:                 Conditions:
485:                   This function should not be called by the user.
486:                 Input:
487:                   foDest -       FSFILE object containing information of the file found
488:                   foCompareTo -  FSFILE object containing the name/attr of the file to be
489:                                  found
490:                   cmd -
491:                       -          LOOK_FOR_EMPTY_ENTRY: Search for empty entry.
492:                       -          LOOK_FOR_MATCHING_ENTRY: Search for matching entry.
493:                   mode -
494:                        -         0: Match file exactly with default attributes.
495:                        -         1: Match file to user-specified attributes.
496:                 Return Values:
497:                   CE_GOOD -            File found.
498:                   CE_FILE_NOT_FOUND -  File not found.
499:                 Side Effects:
500:                   None.
501:                 Description:
502:                   The FILEfind function will sequentially cache directory entries within
503:                   the current working directory into the foDest FSFILE object.  If the cmd
504:                   parameter is specified as LOOK_FOR_EMPTY_ENTRY the search will continue
505:                   until an empty directory entry is found. If the cmd parameter is specified
506:                   as LOOK_FOR_MATCHING_ENTRY these entries will be compared to the foCompareTo
507:                   object until a match is found or there are no more entries in the current
508:                   working directory. If the mode is specified a '0' the attributes of the FSFILE
509:                   entries are irrelevant. If the mode is specified as '1' the attributes of the
510:                   foDest entry must match the attributes specified in the foCompareTo file and
511:                   partial string search characters may bypass portions of the comparison.
512:                 Remarks:
513:                   None
514:                 ********************************************************************************/
515:               
516:               CETYPE FILEfind( FILEOBJ foDest, FILEOBJ foCompareTo, BYTE cmd, BYTE mode)
517:               {
009A96  5301ED     SUB W6, #0xD, W3
009A98  418003     ADD W3, W3, W0
009A9A  400002     ADD W0, W2, W0
009A9C  780083     MOV W3, W1
009A9E  9FAFF6     MOV W6, [W15-34]
009AA0  B3C0D2     MOV #0xD, W2
518:                   WORD   attrib, compareAttrib;
519:                   WORD   fHandle = foDest->entry;                  // current entry counter
00992E  901070     MOV [W0+46], W0
009930  9F9780     MOV W0, [W15-96]
520:                   CETYPE   statusB = CE_FILE_NOT_FOUND;
521:                   BYTE   character,test,state,index;
522:               
523:               	#if defined(SUPPORT_LFN)
524:               
525:                	LFN_ENTRY lfnObject;	// Long File Name Object
526:               	unsigned char *dst = (unsigned char *)&fileFoundString[0];
527:               	unsigned short int *templfnPtr = (unsigned short int *)foCompareTo -> utf16LFNptr;
009932  9010D1     MOV [W1+42], W1
009934  9FB7A1     MOV W1, [W15-28]
528:               	UINT16_VAL tempShift;
529:               	short int   fileCompareLfnIndex,fileFoundLfnIndex = 0,fileFoundMaxLfnIndex = 0,lfnCountIndex,fileFoundLength = 0;
530:               	BOOL  lfnFirstCheck = FALSE,foundSFN,foundLFN,fileFoundDotPosition = FALSE,fileCompareDotPosition;
531:               	BYTE  lfnCompareMaxSequenceNum = 0,lfnFoundMaxSequenceNum,reminder = 0;
532:               	char  tempDst[13];
533:               	fileNameLength = foCompareTo->utf16LFNlength;
009936  97B16F     MOV [W15-20], W2
009938  9010E2     MOV [W2+44], W1
00993A  8A42B1     MOV W1, fileNameLength
534:               
535:               	// If 'fileNameLength' is non zero then it means that file name is of LFN format.
536:               	// If 'fileNameLength' is zero then it means that file name is of 8.3 format
537:               	if(fileNameLength)
00993C  E00001     CP0 W1
00993E  3A0002     BRA NZ, 0x9944
009940  9FD7C1     MOV.B W1, [W15-44]
009942  370010     BRA 0x9964
538:               	{
539:               		// Find out the number of root entries for the given LFN
540:               		reminder = fileNameLength % MAX_UTF16_CHARS_IN_LFN_ENTRY;
541:               
542:               		index = fileNameLength/MAX_UTF16_CHARS_IN_LFN_ENTRY;
009944  2000D2     MOV #0xD, W2
009946  781F81     MOV W1, [W15++]
009948  090011     REPEAT #0x11
00994A  D88082     DIV.UW W1, W2
00994C  780100     MOV W0, W2
00994E  780001     MOV W1, W0
009950  7800CF     MOV [--W15], W1
009952  784182     MOV.B W2, W3
543:               
544:               		if(reminder || (fileNameLength < MAX_UTF16_CHARS_IN_LFN_ENTRY))
009954  E00400     CP0.B W0
009956  3A0004     BRA NZ, 0x9960
009958  508FEC     SUB W1, #0xC, [W15]
00995A  360002     BRA LEU, 0x9960
00995C  9FD7C2     MOV.B W2, [W15-44]
00995E  370002     BRA 0x9964
545:               		{
546:               			index++;
009960  E84183     INC.B W3, W3
009962  9FD7C3     MOV.B W3, [W15-44]
547:               		}
548:               
549:               		// The maximum sequence number of the LFN
550:               		lfnCompareMaxSequenceNum = index;
551:               	}
552:               	#endif
553:               
554:                   // reset the cluster
555:                   foDest->dirccls = foDest->dirclus;
009964  97B05F     MOV [W15-22], W0
009966  9018B0     MOV [W0+54], W1
009968  901820     MOV [W0+52], W0
00996A  97B15F     MOV [W15-22], W2
00996C  981940     MOV W0, [W2+56]
00996E  981951     MOV W1, [W2+58]
556:               	// Attribute to be compared as per application layer request
557:                   compareAttrib = 0xFFFF ^ foCompareTo->attributes;
009970  97B0EF     MOV [W15-20], W1
009972  901811     MOV [W1+50], W0
009974  EA8000     COM W0, W0
009976  9FB7B0     MOV W0, [W15-26]
558:               
559:                   if (fHandle == 0)
009978  97900F     MOV [W15-96], W0
00997A  E00000     CP0 W0
00997C  320002     BRA Z, 0x9982
560:                   {
561:                       if (Cache_File_Entry(foDest, &fHandle, TRUE) == NULL)
562:                       {
563:                           statusB = CE_BADCACHEREAD;
564:                       }
565:                   }
566:                   else
567:                   {
568:               		// Maximum 16 entries possible
569:                       if ((fHandle & MASK_MAX_FILE_ENTRY_LIMIT_BITS) != 0)
00997E  60006F     AND W0, #0xF, W0
009980  32037E     BRA Z, 0xA07E
570:                       {
571:                           if (Cache_File_Entry (foDest, &fHandle, TRUE) == NULL)
009982  B3C012     MOV #0x1, W2
009984  2FFA01     MOV #0xFFA0, W1
009986  40808F     ADD W1, W15, W1
009988  97B05F     MOV [W15-22], W0
00998A  07EE0F     RCALL Cache_File_Entry
00998C  E00000     CP0 W0
00998E  3A0377     BRA NZ, 0xA07E
009990  370374     BRA 0xA07A
009992  EB0480     CLR W9
572:                           {
573:                               statusB = CE_BADCACHEREAD;
574:                           }
575:                       }
576:                   }
577:               
578:                   if (statusB != CE_BADCACHEREAD)
579:                   {
580:                       // Loop until you reach the end or find the file
581:                       while(1)
582:                       {
583:                           if(statusB != CE_GOOD) //First time entry always here
00A074  E00005     CP0 W5
00A076  3AFC8D     BRA NZ, 0x9992
00A078  37000A     BRA 0xA08E
584:                           {
585:               				#if defined(SUPPORT_LFN)
586:               					foundSFN = FALSE;
587:               					foundLFN = FALSE;
588:               
589:                               	state = Fill_LFN_Object(foDest,&lfnObject,&fHandle);
009994  2FFB02     MOV #0xFFB0, W2
009996  478402     ADD W15, W2, W8
009998  510170     SUB W2, #0x10, W2
00999A  41010F     ADD W2, W15, W2
00999C  780088     MOV W8, W1
00999E  97B05F     MOV [W15-22], W0
0099A0  9FBF85     MOV W5, [W15-16]
0099A2  07EED8     RCALL Fill_LFN_Object
590:               				#else
591:                               	state = Fill_File_Object(foDest, &fHandle);
592:               				#endif
593:               
594:                               if(state == NO_MORE) // Reached the end of available files. Comparision over and file not found so quit.
0099A4  97BA8F     MOV [W15-16], W5
0099A6  504FE2     SUB.B W0, #0x2, [W15]
0099A8  320372     BRA Z, 0xA08E
595:                               {
596:                                   break;
597:                               }
598:                           }
599:                           else // statusB == CE_GOOD then exit
600:                           {
601:                               break; // Code below intializes"statusB = CE_GOOD;" so, if no problem in the filled file, Exit the while loop.
00A07A  2001B5     MOV #0x1B, W5
00A07C  370008     BRA 0xA08E
00A07E  2000B5     MOV #0xB, W5
00A080  EB0180     CLR W3
00A082  9FB793     MOV W3, [W15-30]
00A084  9FB783     MOV W3, [W15-32]
00A086  9FAFF3     MOV W3, [W15-34]
00A088  780483     MOV W3, W9
00A08A  9FAFC3     MOV W3, [W15-40]
00A08C  37FC83     BRA 0x9994
602:                           }
603:               
604:                           if(state == FOUND) // Validate the correct matching of filled file data with the required(to be found) one.
0099AA  E00400     CP0.B W0
0099AC  3A0352     BRA NZ, 0xA052
605:                           {
606:               				#if defined(SUPPORT_LFN)
607:               
608:               				if(lfnObject.LFN_Attribute != ATTR_LONG_NAME)
0099AE  97783F     MOV.B [W15-69], W0
0099B0  504FEF     SUB.B W0, #0xF, [W15]
0099B2  32000B     BRA Z, 0x99CA
609:               				{
610:               					lfnFirstCheck = FALSE;
611:               
612:               					*dst = lfnObject.LFN_SequenceNo;
0099B4  2494A3     MOV #0x494A, W3
0099B6  784998     MOV.B [W8], [W3]
0099B8  2494B2     MOV #0x494B, W2
0099BA  2FFA04     MOV #0xFFA0, W4
0099BC  42020F     ADD W4, W15, W4
0099BE  420071     ADD W4, #0x11, W0
0099C0  4200FB     ADD W4, #0x1B, W1
613:               					for(index = 0;index < 10;index++)
0099C4  500F81     SUB W0, W1, [W15]
0099C6  3200EA     BRA Z, 0x9B9C
0099C8  37FFFC     BRA 0x99C2
614:               						dst[index + 1] = lfnObject.LFN_Part1[index];
0099C2  785930     MOV.B [W0++], [W2++]
615:               					foundSFN = TRUE;
616:               				}
617:               				else
618:               				{
619:               					if(lfnObject.LFN_SequenceNo & 0x40)
0099CA  784098     MOV.B [W8], W1
0099CC  A36801     BTST.Z W1, #6
0099CE  320082     BRA Z, 0x9AD4
620:               					{
621:               						lfnFoundMaxSequenceNum = lfnObject.LFN_SequenceNo & 0x1F;
0099D0  60C17F     AND.B W1, #0x1F, W2
622:               						
623:               						if((mode == 0x00) && ((fileNameLength && (lfnFoundMaxSequenceNum != lfnCompareMaxSequenceNum)) || 
0099D2  97E87F     MOV.B [W15-17], W0
0099D4  E00400     CP0.B W0
0099D6  3A000D     BRA NZ, 0x99F2
0099D8  8242B0     MOV fileNameLength, W0
0099DA  E00000     CP0 W0
0099DC  320004     BRA Z, 0x99E6
0099DE  97D1CF     MOV.B [W15-44], W3
0099E0  514F83     SUB.B W2, W3, [W15]
0099E2  3A0003     BRA NZ, 0x99EA
0099E4  370006     BRA 0x99F2
0099E6  514FE1     SUB.B W2, #0x1, [W15]
0099E8  320004     BRA Z, 0x99F2
624:               						   (!fileNameLength && (lfnFoundMaxSequenceNum != 0x01))))
625:               						{
626:               //							fHandle = fHandle + lfnFoundMaxSequenceNum + 1;
627:               							fHandle++;
0099EA  97920F     MOV [W15-96], W4
0099EC  E80204     INC W4, W4
0099EE  9F9784     MOV W4, [W15-96]
0099F0  37FFD1     BRA 0x9994
628:               							continue;
629:               						}
630:               
631:               						fileFoundLfnIndex = (lfnObject.LFN_SequenceNo & 0xBF) * MAX_UTF16_CHARS_IN_LFN_ENTRY - 1;
0099F2  780301     MOV W1, W6
0099F4  B20BF6     AND #0xBF, W6
0099F6  B9336D     MUL.SU W6, #13, W6
632:               						fileCompareLfnIndex = fileFoundLfnIndex;
633:               
634:               						fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part3[1];
0099F8  430086     ADD W6, W6, W1
0099FA  E98001     DEC2 W1, W0
0099FC  2494A2     MOV #0x494A, W2
0099FE  97A27F     MOV [W15-50], W4
009A00  783104     MOV W4, [W2+W0]
635:               						fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part3[0];
009A02  508064     SUB W1, #0x4, W0
009A04  97A26F     MOV [W15-52], W4
009A06  783104     MOV W4, [W2+W0]
636:               
637:               						fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[5];
009A08  508066     SUB W1, #0x6, W0
009A0A  97A24F     MOV [W15-56], W4
009A0C  783104     MOV W4, [W2+W0]
638:               						fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[4];
009A0E  508068     SUB W1, #0x8, W0
009A10  97A23F     MOV [W15-58], W4
009A12  783104     MOV W4, [W2+W0]
639:               						fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[3];
009A14  50806A     SUB W1, #0xA, W0
009A16  97A22F     MOV [W15-60], W4
009A18  783104     MOV W4, [W2+W0]
640:               						fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[2];
009A1A  50806C     SUB W1, #0xC, W0
009A1C  97A21F     MOV [W15-62], W4
009A1E  783104     MOV W4, [W2+W0]
641:               						fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[1];
009A20  50806E     SUB W1, #0xE, W0
009A22  97A20F     MOV [W15-64], W4
009A24  783104     MOV W4, [W2+W0]
642:               						fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[0];
009A26  508070     SUB W1, #0x10, W0
009A28  979A7F     MOV [W15-66], W4
009A2A  783104     MOV W4, [W2+W0]
643:               
644:               						tempShift.byte.LB = lfnObject.LFN_Part1[8];
009A2C  97781F     MOV.B [W15-71], W0
009A2E  FB8000     ZE W0, W0
009A30  2FF004     MOV #0xFF00, W4
009A32  650504     AND W10, W4, W10
009A34  750500     IOR W10, W0, W10
645:               						tempShift.byte.HB = lfnObject.LFN_Part1[9];
009A36  97782F     MOV.B [W15-70], W0
009A38  DD0048     SL W0, #8, W0
009A3A  B20FFA     AND #0xFF, W10
009A3C  750500     IOR W10, W0, W10
646:               						fileFoundString[fileFoundLfnIndex--] = tempShift.Val;
009A3E  508072     SUB W1, #0x12, W0
009A40  78310A     MOV W10, [W2+W0]
647:               						tempShift.byte.LB = lfnObject.LFN_Part1[6];
009A42  97707F     MOV.B [W15-73], W0
009A44  FB8000     ZE W0, W0
009A46  650504     AND W10, W4, W10
009A48  750500     IOR W10, W0, W10
648:               						tempShift.byte.HB = lfnObject.LFN_Part1[7];
009A4A  97780F     MOV.B [W15-72], W0
009A4C  DD0048     SL W0, #8, W0
009A4E  B20FFA     AND #0xFF, W10
009A50  750500     IOR W10, W0, W10
649:               						fileFoundString[fileFoundLfnIndex--] = tempShift.Val;
009A52  508074     SUB W1, #0x14, W0
009A54  78310A     MOV W10, [W2+W0]
650:               						tempShift.byte.LB = lfnObject.LFN_Part1[4];
009A56  97705F     MOV.B [W15-75], W0
009A58  FB8000     ZE W0, W0
009A5A  650504     AND W10, W4, W10
009A5C  750500     IOR W10, W0, W10
651:               						tempShift.byte.HB = lfnObject.LFN_Part1[5];
009A5E  97706F     MOV.B [W15-74], W0
009A60  DD0048     SL W0, #8, W0
009A62  B20FFA     AND #0xFF, W10
009A64  750500     IOR W10, W0, W10
652:               						fileFoundString[fileFoundLfnIndex--] = tempShift.Val;
009A66  508076     SUB W1, #0x16, W0
009A68  78310A     MOV W10, [W2+W0]
653:               						tempShift.byte.LB = lfnObject.LFN_Part1[2];
009A6A  97703F     MOV.B [W15-77], W0
009A6C  FB8000     ZE W0, W0
009A6E  650504     AND W10, W4, W10
009A70  750500     IOR W10, W0, W10
654:               						tempShift.byte.HB = lfnObject.LFN_Part1[3];
009A72  97704F     MOV.B [W15-76], W0
009A74  DD0048     SL W0, #8, W0
009A76  B20FFA     AND #0xFF, W10
009A78  750500     IOR W10, W0, W10
655:               						fileFoundString[fileFoundLfnIndex--] = tempShift.Val;
009A7A  508078     SUB W1, #0x18, W0
009A7C  78310A     MOV W10, [W2+W0]
656:               						tempShift.byte.LB = lfnObject.LFN_Part1[0];
009A7E  97701F     MOV.B [W15-79], W0
009A80  FB8000     ZE W0, W0
009A82  650504     AND W10, W4, W10
009A84  750500     IOR W10, W0, W10
657:               						tempShift.byte.HB = lfnObject.LFN_Part1[1];
009A86  97702F     MOV.B [W15-78], W0
009A88  DD0048     SL W0, #8, W0
009A8A  B20FFA     AND #0xFF, W10
009A8C  750500     IOR W10, W0, W10
658:               						fileFoundString[fileFoundLfnIndex--] = tempShift.Val;
009A8E  5080FA     SUB W1, #0x1A, W1
009A90  78B10A     MOV W10, [W2+W1]
009A92  53006E     SUB W6, #0xE, W0
009A94  9FB790     MOV W0, [W15-30]
659:               
660:               						
661:               						fileFoundLength = fileCompareLfnIndex + 1;
662:               						for(index = 1;index <= MAX_UTF16_CHARS_IN_LFN_ENTRY;index++)
009AAE  E00402     CP0.B W2
009AB0  3AFFF8     BRA NZ, 0x9AA2
663:               						{
664:               							if(fileFoundString[fileFoundLfnIndex + index] == 0x0000)
009AA2  E00010     CP0 [W0]
009AA4  3A0001     BRA NZ, 0x9AA8
009AA6  9FAFF1     MOV W1, [W15-34]
009AA8  E94102     DEC.B W2, W2
009AAA  E88000     INC2 W0, W0
009AAC  E80081     INC W1, W1
665:               								fileFoundLength = fileFoundLfnIndex + index;
666:               						}
667:               
668:               						if(mode == 0x00)
009AB2  97EA7F     MOV.B [W15-17], W4
009AB4  E00404     CP0.B W4
009AB6  3A000A     BRA NZ, 0x9ACC
669:               						{
670:               							if((fileNameLength != fileFoundLength) && fileNameLength)
009AB8  8242B0     MOV fileNameLength, W0
009ABA  97A8FF     MOV [W15-34], W1
009ABC  500F81     SUB W0, W1, [W15]
009ABE  320006     BRA Z, 0x9ACC
009AC0  E00000     CP0 W0
009AC2  320004     BRA Z, 0x9ACC
671:               							{
672:               //								fHandle = fHandle + lfnFoundMaxSequenceNum + 1;
673:               								fHandle++;
009AC4  97910F     MOV [W15-96], W2
009AC6  E80102     INC W2, W2
009AC8  9F9782     MOV W2, [W15-96]
009ACA  37FF64     BRA 0x9994
674:               								continue;
675:               							}
676:               						}
677:               
678:               						fileFoundMaxLfnIndex = fileFoundLength - 1;
009ACC  97A9FF     MOV [W15-34], W3
009ACE  E90183     DEC W3, W3
009AD0  9FB783     MOV W3, [W15-32]
009AD2  370057     BRA 0x9B82
679:               						lfnFirstCheck = TRUE;
680:               					}
681:               					else if(lfnFirstCheck == TRUE)
009AD4  548FE1     SUB W9, #0x1, [W15]
009AD6  3A0051     BRA NZ, 0x9B7A
682:               					{
683:               						fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part3[1];
009AD8  97B21F     MOV [W15-30], W4
009ADA  420084     ADD W4, W4, W1
009ADC  2494A2     MOV #0x494A, W2
009ADE  97A07F     MOV [W15-50], W0
009AE0  78B100     MOV W0, [W2+W1]
684:               						fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part3[0];
009AE2  E98001     DEC2 W1, W0
009AE4  97A1EF     MOV [W15-52], W3
009AE6  783103     MOV W3, [W2+W0]
685:               
686:               						fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[5];
009AE8  508064     SUB W1, #0x4, W0
009AEA  97A24F     MOV [W15-56], W4
009AEC  783104     MOV W4, [W2+W0]
687:               						fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[4];
009AEE  508066     SUB W1, #0x6, W0
009AF0  97A1BF     MOV [W15-58], W3
009AF2  783103     MOV W3, [W2+W0]
688:               						fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[3];
009AF4  508068     SUB W1, #0x8, W0
009AF6  97A22F     MOV [W15-60], W4
009AF8  783104     MOV W4, [W2+W0]
689:               						fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[2];
009AFA  50806A     SUB W1, #0xA, W0
009AFC  97A19F     MOV [W15-62], W3
009AFE  783103     MOV W3, [W2+W0]
690:               						fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[1];
009B00  50806C     SUB W1, #0xC, W0
009B02  97A20F     MOV [W15-64], W4
009B04  783104     MOV W4, [W2+W0]
691:               						fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[0];
009B06  50806E     SUB W1, #0xE, W0
009B08  9799FF     MOV [W15-66], W3
009B0A  783103     MOV W3, [W2+W0]
692:               
693:               						tempShift.byte.LB = lfnObject.LFN_Part1[8];
009B0C  97781F     MOV.B [W15-71], W0
009B0E  FB8000     ZE W0, W0
009B10  2FF003     MOV #0xFF00, W3
009B12  650503     AND W10, W3, W10
009B14  750500     IOR W10, W0, W10
694:               						tempShift.byte.HB = lfnObject.LFN_Part1[9];
009B16  97782F     MOV.B [W15-70], W0
009B18  DD0048     SL W0, #8, W0
009B1A  B20FFA     AND #0xFF, W10
009B1C  750500     IOR W10, W0, W10
695:               						fileFoundString[fileFoundLfnIndex--] = tempShift.Val;
009B1E  508070     SUB W1, #0x10, W0
009B20  78310A     MOV W10, [W2+W0]
696:               						tempShift.byte.LB = lfnObject.LFN_Part1[6];
009B22  97707F     MOV.B [W15-73], W0
009B24  FB8000     ZE W0, W0
009B26  650503     AND W10, W3, W10
009B28  750500     IOR W10, W0, W10
697:               						tempShift.byte.HB = lfnObject.LFN_Part1[7];
009B2A  97780F     MOV.B [W15-72], W0
009B2C  DD0048     SL W0, #8, W0
009B2E  B20FFA     AND #0xFF, W10
009B30  750500     IOR W10, W0, W10
698:               						fileFoundString[fileFoundLfnIndex--] = tempShift.Val;
009B32  508072     SUB W1, #0x12, W0
009B34  78310A     MOV W10, [W2+W0]
699:               						tempShift.byte.LB = lfnObject.LFN_Part1[4];
009B36  97705F     MOV.B [W15-75], W0
009B38  FB8000     ZE W0, W0
009B3A  650503     AND W10, W3, W10
009B3C  750500     IOR W10, W0, W10
700:               						tempShift.byte.HB = lfnObject.LFN_Part1[5];
009B3E  97706F     MOV.B [W15-74], W0
009B40  DD0048     SL W0, #8, W0
009B42  B20FFA     AND #0xFF, W10
009B44  750500     IOR W10, W0, W10
701:               						fileFoundString[fileFoundLfnIndex--] = tempShift.Val;
009B46  508074     SUB W1, #0x14, W0
009B48  78310A     MOV W10, [W2+W0]
702:               						tempShift.byte.LB = lfnObject.LFN_Part1[2];
009B4A  97703F     MOV.B [W15-77], W0
009B4C  FB8000     ZE W0, W0
009B4E  650503     AND W10, W3, W10
009B50  750500     IOR W10, W0, W10
703:               						tempShift.byte.HB = lfnObject.LFN_Part1[3];
009B52  97704F     MOV.B [W15-76], W0
009B54  DD0048     SL W0, #8, W0
009B56  B20FFA     AND #0xFF, W10
009B58  750500     IOR W10, W0, W10
704:               						fileFoundString[fileFoundLfnIndex--] = tempShift.Val;
009B5A  508076     SUB W1, #0x16, W0
009B5C  78310A     MOV W10, [W2+W0]
705:               						tempShift.byte.LB = lfnObject.LFN_Part1[0];
009B5E  97701F     MOV.B [W15-79], W0
009B60  FB8000     ZE W0, W0
009B62  650503     AND W10, W3, W10
009B64  750500     IOR W10, W0, W10
706:               						tempShift.byte.HB = lfnObject.LFN_Part1[1];
009B66  97702F     MOV.B [W15-78], W0
009B68  DD0048     SL W0, #8, W0
009B6A  B20FFA     AND #0xFF, W10
009B6C  750500     IOR W10, W0, W10
707:               						fileFoundString[fileFoundLfnIndex--] = tempShift.Val;
009B6E  5080F8     SUB W1, #0x18, W1
009B70  78B10A     MOV W10, [W2+W1]
009B72  97B21F     MOV [W15-30], W4
009B74  52026D     SUB W4, #0xD, W4
009B76  9FB794     MOV W4, [W15-30]
009B78  370004     BRA 0x9B82
708:               					}
709:               					else
710:                        			{
711:                        				fHandle++;
009B7A  97900F     MOV [W15-96], W0
009B7C  E80000     INC W0, W0
009B7E  9F9780     MOV W0, [W15-96]
009B80  37FF09     BRA 0x9994
712:               						continue;
713:               					}
714:               
715:                        			if(fileFoundLfnIndex > 0)
009B82  97B09F     MOV [W15-30], W1
009B84  E00001     CP0 W1
009B86  3C0005     BRA GT, 0x9B92
009B88  EB0100     CLR W2
009B8A  9FAFE2     MOV W2, [W15-36]
009B8C  200013     MOV #0x1, W3
009B8E  9FAFD3     MOV W3, [W15-38]
009B90  370009     BRA 0x9BA4
716:                        			{
717:                        				fHandle++;
009B92  97920F     MOV [W15-96], W4
009B94  E80204     INC W4, W4
009B96  9F9784     MOV W4, [W15-96]
009B98  200019     MOV #0x1, W9
009B9A  37FEFC     BRA 0x9994
718:               						continue;
009B9C  200010     MOV #0x1, W0
009B9E  9FAFE0     MOV W0, [W15-36]
009BA0  EB0080     CLR W1
009BA2  9FAFD1     MOV W1, [W15-38]
719:               					}
720:               
721:               					foundLFN = TRUE;
722:               				}
723:               
724:               				lfnFirstCheck = FALSE;
725:               				statusB = CE_GOOD;
726:                         	    switch (mode)
009BA4  97E97F     MOV.B [W15-17], W2
009BA6  E00402     CP0.B W2
009BA8  320003     BRA Z, 0x9BB0
009BAA  514FE1     SUB.B W2, #0x1, [W15]
009BAC  3A0226     BRA NZ, 0x9FFA
009BAE  3700BC     BRA 0x9D28
009BB0  EB0000     CLR W0
009BB2  2FFA23     MOV #0xFFA2, W3
009BB4  478083     ADD W15, W3, W1
727:                         	    {
728:                         	        case 0:
729:               
730:               							// Copy the contents of any SFN found to temporary string
731:               							// for future comparision tests
732:               							for(index = 0;index < FILE_NAME_SIZE_8P3;index++)
009BBC  500FEB     SUB W0, #0xB, [W15]
009BBE  3AFFFB     BRA NZ, 0x9BB6
733:               								tempDst[index] = dst[index];
009BB6  2494A4     MOV #0x494A, W4
009BB8  7870E4     MOV.B [W4+W0], [W1+W0]
009BBA  E80000     INC W0, W0
734:               
735:               							// Try to deduce the original name from the found SFN
736:               							if(dst[8] != ' ')
009BC0  2494A0     MOV #0x494A, W0
009BC2  904980     MOV.B [W0+8], W3
009BC4  B3C200     MOV #0x20, W0
009BC6  51CF80     SUB.B W3, W0, [W15]
009BC8  32002C     BRA Z, 0x9C22
009BCA  EB0080     CLR W1
009BCC  784280     MOV.B W0, W5
009BCE  784101     MOV.B W1, W2
737:               							{
738:               								for(index = 0;index < 8;index++)
009BDC  508FE8     SUB W1, #0x8, [W15]
009BDE  3AFFF7     BRA NZ, 0x9BCE
739:               								{
740:               									if(dst[index] == ' ')
009BD0  2494A4     MOV #0x494A, W4
009BD2  7A4061     MOV.B [W1+W4], W0
009BD4  504F85     SUB.B W0, W5, [W15]
009BD6  320004     BRA Z, 0x9BE0
741:               										break;
009BD8  E84101     INC.B W1, W2
009BDA  E80081     INC W1, W1
742:               								}
743:               								tempDst[index++] = '.';
009BE0  2FFA20     MOV #0xFFA2, W0
009BE2  478200     ADD W15, W0, W4
009BE4  FB8082     ZE W2, W1
009BE6  B3C2E0     MOV #0x2E, W0
009BE8  78F200     MOV.B W0, [W4+W1]
744:               								tempDst[index++] = dst[8];
009BEA  E84002     INC.B W2, W0
009BEC  FB8000     ZE W0, W0
009BEE  787203     MOV.B W3, [W4+W0]
009BF0  E8C002     INC2.B W2, W0
745:               								
746:               								if(dst[9] != ' ')
009BF2  2494A1     MOV #0x494A, W1
009BF4  904991     MOV.B [W1+9], W3
009BF6  FB8000     ZE W0, W0
009BF8  4140E3     ADD.B W2, #0x3, W1
009BFA  51CF85     SUB.B W3, W5, [W15]
009BFC  320002     BRA Z, 0x9C02
747:               									tempDst[index++] = dst[9];
009BFE  787203     MOV.B W3, [W4+W0]
009C00  370002     BRA 0x9C06
748:               								else
749:               									tempDst[index++] = 0x00;
009C02  420000     ADD W4, W0, W0
009C04  EB4800     CLR.B [W0]
750:               							
751:               								if(dst[10] != ' ')
009C06  2494A2     MOV #0x494A, W2
009C08  9049A2     MOV.B [W2+10], W3
009C0A  2FFA20     MOV #0xFFA2, W0
009C0C  478200     ADD W15, W0, W4
009C0E  FB8101     ZE W1, W2
009C10  E84081     INC.B W1, W1
009C12  B3C200     MOV #0x20, W0
009C14  51CF80     SUB.B W3, W0, [W15]
009C16  320002     BRA Z, 0x9C1C
752:               									tempDst[index++] = dst[10];
009C18  797203     MOV.B W3, [W4+W2]
009C1A  37000E     BRA 0x9C38
753:               								else
754:               									tempDst[index++] = 0x00;
009C1C  420002     ADD W4, W2, W0
009C1E  EB4800     CLR.B [W0]
009C20  37000B     BRA 0x9C38
009C22  EB0100     CLR W2
009C24  2FFA21     MOV #0xFFA2, W1
009C26  478201     ADD W15, W1, W4
009C28  784082     MOV.B W2, W1
755:               							}
756:                         	    		    else
757:               							{
758:                         	    		    	for(index = 0;index < 8;index++)
009C34  510FE8     SUB W2, #0x8, [W15]
009C36  3AFFF8     BRA NZ, 0x9C28
759:               								{
760:               									if(tempDst[index] == ' ')
009C2A  7A4062     MOV.B [W2+W4], W0
009C2C  504F83     SUB.B W0, W3, [W15]
009C2E  320004     BRA Z, 0x9C38
761:               										break;
009C30  E84082     INC.B W2, W1
009C32  E80102     INC W2, W2
762:               								}
763:               							}
764:               
765:               							// Terminate the string using the NULL value
766:               							tempDst[index] = 0x00;
009C38  2FFA23     MOV #0xFFA2, W3
009C3A  478103     ADD W15, W3, W2
009C3C  FB8001     ZE W1, W0
009C3E  410000     ADD W2, W0, W0
009C40  EB4800     CLR.B [W0]
767:                         
768:                         	            	if(fileNameLength)
009C42  8242BC     MOV fileNameLength, W12
009C44  E0000C     CP0 W12
009C46  320040     BRA Z, 0x9CC8
769:                         	            	{
770:                         	        			if(foundLFN)
009C48  97AA5F     MOV [W15-38], W4
009C4A  E00004     CP0 W4
009C4C  32001F     BRA Z, 0x9C8C
009C4E  97B4AF     MOV [W15-28], W9
009C50  EB0700     CLR W14
009C52  2494AD     MOV #0x494A, W13
009C54  370018     BRA 0x9C86
771:                         	        			{
772:                         	        				// see if we are a volume id or hidden, ignore
773:                         	        				// search for one. if status = TRUE we found one
774:                         	        				for(fileCompareLfnIndex = 0;fileCompareLfnIndex < fileNameLength;fileCompareLfnIndex++)
009C80  E8070E     INC W14, W14
009C82  E88489     INC2 W9, W9
009C84  E8868D     INC2 W13, W13
009C86  570F8C     SUB W14, W12, [W15]
009C88  3AFFE6     BRA NZ, 0x9C56
009C8A  3701BA     BRA 0xA000
775:                         	        				{
776:               				  						if(foCompareTo -> AsciiEncodingType)
009C56  97B0EF     MOV [W15-20], W1
009C58  901041     MOV [W1+40], W0
009C5A  E00000     CP0 W0
009C5C  32000E     BRA Z, 0x9C7A
777:               				  						{
778:                         	        					       // get the source character
779:                         	        					       character = (BYTE)templfnPtr[fileCompareLfnIndex];
009C5E  784119     MOV.B [W9], W2
780:                         	        					       // get the destination character
781:                         	        					       test = (BYTE)fileFoundString[fileCompareLfnIndex];
009C60  78009D     MOV [W13], W1
009C62  784581     MOV.B W1, W11
782:                         	        					       if((fileFoundString[fileCompareLfnIndex] > 0xFF) || (tolower(character) != tolower(test)))
009C64  200FF0     MOV #0xFF, W0
009C66  508F80     SUB W1, W0, [W15]
009C68  3E01F9     BRA GTU, 0xA05C
009C6A  FB8002     ZE W2, W0
009C6C  07DBB7     RCALL tolower
009C6E  780400     MOV W0, W8
009C70  FB800B     ZE W11, W0
009C72  07DBB4     RCALL tolower
009C74  540F80     SUB W8, W0, [W15]
009C76  320004     BRA Z, 0x9C80
009C78  3701F1     BRA 0xA05C
783:                         	        					       {
784:                         	        								statusB = CE_FILE_NOT_FOUND; // Nope its not a match
785:                         	        								break;
786:                         	        					       }
787:               				  						}
788:               				  						else
789:               				  						{
790:               				  							if(templfnPtr[fileCompareLfnIndex] != fileFoundString[fileCompareLfnIndex])
009C7A  780119     MOV [W9], W2
009C7C  510F9D     SUB W2, [W13], [W15]
009C7E  3A01EE     BRA NZ, 0xA05C
791:               				  							{
792:                         	    	  							statusB = CE_FILE_NOT_FOUND; // Nope its not a match
793:               				  								break;
794:               				  							}
795:               				  						}
796:                         	        				}// for loop
797:               								}
798:               								else if(foundSFN && foCompareTo -> AsciiEncodingType)
009C8C  97A9EF     MOV [W15-36], W3
009C8E  E00003     CP0 W3
009C90  3201E5     BRA Z, 0xA05C
009C92  97B26F     MOV [W15-20], W4
009C94  901044     MOV [W4+40], W0
009C96  E00000     CP0 W0
009C98  3201E1     BRA Z, 0xA05C
799:               								{
800:                         	        				if(strlen(tempDst) != fileNameLength)
009C9A  780002     MOV W2, W0
009C9C  07DD76     RCALL strlen
009C9E  780680     MOV W0, W13
009CA0  500F8C     SUB W0, W12, [W15]
009CA2  3A01DC     BRA NZ, 0xA05C
009CA4  97B5AF     MOV [W15-28], W11
009CA6  EB0480     CLR W9
009CA8  37000C     BRA 0x9CC2
801:                         	        					statusB = CE_FILE_NOT_FOUND; // Nope its not a match
802:                         	        				else
803:                         	        				{
804:                         	        					for(fileCompareLfnIndex = 0;fileCompareLfnIndex < fileNameLength;fileCompareLfnIndex++)
009CC0  E80489     INC W9, W9
009CC2  548F8D     SUB W9, W13, [W15]
009CC4  39FFF2     BRA NC, 0x9CAA
009CC6  37019F     BRA 0xA006
805:                         	        					{
806:                         	        						// get the source character
807:                         	        						character = (BYTE)templfnPtr[fileCompareLfnIndex];
808:                         	        						// get the destination character
809:                         	        						test = tempDst[fileCompareLfnIndex];
810:                         	        						if(tolower(character) != tolower(test))
009CAA  78003B     MOV [W11++], W0
009CAC  FB8000     ZE W0, W0
009CAE  07DB96     RCALL tolower
009CB0  780400     MOV W0, W8
009CB2  2FFA21     MOV #0xFFA2, W1
009CB4  478001     ADD W15, W1, W0
009CB6  784069     MOV.B [W9+W0], W0
009CB8  FB8000     ZE W0, W0
009CBA  07DB90     RCALL tolower
009CBC  540F80     SUB W8, W0, [W15]
009CBE  3A01CE     BRA NZ, 0xA05C
811:                         	        						{
812:                         	        							statusB = CE_FILE_NOT_FOUND; // Nope its not a match
813:                         	        							break;
814:                         	        						}
815:                         	        					}// for loop
816:               									}
817:               								}
818:               								else
819:               								{
820:                         	        				statusB = CE_FILE_NOT_FOUND; // Nope its not a match
821:               								}
822:               							}
823:               							else
824:                         	            	{
825:                         	    				if(foundLFN)
009CC8  97A9DF     MOV [W15-38], W3
009CCA  E00003     CP0 W3
009CCC  32001C     BRA Z, 0x9D06
826:                         	    				{
827:                         	        				if(strlen(tempDst) != fileFoundLength)
009CCE  780002     MOV W2, W0
009CD0  07DD5C     RCALL strlen
009CD2  97AA7F     MOV [W15-34], W4
009CD4  500F84     SUB W0, W4, [W15]
009CD6  3A01C2     BRA NZ, 0xA05C
009CD8  EB0480     CLR W9
009CDA  2494AC     MOV #0x494A, W12
009CDC  370010     BRA 0x9CFE
828:                         	        					statusB = CE_FILE_NOT_FOUND; // Nope its not a match
829:                         	        				else
830:                         	        				{
831:                         	        					for(fileCompareLfnIndex = 0;fileCompareLfnIndex < fileFoundLength;fileCompareLfnIndex++)
009CFC  E80489     INC W9, W9
009CFE  97AA7F     MOV [W15-34], W4
009D00  548F84     SUB W9, W4, [W15]
009D02  35FFED     BRA LT, 0x9CDE
009D04  37017D     BRA 0xA000
009D06  97B06F     MOV [W15-20], W0
009D08  4004FC     ADD W0, #0x1C, W9
009D0A  97ADDF     MOV [W15-38], W11
832:                         	        					{
833:                         	        						// get the source character
834:                         	        						character = (BYTE)fileFoundString[fileCompareLfnIndex];
009CDE  78001C     MOV [W12], W0
835:                         	        						// get the destination character
836:                         	        						test = tempDst[fileCompareLfnIndex];
009CE0  2FFA23     MOV #0xFFA2, W3
009CE2  478083     ADD W15, W3, W1
009CE4  78C5E9     MOV.B [W9+W1], W11
837:                         	        						if((fileFoundString[fileCompareLfnIndex] > 0xFF) || (tolower(character) != tolower(test)))
009CE6  200FF1     MOV #0xFF, W1
009CE8  500F81     SUB W0, W1, [W15]
009CEA  3E01B8     BRA GTU, 0xA05C
009CEC  E8860C     INC2 W12, W12
009CEE  FB8000     ZE W0, W0
009CF0  07DB75     RCALL tolower
009CF2  780400     MOV W0, W8
009CF4  FB800B     ZE W11, W0
009CF6  07DB72     RCALL tolower
009CF8  540F80     SUB W8, W0, [W15]
009CFA  3A01B0     BRA NZ, 0xA05C
838:                         	        						{
839:                         	        							statusB = CE_FILE_NOT_FOUND; // Nope its not a match
840:                         	        							break;
841:                         	        						}
842:                         	        					}// for loop
843:               									}
844:                         	    				}
845:                         	    				else
846:                         	    				{
847:                         	     					// search for one. if status = TRUE we found one
848:                         	     					for(index = 0; index < DIR_NAMECOMP; index++)
009D22  558FEB     SUB W11, #0xB, [W15]
009D24  320170     BRA Z, 0xA006
009D26  37FFF2     BRA 0x9D0C
849:                         	     					{
850:                         	     					    // get the source character
851:                         	     					    character = dst[index];
852:                         	     					    // get the destination character
853:                         	     					    test = foCompareTo->name[index];
854:                         	     					    if(tolower(character) != tolower(test))
009D0C  2494A1     MOV #0x494A, W1
009D0E  78C06B     MOV.B [W11+W1], W0
009D10  FB8000     ZE W0, W0
009D12  07DB64     RCALL tolower
009D14  780400     MOV W0, W8
009D16  FB8019     ZE [W9], W0
009D18  07DB61     RCALL tolower
009D1A  540F80     SUB W8, W0, [W15]
009D1C  3A019F     BRA NZ, 0xA05C
009D1E  E8058B     INC W11, W11
009D20  E80489     INC W9, W9
855:                         	     					    {
856:                         	     					        statusB = CE_FILE_NOT_FOUND; // Nope its not a match
857:                         	     					        break;
858:                         	     					    }
859:                         	     					}// for loop
860:               								}
861:               							}
862:                         	        		break;
863:               
864:                         	        case 1:
865:               							if(fileNameLength)
009D28  8242B2     MOV fileNameLength, W2
009D2A  9FB7C2     MOV W2, [W15-24]
009D2C  E00002     CP0 W2
009D2E  3200D3     BRA Z, 0x9ED6
866:                         	            	{
867:               								fileFoundDotPosition = FALSE;
868:               								if(foundLFN)
009D30  97A9DF     MOV [W15-38], W3
009D32  E00003     CP0 W3
009D34  320010     BRA Z, 0x9D56
009D36  97B20F     MOV [W15-32], W4
009D38  420084     ADD W4, W4, W1
009D3A  2494A0     MOV #0x494A, W0
009D3C  408080     ADD W1, W0, W1
009D3E  780004     MOV W4, W0
009D40  2002E2     MOV #0x2E, W2
009D42  370003     BRA 0x9D4A
009D44  E90000     DEC W0, W0
869:               								{
870:               									lfnCountIndex = fileFoundMaxLfnIndex;
871:               									while(lfnCountIndex > 0)
009D4A  E00000     CP0 W0
009D4C  3CFFFB     BRA GT, 0x9D44
009D4E  97B60F     MOV [W15-32], W12
009D50  EB0000     CLR W0
009D52  9FAFC0     MOV W0, [W15-40]
009D54  370014     BRA 0x9D7E
872:               									{
873:               										if(fileFoundString[lfnCountIndex] == '.')
009D46  110FA1     SUBR W2, [W1--], [W15]
009D48  32000F     BRA Z, 0x9D68
874:               										{
875:               											fileFoundDotPosition = TRUE;
876:               											lfnCountIndex--;
009D68  780600     MOV W0, W12
009D6A  200014     MOV #0x1, W4
009D6C  9FAFC4     MOV W4, [W15-40]
009D6E  370007     BRA 0x9D7E
877:               											break;
878:               										}
879:               										lfnCountIndex--;
880:               									}
881:               
882:               									if(fileFoundDotPosition == FALSE)
883:               										lfnCountIndex = fileFoundMaxLfnIndex;
884:               								}
885:               								else
886:               								{
887:               									if(dst[DIR_NAMESIZE] != ' ')
009D56  2494A2     MOV #0x494A, W2
009D58  904882     MOV.B [W2+8], W1
009D5A  200013     MOV #0x1, W3
009D5C  9FAFC3     MOV W3, [W15-40]
009D5E  20007C     MOV #0x7, W12
009D60  B3C200     MOV #0x20, W0
009D62  50CF80     SUB.B W1, W0, [W15]
009D64  3A000C     BRA NZ, 0x9D7E
009D66  370008     BRA 0x9D78
009D78  97A8DF     MOV [W15-38], W1
009D7A  9FAFC1     MOV W1, [W15-40]
009D7C  20007C     MOV #0x7, W12
888:               										fileFoundDotPosition = TRUE;
889:               									lfnCountIndex = DIR_NAMESIZE - 1;
890:               								}
891:               
892:               								fileFoundLfnIndex = fileNameLength - 1;
009D7E  97B14F     MOV [W15-24], W2
009D80  E90102     DEC W2, W2
009D82  9FB792     MOV W2, [W15-30]
009D84  410002     ADD W2, W2, W0
009D86  97B1AF     MOV [W15-28], W3
009D88  418080     ADD W3, W0, W1
009D8A  780002     MOV W2, W0
009D8C  2002E2     MOV #0x2E, W2
009D8E  370003     BRA 0x9D96
009D90  E90000     DEC W0, W0
893:               								fileCompareDotPosition = FALSE;
894:               								while(fileFoundLfnIndex > 0)
009D96  E00000     CP0 W0
009D98  3CFFFB     BRA GT, 0x9D90
009D9A  EB0200     CLR W4
009D9C  9FAFB4     MOV W4, [W15-42]
009D9E  97B5AF     MOV [W15-28], W11
009DA0  EB0680     CLR W13
009DA2  2494AE     MOV #0x494A, W14
895:               								{
896:               									if(templfnPtr[fileFoundLfnIndex] == '.')
009D92  110FA1     SUBR W2, [W1--], [W15]
009D94  32FFED     BRA Z, 0x9D70
897:               									{
898:               										fileCompareDotPosition = TRUE;
899:               										fileFoundLfnIndex--;
009D70  9FB790     MOV W0, [W15-30]
009D72  200010     MOV #0x1, W0
009D74  9FAFB0     MOV W0, [W15-42]
009D76  370013     BRA 0x9D9E
900:               										break;
901:               									}
902:               									fileFoundLfnIndex--;
903:               								}
904:               								if(fileCompareDotPosition == FALSE)
905:               									fileFoundLfnIndex = fileNameLength - 1;
906:               
907:                         	         			// Check for attribute match
908:                         	         			for(fileCompareLfnIndex = 0;;)
909:                         	         			{
910:                         	         				if (templfnPtr[fileCompareLfnIndex] == '*')
009DA4  78009B     MOV [W11], W1
009DA6  2002A0     MOV #0x2A, W0
009DA8  508F80     SUB W1, W0, [W15]
009DAA  32002A     BRA Z, 0x9E00
911:                         	         					break;
912:                         	         			   
913:               									if(fileCompareLfnIndex > lfnCountIndex)
009DAC  568F8C     SUB W13, W12, [W15]
009DAE  3C002A     BRA GT, 0x9E04
914:                         	         			    {
915:                         	         			    	statusB = CE_FILE_NOT_FOUND; // Nope its not a match
916:                         	         			    	break;
917:                         	         			    }
918:                         	         			   
919:                         	         			   if (templfnPtr[fileCompareLfnIndex] != '?')
009DB0  400075     ADD W0, #0x15, W0
009DB2  508F80     SUB W1, W0, [W15]
009DB4  32001D     BRA Z, 0x9DF0
920:                         	         			   {
921:               				  						if(foCompareTo -> AsciiEncodingType)
009DB6  97B16F     MOV [W15-20], W2
009DB8  901042     MOV [W2+40], W0
009DBA  E00000     CP0 W0
009DBC  320014     BRA Z, 0x9DE6
922:               				  						{
923:                         	         			    		// get the source character
924:                         	         			    		character = (BYTE)templfnPtr[fileCompareLfnIndex];
009DBE  784101     MOV.B W1, W2
925:                         	         			    		// get the destination character
926:                         	         			    		if(foundLFN)
009DC0  97A9DF     MOV [W15-38], W3
009DC2  E00003     CP0 W3
009DC4  320006     BRA Z, 0x9DD2
927:                         	         			    			test = (BYTE)fileFoundString[fileCompareLfnIndex];
009DC6  78009E     MOV [W14], W1
009DC8  784481     MOV.B W1, W9
928:               											else
929:                         	         			    			test = dst[fileCompareLfnIndex];
009DD2  2494A4     MOV #0x494A, W4
009DD4  7A44ED     MOV.B [W13+W4], W9
930:               
931:               											if((foundLFN && (fileFoundString[fileCompareLfnIndex] > 0xFF)) ||
009DCA  200FF0     MOV #0xFF, W0
009DCC  508F80     SUB W1, W0, [W15]
009DCE  360003     BRA LEU, 0x9DD6
009DD0  370019     BRA 0x9E04
009DD6  FB8002     ZE W2, W0
009DD8  07DB01     RCALL tolower
009DDA  780400     MOV W0, W8
009DDC  FB8009     ZE W9, W0
009DDE  07DAFE     RCALL tolower
009DE0  540F80     SUB W8, W0, [W15]
009DE2  320006     BRA Z, 0x9DF0
009DE4  37000F     BRA 0x9E04
932:                         	         			    			(tolower(character) != tolower(test)))
933:                         	         			    		{
934:                         	         			    			statusB = CE_FILE_NOT_FOUND; // Nope its not a match
935:                         	         			    			break;
936:                         	         			    		}
937:               				  						}
938:               				  						else
939:               				  						{
940:               				  							if((templfnPtr[fileCompareLfnIndex] != fileFoundString[fileCompareLfnIndex]) || foundSFN)
009DE6  508F9E     SUB W1, [W14], [W15]
009DE8  3A000D     BRA NZ, 0x9E04
009DEA  97A86F     MOV [W15-36], W0
009DEC  E00000     CP0 W0
009DEE  3A000A     BRA NZ, 0x9E04
941:               				  							{
942:                         	    	   							statusB = CE_FILE_NOT_FOUND; // Nope its not a match
943:               				  								break;
944:               				  							}
945:               				  						}
946:                         	         				}
947:               
948:                              		    	 		fileCompareLfnIndex++;
009DF0  E8068D     INC W13, W13
009DF2  E8858B     INC2 W11, W11
009DF4  E8870E     INC2 W14, W14
949:                              		    	 		if(fileCompareLfnIndex > fileFoundLfnIndex)
009DF6  97B09F     MOV [W15-30], W1
009DF8  568F81     SUB W13, W1, [W15]
009DFA  34FFD4     BRA LE, 0x9DA4
950:                              		    	        {
951:                              		    	            if(fileCompareLfnIndex <= lfnCountIndex)
009DFC  568F8C     SUB W13, W12, [W15]
009DFE  340002     BRA LE, 0x9E04
009E00  EB0280     CLR W5
009E02  370001     BRA 0x9E06
009E04  2000B5     MOV #0xB, W5
952:                              		    	            {
953:                         	    	   						statusB = CE_FILE_NOT_FOUND; // Nope its not a match
954:               										}
955:                              		    	            break;
956:               									}
957:                         	         			}// for loop
958:               
959:               								if(fileCompareDotPosition == FALSE)
009E06  97A93F     MOV [W15-42], W2
009E08  E00002     CP0 W2
009E0A  3A0004     BRA NZ, 0x9E14
960:               								{
961:               									if(fileFoundDotPosition == TRUE)
009E0C  97A9CF     MOV [W15-40], W3
009E0E  518FE1     SUB W3, #0x1, [W15]
009E10  3A00F2     BRA NZ, 0x9FF6
009E12  370126     BRA 0xA060
962:                         	         			    {
963:                         	         			    	statusB = CE_FILE_NOT_FOUND; // Nope its not a match
964:                         	         			    }
965:               									break;
966:               								}
967:               								else
968:               								{
969:               									if(fileFoundDotPosition == FALSE)
009E14  97AA4F     MOV [W15-40], W4
009E16  E00004     CP0 W4
009E18  320127     BRA Z, 0xA068
970:                         	         			    {
971:                         	         			    	statusB = CE_FILE_NOT_FOUND; // Nope its not a match
972:                         	         			    	break;
973:                         	         			    }
974:               
975:               									if(foundLFN)
009E1A  20008B     MOV #0x8, W11
009E1C  97A85F     MOV [W15-38], W0
009E1E  E00000     CP0 W0
009E20  320001     BRA Z, 0x9E24
976:               										lfnCountIndex = lfnCountIndex + 2;
009E22  E8858C     INC2 W12, W11
977:               									else
978:               										lfnCountIndex = DIR_NAMESIZE;
979:               								}
980:               
981:                         	         			// Check for attribute match
982:                         	         			for(fileCompareLfnIndex = fileFoundLfnIndex + 2;;)
009E24  97B09F     MOV [W15-30], W1
009E26  E88081     INC2 W1, W1
009E28  9FAF81     MOV W1, [W15-48]
009E2A  408001     ADD W1, W1, W0
009E2C  97B12F     MOV [W15-28], W2
009E2E  410700     ADD W2, W0, W14
009E30  45808B     ADD W11, W11, W1
009E32  2494A0     MOV #0x494A, W0
009E34  408600     ADD W1, W0, W12
009E36  40068B     ADD W0, W11, W13
009E38  EB0180     CLR W3
009E3A  9FAF93     MOV W3, [W15-46]
983:                         	         			{
984:                         	         				if (templfnPtr[fileCompareLfnIndex] == '*')
009E3C  78009E     MOV [W14], W1
009E3E  2002A0     MOV #0x2A, W0
009E40  508F80     SUB W1, W0, [W15]
009E42  3200D9     BRA Z, 0x9FF6
985:                         	         					break;
986:                         	         			   
987:               									if((foundLFN && (lfnCountIndex > fileFoundMaxLfnIndex)) || (foundSFN && (lfnCountIndex == 11)))
009E44  97AA5F     MOV [W15-38], W4
009E46  E00004     CP0 W4
009E48  320003     BRA Z, 0x9E50
009E4A  97B00F     MOV [W15-32], W0
009E4C  558F80     SUB W11, W0, [W15]
009E4E  3C0106     BRA GT, 0xA05C
009E50  97A96F     MOV [W15-36], W2
009E52  E00002     CP0 W2
009E54  320002     BRA Z, 0x9E5A
009E56  558FEB     SUB W11, #0xB, [W15]
009E58  320101     BRA Z, 0xA05C
988:               									{
989:                         	         			    	statusB = CE_FILE_NOT_FOUND; // Nope its not a match
990:                         	         			    	break;
991:               									}
992:                         	         			   
993:                         	         			   if (templfnPtr[fileCompareLfnIndex] != '?')
009E5A  2003F0     MOV #0x3F, W0
009E5C  508F80     SUB W1, W0, [W15]
009E5E  32001E     BRA Z, 0x9E9C
994:                         	         			   {
995:               				  						if(foCompareTo -> AsciiEncodingType)
009E60  97B1EF     MOV [W15-20], W3
009E62  901043     MOV [W3+40], W0
009E64  E00000     CP0 W0
009E66  320015     BRA Z, 0x9E92
996:               				  						{
997:                         	         			    	    // get the source character
998:                         	         			    	    character = (BYTE)templfnPtr[fileCompareLfnIndex];
009E68  784101     MOV.B W1, W2
999:                         	         			    	    // get the destination character
1000:                        	         			    		if(foundLFN)
009E6A  97AA5F     MOV [W15-38], W4
009E6C  E00004     CP0 W4
009E6E  320006     BRA Z, 0x9E7C
1001:                        	         			    			test = (BYTE)fileFoundString[lfnCountIndex];
009E70  78009C     MOV [W12], W1
009E72  784481     MOV.B W1, W9
1002:              											else
1003:                        	         			    			test = dst[lfnCountIndex];
009E7C  78449D     MOV.B [W13], W9
1004:              											if((foundLFN && (fileFoundString[lfnCountIndex] > 0xFF)) ||
009E74  200FF0     MOV #0xFF, W0
009E76  508F80     SUB W1, W0, [W15]
009E78  360002     BRA LEU, 0x9E7E
009E7A  3700F0     BRA 0xA05C
009E7E  FB8002     ZE W2, W0
009E80  9FBF85     MOV W5, [W15-16]
009E82  07DAAC     RCALL tolower
009E84  780400     MOV W0, W8
009E86  FB8009     ZE W9, W0
009E88  07DAA9     RCALL tolower
009E8A  97BA8F     MOV [W15-16], W5
009E8C  540F80     SUB W8, W0, [W15]
009E8E  320006     BRA Z, 0x9E9C
009E90  3700E5     BRA 0xA05C
1005:                        	         			    			(tolower(character) != tolower(test)))
1006:                        	         			    		{
1007:                        	         			    			statusB = CE_FILE_NOT_FOUND; // Nope its not a match
1008:                        	         			    			break;
1009:                        	         			    		}
1010:              				  						}
1011:              				  						else
1012:              				  						{
1013:              				  							if((templfnPtr[fileCompareLfnIndex] != fileFoundString[lfnCountIndex]) || foundSFN)
009E92  508F9C     SUB W1, [W12], [W15]
009E94  3A00E3     BRA NZ, 0xA05C
009E96  97A86F     MOV [W15-36], W0
009E98  E00000     CP0 W0
009E9A  3A00E0     BRA NZ, 0xA05C
1014:              				  							{
1015:                        	    	   							statusB = CE_FILE_NOT_FOUND; // Nope its not a match
1016:              				  								break;
1017:              				  							}
1018:              				  						}
1019:                        	         				}
1020:                             		    	 		lfnCountIndex++;
009E9C  E8058B     INC W11, W11
009E9E  97A89F     MOV [W15-46], W1
009EA0  E80081     INC W1, W1
009EA2  9FAF91     MOV W1, [W15-46]
009EA4  E8870E     INC2 W14, W14
009EA6  E8860C     INC2 W12, W12
009EA8  E8068D     INC W13, W13
1021:                             		    	 		fileCompareLfnIndex++;
1022:                             		    	 		if(fileCompareLfnIndex == fileNameLength)
009EAA  97B14F     MOV [W15-24], W2
009EAC  97A98F     MOV [W15-48], W3
009EAE  510003     SUB W2, W3, W0
009EB0  508F80     SUB W1, W0, [W15]
009EB2  3AFFC4     BRA NZ, 0x9E3C
1023:                             		    	        {
1024:                             		    	            if((foundLFN && (lfnCountIndex <= fileFoundMaxLfnIndex)) || (foundSFN && (lfnCountIndex < 11) && (dst[lfnCountIndex] != ' ')))
009EB4  97AA5F     MOV [W15-38], W4
009EB6  E00004     CP0 W4
009EB8  320003     BRA Z, 0x9EC0
009EBA  97B00F     MOV [W15-32], W0
009EBC  558F80     SUB W11, W0, [W15]
009EBE  3400CE     BRA LE, 0xA05C
009EC0  97A8EF     MOV [W15-36], W1
009EC2  E00001     CP0 W1
009EC4  320098     BRA Z, 0x9FF6
009EC6  558FEA     SUB W11, #0xA, [W15]
009EC8  3C0096     BRA GT, 0x9FF6
009ECA  2494A2     MOV #0x494A, W2
009ECC  7DC0E2     MOV.B [W2+W11], W1
009ECE  B3C200     MOV #0x20, W0
009ED0  50CF80     SUB.B W1, W0, [W15]
009ED2  3A00C4     BRA NZ, 0xA05C
009ED4  370090     BRA 0x9FF6
1025:                             		    	            {
1026:                        	    	   						statusB = CE_FILE_NOT_FOUND; // Nope its not a match
1027:              										}
1028:                             		    	            break;
1029:              									}
1030:                        	         			}// for loop
1031:              							}
1032:              							else
1033:              							{
1034:                        	    				/* We got something */
1035:                             		    		if(foundLFN)
009ED6  20007E     MOV #0x7, W14
009ED8  97A9DF     MOV [W15-38], W3
009EDA  E00003     CP0 W3
009EDC  320014     BRA Z, 0x9F06
009EDE  370004     BRA 0x9EE8
009EE8  97B00F     MOV [W15-32], W0
009EEA  400080     ADD W0, W0, W1
009EEC  2494A0     MOV #0x494A, W0
009EEE  408080     ADD W1, W0, W1
009EF0  97B00F     MOV [W15-32], W0
009EF2  2002E2     MOV #0x2E, W2
009EF4  370003     BRA 0x9EFC
009EF6  E90000     DEC W0, W0
1036:                             		    		{
1037:              									fileCompareLfnIndex = fileFoundMaxLfnIndex;
1038:              									fileFoundDotPosition = FALSE;
1039:              									while(fileCompareLfnIndex > 0)
009EFC  E00000     CP0 W0
009EFE  3CFFFB     BRA GT, 0x9EF6
009F00  97B70F     MOV [W15-32], W14
009F02  EB0080     CLR W1
009F04  9FAFC1     MOV W1, [W15-40]
1040:              									{
1041:              										if(fileFoundString[fileCompareLfnIndex] == '.')
009EF8  110FA1     SUBR W2, [W1--], [W15]
009EFA  32FFF2     BRA Z, 0x9EE0
1042:              										{
1043:              											fileFoundDotPosition = TRUE;
1044:              											fileCompareLfnIndex--;
009EE0  780700     MOV W0, W14
009EE2  200014     MOV #0x1, W4
009EE4  9FAFC4     MOV W4, [W15-40]
009EE6  37000F     BRA 0x9F06
1045:              											break;
1046:              										}
1047:              										fileCompareLfnIndex--;
1048:              									}
1049:              
1050:              									if(fileFoundDotPosition == FALSE)
1051:              										fileCompareLfnIndex = fileFoundMaxLfnIndex;
1052:              								}
1053:              								else
1054:              									fileCompareLfnIndex = DIR_NAMESIZE - 1;	// Short File name last char position
1055:              
1056:                             		    	    if (foCompareTo->name[0] != '*')   //If "*" is passed for comparion as 1st char then don't proceed. Go back, file alreay found.
009F06  97B16F     MOV [W15-20], W2
009F08  9058C2     MOV.B [W2+28], W1
009F0A  B3C2A0     MOV #0x2A, W0
009F0C  50CF80     SUB.B W1, W0, [W15]
009F0E  320027     BRA Z, 0x9F5E
009F10  4105FC     ADD W2, #0x1C, W11
009F12  EB0600     CLR W12
009F14  2494AD     MOV #0x494A, W13
1057:                             		    	    {
1058:                             		    	        for (index = 0;;)
1059:                             		    	        {
1060:                             		    	            if(foundLFN)
009F16  97A9DF     MOV [W15-38], W3
009F18  E00003     CP0 W3
009F1A  320007     BRA Z, 0x9F2A
1061:                             		    	            {
1062:                             		    	            	if((fileFoundString[index] > 0xFF) || (index > fileCompareLfnIndex))
009F1C  78009D     MOV [W13], W1
009F1E  200FF0     MOV #0xFF, W0
009F20  508F80     SUB W1, W0, [W15]
009F22  3E001F     BRA GTU, 0x9F62
009F24  560F8E     SUB W12, W14, [W15]
009F26  3C001D     BRA GT, 0x9F62
009F28  370002     BRA 0x9F2E
1063:                             		    	            	{
1064:                             		    	                	statusB = CE_FILE_NOT_FOUND; // it's not a match
1065:                             		    	                	break;
1066:              											}
1067:              										}
1068:              
1069:                             		    	            // Get the source character
1070:                        	         					if(foundLFN)
1071:                        	         						character = (BYTE)fileFoundString[index];
1072:              										else
1073:                        	         						character = dst[index];
009F2A  2494A4     MOV #0x494A, W4
009F2C  7A40EC     MOV.B [W12+W4], W1
1074:              
1075:                             		    	            // Get the destination character
1076:                             		    	            test = foCompareTo->name[index];
009F2E  78449B     MOV.B [W11], W9
1077:                             		    	            if (test == '*')
009F30  B3C2A0     MOV #0x2A, W0
009F32  54CF80     SUB.B W9, W0, [W15]
009F34  320014     BRA Z, 0x9F5E
1078:                             		    	                break;
1079:                             		    	            if (test != '?')
009F36  404075     ADD.B W0, #0x15, W0
009F38  54CF80     SUB.B W9, W0, [W15]
009F3A  320007     BRA Z, 0x9F4A
1080:                             		    	            {
1081:                             		    	                if(tolower(character) != tolower(test))
009F3C  FB8001     ZE W1, W0
009F3E  07DA4E     RCALL tolower
009F40  780400     MOV W0, W8
009F42  FB8009     ZE W9, W0
009F44  07DA4B     RCALL tolower
009F46  540F80     SUB W8, W0, [W15]
009F48  3A000C     BRA NZ, 0x9F62
009F4A  E8060C     INC W12, W12
009F4C  E8058B     INC W11, W11
009F4E  E8868D     INC2 W13, W13
1082:                             		    	                {
1083:                             		    	                    statusB = CE_FILE_NOT_FOUND; // it's not a match
1084:                             		    	                    break;
1085:                             		    	                }
1086:                             		    	            }
1087:                             		    	 
1088:                             		    	 			index++;
1089:                             		    	 			if(index == DIR_NAMESIZE)
009F50  560FE8     SUB W12, #0x8, [W15]
009F52  3AFFE1     BRA NZ, 0x9F16
1090:                             		    	        	{
1091:                             		    	        	    if(foundLFN && (index <= fileCompareLfnIndex))
009F54  97A85F     MOV [W15-38], W0
009F56  E00000     CP0 W0
009F58  320002     BRA Z, 0x9F5E
009F5A  570FE7     SUB W14, #0x7, [W15]
009F5C  3C0002     BRA GT, 0x9F62
009F5E  EB0280     CLR W5
009F60  370001     BRA 0x9F64
009F62  2000B5     MOV #0xB, W5
1092:                             		    	        	    {
1093:                             		    	                	statusB = CE_FILE_NOT_FOUND; // it's not a match
1094:              											}
1095:                             		    	                break;
1096:              										}
1097:                             		    	        }
1098:                             		    	    }
1099:              
1100:                             		    	    // Before calling this "FILEfind" fn, "formatfilename" must be called. Hence, extn always starts from position "8".
1101:                             		    	    if ((foCompareTo->name[8] != '*') && (statusB == CE_GOOD))
009F64  97B16F     MOV [W15-20], W2
009F66  9060C2     MOV.B [W2+36], W1
009F68  B3C2A0     MOV #0x2A, W0
009F6A  50CF80     SUB.B W1, W0, [W15]
009F6C  320044     BRA Z, 0x9FF6
009F6E  E00005     CP0 W5
009F70  3A007E     BRA NZ, 0xA06E
1102:                             		    	    {
1103:                             		    	        if(foundLFN)
009F72  20008B     MOV #0x8, W11
009F74  97A9DF     MOV [W15-38], W3
009F76  E00003     CP0 W3
009F78  32000B     BRA Z, 0x9F90
1104:                             		    	        {
1105:              										if(foCompareTo->name[8] == ' ')
009F7A  50406A     SUB.B W0, #0xA, W0
009F7C  50CF80     SUB.B W1, W0, [W15]
009F7E  3A0004     BRA NZ, 0x9F88
1106:              										{
1107:              											if(fileFoundDotPosition == TRUE)
009F80  97AA4F     MOV [W15-40], W4
009F82  520FE1     SUB W4, #0x1, [W15]
009F84  3A003D     BRA NZ, 0xA000
009F86  37006C     BRA 0xA060
1108:                             		    	        	    {
1109:                             		    	                	statusB = CE_FILE_NOT_FOUND; // it's not a match
1110:              											}
1111:              											break;
1112:              										}
1113:              										else
1114:              										{
1115:              											if(fileFoundDotPosition == FALSE)
009F88  97A84F     MOV [W15-40], W0
009F8A  E00000     CP0 W0
009F8C  32006D     BRA Z, 0xA068
1116:              											{
1117:                             		    	                	statusB = CE_FILE_NOT_FOUND; // it's not a match
1118:              												break;
1119:              											}
1120:              										}
1121:              										fileCompareLfnIndex = fileCompareLfnIndex + 2;
009F8E  E8858E     INC2 W14, W11
009F90  97B6EF     MOV [W15-20], W13
009F92  B0024D     ADD #0x24, W13
009F94  B3C08E     MOV #0x8, W14
1122:              									}
1123:              									else
1124:              										fileCompareLfnIndex = DIR_NAMESIZE;
1125:              
1126:                             		    	        for (index = 8;;)
1127:                             		    	        {
1128:                             		    	            if(foundLFN)
009F96  97A8DF     MOV [W15-38], W1
009F98  E00001     CP0 W1
009F9A  320009     BRA Z, 0x9FAE
1129:                             		    	            {
1130:                             		    	            	if((fileFoundString[fileCompareLfnIndex] > 0xFF) || (fileCompareLfnIndex > fileFoundMaxLfnIndex))
009F9C  45808B     ADD W11, W11, W1
009F9E  2494A0     MOV #0x494A, W0
009FA0  7880E0     MOV [W0+W1], W1
009FA2  200FF0     MOV #0xFF, W0
009FA4  508F80     SUB W1, W0, [W15]
009FA6  3E005A     BRA GTU, 0xA05C
009FA8  97B10F     MOV [W15-32], W2
009FAA  558F82     SUB W11, W2, [W15]
009FAC  3C0057     BRA GT, 0xA05C
009FAE  E8060B     INC W11, W12
1131:                             		    	            	{
1132:                             		    	                	statusB = CE_FILE_NOT_FOUND; // it's not a match
1133:                             		    	                	break;
1134:              											}
1135:              										}
1136:                             		    	            // Get the destination character
1137:                             		    	            test = foCompareTo->name[index];
009FB0  78449D     MOV.B [W13], W9
1138:                             		    	            // Get the source character
1139:                        	         					if(foundLFN)
009FB2  97A9DF     MOV [W15-38], W3
009FB4  E00003     CP0 W3
009FB6  320004     BRA Z, 0x9FC0
1140:                        	         						character = (BYTE)fileFoundString[fileCompareLfnIndex++];
009FB8  45808B     ADD W11, W11, W1
009FBA  2494A0     MOV #0x494A, W0
009FBC  78C0E0     MOV.B [W0+W1], W1
009FBE  370002     BRA 0x9FC4
1141:              										else
1142:                        	         						character = dst[fileCompareLfnIndex++];
009FC0  2494A4     MOV #0x494A, W4
009FC2  7DC0E4     MOV.B [W4+W11], W1
009FC4  78058C     MOV W12, W11
1143:              
1144:                             		    	            if (test == '*')
009FC6  B3C2A0     MOV #0x2A, W0
009FC8  54CF80     SUB.B W9, W0, [W15]
009FCA  320017     BRA Z, 0x9FFA
1145:                             		    	                break;
1146:                             		    	            if (test != '?')
009FCC  404075     ADD.B W0, #0x15, W0
009FCE  54CF80     SUB.B W9, W0, [W15]
009FD0  320007     BRA Z, 0x9FE0
1147:                             		    	            {
1148:                             		    	                if(tolower(character) != tolower(test))
009FD2  FB8001     ZE W1, W0
009FD4  07DA03     RCALL tolower
009FD6  780400     MOV W0, W8
009FD8  FB8009     ZE W9, W0
009FDA  07DA00     RCALL tolower
009FDC  540F80     SUB W8, W0, [W15]
009FDE  3A003E     BRA NZ, 0xA05C
1149:                             		    	                {
1150:                             		    	                    statusB = CE_FILE_NOT_FOUND; // it's not a match
1151:                             		    	                    break;
1152:                             		    	                }
1153:                             		    	            }
1154:              
1155:              										index++;
009FE0  E8470E     INC.B W14, W14
009FE2  E8068D     INC W13, W13
1156:              										if(index == DIR_NAMECOMP)
009FE4  574FEB     SUB.B W14, #0xB, [W15]
009FE6  3AFFD7     BRA NZ, 0x9F96
1157:              										{
1158:              											if(foundLFN && (fileCompareLfnIndex <= fileFoundMaxLfnIndex))
009FE8  97A85F     MOV [W15-38], W0
009FEA  E00000     CP0 W0
009FEC  32000C     BRA Z, 0xA006
009FEE  97B08F     MOV [W15-32], W1
009FF0  560F81     SUB W12, W1, [W15]
009FF2  340034     BRA LE, 0xA05C
009FF4  370005     BRA 0xA000
1159:              												statusB = CE_FILE_NOT_FOUND; // it's not a match
1160:              											break;
1161:              										}
1162:                             		    	        }
1163:                             		    	    }
1164:              							}
1165:                        	            	break;
1166:              				  }
1167:              
1168:              				// If the comparision of each character in LFN is completed
1169:              				if(statusB == CE_GOOD)
009FF6  E00005     CP0 W5
009FF8  3A003A     BRA NZ, 0xA06E
1170:              				{
1171:              					if(foundLFN)
009FFA  97A95F     MOV [W15-38], W2
009FFC  E00002     CP0 W2
009FFE  320003     BRA Z, 0xA006
1172:              						fHandle++;
00A000  97918F     MOV [W15-96], W3
00A002  E80183     INC W3, W3
00A004  9F9783     MOV W3, [W15-96]
1173:              
1174:                              	state = Fill_File_Object(foDest, &fHandle);
00A006  2FFA01     MOV #0xFFA0, W1
00A008  40808F     ADD W1, W15, W1
00A00A  97B05F     MOV [W15-22], W0
00A00C  07FBCB     RCALL Fill_File_Object
1175:              
1176:              					if(foundLFN)
00A00E  97AA5F     MOV [W15-38], W4
00A010  E00004     CP0 W4
00A012  320003     BRA Z, 0xA01A
1177:              						fHandle--;
00A014  97900F     MOV [W15-96], W0
00A016  E90000     DEC W0, W0
00A018  9F9780     MOV W0, [W15-96]
1178:              
1179:                             		/* We got something get the attributes */
1180:                             		attrib = foDest->attributes;
00A01A  97B0DF     MOV [W15-22], W1
00A01C  901811     MOV [W1+50], W0
1181:              
1182:                             		attrib &= ATTR_MASK;
00A01E  B203F0     AND #0x3F, W0
1183:              
1184:                             		switch (mode)
00A020  97E97F     MOV.B [W15-17], W2
00A022  E00402     CP0.B W2
00A024  320003     BRA Z, 0xA02C
00A026  514FE1     SUB.B W2, #0x1, [W15]
00A028  3A0017     BRA NZ, 0xA058
00A02A  370003     BRA 0xA032
1185:                             		{
1186:                             		    case 0:
1187:                             		        // see if we are a volume id or hidden, ignore
1188:                             		        if(attrib == ATTR_VOLUME)
00A02C  500FE8     SUB W0, #0x8, [W15]
00A02E  3A0014     BRA NZ, 0xA058
00A030  370015     BRA 0xA05C
1189:                             		            statusB = CE_FILE_NOT_FOUND;
1190:                             		        break;
1191:              
1192:                             		    case 1:
1193:                             		        // Check for attribute match
1194:                             		        if ((attrib & compareAttrib) != 0)
00A032  97B1BF     MOV [W15-26], W3
00A034  600003     AND W0, W3, W0
00A036  2000B5     MOV #0xB, W5
00A038  3A0001     BRA NZ, 0xA03C
00A03A  780280     MOV W0, W5
1195:                             		            statusB = CE_FILE_NOT_FOUND; // Indicate the already filled file data is correct and go back
1196:                             		        if(foundLFN)
00A03C  97AA5F     MOV [W15-38], W4
00A03E  E00004     CP0 W4
00A040  320004     BRA Z, 0xA04A
1197:                             		        	foDest->utf16LFNlength = fileFoundLength;
00A042  97A8FF     MOV [W15-34], W1
00A044  97B05F     MOV [W15-22], W0
00A046  981061     MOV W1, [W0+44]
00A048  370012     BRA 0xA06E
1198:                             		        else
1199:              								foDest->utf16LFNlength = 0;
00A04A  97A9DF     MOV [W15-38], W3
00A04C  97B15F     MOV [W15-22], W2
00A04E  981163     MOV W3, [W2+44]
00A050  37000E     BRA 0xA06E
1200:                             		        break;
1201:                             		}
1202:              				}
1203:              				#else
1204:              				{
1205:                             		 /* We got something */
1206:                             		 // get the attributes
1207:                             		 attrib = foDest->attributes;
1208:              
1209:                             		 attrib &= ATTR_MASK;
1210:                             		 switch (mode)
1211:                             		 {
1212:                             		     case 0:
1213:                             		         // see if we are a volume id or hidden, ignore
1214:                             		         if(attrib != ATTR_VOLUME)
1215:                             		         {
1216:                             		             statusB = CE_GOOD;
1217:                             		             character = (BYTE)'m'; // random value
1218:              
1219:                             		             // search for one. if status = TRUE we found one
1220:                             		             for(index = 0; index < DIR_NAMECOMP; index++)
1221:                             		             {
1222:                             		                 // get the source character
1223:                             		                 character = foDest->name[index];
1224:                             		                 // get the destination character
1225:                             		                 test = foCompareTo->name[index];
1226:                             		                 if(tolower(character) != tolower(test))
1227:                             		                 {
1228:                             		                     statusB = CE_FILE_NOT_FOUND; // Nope its not a match
1229:                             		                     break;
1230:                             		                 }
1231:                             		             }// for loop
1232:                             		         } // not dir nor vol
1233:                             		         break;
1234:              
1235:                             		     case 1:
1236:                             		         // Check for attribute match
1237:                             		         if (((attrib & compareAttrib) == 0) && (attrib != ATTR_LONG_NAME))
1238:                             		         {
1239:                             		             statusB = CE_GOOD;                 // Indicate the already filled file data is correct and go back
1240:                             		             character = (BYTE)'m';             // random value
1241:                             		             if (foCompareTo->name[0] != '*')   //If "*" is passed for comparion as 1st char then don't proceed. Go back, file alreay found.
1242:                             		             {
1243:                             		                 for (index = 0; index < DIR_NAMESIZE; index++)
1244:                             		                 {
1245:                             		                     // Get the source character
1246:                             		                     character = foDest->name[index];
1247:                             		                     // Get the destination character
1248:                             		                     test = foCompareTo->name[index];
1249:                             		                     if (test == '*')
1250:                             		                         break;
1251:                             		                     if (test != '?')
1252:                             		                     {
1253:                             		                         if(tolower(character) != tolower(test))
1254:                             		                         {
1255:                             		                             statusB = CE_FILE_NOT_FOUND; // it's not a match
1256:                             		                             break;
1257:                             		                         }
1258:                             		                     }
1259:                             		                 }
1260:                             		             }
1261:              
1262:                             		             // Before calling this "FILEfind" fn, "formatfilename" must be called. Hence, extn always starts from position "8".
1263:                             		             if ((foCompareTo->name[8] != '*') && (statusB == CE_GOOD))
1264:                             		             {
1265:                             		                 for (index = 8; index < DIR_NAMECOMP; index++)
1266:                             		                 {
1267:                             		                     // Get the source character
1268:                             		                     character = foDest->name[index];
1269:                             		                     // Get the destination character
1270:                             		                     test = foCompareTo->name[index];
1271:                             		                     if (test == '*')
1272:                             		                         break;
1273:                             		                     if (test != '?')
1274:                             		                     {
1275:                             		                         if(tolower(character) != tolower(test))
1276:                             		                         {
1277:                             		                             statusB = CE_FILE_NOT_FOUND; // it's not a match
1278:                             		                             break;
1279:                             		                         }
1280:                             		                     }
1281:                             		                 }
1282:                             		             }
1283:              
1284:                             		         } // Attribute match
1285:              
1286:                             		         break;
1287:                             		 }
1288:                          	}
1289:                				#endif
1290:                          } // not found
1291:                          else
1292:                          {
1293:              				#if defined(SUPPORT_LFN)
1294:              					lfnFirstCheck = FALSE;
1295:              				#endif
1296:                              /*** looking for an empty/re-usable entry ***/
1297:                              if ( cmd == LOOK_FOR_EMPTY_ENTRY)
00A052  97EA6F     MOV.B [W15-18], W4
00A054  E00404     CP0.B W4
00A056  3A000B     BRA NZ, 0xA06E
00A058  EB0280     CLR W5
00A05A  370009     BRA 0xA06E
00A05C  2000B5     MOV #0xB, W5
00A05E  370007     BRA 0xA06E
00A060  2000B5     MOV #0xB, W5
00A062  200010     MOV #0x1, W0
00A064  9FAFC0     MOV W0, [W15-40]
00A066  370003     BRA 0xA06E
00A068  2000B5     MOV #0xB, W5
00A06A  EB0080     CLR W1
00A06C  9FAFC1     MOV W1, [W15-40]
1298:                                  statusB = CE_GOOD;
1299:                          } // found or not
1300:              
1301:              			#if defined(SUPPORT_LFN)
1302:              //            if(foundLFN)
1303:              //				fHandle = fHandle + 2;
1304:              //			 	fHandle++;
1305:              //			else
1306:              			#endif
1307:                          	// increment it no matter what happened
1308:                          	fHandle++;
00A06E  97910F     MOV [W15-96], W2
00A070  E80102     INC W2, W2
00A072  9F9782     MOV W2, [W15-96]
1309:              
1310:                      }// while
1311:                  }
1312:              
1313:                  return(statusB);
1314:              } // FILEFind
00A09C  FA003C     LNK #0x3C
00A09E  BE9F88     MOV.D W8, [W15++]
00A0A0  780400     MOV W0, W8
1315:              
1316:              
1317:              /**************************************************************************
1318:                Function:
1319:                  CETYPE FILEopen (FILEOBJ fo, WORD *fHandle, char type)
1320:                Summary:
1321:                  Loads file information from the device
1322:                Conditions:
1323:                  This function should not be called by the user.
1324:                Input:
1325:                  fo -       File to be opened
1326:                  fHandle -  Location of file
1327:                  type -
1328:                       -     FS_WRITE -  Create a new file or replace an existing file
1329:                       -     FS_READ -   Read data from an existing file
1330:                       -     FS_APPEND - Append data to an existing file
1331:                Return Values:
1332:                  CE_GOOD -            FILEopen successful
1333:                  CE_NOT_INIT -        Device is not yet initialized
1334:                  CE_FILE_NOT_FOUND -  Could not find the file on the device
1335:                  CE_BAD_SECTOR_READ - A bad read of a sector occured
1336:                Side Effects:
1337:                  None
1338:                Description:
1339:                  This function will cache a directory entry in the directory specified
1340:                  by the dirclus parameter of hte FSFILE object 'fo.'  The offset of the
1341:                  entry in the directory is specified by fHandle.  Once the directory entry
1342:                  has been loaded, the first sector of the file can be loaded using the
1343:                  cluster value specified in the directory entry. The type argument will
1344:                  specify the mode the files will be opened in.  This will allow this
1345:                  function to set the correct read/write flags for the file.
1346:                Remarks:
1347:                  If the mode the file is being opened in is a plus mode (e.g. FS_READ+) the
1348:                  flags will be modified further in the FSfopen function.
1349:                **************************************************************************/
1350:              
1351:              CETYPE FILEopen (FILEOBJ fo, WORD *fHandle, char type)
1352:              {
1353:                  DISK   *dsk;      //Disk structure
1354:                  BYTE    r;               //Result of search for file
1355:                  DWORD    l;               //lba of first sector of first cluster
1356:                  CETYPE    error = CE_GOOD;
1357:              
1358:                  dsk = (DISK *)(fo->dsk);
009866  780490     MOV [W0], W9
1359:                  if (dsk->mount == FALSE)
009868  906039     MOV.B [W9+35], W0
00986A  20007C     MOV #0x7, W12
00986C  E00400     CP0.B W0
00986E  320051     BRA Z, 0x9912
1360:                  {
1361:                      error = CE_NOT_INIT;
1362:                  }
1363:                  else
1364:                  {
1365:                      // load the sector
1366:                      fo->dirccls = fo->dirclus;
009870  901828     MOV [W8+52], W0
009872  9018B8     MOV [W8+54], W1
009874  981C40     MOV W0, [W8+56]
009876  981C51     MOV W1, [W8+58]
1367:                      // Cache no matter what if it's the first entry
1368:                      if (*fHandle == 0)
009878  78001A     MOV [W10], W0
00987A  E00000     CP0 W0
00987C  320002     BRA Z, 0x9882
1369:                      {
1370:                          if (Cache_File_Entry(fo, fHandle, TRUE) == NULL)
1371:                          {
1372:                              error = CE_BADCACHEREAD;
1373:                          }
1374:                      }
1375:                      else
1376:                      {
1377:                          // If it's not the first, only cache it if it's
1378:                          // not divisible by the number of entries per sector
1379:                          // If it is, Fill_File_Object will cache it
1380:                          if ((*fHandle & 0xf) != 0)
00987E  60006F     AND W0, #0xF, W0
009880  320007     BRA Z, 0x9890
1381:                          {
1382:                              if (Cache_File_Entry (fo, fHandle, TRUE) == NULL)
009882  B3C012     MOV #0x1, W2
009884  78008A     MOV W10, W1
009886  780008     MOV W8, W0
009888  07EE90     RCALL Cache_File_Entry
00988A  2001BC     MOV #0x1B, W12
00988C  E00000     CP0 W0
00988E  320001     BRA Z, 0x9892
009890  EB0600     CLR W12
1383:                              {
1384:                                  error = CE_BADCACHEREAD;
1385:                              }
1386:                          }
1387:                      }
1388:              
1389:                      // Fill up the File Object with the information pointed to by fHandle
1390:                      r = Fill_File_Object(fo, fHandle);
009892  78008A     MOV W10, W1
009894  780008     MOV W8, W0
009896  07FF86     RCALL Fill_File_Object
1391:                      if (r != FOUND)
009898  E00400     CP0.B W0
00989A  320002     BRA Z, 0x98A0
00989C  2000BC     MOV #0xB, W12
00989E  370039     BRA 0x9912
1392:                          error = CE_FILE_NOT_FOUND;
1393:                      else
1394:                      {
1395:                          fo->seek = 0;               // first byte in file
0098A0  B80060     MUL.UU W0, #0, W0
0098A2  980470     MOV W0, [W8+14]
0098A4  980C01     MOV W1, [W8+16]
1396:                          fo->ccls = fo->cluster;     // first cluster
0098A6  900018     MOV [W8+2], W0
0098A8  9000A8     MOV [W8+4], W1
0098AA  980430     MOV W0, [W8+6]
0098AC  980441     MOV W1, [W8+8]
1397:                          fo->sec = 0;                // first sector in the cluster
0098AE  EB0000     CLR W0
0098B0  980450     MOV W0, [W8+10]
1398:                          fo->pos = 0;                // first byte in sector/cluster
0098B2  980460     MOV W0, [W8+12]
1399:              
1400:                          if  ( r == NOT_FOUND)
1401:                          {
1402:                              error = CE_FILE_NOT_FOUND;
1403:                          }
1404:                          else
1405:                          {
1406:                              // Determine the lba of the selected sector and load
1407:                              l = Cluster2Sector(dsk,fo->ccls);
0098B4  900118     MOV [W8+2], W2
0098B6  9001A8     MOV [W8+4], W3
0098B8  780009     MOV W9, W0
0098BA  07EAE5     RCALL Cluster2Sector
0098BC  BE0500     MOV.D W0, W10
1408:              #ifdef ALLOW_WRITES
1409:                              if (gNeedDataWrite)
0098BE  270BB0     MOV #0x70BB, W0
0098C0  E00410     CP0.B [W0]
0098C2  320005     BRA Z, 0x98CE
1410:                                  if (flushData())
0098C4  07EB2F     RCALL flushData
0098C6  E00400     CP0.B W0
0098C8  320002     BRA Z, 0x98CE
0098CA  20009C     MOV #0x9, W12
0098CC  370022     BRA 0x9912
1411:                                      return CE_WRITE_ERROR;
1412:              #endif
1413:                              gBufferOwner = fo;
0098CE  8B8608     MOV W8, gBufferOwner
1414:                              if (gLastDataSectorRead != l)
0098D0  8385E0     MOV gLastDataSectorRead, W0
0098D2  8385F1     MOV 0x70BE, W1
0098D4  500F8A     SUB W0, W10, [W15]
0098D6  588F8B     SUBB W1, W11, [W15]
0098D8  32000D     BRA Z, 0x98F4
1415:                              {
1416:                                  gBufferZeroed = FALSE;
0098DA  270B90     MOV #0x70B9, W0
0098DC  EB4800     CLR.B [W0]
1417:                                  if ( !MDD_SectorRead( l, dsk->buffer))
0098DE  FB8019     ZE [W9], W0
0098E0  904119     MOV.B [W9+1], W2
0098E2  DD1148     SL W2, #8, W2
0098E4  710100     IOR W2, W0, W2
0098E6  BE000A     MOV.D W10, W0
0098E8  071DFC     RCALL MDD_SDSPI_SectorRead
0098EA  E00400     CP0.B W0
0098EC  3A0001     BRA NZ, 0x98F0
0098EE  20008C     MOV #0x8, W12
1418:                                      error = CE_BAD_SECTOR_READ;
1419:                                  gLastDataSectorRead = l;
0098F0  8B85EA     MOV W10, gLastDataSectorRead
0098F2  8B85FB     MOV W11, 0x70BE
1420:                              }
1421:                          } // -- found
1422:              
1423:                          fo->flags.FileWriteEOF = FALSE;
0098F4  9008B8     MOV [W8+22], W1
0098F6  A12001     BCLR W1, #2
0098F8  980C31     MOV W1, [W8+22]
1424:                          // Set flag for operation type
1425:              #ifdef ALLOW_WRITES
1426:                          if ((type == 'w') || (type == 'a'))
0098FA  B3C770     MOV #0x77, W0
0098FC  56CF80     SUB.B W13, W0, [W15]
0098FE  320003     BRA Z, 0x9906
009900  504076     SUB.B W0, #0x16, W0
009902  56CF80     SUB.B W13, W0, [W15]
009904  3A0003     BRA NZ, 0x990C
1427:                          {
1428:                              fo->flags.write = 1;   //write or append
009906  A00001     BSET W1, #0
1429:                              fo->flags.read = 0;
009908  A11001     BCLR W1, #1
00990A  370002     BRA 0x9910
1430:                          }
1431:                          else
1432:                          {
1433:              #endif
1434:                              fo->flags.write = 0;   //read
00990C  A10001     BCLR W1, #0
1435:                              fo->flags.read = 1;
00990E  A01001     BSET W1, #1
009910  980C31     MOV W1, [W8+22]
1436:              #ifdef ALLOW_WRITES
1437:                          } // -- flags
1438:              #endif
1439:                      } // -- r = Found
1440:                  } // -- Mounted
1441:                  return (error);
1442:              } // -- FILEopen
00991C  B0054F     ADD #0x54, W15
00991E  BE9F88     MOV.D W8, [W15++]
009920  BE9F8A     MOV.D W10, [W15++]
009922  BE9F8C     MOV.D W12, [W15++]
009924  781F8E     MOV W14, [W15++]
009926  9FB7D0     MOV W0, [W15-22]
009928  9FB7E1     MOV W1, [W15-20]
00992A  9FEFE2     MOV.B W2, [W15-18]
00992C  9FEFF3     MOV.B W3, [W15-17]
1443:              
1444:              
1445:              /*************************************************************************
1446:                Function:
1447:                  BYTE FILEget_next_cluster(FSFILE *fo, DWORD n)
1448:                Summary:
1449:                  Step through a chain of clusters
1450:                Conditions:
1451:                  None
1452:                Input:
1453:                  fo - The file to get the next cluster of
1454:                  n -  Number of links in the FAT cluster chain to jump through
1455:                Return Values:
1456:                  CE_GOOD - Operation successful
1457:                  CE_BAD_SECTOR_READ - A bad read occured of a sector
1458:                  CE_INVALID_CLUSTER - Invalid cluster value \> maxcls
1459:                  CE_FAT_EOF - Fat attempt to read beyond EOF
1460:                Side Effects:
1461:                  None
1462:                Description:
1463:                  This function will load 'n' proximate clusters for a file from
1464:                  the FAT on the device.  It will stop checking for clusters if the
1465:                  ReadFAT function returns an error, if it reaches the last cluster in
1466:                  a file, or if the device tries to read beyond the last cluster used
1467:                  by the device.
1468:                Remarks:
1469:                  None
1470:                *************************************************************************/
1471:              
1472:              BYTE FILEget_next_cluster(FSFILE *fo, DWORD n)
1473:              {
1474:                  DWORD         c, c2, ClusterFailValue, LastClustervalue;
1475:                  BYTE          error = CE_GOOD;
1476:                  DISK *      disk;
1477:              
1478:                  disk = fo->dsk;
0077B0  780510     MOV [W0], W10
1479:              
1480:                  /* Settings based on FAT type */
1481:                  switch (disk->type)
0077B2  90602A     MOV.B [W10+34], W0
0077B4  504FE1     SUB.B W0, #0x1, [W15]
0077B6  320005     BRA Z, 0x77C2
0077B8  2FFF8C     MOV #0xFFF8, W12
0077BA  20000D     MOV #0x0, W13
0077BC  504FE3     SUB.B W0, #0x3, [W15]
0077BE  3A0003     BRA NZ, 0x77C6
0077C0  37000A     BRA 0x77D6
0077C2  20FF8C     MOV #0xFF8, W12
0077C4  20000D     MOV #0x0, W13
0077C6  2FFFF0     MOV #0xFFFF, W0
0077C8  200001     MOV #0x0, W1
0077CA  9FB7D0     MOV W0, [W15-22]
0077CC  9FB7E1     MOV W1, [W15-20]
0077CE  97B47F     MOV [W15-18], W8
0077D0  97BC8F     MOV [W15-16], W9
0077D2  EB4580     CLR.B W11
0077D4  370005     BRA 0x77E0
0077D6  2FFF8C     MOV #0xFFF8, W12
0077D8  20FFFD     MOV #0xFFF, W13
0077DA  2FFFF0     MOV #0xFFFF, W0
0077DC  20FFF1     MOV #0xFFF, W1
0077DE  37FFF5     BRA 0x77CA
1482:                  {
1483:              #ifdef SUPPORT_FAT32 // If FAT32 supported.
1484:                      case FAT32:
1485:                          LastClustervalue = LAST_CLUSTER_FAT32;
1486:                          ClusterFailValue  = CLUSTER_FAIL_FAT32;
1487:                          break;
1488:              #endif
1489:                      case FAT12:
1490:                          LastClustervalue = LAST_CLUSTER_FAT12;
1491:                          ClusterFailValue  = CLUSTER_FAIL_FAT16;
1492:                          break;
1493:                      case FAT16:
1494:                      default:
1495:                          LastClustervalue = LAST_CLUSTER_FAT16;
1496:                          ClusterFailValue  = CLUSTER_FAIL_FAT16;
1497:                          break;
1498:                  }
1499:              
1500:                  // loop n times
1501:                  do
1502:                  {
1503:                      // get the next cluster link from FAT
1504:                      c2 = fo->ccls;
1505:                      if ( (c = ReadFAT( disk, c2)) == ClusterFailValue)
0077E0  90013E     MOV [W14+6], W2
0077E2  9001CE     MOV [W14+8], W3
0077E4  78000A     MOV W10, W0
0077E6  07FDD1     RCALL ReadFAT
0077E8  BE0200     MOV.D W0, W4
0077EA  97B05F     MOV [W15-22], W0
0077EC  97B0EF     MOV [W15-20], W1
0077EE  520F80     SUB W4, W0, [W15]
0077F0  5A8F81     SUBB W5, W1, [W15]
0077F2  3A0002     BRA NZ, 0x77F8
0077F4  B3C08B     MOV #0x8, W11
0077F6  370014     BRA 0x7820
1506:                          error = CE_BAD_SECTOR_READ;
1507:                      else
1508:                      {
1509:                          // check if cluster value is valid
1510:                          if ( c >= (disk->maxcls + 2))
0077F8  9050CA     MOV.B [W10+20], W1
0077FA  FB8081     ZE W1, W1
0077FC  90505A     MOV.B [W10+21], W0
0077FE  DD0048     SL W0, #8, W0
007800  700101     IOR W0, W1, W2
007802  9050EA     MOV.B [W10+22], W1
007804  FB8081     ZE W1, W1
007806  90507A     MOV.B [W10+23], W0
007808  DD0048     SL W0, #8, W0
00780A  700181     IOR W0, W1, W3
00780C  410162     ADD W2, #0x2, W2
00780E  4981E0     ADDC W3, #0x0, W3
007810  520F82     SUB W4, W2, [W15]
007812  5A8F83     SUBB W5, W3, [W15]
007814  390001     BRA NC, 0x7818
007816  B3C0AB     MOV #0xA, W11
1511:                          {
1512:                              error = CE_INVALID_CLUSTER;
1513:                          }
1514:              
1515:                          // compare against max value of a cluster in FAT
1516:                          // return if eof
1517:                          if ( c >= LastClustervalue)    // check against eof
007818  520F8C     SUB W4, W12, [W15]
00781A  5A8F8D     SUBB W5, W13, [W15]
00781C  390001     BRA NC, 0x7820
00781E  B3C3CB     MOV #0x3C, W11
1518:                          {
1519:                              error = CE_FAT_EOF;
1520:                          }
1521:                      }
1522:              
1523:                      // update the FSFILE structure
1524:                      fo->ccls = c;
007820  980734     MOV W4, [W14+6]
007822  980745     MOV W5, [W14+8]
1525:              
1526:                  } while ((--n > 0) && (error == CE_GOOD));// loop end
007824  540461     SUB W8, #0x1, W8
007826  5C84E0     SUBB W9, #0x0, W9
007828  320002     BRA Z, 0x782E
00782A  E0040B     CP0.B W11
00782C  32FFD9     BRA Z, 0x77E0
00782E  FB800B     ZE W11, W0
1527:              
1528:                  return(error);
1529:              } // get next cluster
00783C  FA0008     LNK #0x8
00783E  BE9F88     MOV.D W8, [W15++]
007840  BE9F8A     MOV.D W10, [W15++]
007842  BE9F8C     MOV.D W12, [W15++]
007844  BE0500     MOV.D W0, W10
007846  780682     MOV W2, W13
1530:              
1531:              
1532:              /**************************************************************************
1533:                Function:
1534:                  BYTE DISKmount ( DISK *dsk)
1535:                Summary:
1536:                  Initialies the device and loads MBR and boot sector information
1537:                Conditions:
1538:                  This function should not be called by the user.
1539:                Input:
1540:                  dsk -  The disk structure to be initialized.
1541:                Return Values:
1542:                  CE_GOOD -       Disk mounted
1543:                  CE_INIT_ERROR - Initialization error has occured
1544:                  CE_UNSUPPORTED_SECTOR_SIZE - Media sector size bigger than
1545:                              MEDIA_SECTOR_SIZE as defined in FSconfig.h.
1546:                Side Effects:
1547:                  None
1548:                Description:
1549:                  This function will use the function pointed to by the MDD_MediaInitialize
1550:                  function pointer to initialize the device (if any initialization is
1551:                  required).  It then attempts to load the master boot record with the
1552:                  LoadMBR function and the boot sector with the LoadBootSector function.
1553:                  These two functions will be used to initialize a global DISK structure
1554:                  that will be used when accessing file information in the future.
1555:                Remarks:
1556:                  None
1557:                **************************************************************************/
1558:              
1559:              BYTE DISKmount( DISK *dsk)
1560:              {
1561:                  BYTE                error = CE_GOOD;
1562:                  MEDIA_INFORMATION   *mediaInformation;
1563:              
1564:                  dsk->mount = FALSE; // default invalid
008EB6  EB4480     CLR.B W9
008EB8  986039     MOV.B W9, [W0+35]
1565:                  dsk->buffer = gDataBuffer;    // assign buffer
008EBA  26A980     MOV #0x6A98, W0
008EBC  784C00     MOV.B W0, [W8]
008EBE  DE0048     LSR W0, #8, W0
008EC0  984410     MOV.B W0, [W8+1]
1566:              
1567:                  // Initialize the device
1568:                  mediaInformation = MDD_MediaInitialize();
008EC2  07245B     RCALL MDD_SDSPI_MediaInitialize
008EC4  780100     MOV W0, W2
1569:                  if (mediaInformation->errorCode != MEDIA_NO_ERROR)
008EC6  E00410     CP0.B [W0]
008EC8  320004     BRA Z, 0x8ED2
1570:                  {
1571:                      error = CE_INIT_ERROR;
1572:                      FSerrno = CE_INIT_ERROR;
008ECA  B3C061     MOV #0x6, W1
008ECC  249380     MOV #0x4938, W0
008ECE  784801     MOV.B W1, [W0]
008ED0  37001F     BRA 0x8F10
1573:                  }
1574:                  else
1575:                  {
1576:                      // If the media initialization routine determined the sector size,
1577:                      // check it and make sure we can support it.
1578:                      if (mediaInformation->validityFlags.bits.sectorSize)
008ED2  201000     MOV #0x100, W0
008ED4  600012     AND W0, [W2], W0
008ED6  320010     BRA Z, 0x8EF8
1579:                      {
1580:              			dsk->sectorSize = mediaInformation->sectorSize;
008ED8  900012     MOV [W2+2], W0
008EDA  200001     MOV #0x0, W1
008EDC  985C00     MOV.B W0, [W8+24]
008EDE  DE0048     LSR W0, #8, W0
008EE0  985C10     MOV.B W0, [W8+25]
008EE2  985C29     MOV.B W9, [W8+26]
008EE4  985C39     MOV.B W9, [W8+27]
1581:                          if (mediaInformation->sectorSize > MEDIA_SECTOR_SIZE)
008EE6  900092     MOV [W2+2], W1
008EE8  202000     MOV #0x200, W0
008EEA  508F80     SUB W1, W0, [W15]
008EEC  360005     BRA LEU, 0x8EF8
1582:                          {
1583:                              error = CE_UNSUPPORTED_SECTOR_SIZE;
1584:                              FSerrno = CE_UNSUPPORTED_SECTOR_SIZE;
008EEE  B3C211     MOV #0x21, W1
008EF0  249380     MOV #0x4938, W0
008EF2  784801     MOV.B W1, [W0]
008EF4  200210     MOV #0x21, W0
008EF6  37000D     BRA 0x8F12
1585:                              return error;
1586:                          }
1587:                      }
1588:              
1589:                      // Load the Master Boot Record (partition)
1590:                      if((error = LoadMBR(dsk)) == CE_GOOD)
008EF8  780008     MOV W8, W0
008EFA  07FDC0     RCALL LoadMBR
008EFC  784080     MOV.B W0, W1
008EFE  E00400     CP0.B W0
008F00  3A0007     BRA NZ, 0x8F10
1591:                      {
1592:                          // Now the boot sector
1593:                          if((error = LoadBootSector(dsk)) == CE_GOOD)
008F02  780008     MOV W8, W0
008F04  07FE46     RCALL LoadBootSector
008F06  784080     MOV.B W0, W1
008F08  E00400     CP0.B W0
008F0A  3A0002     BRA NZ, 0x8F10
1594:                              dsk->mount = TRUE; // Mark that the DISK mounted successfully
008F0C  B3C010     MOV #0x1, W0
008F0E  986430     MOV.B W0, [W8+35]
1595:                      }
1596:                  } // -- Load file parameters
1597:              
1598:                  return(error);
008F10  FB8001     ZE W1, W0
1599:              } // -- mount
1600:              
1601:              
1602:              
1603:              /********************************************************************
1604:                Function:
1605:                  CETYPE LoadMBR ( DISK *dsk)
1606:                Summary:
1607:                  Loads the MBR and extracts necessary information
1608:                Conditions:
1609:                  This function should not be called by the user.
1610:                Input:
1611:                  dsk -  The disk containing the master boot record to be loaded
1612:                Return Values:
1613:                  CE_GOOD -            MBR loaded successfully
1614:                  CE_BAD_SECTOR_READ - A bad read occured of a sector
1615:                  CE_BAD_PARTITION -   The boot record is bad
1616:                Side Effects:
1617:                  None
1618:                Description:
1619:                  The LoadMBR function will use the function pointed to by the
1620:                  MDD_SectorRead function pointer to read the 0 sector from the
1621:                  device.  If a valid boot signature is obtained, this function
1622:                  will compare fields in that cached sector to the values that
1623:                  would be present if that sector was a boot sector.  If all of
1624:                  those values match, it will be assumed that the device does not
1625:                  have a master boot record and the 0 sector is actually the boot
1626:                  sector.  Otherwise, data about the partition and the actual
1627:                  location of the boot sector will be loaded from the MBR into
1628:                  the DISK structure pointed to by 'dsk.'
1629:                Remarks:
1630:                  None
1631:                ********************************************************************/
1632:              
1633:              BYTE LoadMBR(DISK *dsk)
1634:              {
1635:                  PT_MBR  Partition;
1636:                  BYTE error = CE_GOOD;
1637:                  BYTE type;
1638:                  BootSec BSec;
1639:              
1640:                  // Get the partition table from the MBR
1641:                  if ( MDD_SectorRead( FO_MBR, dsk->buffer) != TRUE)
008A80  FB8010     ZE [W0], W0
008A82  904118     MOV.B [W8+1], W2
008A84  DD1148     SL W2, #8, W2
008A86  710100     IOR W2, W0, W2
008A88  B80060     MUL.UU W0, #0, W0
008A8A  07252B     RCALL MDD_SDSPI_SectorRead
008A8E  504FE1     SUB.B W0, #0x1, [W15]
008A90  3A007B     BRA NZ, 0x8B88
1642:                  {
1643:                      error = CE_BAD_SECTOR_READ;
1644:                      FSerrno = CE_BAD_SECTOR_READ;
008A8C  B3C081     MOV #0x8, W1
1645:                  }
1646:                  else
1647:                  {
1648:                      // Check if the card has no MBR
1649:                      BSec = (BootSec) dsk->buffer;
008A92  FB8098     ZE [W8], W1
008A94  904018     MOV.B [W8+1], W0
008A96  DD0048     SL W0, #8, W0
008A98  700101     IOR W0, W1, W2
1650:              
1651:                      if((BSec->Signature0 == FAT_GOOD_SIGN_0) && (BSec->Signature1 == FAT_GOOD_SIGN_1))
008A9A  93F8E2     MOV.B [W2+510], W1
008A9C  B3C550     MOV #0x55, W0
008A9E  50CF80     SUB.B W1, W0, [W15]
008AA0  3A003B     BRA NZ, 0x8B18
008AA2  93F8F2     MOV.B [W2+511], W1
008AA4  B3CAA0     MOV #0xAA, W0
008AA6  50CF80     SUB.B W1, W0, [W15]
008AA8  3A0037     BRA NZ, 0x8B18
1652:                      {
1653:                       // Technically, the OEM name is not for indication
1654:                       // The alternative is to read the CIS from attribute
1655:                       // memory.  See the PCMCIA metaformat for more details
1656:              #if defined (__C30__) || defined (__PIC32MX__)
1657:                          if ((ReadByte( dsk->buffer, BSI_FSTYPE ) == 'F') && \
008AAA  9070E2     MOV.B [W2+54], W1
008AAC  B3C460     MOV #0x46, W0
008AAE  50CF80     SUB.B W1, W0, [W15]
008AB0  3A0016     BRA NZ, 0x8ADE
008AB2  9070F2     MOV.B [W2+55], W1
008AB4  504065     SUB.B W0, #0x5, W0
008AB6  50CF80     SUB.B W1, W0, [W15]
008AB8  3A0012     BRA NZ, 0x8ADE
008ABA  907882     MOV.B [W2+56], W1
008ABC  404073     ADD.B W0, #0x13, W0
008ABE  50CF80     SUB.B W1, W0, [W15]
008AC0  3A000E     BRA NZ, 0x8ADE
008AC2  907892     MOV.B [W2+57], W1
008AC4  B3C310     MOV #0x31, W0
008AC6  50CF80     SUB.B W1, W0, [W15]
008AC8  3A000A     BRA NZ, 0x8ADE
008ACA  9060E2     MOV.B [W2+38], W1
008ACC  504068     SUB.B W0, #0x8, W0
008ACE  50CF80     SUB.B W1, W0, [W15]
008AD0  3A0006     BRA NZ, 0x8ADE
1658:                          (ReadByte( dsk->buffer, BSI_FSTYPE + 1 ) == 'A') && \
1659:                          (ReadByte( dsk->buffer, BSI_FSTYPE + 2 ) == 'T') && \
1660:                          (ReadByte( dsk->buffer, BSI_FSTYPE + 3 ) == '1') && \
1661:                          (ReadByte( dsk->buffer, BSI_BOOTSIG) == 0x29))
1662:              #else
1663:                          if ((BSec->FAT.FAT_16.BootSec_FSType[0] == 'F') && \
1664:                              (BSec->FAT.FAT_16.BootSec_FSType[1] == 'A') && \
1665:                              (BSec->FAT.FAT_16.BootSec_FSType[2] == 'T') && \
1666:                              (BSec->FAT.FAT_16.BootSec_FSType[3] == '1') && \
1667:                              (BSec->FAT.FAT_16.BootSec_BootSig == 0x29))
1668:              #endif
1669:                           {
1670:                              dsk->firsts = 0;
008AD2  EB4000     CLR.B W0
008AD4  984420     MOV.B W0, [W8+2]
008AD6  984430     MOV.B W0, [W8+3]
008AD8  984440     MOV.B W0, [W8+4]
008ADA  984450     MOV.B W0, [W8+5]
008ADC  37004B     BRA 0x8B74
1671:                              dsk->type = FAT16;
1672:                              return CE_GOOD;
1673:                           }
1674:                           else
1675:                           {
1676:              #if defined (__C30__) || defined (__PIC32MX__)
1677:                              if ((ReadByte( dsk->buffer, BSI_FAT32_FSTYPE ) == 'F') && \
008ADE  90D0A2     MOV.B [W2+82], W1
008AE0  B3C460     MOV #0x46, W0
008AE2  50CF80     SUB.B W1, W0, [W15]
008AE4  3A0019     BRA NZ, 0x8B18
008AE6  90D0B2     MOV.B [W2+83], W1
008AE8  504065     SUB.B W0, #0x5, W0
008AEA  50CF80     SUB.B W1, W0, [W15]
008AEC  3A0015     BRA NZ, 0x8B18
008AEE  90D0C2     MOV.B [W2+84], W1
008AF0  404073     ADD.B W0, #0x13, W0
008AF2  50CF80     SUB.B W1, W0, [W15]
008AF4  3A0011     BRA NZ, 0x8B18
008AF6  90D0D2     MOV.B [W2+85], W1
008AF8  B3C330     MOV #0x33, W0
008AFA  50CF80     SUB.B W1, W0, [W15]
008AFC  3A000D     BRA NZ, 0x8B18
008AFE  90C0A2     MOV.B [W2+66], W1
008B00  50406A     SUB.B W0, #0xA, W0
008B02  50CF80     SUB.B W1, W0, [W15]
008B04  3A0009     BRA NZ, 0x8B18
1678:                                  (ReadByte( dsk->buffer, BSI_FAT32_FSTYPE + 1 ) == 'A') && \
1679:                                  (ReadByte( dsk->buffer, BSI_FAT32_FSTYPE + 2 ) == 'T') && \
1680:                                  (ReadByte( dsk->buffer, BSI_FAT32_FSTYPE + 3 ) == '3') && \
1681:                                  (ReadByte( dsk->buffer, BSI_FAT32_BOOTSIG) == 0x29))
1682:              #else
1683:                              if ((BSec->FAT.FAT_32.BootSec_FilSysType[0] == 'F') && \
1684:                                  (BSec->FAT.FAT_32.BootSec_FilSysType[1] == 'A') && \
1685:                                  (BSec->FAT.FAT_32.BootSec_FilSysType[2] == 'T') && \
1686:                                  (BSec->FAT.FAT_32.BootSec_FilSysType[3] == '3') && \
1687:                                  (BSec->FAT.FAT_32.BootSec_BootSig == 0x29))
1688:              #endif
1689:                              {
1690:                                  dsk->firsts = 0;
008B06  EB4000     CLR.B W0
008B08  984420     MOV.B W0, [W8+2]
008B0A  984430     MOV.B W0, [W8+3]
008B0C  984440     MOV.B W0, [W8+4]
008B0E  984450     MOV.B W0, [W8+5]
1691:                                  dsk->type = FAT32;
008B10  B3C030     MOV #0x3, W0
008B12  986420     MOV.B W0, [W8+34]
008B14  EB0000     CLR W0
008B16  37003B     BRA 0x8B8E
1692:                                  return CE_GOOD;
1693:                              }
1694:                          }
1695:                      }
1696:                      // assign it the partition table strucutre
1697:                      Partition = (PT_MBR)dsk->buffer;
1698:              
1699:                      // Ensure its good
1700:                      if((Partition->Signature0 != FAT_GOOD_SIGN_0) || (Partition->Signature1 != FAT_GOOD_SIGN_1))
008B18  93F8E2     MOV.B [W2+510], W1
008B1A  B3C550     MOV #0x55, W0
008B1C  50CF80     SUB.B W1, W0, [W15]
008B1E  3A0004     BRA NZ, 0x8B28
008B20  93F8F2     MOV.B [W2+511], W1
008B22  B3CAA0     MOV #0xAA, W0
008B24  50CF80     SUB.B W1, W0, [W15]
008B26  320002     BRA Z, 0x8B2C
1701:                      {
1702:                          FSerrno = CE_BAD_PARTITION;
008B28  B3C041     MOV #0x4, W1
008B2A  37002E     BRA 0x8B88
1703:                          error = CE_BAD_PARTITION;
1704:                      }
1705:                      else
1706:                      {
1707:                          BYTE i;
1708:                          PTE_MBR* partitionEntry = &Partition->Partition0;
008B2C  B3C045     MOV #0x4, W5
008B2E  201C24     MOV #0x1C2, W4
008B30  420202     ADD W4, W2, W4
1709:              
1710:                          for(i=0; i<4; i++)
008B84  3AFFD6     BRA NZ, 0x8B32
1711:                          {                
1712:                              /*    Valid Master Boot Record Loaded   */
1713:              
1714:                              // Get the 32 bit offset to the first partition
1715:                              dsk->firsts = partitionEntry->PTE_FrstSect;
008B32  9040C4     MOV.B [W4+4], W1
008B34  FB8081     ZE W1, W1
008B36  904054     MOV.B [W4+5], W0
008B38  DD0048     SL W0, #8, W0
008B3A  700101     IOR W0, W1, W2
008B3C  9040E4     MOV.B [W4+6], W1
008B3E  FB8081     ZE W1, W1
008B40  904074     MOV.B [W4+7], W0
008B42  DD0048     SL W0, #8, W0
008B44  700181     IOR W0, W1, W3
008B46  984422     MOV.B W2, [W8+2]
008B48  DE1048     LSR W2, #8, W0
008B4A  984430     MOV.B W0, [W8+3]
008B4C  984443     MOV.B W3, [W8+4]
008B4E  DE1848     LSR W3, #8, W0
008B50  984450     MOV.B W0, [W8+5]
1716:              
1717:                              // check if the partition type is acceptable
1718:                                type = partitionEntry->PTE_FSDesc;
1719:              
1720:                              switch (type)
008B52  784014     MOV.B [W4], W0
008B54  504FEE     SUB.B W0, #0xE, [W15]
008B56  3E0014     BRA GTU, 0x8B80
008B58  FB0000     SE W0, W0
008B5A  200013     MOV #0x1, W3
008B5C  DD1880     SL W3, W0, W1
008B5E  240500     MOV #0x4050, W0
008B60  608000     AND W1, W0, W0
008B62  3A0008     BRA NZ, 0x8B74
008B64  608162     AND W1, #0x2, W2
008B66  3A0004     BRA NZ, 0x8B70
008B68  218000     MOV #0x1800, W0
008B6A  608000     AND W1, W0, W0
008B6C  3A0005     BRA NZ, 0x8B78
008B6E  370008     BRA 0x8B80
1721:                              {
1722:                                  case 0x01:
1723:                                      dsk->type = FAT12;
008B70  986423     MOV.B W3, [W8+34]
008B72  370006     BRA 0x8B80
1724:                                      break;
1725:              
1726:                              case 0x04:
1727:                                  case 0x06:
1728:                                  case 0x0E:
1729:                                      dsk->type = FAT16;
008B74  B3C020     MOV #0x2, W0
008B76  37FFCD     BRA 0x8B12
1730:                                      return(error);
1731:              
1732:                                  case 0x0B:
1733:                                  case 0x0C:
1734:                                      #ifdef SUPPORT_FAT32 // If FAT32 supported.
1735:                                          dsk->type = FAT32;    // FAT32 is supported too
008B78  B3C030     MOV #0x3, W0
008B7A  986420     MOV.B W0, [W8+34]
008B7C  780002     MOV W2, W0
008B7E  370007     BRA 0x8B8E
1736:                                          return(error);
1737:                                      #endif
1738:                              } // switch
1739:              
1740:                              /* If we are here, we didn't find a matching partition.  We
1741:                                 should increment to the next partition table entry */
1742:                              partitionEntry++;
008B80  420270     ADD W4, #0x10, W4
008B82  E94285     DEC.B W5, W5
1743:                          }
1744:              
1745:                          FSerrno = CE_UNSUPPORTED_FS;
008B86  B3C051     MOV #0x5, W1
008B88  249380     MOV #0x4938, W0
008B8A  784801     MOV.B W1, [W0]
1746:                          error = CE_UNSUPPORTED_FS;
1747:                      }
1748:                  }
1749:              
1750:                  return(error);
008B8C  FB8001     ZE W1, W0
1751:              }// -- LoadMBR
008B92  4787F4     ADD W15, #0x14, W15
008B94  BE9F88     MOV.D W8, [W15++]
008B96  BE9F8A     MOV.D W10, [W15++]
008B98  BE9F8C     MOV.D W12, [W15++]
008B9A  781F8E     MOV W14, [W15++]
008B9C  780500     MOV W0, W10
1752:              
1753:              
1754:              /**************************************************************************
1755:                Function:
1756:                  BYTE LoadBootSector (DISK *dsk)
1757:                Summary:
1758:                  Load the boot sector and extract the necessary information
1759:                Conditions:
1760:                  This function should not be called by the user.
1761:                Input:
1762:                  dsk -  The disk containing the boot sector
1763:                Return Values:
1764:                  CE_GOOD -                    Boot sector loaded
1765:                  CE_BAD_SECTOR_READ -         A bad read occured of a sector
1766:                  CE_NOT_FORMATTED -           The disk is of an unsupported format
1767:                  CE_CARDFAT32 -               FAT 32 device not supported
1768:                  CE_UNSUPPORTED_SECTOR_SIZE - The sector size is not supported
1769:                Side Effects:
1770:                  None
1771:                Description:
1772:                  LoadBootSector will use the function pointed to by the MDD_SectorWrite
1773:                  function pointer to load the boot sector, whose location was obtained
1774:                  by a previous call of LoadMBR.  If the boot sector is loaded successfully,
1775:                  partition information will be calcualted from it and copied into the DISK
1776:                  structure pointed to by 'dsk.'
1777:                Remarks:
1778:                  None
1779:                **************************************************************************/
1780:              
1781:              
1782:              BYTE LoadBootSector(DISK *dsk)
1783:              {
1784:                  DWORD       RootDirSectors;
1785:                  DWORD       TotSec,DataSec;
1786:                  BYTE        error = CE_GOOD;
1787:                  BootSec     BSec;
1788:                  WORD        BytesPerSec;
1789:                  WORD        ReservedSectorCount;
1790:              
1791:                  #if defined(SUPPORT_FAT32)
1792:                  BOOL        TriedSpecifiedBackupBootSec = FALSE;
1793:                  BOOL        TriedBackupBootSecAtAddress6 = FALSE;
1794:                  #endif
1795:                  // Get the Boot sector
1796:                  if ( MDD_SectorRead( dsk->firsts, dsk->buffer) != TRUE)
008B9E  FB8010     ZE [W0], W0
008BA0  90411A     MOV.B [W10+1], W2
008BA2  DD1148     SL W2, #8, W2
008BA4  710100     IOR W2, W0, W2
008BA6  90422A     MOV.B [W10+2], W4
008BA8  FB8204     ZE W4, W4
008BAA  9041BA     MOV.B [W10+3], W3
008BAC  DD19C8     SL W3, #8, W3
008BAE  718004     IOR W3, W4, W0
008BB0  90424A     MOV.B [W10+4], W4
008BB2  FB8204     ZE W4, W4
008BB4  9041DA     MOV.B [W10+5], W3
008BB6  DD19C8     SL W3, #8, W3
008BB8  718084     IOR W3, W4, W1
008BBA  072493     RCALL MDD_SDSPI_SectorRead
008BBE  504FE1     SUB.B W0, #0x1, [W15]
008BC0  3A016F     BRA NZ, 0x8EA0
1797:                  {
1798:                      error = CE_BAD_SECTOR_READ;
1799:                  }
1800:                  else
1801:                  {
1802:                      BSec = (BootSec)dsk->buffer;
008BC2  FB809A     ZE [W10], W1
008BC4  90401A     MOV.B [W10+1], W0
008BC6  DD0048     SL W0, #8, W0
008BC8  700581     IOR W0, W1, W11
008BCA  EB0000     CLR W0
008BCC  9FB790     MOV W0, [W15-30]
008BCE  780080     MOV W0, W1
008BD0  370160     BRA 0x8E92
008BD2  200012     MOV #0x1, W2
008BD4  9FB792     MOV W2, [W15-30]
1803:              
1804:                      do      //test each possible boot sector (FAT32 can have backup boot sectors)
1805:                      {
1806:              
1807:                          //Verify the Boot Sector has a valid signature
1808:                          if(    (BSec->Signature0 != FAT_GOOD_SIGN_0)
008BD6  93F8EB     MOV.B [W11+510], W1
008BD8  B3C550     MOV #0x55, W0
008BDA  50CF80     SUB.B W1, W0, [W15]
008BDC  3A00E7     BRA NZ, 0x8DAC
008BDE  93F8FB     MOV.B [W11+511], W1
008BE0  B3CAA0     MOV #0xAA, W0
008BE2  50CF80     SUB.B W1, W0, [W15]
008BE4  3A00E3     BRA NZ, 0x8DAC
1809:                              || (BSec->Signature1 != FAT_GOOD_SIGN_1)
1810:                            )
1811:                          {
1812:                              error = CE_NOT_FORMATTED;
1813:                          }
1814:                          else   
1815:                          {
1816:              
1817:                              do      //loop just to allow a break to jump out of this section of code
1818:                              {
1819:                                  #ifdef __18CXX
1820:                                  // Load count of sectors per cluster
1821:                                  dsk->SecPerClus = BSec->FAT.FAT_16.BootSec_SPC;
1822:                                  // Load the sector number of the first FAT sector
1823:                                  dsk->fat        = dsk->firsts + BSec->FAT.FAT_16.BootSec_ResrvSec;
1824:                                  // Load the count of FAT tables
1825:                                  dsk->fatcopy    = BSec->FAT.FAT_16.BootSec_FATCount;
1826:                                  // Load the size of the FATs
1827:                                  dsk->fatsize = BSec->FAT.FAT_16.BootSec_SPF;
1828:                                  if(dsk->fatsize == 0)
1829:                                      dsk->fatsize  = BSec->FAT.FAT_32.BootSec_FATSz32;
1830:                                  // Calculate the location of the root sector (for FAT12/16)
1831:                                  dsk->root = dsk->fat + (DWORD)(dsk->fatcopy * (DWORD)dsk->fatsize);
1832:                                  // Determine the max size of the root (will be 0 for FAT32)
1833:                                  dsk->maxroot    = BSec->FAT.FAT_16.BootSec_RootDirEnts;
1834:                  
1835:                                  // Determine the total number of sectors in the partition
1836:                                  if(BSec->FAT.FAT_16.BootSec_TotSec16 != 0)
1837:                                  {
1838:                                      TotSec = BSec->FAT.FAT_16.BootSec_TotSec16;
1839:                                  }
1840:                                  else
1841:                                  {
1842:                                      TotSec = BSec->FAT.FAT_16.BootSec_TotSec32;
1843:                                  }
1844:                  
1845:                                  // Calculate the number of bytes in each sector
1846:                                  BytesPerSec = BSec->FAT.FAT_16.BootSec_BPS;
1847:                                  if( (BytesPerSec == 0) || ((BytesPerSec & 1) == 1) )
1848:                                  {
1849:                                      error = CE_UNSUPPORTED_SECTOR_SIZE;
1850:                                      break;  //break out of the do while loop
1851:                                  }
1852:                  
1853:                                  // Calculate the number of sectors in the root (will be 0 for FAT32)
1854:                                  RootDirSectors = ((BSec->FAT.FAT_16.BootSec_RootDirEnts * 32) + (BSec->FAT.FAT_16.BootSec_BPS - 1)) / BSec->FAT.FAT_16.BootSec_BPS;
1855:                                  // Calculate the number of data sectors on the card
1856:                                  DataSec = TotSec - (dsk->root + RootDirSectors);
1857:                                  // Calculate the maximum number of clusters on the card
1858:                                  dsk->maxcls = DataSec / dsk->SecPerClus;
1859:                  
1860:                                  #else // PIC24/30/33
1861:                  
1862:                                  // Read the count of reserved sectors
1863:                                  ReservedSectorCount = ReadWord( dsk->buffer, BSI_RESRVSEC );
008BE6  FB809A     ZE [W10], W1
008BE8  90401A     MOV.B [W10+1], W0
008BEA  DD0048     SL W0, #8, W0
008BEC  700401     IOR W0, W1, W8
008BEE  2000E1     MOV #0xE, W1
008BF0  780008     MOV W8, W0
008BF2  07F176     RCALL ReadWord
1864:                                  // Load the count of sectors per cluster
1865:                                  dsk->SecPerClus = ReadByte( dsk->buffer, BSI_SPC );
008BF4  9049D8     MOV.B [W8+13], W3
008BF6  986513     MOV.B W3, [W10+33]
1866:                                  // Load the sector number of the first FAT sector
1867:                                  dsk->fat = dsk->firsts + ReservedSectorCount;
008BF8  B80161     MUL.UU W0, #1, W2
008BFA  9FB7C2     MOV W2, [W15-24]
008BFC  9FB7D3     MOV W3, [W15-22]
008BFE  9041AA     MOV.B [W10+2], W3
008C00  FB8183     ZE W3, W3
008C02  90413A     MOV.B [W10+3], W2
008C04  DD1148     SL W2, #8, W2
008C06  710003     IOR W2, W3, W0
008C08  9041CA     MOV.B [W10+4], W3
008C0A  FB8183     ZE W3, W3
008C0C  90415A     MOV.B [W10+5], W2
008C0E  DD1148     SL W2, #8, W2
008C10  710083     IOR W2, W3, W1
008C12  97B14F     MOV [W15-24], W2
008C14  97B1DF     MOV [W15-22], W3
008C16  410000     ADD W2, W0, W0
008C18  498081     ADDC W3, W1, W1
008C1A  984560     MOV.B W0, [W10+6]
008C1C  DE0148     LSR W0, #8, W2
008C1E  984572     MOV.B W2, [W10+7]
008C20  984D01     MOV.B W1, [W10+8]
008C22  DE0848     LSR W1, #8, W0
008C24  984D10     MOV.B W0, [W10+9]
1868:                                  // Load the count of FAT tables
1869:                                  dsk->fatcopy    = ReadByte( dsk->buffer, BSI_FATCOUNT );
008C26  905188     MOV.B [W8+16], W3
008C28  986503     MOV.B W3, [W10+32]
1870:                                  // Load the size of the FATs
1871:                                  dsk->fatsize = ReadWord( dsk->buffer, BSI_SPF );
008C2A  200161     MOV #0x16, W1
008C2C  780008     MOV W8, W0
008C2E  07F158     RCALL ReadWord
008C30  B80161     MUL.UU W0, #1, W2
008C32  985D42     MOV.B W2, [W10+28]
008C34  DE1148     LSR W2, #8, W2
008C36  985D52     MOV.B W2, [W10+29]
008C38  EB0080     CLR W1
008C3A  985D61     MOV.B W1, [W10+30]
008C3C  985D71     MOV.B W1, [W10+31]
1872:                                  if(dsk->fatsize == 0)
008C3E  E00000     CP0 W0
008C40  3A0009     BRA NZ, 0x8C54
1873:                                      dsk->fatsize  = ReadDWord( dsk->buffer, BSI_FATSZ32 );
008C42  200241     MOV #0x24, W1
008C44  780008     MOV W8, W0
008C46  07F152     RCALL ReadDWord
008C48  985D40     MOV.B W0, [W10+28]
008C4A  DE0148     LSR W0, #8, W2
008C4C  985D52     MOV.B W2, [W10+29]
008C4E  985D61     MOV.B W1, [W10+30]
008C50  DE0848     LSR W1, #8, W0
008C52  985D70     MOV.B W0, [W10+31]
1874:                                  // Calculate the location of the root sector (for FAT12/16)
1875:                                  dsk->root = dsk->fat + (DWORD)(dsk->fatcopy * (DWORD)dsk->fatsize);
008C54  9040EA     MOV.B [W10+6], W1
008C56  FB8081     ZE W1, W1
008C58  90407A     MOV.B [W10+7], W0
008C5A  DD0048     SL W0, #8, W0
008C5C  700401     IOR W0, W1, W8
008C5E  90488A     MOV.B [W10+8], W1
008C60  FB8081     ZE W1, W1
008C62  90481A     MOV.B [W10+9], W0
008C64  DD0048     SL W0, #8, W0
008C66  700481     IOR W0, W1, W9
008C68  90600A     MOV.B [W10+32], W0
008C6A  FB8100     ZE W0, W2
008C6C  200003     MOV #0x0, W3
008C6E  9FB7E2     MOV W2, [W15-20]
008C70  9FB7F3     MOV W3, [W15-18]
008C72  9058CA     MOV.B [W10+28], W1
008C74  FB8081     ZE W1, W1
008C76  90585A     MOV.B [W10+29], W0
008C78  DD0048     SL W0, #8, W0
008C7A  700001     IOR W0, W1, W0
008C7C  9FBF80     MOV W0, [W15-16]
008C7E  780100     MOV W0, W2
008C80  9058EA     MOV.B [W10+30], W1
008C82  FB8081     ZE W1, W1
008C84  90587A     MOV.B [W10+31], W0
008C86  DD0048     SL W0, #8, W0
008C88  700701     IOR W0, W1, W14
008C8A  78018E     MOV W14, W3
008C8C  97B06F     MOV [W15-20], W0
008C8E  97B0FF     MOV [W15-18], W1
008C90  07E398     RCALL __mulp32eds3
008C92  400408     ADD W0, W8, W8
008C94  488489     ADDC W1, W9, W9
008C96  984D28     MOV.B W8, [W10+10]
008C98  DE4048     LSR W8, #8, W0
008C9A  984D30     MOV.B W0, [W10+11]
008C9C  984D49     MOV.B W9, [W10+12]
008C9E  DE4848     LSR W9, #8, W0
008CA0  984D50     MOV.B W0, [W10+13]
1876:                                  // Determine the max size of the root (will be 0 for FAT32)
1877:                                  dsk->maxroot = ReadWord( dsk->buffer, BSI_ROOTDIRENTS );
008CA2  FB809A     ZE [W10], W1
008CA4  90401A     MOV.B [W10+1], W0
008CA6  DD0048     SL W0, #8, W0
008CA8  700401     IOR W0, W1, W8
008CAA  200111     MOV #0x11, W1
008CAC  780008     MOV W8, W0
008CAE  07F118     RCALL ReadWord
008CB0  780480     MOV W0, W9
008CB2  985520     MOV.B W0, [W10+18]
008CB4  DE0048     LSR W0, #8, W0
008CB6  985530     MOV.B W0, [W10+19]
1878:                  
1879:                                  // Determine the total number of sectors in the partition
1880:                                  TotSec = ReadWord( dsk->buffer, BSI_TOTSEC16 );
008CB8  200131     MOV #0x13, W1
008CBA  780008     MOV W8, W0
008CBC  07F111     RCALL ReadWord
008CBE  B80661     MUL.UU W0, #1, W12
1881:                                  if( TotSec == 0 )
008CC0  E00000     CP0 W0
008CC2  3A0004     BRA NZ, 0x8CCC
1882:                                      TotSec = ReadDWord( dsk->buffer, BSI_TOTSEC32 );
008CC4  200201     MOV #0x20, W1
008CC6  780008     MOV W8, W0
008CC8  07F111     RCALL ReadDWord
008CCA  BE0600     MOV.D W0, W12
1883:                  
1884:                                  // Calculate the number of bytes in each sector
1885:                                  BytesPerSec = ReadWord( dsk->buffer, BSI_BPS );
008CCC  2000B1     MOV #0xB, W1
008CCE  780008     MOV W8, W0
008CD0  07F107     RCALL ReadWord
008CD2  780400     MOV W0, W8
1886:                                  if( (BytesPerSec == 0) || ((BytesPerSec & 1) == 1) )
008CD4  E00000     CP0 W0
008CD6  32006C     BRA Z, 0x8DB0
008CD8  A30800     BTST.Z W0, #0
008CDA  3A006A     BRA NZ, 0x8DB0
1887:                                  {
1888:                                      error = CE_UNSUPPORTED_SECTOR_SIZE;
1889:                                      break;
1890:                                  }
1891:                  
1892:                                  // Calculate the number of sectors in the root (will be 0 for FAT32)
1893:                                  RootDirSectors = ((dsk->maxroot * NUMBER_OF_BYTES_IN_DIR_ENTRY) + (BytesPerSec - 1)) / BytesPerSec;
008CDC  DD4845     SL W9, #5, W0
008CDE  400008     ADD W0, W8, W0
008CE0  E90000     DEC W0, W0
008CE2  090011     REPEAT #0x11
008CE4  D88008     DIV.UW W0, W8
008CE6  B80161     MUL.UU W0, #1, W2
008CE8  9FB7A2     MOV W2, [W15-28]
008CEA  9FB7B3     MOV W3, [W15-26]
1894:                                  // Calculate the number of data sectors on the card
1895:                                  DataSec = TotSec - (ReservedSectorCount + (dsk->fatcopy * dsk->fatsize )  + RootDirSectors);
1896:                                  // Calculate the maximum number of clusters on the card
1897:                                  dsk->maxcls = DataSec / dsk->SecPerClus;
008CEC  97B90F     MOV [W15-16], W2
008CEE  78018E     MOV W14, W3
008CF0  97B06F     MOV [W15-20], W0
008CF2  97B0FF     MOV [W15-18], W1
008CF4  07E366     RCALL __mulp32eds3
008CF6  97B14F     MOV [W15-24], W2
008CF8  97B1DF     MOV [W15-22], W3
008CFA  400002     ADD W0, W2, W0
008CFC  488083     ADDC W1, W3, W1
008CFE  97B12F     MOV [W15-28], W2
008D00  97B1BF     MOV [W15-26], W3
008D02  410000     ADD W2, W0, W0
008D04  498081     ADDC W3, W1, W1
008D06  560000     SUB W12, W0, W0
008D08  5E8081     SUBB W13, W1, W1
008D0A  90611A     MOV.B [W10+33], W2
008D0C  FB8102     ZE W2, W2
008D0E  200003     MOV #0x0, W3
008D10  07E3C8     RCALL __udivsi3
008D12  BE0100     MOV.D W0, W2
008D14  985540     MOV.B W0, [W10+20]
008D16  DE0048     LSR W0, #8, W0
008D18  985550     MOV.B W0, [W10+21]
008D1A  985563     MOV.B W3, [W10+22]
008D1C  DE1848     LSR W3, #8, W0
008D1E  985570     MOV.B W0, [W10+23]
1898:                  
1899:                                  #endif
1900:                  
1901:                                  // Determine the file system type based on the number of clusters used
1902:                                  if(dsk->maxcls < 4085)
008D20  20FF40     MOV #0xFF4, W0
008D22  510F80     SUB W2, W0, [W15]
008D24  598FE0     SUBB W3, #0x0, [W15]
008D26  3E0002     BRA GTU, 0x8D2C
1903:                                  {
1904:                                      dsk->type = FAT12;
008D28  B3C010     MOV #0x1, W0
008D2A  370005     BRA 0x8D36
1905:                                  }
1906:                                  else
1907:                                  {
1908:                                      if(dsk->maxcls < 65525)
008D2E  410FEC     ADD W2, #0xC, [W15]
008D30  598FE0     SUBB W3, #0x0, [W15]
008D32  360001     BRA LEU, 0x8D36
1909:                                      {
1910:                                          dsk->type = FAT16;
008D2C  B3C020     MOV #0x2, W0
1911:                                      }
1912:                                      else
1913:                                      {
1914:                                          #ifdef SUPPORT_FAT32
1915:                                              dsk->type = FAT32;
008D34  B3C030     MOV #0x3, W0
008D36  986520     MOV.B W0, [W10+34]
1916:                                          #else
1917:                                              error = CE_CARDFAT32;
1918:                                          #endif
1919:                                      }
1920:                                  }
1921:                      
1922:                                  #ifdef SUPPORT_FAT32
1923:                                      if (dsk->type == FAT32)
008D38  90602A     MOV.B [W10+34], W0
008D3A  504FE3     SUB.B W0, #0x3, [W15]
008D3C  3A0017     BRA NZ, 0x8D6C
1924:                                      {
1925:                                          #ifdef __18CXX
1926:                                              FatRootDirClusterValue =  BSec->FAT.FAT_32.BootSec_RootClus;
1927:                                          #else
1928:                                              FatRootDirClusterValue = ReadDWord( dsk->buffer, BSI_ROOTCLUS );
008D3E  FB809A     ZE [W10], W1
008D40  90401A     MOV.B [W10+1], W0
008D42  DD0048     SL W0, #8, W0
008D44  700001     IOR W0, W1, W0
008D46  2002C1     MOV #0x2C, W1
008D48  07F0D1     RCALL ReadDWord
008D4A  8A49D0     MOV W0, FatRootDirClusterValue
008D4C  8A49E1     MOV W1, 0x493C
1929:                                          #endif
1930:                                          dsk->data = dsk->root + RootDirSectors;
008D4E  9049AA     MOV.B [W10+10], W3
008D50  FB8183     ZE W3, W3
008D52  90493A     MOV.B [W10+11], W2
008D54  DD1148     SL W2, #8, W2
008D56  710003     IOR W2, W3, W0
008D58  9049CA     MOV.B [W10+12], W3
008D5A  FB8183     ZE W3, W3
008D5C  90495A     MOV.B [W10+13], W2
008D5E  DD1148     SL W2, #8, W2
008D60  710083     IOR W2, W3, W1
008D62  97B12F     MOV [W15-28], W2
008D64  97B1BF     MOV [W15-26], W3
008D66  410000     ADD W2, W0, W0
008D68  498081     ADDC W3, W1, W1
008D6A  370015     BRA 0x8D96
1931:                                      }
1932:                                      else
1933:                                  #endif
1934:                                  {
1935:                                      FatRootDirClusterValue = 0;
008D6C  B80060     MUL.UU W0, #0, W0
008D6E  8A49D0     MOV W0, FatRootDirClusterValue
008D70  8A49E1     MOV W1, 0x493C
1936:                                      dsk->data = dsk->root + ( dsk->maxroot >> 4);
008D72  9048AA     MOV.B [W10+10], W1
008D74  FB8081     ZE W1, W1
008D76  90483A     MOV.B [W10+11], W0
008D78  DD0048     SL W0, #8, W0
008D7A  700201     IOR W0, W1, W4
008D7C  9048CA     MOV.B [W10+12], W1
008D7E  FB8081     ZE W1, W1
008D80  90485A     MOV.B [W10+13], W0
008D82  DD0048     SL W0, #8, W0
008D84  700281     IOR W0, W1, W5
008D86  90512A     MOV.B [W10+18], W2
008D88  FB8102     ZE W2, W2
008D8A  90503A     MOV.B [W10+19], W0
008D8C  DD0048     SL W0, #8, W0
008D8E  700002     IOR W0, W2, W0
008D90  DE0044     LSR W0, #4, W0
008D92  420000     ADD W4, W0, W0
008D94  4A80E0     ADDC W5, #0x0, W1
008D96  984D60     MOV.B W0, [W10+14]
008D98  DE0148     LSR W0, #8, W2
008D9A  984D72     MOV.B W2, [W10+15]
008D9C  985501     MOV.B W1, [W10+16]
008D9E  DE0848     LSR W1, #8, W0
008DA0  985510     MOV.B W0, [W10+17]
1937:                                  }
1938:                  
1939:                              #ifdef __18CXX
1940:                                  if(BSec->FAT.FAT_16.BootSec_BPS > MEDIA_SECTOR_SIZE)
1941:                              #else
1942:                                  if(BytesPerSec > MEDIA_SECTOR_SIZE)
008DA2  EB4100     CLR.B W2
008DA4  202000     MOV #0x200, W0
008DA6  540F80     SUB W8, W0, [W15]
008DA8  360004     BRA LEU, 0x8DB2
008DAA  370002     BRA 0x8DB0
008DAC  B3C032     MOV #0x3, W2
008DAE  370001     BRA 0x8DB2
008DB0  B3C212     MOV #0x21, W2
1943:                              #endif
1944:                                  {
1945:                                      error = CE_UNSUPPORTED_SECTOR_SIZE;
1946:                                  }
1947:              
1948:                              }while(0);  // do/while loop designed to allow to break out if
1949:                                          //   there is an error detected without returning
1950:                                          //   from the function.
1951:              
1952:                          }
1953:              
1954:                          #if defined(SUPPORT_FAT32)
1955:                          if ((dsk->type == FAT32) || ((error != CE_GOOD) && ((BSec->FAT.FAT_32.BootSec_BootSig == 0x29) || (BSec->FAT.FAT_32.BootSec_BootSig == 0x28))))
008DB2  90602A     MOV.B [W10+34], W0
008DB4  504FE3     SUB.B W0, #0x3, [W15]
008DB6  320007     BRA Z, 0x8DC6
008DB8  E00402     CP0.B W2
008DBA  320074     BRA Z, 0x8EA4
008DBC  90C02B     MOV.B [W11+66], W0
008DBE  B3CD81     MOV #0xD8, W1
008DC0  404001     ADD.B W0, W1, W0
008DC2  504FE1     SUB.B W0, #0x1, [W15]
008DC4  3E006D     BRA GTU, 0x8EA0
1956:                          {
1957:                              //Check for possible errors in the formatting
1958:                              if(    (BSec->FAT.FAT_32.BootSec_TotSec16 != 0)
008DC6  9050BB     MOV.B [W11+19], W1
008DC8  FB8081     ZE W1, W1
008DCA  90504B     MOV.B [W11+20], W0
008DCC  DD0048     SL W0, #8, W0
008DCE  700001     IOR W0, W1, W0
008DD0  3A002C     BRA NZ, 0x8E2A
008DD2  90704B     MOV.B [W11+52], W0
008DD4  E00400     CP0.B W0
008DD6  3A0029     BRA NZ, 0x8E2A
008DD8  90705B     MOV.B [W11+53], W0
008DDA  E00400     CP0.B W0
008DDC  3A0026     BRA NZ, 0x8E2A
008DDE  90706B     MOV.B [W11+54], W0
008DE0  E00400     CP0.B W0
008DE2  3A0023     BRA NZ, 0x8E2A
008DE4  90707B     MOV.B [W11+55], W0
008DE6  E00400     CP0.B W0
008DE8  3A0020     BRA NZ, 0x8E2A
008DEA  90780B     MOV.B [W11+56], W0
008DEC  E00400     CP0.B W0
008DEE  3A001D     BRA NZ, 0x8E2A
008DF0  90781B     MOV.B [W11+57], W0
008DF2  E00400     CP0.B W0
008DF4  3A001A     BRA NZ, 0x8E2A
008DF6  90782B     MOV.B [W11+58], W0
008DF8  E00400     CP0.B W0
008DFA  3A0017     BRA NZ, 0x8E2A
008DFC  90783B     MOV.B [W11+59], W0
008DFE  E00400     CP0.B W0
008E00  3A0014     BRA NZ, 0x8E2A
008E02  90784B     MOV.B [W11+60], W0
008E04  E00400     CP0.B W0
008E06  3A0011     BRA NZ, 0x8E2A
008E08  90785B     MOV.B [W11+61], W0
008E0A  E00400     CP0.B W0
008E0C  3A000E     BRA NZ, 0x8E2A
008E0E  90786B     MOV.B [W11+62], W0
008E10  E00400     CP0.B W0
008E12  3A000B     BRA NZ, 0x8E2A
008E14  90787B     MOV.B [W11+63], W0
008E16  E00400     CP0.B W0
008E18  3A0008     BRA NZ, 0x8E2A
008E1A  90C02B     MOV.B [W11+66], W0
008E1C  B3CD81     MOV #0xD8, W1
008E1E  404001     ADD.B W0, W1, W0
008E20  504FE1     SUB.B W0, #0x1, [W15]
008E22  3E0003     BRA GTU, 0x8E2A
1959:                                  || (BSec->FAT.FAT_32.BootSec_Reserved[0] != 0)
1960:                                  || (BSec->FAT.FAT_32.BootSec_Reserved[1] != 0)
1961:                                  || (BSec->FAT.FAT_32.BootSec_Reserved[2] != 0)
1962:                                  || (BSec->FAT.FAT_32.BootSec_Reserved[3] != 0)
1963:                                  || (BSec->FAT.FAT_32.BootSec_Reserved[4] != 0)
1964:                                  || (BSec->FAT.FAT_32.BootSec_Reserved[5] != 0)
1965:                                  || (BSec->FAT.FAT_32.BootSec_Reserved[6] != 0)
1966:                                  || (BSec->FAT.FAT_32.BootSec_Reserved[7] != 0)
1967:                                  || (BSec->FAT.FAT_32.BootSec_Reserved[8] != 0)
1968:                                  || (BSec->FAT.FAT_32.BootSec_Reserved[9] != 0)
1969:                                  || (BSec->FAT.FAT_32.BootSec_Reserved[10] != 0)
1970:                                  || (BSec->FAT.FAT_32.BootSec_Reserved[11] != 0)
1971:                                  || ((BSec->FAT.FAT_32.BootSec_BootSig != 0x29) && (BSec->FAT.FAT_32.BootSec_BootSig != 0x28))
1972:                                )
1973:                              {
1974:                                  error = CE_NOT_FORMATTED;
1975:                              }
1976:                  
1977:                              //If there were formatting errors then in FAT32 we can try to use
1978:                              //  the backup boot sector
1979:                              if((error != CE_GOOD) && (TriedSpecifiedBackupBootSec == FALSE))
008E24  E00402     CP0.B W2
008E26  3A0002     BRA NZ, 0x8E2C
008E28  37003D     BRA 0x8EA4
008E2A  B3C032     MOV #0x3, W2
008E2C  97B19F     MOV [W15-30], W3
008E2E  E00003     CP0 W3
008E30  3A0019     BRA NZ, 0x8E64
1980:                              {
1981:                                  TriedSpecifiedBackupBootSec = TRUE;
1982:                  
1983:                                  if ( MDD_SectorRead( dsk->firsts + BSec->FAT.FAT_32.BootSec_BkBootSec, dsk->buffer) != TRUE)
008E32  FB801A     ZE [W10], W0
008E34  90411A     MOV.B [W10+1], W2
008E36  DD1148     SL W2, #8, W2
008E38  710100     IOR W2, W0, W2
008E3A  9040AA     MOV.B [W10+2], W1
008E3C  FB8081     ZE W1, W1
008E3E  90403A     MOV.B [W10+3], W0
008E40  DD0048     SL W0, #8, W0
008E42  700201     IOR W0, W1, W4
008E44  9040CA     MOV.B [W10+4], W1
008E46  FB8081     ZE W1, W1
008E48  90405A     MOV.B [W10+5], W0
008E4A  DD0048     SL W0, #8, W0
008E4C  700281     IOR W0, W1, W5
008E4E  9071AB     MOV.B [W11+50], W3
008E50  FB8183     ZE W3, W3
008E52  90703B     MOV.B [W11+51], W0
008E54  DD0048     SL W0, #8, W0
008E56  700003     IOR W0, W3, W0
008E58  420000     ADD W4, W0, W0
008E5A  4A80E0     ADDC W5, #0x0, W1
008E5C  072342     RCALL MDD_SDSPI_SectorRead
008E5E  504FE1     SUB.B W0, #0x1, [W15]
008E60  32FEB8     BRA Z, 0x8BD2
008E62  370019     BRA 0x8E96
1984:                                  {
1985:                                      FSerrno = CE_BAD_SECTOR_READ;
1986:                                      return CE_BAD_SECTOR_READ;
1987:                                  }
1988:                                  else
1989:                                  {
1990:                                      error = CE_GOOD;
1991:                                      continue;
1992:                                  }
1993:                              }
1994:                  
1995:                              if((error != CE_GOOD) && (TriedBackupBootSecAtAddress6 == FALSE))
008E64  97B00F     MOV [W15-32], W0
008E66  E00000     CP0 W0
008E68  3A001B     BRA NZ, 0x8EA0
1996:                              {
1997:                                  TriedBackupBootSecAtAddress6 = TRUE;
1998:                  
1999:                                  //Here we are using the magic number 6 because the FAT32 specification
2000:                                  //  recommends that "No value other than 6 is recommended."  We've
2001:                                  //  already tried using the value specified in the BPB_BkBootSec
2002:                                  //  field and it must have failed
2003:                                  if ( MDD_SectorRead( dsk->firsts + 6, dsk->buffer) != TRUE)
008E6A  FB801A     ZE [W10], W0
008E6C  90411A     MOV.B [W10+1], W2
008E6E  DD1148     SL W2, #8, W2
008E70  710100     IOR W2, W0, W2
008E72  90422A     MOV.B [W10+2], W4
008E74  FB8204     ZE W4, W4
008E76  9041BA     MOV.B [W10+3], W3
008E78  DD19C8     SL W3, #8, W3
008E7A  718004     IOR W3, W4, W0
008E7C  90424A     MOV.B [W10+4], W4
008E7E  FB8204     ZE W4, W4
008E80  9041DA     MOV.B [W10+5], W3
008E82  DD19C8     SL W3, #8, W3
008E84  718084     IOR W3, W4, W1
008E86  400066     ADD W0, #0x6, W0
008E88  4880E0     ADDC W1, #0x0, W1
008E8A  07232B     RCALL MDD_SDSPI_SectorRead
008E8C  504FE1     SUB.B W0, #0x1, [W15]
008E8E  3A0003     BRA NZ, 0x8E96
008E90  200011     MOV #0x1, W1
008E92  9FB781     MOV W1, [W15-32]
008E94  37FEA0     BRA 0x8BD6
2004:                                  {
2005:                                      FSerrno = CE_BAD_SECTOR_READ;
008E96  B3C081     MOV #0x8, W1
008E98  249380     MOV #0x4938, W0
008E9A  784801     MOV.B W1, [W0]
008E9C  200080     MOV #0x8, W0
008E9E  370003     BRA 0x8EA6
2006:                                      return CE_BAD_SECTOR_READ;
008BBC  B3C082     MOV #0x8, W2
2007:                                  }
2008:                                  else
2009:                                  {
2010:                                      error = CE_GOOD;
2011:                                      continue;
2012:                                  }
2013:                              }
2014:              
2015:                          }   //type == FAT32
2016:                          #endif  //SUPPORT_FAT32
2017:                          break;
2018:                      }
2019:                      while(1);
2020:                  }
2021:              
2022:                  if(error != CE_GOOD)
2023:                  {
2024:                      FSerrno = error;
008EA0  249380     MOV #0x4938, W0
008EA2  784802     MOV.B W2, [W0]
2025:                  }
2026:              
2027:                  return(error);
008EA4  FB8002     ZE W2, W0
2028:              }
008EB2  BE9F88     MOV.D W8, [W15++]
008EB4  780400     MOV W0, W8
2029:              
2030:              
2031:              
2032:              /*************************************************************************
2033:                Function:
2034:                  DWORD GetFullClusterNumber (DIRENTRY entry)
2035:                Summary:
2036:                  Gets the cluster number from a directory entry
2037:                Conditions:
2038:                  This function should not be called by the user.
2039:                Input:
2040:                  entry - The cached directory entry to get the cluster number from
2041:                Returns:
2042:                  The cluster value from the passed directory entry
2043:                Side Effects:
2044:                  None.
2045:                Description:
2046:                  This function will load both the high and low 16-bit first cluster
2047:                  values of a file from a directory entry and copy them into a 32-bit
2048:                  cluster number variable, which will be returned.
2049:                Remarks:
2050:                  None
2051:                *************************************************************************/
2052:              
2053:              DWORD GetFullClusterNumber(DIRENTRY entry)
2054:              {
2055:              
2056:                  DWORD TempFullClusterCalc = 0;
2057:              
2058:              #ifndef SUPPORT_FAT32 // If FAT32 Not supported.
2059:                  entry->DIR_FstClusHI = 0; // If FAT32 is not supported then Higher Word of the address is "0"
2060:              #endif
2061:              
2062:                  // Get the cluster
2063:                  TempFullClusterCalc = (entry->DIR_FstClusHI);
006F12  900820     MOV [W0+20], W0
006F14  200001     MOV #0x0, W1
00981E  900829     MOV [W9+20], W0
009820  200001     MOV #0x0, W1
00A876  900928     MOV [W8+20], W2
00A878  200003     MOV #0x0, W3
00ADF6  900920     MOV [W0+20], W2
00ADF8  200003     MOV #0x0, W3
00B022  900920     MOV [W0+20], W2
00B024  200003     MOV #0x0, W3
00B076  900920     MOV [W0+20], W2
00B078  200003     MOV #0x0, W3
00B0CC  90082B     MOV [W11+20], W0
00B0CE  200001     MOV #0x0, W1
00B282  900920     MOV [W0+20], W2
00B284  200003     MOV #0x0, W3
00B2D0  900820     MOV [W0+20], W0
00B2D2  200001     MOV #0x0, W1
00B698  900920     MOV [W0+20], W2
00B69A  200003     MOV #0x0, W3
00BD1E  900820     MOV [W0+20], W0
00BD20  200001     MOV #0x0, W1
2064:                  TempFullClusterCalc = TempFullClusterCalc << 16;
006F16  DD00C0     SL W0, #0, W1
006F18  200000     MOV #0x0, W0
006F1A  900952     MOV [W2+26], W2
006F1C  200003     MOV #0x0, W3
006F1E  700002     IOR W0, W2, W0
006F20  708083     IOR W1, W3, W1
009822  DD00C0     SL W0, #0, W1
009824  200000     MOV #0x0, W0
00ADFA  DD11C0     SL W2, #0, W3
00ADFC  200002     MOV #0x0, W2
00B026  DD11C0     SL W2, #0, W3
00B028  200002     MOV #0x0, W2
00B07A  DD11C0     SL W2, #0, W3
00B07C  200002     MOV #0x0, W2
00B0D0  DD00C0     SL W0, #0, W1
00B0D2  200000     MOV #0x0, W0
00B286  DD11C0     SL W2, #0, W3
00B288  200002     MOV #0x0, W2
00B2D4  DD00C0     SL W0, #0, W1
00B2D6  200000     MOV #0x0, W0
00BD22  DD00C0     SL W0, #0, W1
00BD24  200000     MOV #0x0, W0
2065:                  TempFullClusterCalc |= entry->DIR_FstClusLO;
00A87A  DD11C0     SL W2, #0, W3
00A87C  200002     MOV #0x0, W2
00A87E  900858     MOV [W8+26], W0
00A880  200001     MOV #0x0, W1
00A882  710600     IOR W2, W0, W12
00A884  718681     IOR W3, W1, W13
00A886  EB0000     CLR W0
00A888  9FB7E0     MOV W0, [W15-20]
00ADFE  900850     MOV [W0+26], W0
00AE00  200001     MOV #0x0, W1
00AE02  710100     IOR W2, W0, W2
00AE04  718181     IOR W3, W1, W3
00B02A  900850     MOV [W0+26], W0
00B02C  200001     MOV #0x0, W1
00B02E  710400     IOR W2, W0, W8
00B030  718481     IOR W3, W1, W9
00B07E  900850     MOV [W0+26], W0
00B080  200001     MOV #0x0, W1
00B082  710000     IOR W2, W0, W0
00B084  718081     IOR W3, W1, W1
00B28A  900850     MOV [W0+26], W0
00B28C  200001     MOV #0x0, W1
00B28E  710000     IOR W2, W0, W0
00B290  718081     IOR W3, W1, W1
2066:              
2067:                  return TempFullClusterCalc;
2068:              }
006F24  BE9F88     MOV.D W8, [W15++]
2069:              
2070:              
2071:              #ifdef ALLOW_FORMATS
2072:              #ifdef ALLOW_WRITES
2073:              
2074:              
2075:              /*********************************************************************************
2076:                Function:
2077:                  int FSCreateMBR (unsigned long firstSector, unsigned long numSectors)
2078:                Summary:
2079:                  Creates a master boot record
2080:                Conditions:
2081:                  The I/O pins for the device have been initialized by the InitIO function.
2082:                Input:
2083:                  firstSector -  The first sector of the partition on the device (cannot
2084:                                 be 0; that's the MBR)
2085:                  numSectors -   The number of sectors available in memory (including the
2086:                                 MBR)
2087:                Return Values:
2088:                  0 -   MBR was created successfully
2089:                  EOF - MBR could not be created
2090:                Side Effects:
2091:                  None
2092:                Description:
2093:                  This function can be used to create a master boot record for a device.  Note
2094:                  that this function should not be used on a device that is already formatted
2095:                  with a master boot record (i.e. most SD cards, CF cards, USB keys).  This
2096:                  function will fill the global data buffer with appropriate partition information
2097:                  for a FAT partition with a type determined by the number of sectors available
2098:                  to the partition.  It will then write the MBR information to the first sector
2099:                  on the device.  This function should be followed by a call to FSformat, which
2100:                  will create a boot sector, root dir, and FAT appropriate the the information
2101:                  contained in the new master boot record.  Note that FSformat only supports
2102:                  FAT12 and FAT16 formatting at this time, and so cannot be used to format a
2103:                  device with more than 0x3FFD5F sectors.
2104:                Remarks:
2105:                  This function can damage the device being used, and should not be called
2106:                  unless the user is sure about the size of the device and the first sector value.
2107:                *********************************************************************************/
2108:              
2109:              int FSCreateMBR (unsigned long firstSector, unsigned long numSectors)
2110:              {
2111:                  PT_MBR  Partition;
2112:                  DWORD CyHdSc = 0x00000000;
2113:                  DWORD tempSector;
2114:              
2115:                  if ((firstSector == 0) || (numSectors <= 1))
006F68  500FE0     SUB W0, #0x0, [W15]
006F6A  588FE0     SUBB W1, #0x0, [W15]
006F6C  320098     BRA Z, 0x709E
006F6E  510FE1     SUB W2, #0x1, [W15]
006F70  598FE0     SUBB W3, #0x0, [W15]
006F72  360095     BRA LEU, 0x709E
2116:                      return EOF;
2117:              
2118:                  if (firstSector > (numSectors - 1))
006F74  510061     SUB W2, #0x1, W0
006F76  5980E0     SUBB W3, #0x0, W1
006F78  560F80     SUB W12, W0, [W15]
006F7A  5E8F81     SUBB W13, W1, [W15]
006F7C  3E0090     BRA GTU, 0x709E
2119:                      return EOF;
2120:              
2121:                  if (gNeedDataWrite)
006F7E  270BB0     MOV #0x70BB, W0
006F80  E00410     CP0.B [W0]
006F82  320003     BRA Z, 0x6F8A
2122:                      if (flushData())
006F84  07FFCF     RCALL flushData
006F86  E00400     CP0.B W0
006F88  3A008A     BRA NZ, 0x709E
2123:                          return EOF;
2124:              
2125:                  memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE);
006F8A  26A988     MOV #0x6A98, W8
006F8C  202002     MOV #0x200, W2
006F8E  EB0080     CLR W1
006F90  780008     MOV W8, W0
006F92  07F3C6     RCALL memset
2126:              
2127:                  Partition = (PT_MBR) gDataBuffer;
006F94  780708     MOV W8, W14
2128:              
2129:                  // Set Cylinder-head-sector address of the first sector
2130:                  tempSector = firstSector;
2131:                  CyHdSc = (tempSector / (unsigned int)16065 ) << 14;
006F96  23EC12     MOV #0x3EC1, W2
006F98  200003     MOV #0x0, W3
006F9A  BE000C     MOV.D W12, W0
006F9C  07F282     RCALL __udivsi3
006F9E  BE0400     MOV.D W0, W8
006FA0  DD484E     SL W9, #14, W0
006FA2  DE44C2     LSR W8, #2, W9
006FA4  700489     IOR W0, W9, W9
006FA6  DD444E     SL W8, #14, W8
2132:                  tempSector %= 16065;
006FA8  23EC12     MOV #0x3EC1, W2
006FAA  200003     MOV #0x0, W3
006FAC  BE000C     MOV.D W12, W0
006FAE  07F289     RCALL __umodsi3
006FB0  BE0500     MOV.D W0, W10
2133:                  CyHdSc |= (tempSector / 63) << 6;
006FB2  2003F2     MOV #0x3F, W2
006FB4  200003     MOV #0x0, W3
006FB6  07F275     RCALL __udivsi3
006FB8  DD0946     SL W1, #6, W2
006FBA  DE00CA     LSR W0, #10, W1
006FBC  710081     IOR W2, W1, W1
006FBE  DD0046     SL W0, #6, W0
006FC0  740400     IOR W8, W0, W8
006FC2  748481     IOR W9, W1, W9
2134:                  tempSector %= 63;
2135:                  CyHdSc |= tempSector + 1;
006FC4  2003F2     MOV #0x3F, W2
006FC6  200003     MOV #0x0, W3
006FC8  BE000A     MOV.D W10, W0
006FCA  07F27B     RCALL __umodsi3
006FCC  400061     ADD W0, #0x1, W0
006FCE  4880E0     ADDC W1, #0x0, W1
006FD0  740400     IOR W8, W0, W8
006FD2  748481     IOR W9, W1, W9
2136:                  gDataBuffer[447] = (BYTE)((CyHdSc >> 16) & 0xFF);
006FD4  DE4840     LSR W9, #0, W0
006FD6  200001     MOV #0x0, W1
006FD8  26C572     MOV #0x6C57, W2
006FDA  784900     MOV.B W0, [W2]
2137:                  gDataBuffer[448] = (BYTE)((CyHdSc >> 8) & 0xFF);
006FDC  DD49C8     SL W9, #8, W3
006FDE  DE4048     LSR W8, #8, W0
006FE0  718000     IOR W3, W0, W0
006FE2  DE48C8     LSR W9, #8, W1
006FE4  26C582     MOV #0x6C58, W2
006FE6  784900     MOV.B W0, [W2]
2138:                  gDataBuffer[449] = (BYTE)((CyHdSc) & 0xFF);
006FE8  26C590     MOV #0x6C59, W0
006FEA  784808     MOV.B W8, [W0]
2139:              
2140:                  // Set the count of sectors
2141:                  Partition->Partition0.PTE_NumSect = numSectors - firstSector;
006FEC  97B07F     MOV [W15-18], W0
006FEE  97B88F     MOV [W15-16], W1
006FF0  50010C     SUB W0, W12, W2
006FF2  58818D     SUBB W1, W13, W3
006FF4  9BCF22     MOV.B W2, [W14+458]
006FF6  DE1048     LSR W2, #8, W0
006FF8  9BCF30     MOV.B W0, [W14+459]
006FFA  9BCF43     MOV.B W3, [W14+460]
006FFC  DE1848     LSR W3, #8, W0
006FFE  9BCF50     MOV.B W0, [W14+461]
2142:              
2143:                  // Set the partition type
2144:                  // We only support creating FAT12 and FAT16 MBRs at this time
2145:                  if (Partition->Partition0.PTE_NumSect < 0x1039)
007002  210381     MOV #0x1038, W1
007004  510F81     SUB W2, W1, [W15]
007006  598FE0     SUBB W3, #0x0, [W15]
007008  360006     BRA LEU, 0x7016
2146:                  {
2147:                      // FAT12
2148:                      Partition->Partition0.PTE_FSDesc = 0x01;
007000  B3C010     MOV #0x1, W0
2149:                  }
2150:                  else if (Partition->Partition0.PTE_NumSect <= 0x3FFD5F)
00700A  2FD5F0     MOV #0xFD5F, W0
00700C  2003F1     MOV #0x3F, W1
00700E  510F80     SUB W2, W0, [W15]
007010  598F81     SUBB W3, W1, [W15]
007012  3E0045     BRA GTU, 0x709E
2151:                  {
2152:                      // FAT16
2153:                      Partition->Partition0.PTE_FSDesc = 0x06;
007014  B3C060     MOV #0x6, W0
007016  9BC720     MOV.B W0, [W14+450]
2154:                  }
2155:                  else
2156:                      return EOF;
2157:              
2158:                  // Set the LBA of the first sector
2159:                  Partition->Partition0.PTE_FrstSect = firstSector;
007018  9BC76C     MOV.B W12, [W14+454]
00701A  DE6048     LSR W12, #8, W0
00701C  9BC770     MOV.B W0, [W14+455]
00701E  9BCF0D     MOV.B W13, [W14+456]
007020  DE6848     LSR W13, #8, W0
007022  9BCF10     MOV.B W0, [W14+457]
2160:              
2161:                  // Set the Cylinder-head-sector address of the last sector
2162:                  tempSector = firstSector + numSectors - 1;
007024  97B17F     MOV [W15-18], W2
007026  97B98F     MOV [W15-16], W3
007028  41040C     ADD W2, W12, W8
00702A  49848D     ADDC W3, W13, W9
00702C  540461     SUB W8, #0x1, W8
00702E  5C84E0     SUBB W9, #0x0, W9
2163:                  CyHdSc = (tempSector / (unsigned int)16065 ) << 14;
007030  23EC12     MOV #0x3EC1, W2
007032  200003     MOV #0x0, W3
007034  BE0008     MOV.D W8, W0
007036  07F235     RCALL __udivsi3
007038  DD09CE     SL W1, #14, W3
00703A  DE05C2     LSR W0, #2, W11
00703C  71858B     IOR W3, W11, W11
00703E  DD054E     SL W0, #14, W10
2164:                  tempSector %= 16065;
007040  23EC12     MOV #0x3EC1, W2
007042  200003     MOV #0x0, W3
007044  BE0008     MOV.D W8, W0
007046  07F23D     RCALL __umodsi3
007048  BE0400     MOV.D W0, W8
2165:                  CyHdSc |= (tempSector / 63) << 6;
00704A  2003F2     MOV #0x3F, W2
00704C  200003     MOV #0x0, W3
00704E  07F229     RCALL __udivsi3
007050  DD0946     SL W1, #6, W2
007052  DE00CA     LSR W0, #10, W1
007054  710081     IOR W2, W1, W1
007056  DD0046     SL W0, #6, W0
007058  750500     IOR W10, W0, W10
00705A  758581     IOR W11, W1, W11
2166:                  tempSector %= 63;
2167:                  CyHdSc |= tempSector + 1;
00705C  2003F2     MOV #0x3F, W2
00705E  200003     MOV #0x0, W3
007060  BE0008     MOV.D W8, W0
007062  07F22F     RCALL __umodsi3
007064  400061     ADD W0, #0x1, W0
007066  4880E0     ADDC W1, #0x0, W1
007068  750500     IOR W10, W0, W10
00706A  758581     IOR W11, W1, W11
2168:                  gDataBuffer[451] = (BYTE)((CyHdSc >> 16) & 0xFF);
00706C  DE5840     LSR W11, #0, W0
00706E  200001     MOV #0x0, W1
007070  26C5B2     MOV #0x6C5B, W2
007072  784900     MOV.B W0, [W2]
2169:                  gDataBuffer[452] = (BYTE)((CyHdSc >> 8) & 0xFF);
007074  DD59C8     SL W11, #8, W3
007076  DE5048     LSR W10, #8, W0
007078  718000     IOR W3, W0, W0
00707A  DE58C8     LSR W11, #8, W1
00707C  26C5C2     MOV #0x6C5C, W2
00707E  784900     MOV.B W0, [W2]
2170:                  gDataBuffer[453] = (BYTE)((CyHdSc) & 0xFF);
007080  26C5D0     MOV #0x6C5D, W0
007082  78480A     MOV.B W10, [W0]
2171:              
2172:                  // Set the boot descriptor.  This will be 0, since we won't
2173:                  // be booting anything from our device probably
2174:                  Partition->Partition0.PTE_BootDes = 0x00;
007084  EB4000     CLR.B W0
007086  9B7F60     MOV.B W0, [W14+446]
2175:              
2176:                  // Set the signature codes
2177:                  Partition->Signature0 = 0x55;
007088  B3C550     MOV #0x55, W0
00708A  9BFF60     MOV.B W0, [W14+510]
2178:                  Partition->Signature1 = 0xAA;
00708C  B3CAA0     MOV #0xAA, W0
00708E  9BFF70     MOV.B W0, [W14+511]
2179:              
2180:                  if (MDD_SectorWrite (0x00, gDataBuffer, TRUE) != TRUE)
007090  B3C013     MOV #0x1, W3
007092  26A982     MOV #0x6A98, W2
007094  B80060     MUL.UU W0, #0, W0
007096  073321     RCALL MDD_SDSPI_SectorWrite
007098  EB0080     CLR W1
00709A  504FE1     SUB.B W0, #0x1, [W15]
00709C  320001     BRA Z, 0x70A0
00709E  EB8080     SETM W1
2181:                      return EOF;
2182:                  else
2183:                      return 0;
2184:              
2185:              }
0070AE  BE9F88     MOV.D W8, [W15++]
0070B0  781F8A     MOV W10, [W15++]
0070B2  BE9F8C     MOV.D W12, [W15++]
2186:              
2187:              
2188:              /*******************************************************************
2189:                Function:
2190:                  int FSformat (char mode, long int serialNumber, char * volumeID)
2191:                Summary:
2192:                  Formats a device
2193:                Conditions:
2194:                  The device must possess a valid master boot record.
2195:                Input:
2196:                  mode -          - 0 - Just erase the FAT and root
2197:                                  - 1 - Create a new boot sector
2198:                  serialNumber -  Serial number to write to the card
2199:                  volumeID -      Name of the card
2200:                Return Values:
2201:                  0 -    Format was successful
2202:                  EOF -  Format was unsuccessful
2203:                Side Effects:
2204:                  The FSerrno variable will be changed.
2205:                Description:
2206:                  The FSformat function can be used to create a new boot sector
2207:                  on a device, based on the information in the master boot record.
2208:                  This function will first initialize the I/O pins and the device,
2209:                  and then attempts to read the master boot record.  If the MBR
2210:                  cannot be loaded successfully, the function will fail.  Next, if
2211:                  the 'mode' argument is specified as '0' the existing boot sector
2212:                  information will be loaded.  If the 'mode' argument is '1' an
2213:                  entirely new boot sector will be constructed using the disk
2214:                  values from the master boot record.  Once the boot sector has
2215:                  been successfully loaded/created, the locations of the FAT and
2216:                  root will be loaded from it, and they will be completely
2217:                  erased.  If the user has specified a volumeID parameter, a
2218:                  VOLUME attribute entry will be created in the root directory
2219:                  to name the device.
2220:              
2221:                  FAT12, FAT16 and FAT32 formatting are supported.
2222:              
2223:                  Based on the number of sectors, the format function automatically
2224:                  compute the smallest possible value for the cluster size in order to
2225:                  accommodate the physical size of the media. In this case, if a media 
2226:                  with a big capacity is formatted, the format function may take a very
2227:                  long time to write all the FAT tables. 
2228:              
2229:                  Therefore, the FORMAT_SECTORS_PER_CLUSTER macro may be used to 
2230:                  specify the exact cluster size (in multiples of sector size). This 
2231:                  macro can be defined in FSconfig.h
2232:              
2233:                Remarks:
2234:                  Only devices with a sector size of 512 bytes are supported by the 
2235:                  format function
2236:                *******************************************************************/
2237:              
2238:              int FSformat (char mode, long int serialNumber, char * volumeID)
2239:              {
2240:                  PT_MBR   masterBootRecord;
2241:                  DWORD    secCount, DataClusters, RootDirSectors;
2242:                  BootSec   BSec;
2243:                  DISK   d;
2244:                  DISK * disk = &d;
2245:                  WORD    j;
2246:                  DWORD   fatsize, test;
2247:                  DWORD Index;
2248:                  MEDIA_INFORMATION * mediaInfo;
2249:              #ifdef __18CXX
2250:                  // This is here because of a C18 compiler feature
2251:                  BYTE *  dataBufferPointer = gDataBuffer;
2252:              #endif
2253:              
2254:                  FSerrno = CE_GOOD;
008FA6  24938A     MOV #0x4938, W10
008FA8  EB4D00     CLR.B [W10]
2255:              
2256:                  gBufferZeroed = FALSE;
008FAA  270B90     MOV #0x70B9, W0
008FAC  EB4800     CLR.B [W0]
2257:                  gNeedFATWrite = FALSE;             
008FAE  270C20     MOV #0x70C2, W0
008FB0  EB4800     CLR.B [W0]
2258:                  gLastFATSectorRead = 0xFFFFFFFF;       
008FB2  EB8000     SETM W0
008FB4  EB8080     SETM W1
008FB6  8B8620     MOV W0, gLastFATSectorRead
008FB8  8B8631     MOV W1, 0x70C6
2259:                  gLastDataSectorRead = 0xFFFFFFFF;  
008FBA  8B85E0     MOV W0, gLastDataSectorRead
008FBC  8B85F1     MOV W1, 0x70BE
2260:              
2261:                  disk->buffer = gDataBuffer;
008FBE  26A989     MOV #0x6A98, W9
008FC0  9F9FD9     MOV W9, [W15-70]
2262:              
2263:                  MDD_InitIO();
008FC2  07215B     RCALL MDD_SDSPI_InitIO
2264:              
2265:                  mediaInfo = MDD_MediaInitialize();
008FC4  0723DA     RCALL MDD_SDSPI_MediaInitialize
2266:                  if (mediaInfo->errorCode != MEDIA_NO_ERROR)
008FC6  E00410     CP0.B [W0]
008FC8  320002     BRA Z, 0x8FCE
2267:                  {
2268:                      FSerrno = CE_INIT_ERROR;
008FCA  B3C060     MOV #0x6, W0
008FCC  370006     BRA 0x8FDA
2269:                      return EOF;
2270:                  }
2271:              
2272:                  if (MDD_SectorRead (0x00, gDataBuffer) == FALSE)
008FCE  780109     MOV W9, W2
008FD0  B80060     MUL.UU W0, #0, W0
008FD2  072287     RCALL MDD_SDSPI_SectorRead
008FD4  E00400     CP0.B W0
008FD6  3A0004     BRA NZ, 0x8FE0
2273:                  {
2274:                      FSerrno = CE_BADCACHEREAD;
008FD8  B3C1B0     MOV #0x1B, W0
008FDA  784D00     MOV.B W0, [W10]
008FDC  EB8000     SETM W0
008FDE  3703DC     BRA 0x9798
2275:                      return EOF;
2276:                  }
2277:              
2278:                  // Check if the card has no MBR
2279:                  BSec = (BootSec) disk->buffer;
008FE0  97995F     MOV [W15-70], W2
2280:                  if((BSec->Signature0 == FAT_GOOD_SIGN_0) && (BSec->Signature1 == FAT_GOOD_SIGN_1))
008FE2  93F8E2     MOV.B [W2+510], W1
008FE4  B3C550     MOV #0x55, W0
008FE6  50CF80     SUB.B W1, W0, [W15]
008FE8  3A00B3     BRA NZ, 0x9150
008FEA  93F8F2     MOV.B [W2+511], W1
008FEC  B3CAA0     MOV #0xAA, W0
008FEE  50CF80     SUB.B W1, W0, [W15]
008FF0  3A00AF     BRA NZ, 0x9150
2281:                  {
2282:                      // Technically, the OEM name is not for indication
2283:                      // The alternative is to read the CIS from attribute
2284:                      // memory.  See the PCMCIA metaformat for more details
2285:              #if defined (__C30__) || defined (__PIC32MX__)
2286:                      if ((ReadByte( disk->buffer, BSI_FSTYPE ) == 'F') && \
008FF2  9070E2     MOV.B [W2+54], W1
008FF4  B3C460     MOV #0x46, W0
008FF6  50CF80     SUB.B W1, W0, [W15]
008FF8  3A0020     BRA NZ, 0x903A
008FFA  9070F2     MOV.B [W2+55], W1
008FFC  504065     SUB.B W0, #0x5, W0
008FFE  50CF80     SUB.B W1, W0, [W15]
009000  3A001C     BRA NZ, 0x903A
009002  907882     MOV.B [W2+56], W1
009004  404073     ADD.B W0, #0x13, W0
009006  50CF80     SUB.B W1, W0, [W15]
009008  3A0018     BRA NZ, 0x903A
00900A  907892     MOV.B [W2+57], W1
00900C  B3C310     MOV #0x31, W0
00900E  50CF80     SUB.B W1, W0, [W15]
009010  3A0014     BRA NZ, 0x903A
009012  9060E2     MOV.B [W2+38], W1
009014  504068     SUB.B W0, #0x8, W0
009016  50CF80     SUB.B W1, W0, [W15]
009018  3A0010     BRA NZ, 0x903A
2287:                          (ReadByte( disk->buffer, BSI_FSTYPE + 1 ) == 'A') && \
2288:                          (ReadByte( disk->buffer, BSI_FSTYPE + 2 ) == 'T') && \
2289:                          (ReadByte( disk->buffer, BSI_FSTYPE + 3 ) == '1') && \
2290:                          (ReadByte( disk->buffer, BSI_BOOTSIG) == 0x29))
2291:              #else
2292:                      if ((BSec->FAT.FAT_16.BootSec_FSType[0] == 'F') && \
2293:                          (BSec->FAT.FAT_16.BootSec_FSType[1] == 'A') && \
2294:                          (BSec->FAT.FAT_16.BootSec_FSType[2] == 'T') && \
2295:                          (BSec->FAT.FAT_16.BootSec_FSType[3] == '1') && \
2296:                          (BSec->FAT.FAT_16.BootSec_BootSig == 0x29))
2297:              #endif
2298:                      {
2299:                          /* Mark that we do not have a MBR; 
2300:                              this is not actualy used - is here only to remove a compilation warning */
2301:                          masterBootRecord = (PT_MBR) NULL;
2302:                          switch (mode)
00901A  E00408     CP0.B W8
00901C  320005     BRA Z, 0x9028
009022  544FE1     SUB.B W8, #0x1, [W15]
009024  32FFDA     BRA Z, 0x8FDA
009026  370016     BRA 0x9054
2303:                          {
2304:                              case 1:
2305:                                  // not enough info to construct our own boot sector
2306:                                  FSerrno = CE_INVALID_ARGUMENT;
009020  B3C1F0     MOV #0x1F, W0
2307:                                  return EOF;
2308:                              case 0:
2309:                                  // We have to determine the operating system, and the
2310:                                  // locations and sizes of the root dir and FAT, and the
2311:                                  // count of FATs
2312:                                  disk->firsts = 0;
009028  B80060     MUL.UU W0, #0, W0
00902A  9F9FE0     MOV W0, [W15-68]
00902C  9F9FF1     MOV W1, [W15-66]
2313:                                  if (LoadBootSector (disk) != CE_GOOD)
00902E  2FFBA0     MOV #0xFFBA, W0
009030  40000F     ADD W0, W15, W0
009032  07FDAF     RCALL LoadBootSector
009034  E00400     CP0.B W0
009036  320286     BRA Z, 0x9544
009038  37FFCF     BRA 0x8FD8
2314:                                  {
2315:                                      FSerrno = CE_BADCACHEREAD;
2316:                                      return EOF;
2317:                                  }
2318:                              default:
2319:                                  break;
2320:                          }
2321:                      }
2322:                      else
2323:                      {
2324:                          masterBootRecord = (PT_MBR) &gDataBuffer;
00903A  26A984     MOV #0x6A98, W4
2325:                          disk->firsts = masterBootRecord->Partition0.PTE_FrstSect;
00903C  93C0E4     MOV.B [W4+454], W1
00903E  FB8081     ZE W1, W1
009040  93C074     MOV.B [W4+455], W0
009042  DD0048     SL W0, #8, W0
009044  700101     IOR W0, W1, W2
009046  93C884     MOV.B [W4+456], W1
009048  FB8081     ZE W1, W1
00904A  93C814     MOV.B [W4+457], W0
00904C  DD0048     SL W0, #8, W0
00904E  700181     IOR W0, W1, W3
009050  9F9FE2     MOV W2, [W15-68]
009052  9F9FF3     MOV W3, [W15-66]
2326:                      }
2327:                  }
2328:                  else
2329:                  {
2330:                      /* If the signature is not correct, this is neither a MBR, nor a VBR */
2331:                      FSerrno = CE_BAD_PARTITION;
2332:                      return EOF;
00901E  EB0200     CLR W4
2333:                  }
2334:              
2335:                  switch (mode)
009054  E00408     CP0.B W8
009056  320276     BRA Z, 0x9544
00905A  544FE1     SUB.B W8, #0x1, [W15]
00905C  3A0279     BRA NZ, 0x9550
2336:                  {
2337:                      // True: Rewrite the whole boot sector
2338:                      case 1:
2339:                          secCount = masterBootRecord->Partition0.PTE_NumSect;
00905E  93C8A4     MOV.B [W4+458], W1
009060  FB8081     ZE W1, W1
009062  93C834     MOV.B [W4+459], W0
009064  DD0048     SL W0, #8, W0
009066  700501     IOR W0, W1, W10
009068  93C8C4     MOV.B [W4+460], W1
00906A  FB8081     ZE W1, W1
00906C  93C854     MOV.B [W4+461], W0
00906E  DD0048     SL W0, #8, W0
009070  700581     IOR W0, W1, W11
2340:              
2341:                          if (secCount < 0x1039)
009072  210380     MOV #0x1038, W0
009074  550F80     SUB W10, W0, [W15]
009076  5D8FE0     SUBB W11, #0x0, [W15]
009078  3E001D     BRA GTU, 0x90B4
2342:                          {
2343:                              disk->type = FAT12;
00907A  9FDFC8     MOV.B W8, [W15-36]
2344:                              // Format to FAT12 only if there are too few sectors to format
2345:                              // as FAT16
2346:                              masterBootRecord->Partition0.PTE_FSDesc = 0x01;
00907C  9BC228     MOV.B W8, [W4+450]
2347:                              if (MDD_SectorWrite (0x00, gDataBuffer, TRUE) == FALSE)
00907E  784188     MOV.B W8, W3
009080  26A982     MOV #0x6A98, W2
009082  B80060     MUL.UU W0, #0, W0
009084  07232A     RCALL MDD_SDSPI_SectorWrite
009086  E00400     CP0.B W0
009088  32025B     BRA Z, 0x9540
2348:                              {
2349:                                  FSerrno = CE_WRITE_ERROR;
2350:                                  return EOF;
2351:                              }
2352:              
2353:                              if (secCount >= 0x1028)
00908A  210271     MOV #0x1027, W1
00908C  550F81     SUB W10, W1, [W15]
00908E  5D8FE0     SUBB W11, #0x0, [W15]
009090  360003     BRA LEU, 0x9098
2354:                              {
2355:                                  // More than 0x18 sectors for FATs, 0x20 for root dir,
2356:                                  // 0x8 reserved, and 0xFED for data
2357:                                  // So double the number of sectors in a cluster to reduce
2358:                                  // the number of data clusters used
2359:                                  disk->SecPerClus = 2;
009092  B3C020     MOV #0x2, W0
009094  9FDFB0     MOV.B W0, [W15-37]
009096  370001     BRA 0x909A
2360:                              }
2361:                              else
2362:                              {
2363:                                  // One sector per cluster
2364:                                  disk->SecPerClus = 1;
009098  9FDFB8     MOV.B W8, [W15-37]
2365:                              }
2366:              
2367:                              // Prepare a boot sector
2368:                              memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE);
00909A  202008     MOV #0x200, W8
00909C  780108     MOV W8, W2
00909E  EB0080     CLR W1
0090A0  26A980     MOV #0x6A98, W0
0090A2  07E33E     RCALL memset
2369:              
2370:                              // Last digit of file system name (FAT12   )
2371:                              gDataBuffer[58] = '2';
0090A4  B3C321     MOV #0x32, W1
0090A6  26AD20     MOV #0x6AD2, W0
0090A8  784801     MOV.B W1, [W0]
2372:              
2373:                              // Calculate the size of the FAT
2374:                              fatsize = (secCount - 0x21  + (2*disk->SecPerClus));
0090AA  97D83F     MOV.B [W15-37], W0
0090AC  FB8000     ZE W0, W0
2375:                              test =   (341 * disk->SecPerClus) + 2;
0090AE  201552     MOV #0x155, W2
0090B0  B98102     MUL.SS W0, W2, W2
0090B2  370029     BRA 0x9106
2376:                              fatsize = (fatsize + (test-1)) / test;
2377:                  
2378:                              disk->fatcopy = 0x02;
2379:                              disk->maxroot = 0x200;
2380:                  
2381:                              disk->fatsize = fatsize;
2382:              
2383:                          }
2384:                          else if (secCount <= 0x3FFD5F)
0090B4  2FD5F0     MOV #0xFD5F, W0
0090B6  2003F1     MOV #0x3F, W1
0090B8  550F80     SUB W10, W0, [W15]
0090BA  5D8F81     SUBB W11, W1, [W15]
0090BC  3E002F     BRA GTU, 0x911C
2385:                          {
2386:                              disk->type = FAT16;
0090BE  B3C020     MOV #0x2, W0
0090C0  9FDFC0     MOV.B W0, [W15-36]
2387:                              // Format to FAT16
2388:                              masterBootRecord->Partition0.PTE_FSDesc = 0x06;
0090C2  B3C060     MOV #0x6, W0
0090C4  9BC220     MOV.B W0, [W4+450]
2389:                              if (MDD_SectorWrite (0x00, gDataBuffer, TRUE) == FALSE)
0090C6  784188     MOV.B W8, W3
0090C8  26A982     MOV #0x6A98, W2
0090CA  B80060     MUL.UU W0, #0, W0
0090CC  072306     RCALL MDD_SDSPI_SectorWrite
0090CE  E00400     CP0.B W0
0090D0  320237     BRA Z, 0x9540
2390:                              {
2391:                                  FSerrno = CE_WRITE_ERROR;
2392:                                  return EOF;
2393:                              }
2394:              
2395:                              DataClusters = secCount - 0x218;
0090D2  BE000A     MOV.D W10, W0
0090D4  B12180     SUB #0x218, W0
0090D6  B18001     SUBB #0x0, W1
0090D8  784108     MOV.B W8, W2
0090DA  370003     BRA 0x90E2
2396:                              // Figure out how many sectors per cluster we need
2397:                              disk->SecPerClus = 1;
2398:                              while (DataClusters > 0xFFED)
0090E2  400FF3     ADD W0, #0x13, [W15]
0090E4  588FE0     SUBB W1, #0x0, [W15]
0090E6  3EFFFA     BRA GTU, 0x90DC
0090E8  9FDFB2     MOV.B W2, [W15-37]
2399:                              {
2400:                                  disk->SecPerClus *= 2;
0090DC  D04102     SL.B W2, W2
2401:                                  DataClusters /= 2;
0090DE  D10081     LSR W1, W1
0090E0  D38000     RRC W0, W0
2402:                              }
2403:                              // This shouldnt happen
2404:                              if (disk->SecPerClus > 128)
0090EA  B3C800     MOV #0x80, W0
0090EC  514F80     SUB.B W2, W0, [W15]
0090EE  3E0030     BRA GTU, 0x9150
2405:                              {
2406:                                  FSerrno = CE_BAD_PARTITION;
2407:                                  return EOF;
2408:                              }
2409:              
2410:                              // Prepare a boot sector
2411:                              memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE);
0090F0  202008     MOV #0x200, W8
0090F2  780108     MOV W8, W2
0090F4  EB0080     CLR W1
0090F6  26A980     MOV #0x6A98, W0
0090F8  07E313     RCALL memset
2412:              
2413:                              // Last digit of file system name (FAT16   )
2414:                              gDataBuffer[58] = '6';
0090FA  B3C361     MOV #0x36, W1
0090FC  26AD20     MOV #0x6AD2, W0
0090FE  784801     MOV.B W1, [W0]
2415:              
2416:                              // Calculate the size of the FAT
2417:                              fatsize = (secCount - 0x21  + (2*disk->SecPerClus));
009100  97D83F     MOV.B [W15-37], W0
009102  FB8000     ZE W0, W0
2418:                              test =    (256  * disk->SecPerClus) + 2;
009104  DD0148     SL W0, #8, W2
009106  E88102     INC2 W2, W2
009108  DE91CF     ASR W2, #15, W3
2419:                              fatsize = (fatsize + (test-1)) / test;
00910A  400000     ADD W0, W0, W0
00910C  DE80CF     ASR W0, #15, W1
00910E  40000A     ADD W0, W10, W0
009110  48808B     ADDC W1, W11, W1
009112  410000     ADD W2, W0, W0
009114  498081     ADDC W3, W1, W1
009116  B10220     SUB #0x22, W0
009118  B18001     SUBB #0x0, W1
00911A  37002A     BRA 0x9170
2420:                  
2421:                              disk->fatcopy = 0x02;
2422:                              disk->maxroot = 0x200;
2423:                  
2424:                              disk->fatsize = fatsize;
2425:                          }
2426:                          else
2427:                          {
2428:                              disk->type = FAT32;
00911C  B3C030     MOV #0x3, W0
00911E  9FDFC0     MOV.B W0, [W15-36]
2429:                              // Format to FAT32
2430:                              masterBootRecord->Partition0.PTE_FSDesc = 0x0B;
009120  B3C0B0     MOV #0xB, W0
009122  9BC220     MOV.B W0, [W4+450]
2431:                              if (MDD_SectorWrite (0x00, gDataBuffer, TRUE) == FALSE)
009124  784188     MOV.B W8, W3
009126  26A982     MOV #0x6A98, W2
009128  B80060     MUL.UU W0, #0, W0
00912A  0722D7     RCALL MDD_SDSPI_SectorWrite
00912C  E00400     CP0.B W0
00912E  320208     BRA Z, 0x9540
2432:                              {
2433:                                  FSerrno = CE_WRITE_ERROR;
2434:                                  return EOF;
009130  BE020A     MOV.D W10, W4
009132  784088     MOV.B W8, W1
009134  2BFFE2     MOV #0xBFFE, W2
009136  2003F3     MOV #0x3F, W3
2435:                              }
2436:              
2437:                              #ifdef FORMAT_SECTORS_PER_CLUSTER
2438:                                  disk->SecPerClus = FORMAT_SECTORS_PER_CLUSTER;
2439:                                  DataClusters = secCount / disk->SecPerClus;
2440:              
2441:                                  /* FAT32: 65526 < Number of clusters < 4177918 */
2442:                                  if ((DataClusters <= 65526) || (DataClusters >= 4177918))
2443:                                  {
2444:                                      FSerrno = CE_BAD_PARTITION;
2445:                                      return EOF;
2446:                                  }
2447:                              #else               
2448:                                  /*  FAT32: 65526 < Number of clusters < 4177918 */
2449:                                  DataClusters = secCount;
2450:                                  // Figure out how many sectors per cluster we need
2451:                                  disk->SecPerClus = 1;
2452:                                  while (DataClusters > 0x3FBFFE)
009142  520F82     SUB W4, W2, [W15]
009144  5A8F83     SUBB W5, W3, [W15]
009146  3EFFF8     BRA GTU, 0x9138
009148  9FDFB0     MOV.B W0, [W15-37]
2453:                                  {
2454:                                      disk->SecPerClus *= 2;
009138  FB8001     ZE W1, W0
00913A  400000     ADD W0, W0, W0
00913C  784080     MOV.B W0, W1
2455:                                      DataClusters /= 2;
00913E  D10285     LSR W5, W5
009140  D38204     RRC W4, W4
2456:                                  }
2457:                              #endif
2458:                              // Check the cluster size: FAT32 supports 512, 1024, 2048, 4096, 8192, 16K, 32K, 64K
2459:                              if (disk->SecPerClus > 128)
00914A  B3C800     MOV #0x80, W0
00914C  50CF80     SUB.B W1, W0, [W15]
00914E  360002     BRA LEU, 0x9154
2460:                              {
2461:                                  FSerrno = CE_BAD_PARTITION;
009150  B3C041     MOV #0x4, W1
009152  3701FE     BRA 0x9550
2462:                                  return EOF;
2463:                              }
2464:              
2465:                              // Prepare a boot sector
2466:                              memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE);
009154  202008     MOV #0x200, W8
009156  780108     MOV W8, W2
009158  EB0080     CLR W1
00915A  26A980     MOV #0x6A98, W0
00915C  07E2E1     RCALL memset
2467:              
2468:                             // Calculate the size of the FAT
2469:                              fatsize = (secCount - 0x20);
2470:                              test =    (128  * disk->SecPerClus) + 1;
00915E  97D93F     MOV.B [W15-37], W2
009160  FB8102     ZE W2, W2
009162  DD1147     SL W2, #7, W2
009164  E80102     INC W2, W2
009166  DE91CF     ASR W2, #15, W3
2471:                              fatsize = (fatsize + (test-1)) / test;
009168  41000A     ADD W2, W10, W0
00916A  49808B     ADDC W3, W11, W1
00916C  B10210     SUB #0x21, W0
00916E  B18001     SUBB #0x0, W1
009170  07E198     RCALL __udivsi3
009172  BE0200     MOV.D W0, W4
2472:                  
2473:                              disk->fatcopy = 0x02;
009174  B3C020     MOV #0x2, W0
009176  9FDFA0     MOV.B W0, [W15-38]
2474:                              disk->maxroot = 0x200;
009178  9FA7E8     MOV W8, [W15-52]
2475:                  
2476:                              disk->fatsize = fatsize;
00917A  9FAFB4     MOV W4, [W15-42]
00917C  9FAFC5     MOV W5, [W15-40]
2477:                          }
2478:              
2479:                          // Non-file system specific values
2480:                          gDataBuffer[0] = 0xEB;         //Jump instruction
00917E  B3CEB0     MOV #0xEB, W0
009180  26A982     MOV #0x6A98, W2
009182  784900     MOV.B W0, [W2]
2481:                          gDataBuffer[1] = 0x3C;
009184  B3C3C1     MOV #0x3C, W1
009186  26A990     MOV #0x6A99, W0
009188  784801     MOV.B W1, [W0]
2482:                          gDataBuffer[2] = 0x90;
00918A  B3C901     MOV #0x90, W1
00918C  26A9A0     MOV #0x6A9A, W0
00918E  784801     MOV.B W1, [W0]
2483:                          gDataBuffer[3] =  'M';         //OEM Name "MCHP FAT"
009190  B3C4D1     MOV #0x4D, W1
009192  26A9B0     MOV #0x6A9B, W0
009194  784801     MOV.B W1, [W0]
2484:                          gDataBuffer[4] =  'C';
009196  50C0EA     SUB.B W1, #0xA, W1
009198  26A9C0     MOV #0x6A9C, W0
00919A  784801     MOV.B W1, [W0]
2485:                          gDataBuffer[5] =  'H';
00919C  40C0E5     ADD.B W1, #0x5, W1
00919E  26A9D0     MOV #0x6A9D, W0
0091A0  784801     MOV.B W1, [W0]
2486:                          gDataBuffer[6] =  'P';
0091A2  40C0E8     ADD.B W1, #0x8, W1
0091A4  26A9E0     MOV #0x6A9E, W0
0091A6  784801     MOV.B W1, [W0]
2487:                          gDataBuffer[7] =  ' ';
0091A8  B3C203     MOV #0x20, W3
0091AA  26A9F0     MOV #0x6A9F, W0
0091AC  784803     MOV.B W3, [W0]
2488:                          gDataBuffer[8] =  'F';
0091AE  50C0EA     SUB.B W1, #0xA, W1
0091B0  26AA00     MOV #0x6AA0, W0
0091B2  784801     MOV.B W1, [W0]
2489:                          gDataBuffer[9] =  'A';
0091B4  50C0E5     SUB.B W1, #0x5, W1
0091B6  26AA10     MOV #0x6AA1, W0
0091B8  784801     MOV.B W1, [W0]
2490:                          gDataBuffer[10] = 'T';
0091BA  40C0F3     ADD.B W1, #0x13, W1
0091BC  26AA20     MOV #0x6AA2, W0
0091BE  784801     MOV.B W1, [W0]
2491:              
2492:                          gDataBuffer[11] = 0x00;             //Sector size 
0091C0  26AA30     MOV #0x6AA3, W0
0091C2  EB4800     CLR.B [W0]
2493:                          gDataBuffer[12] = 0x02;
0091C4  B3C02E     MOV #0x2, W14
0091C6  26AA40     MOV #0x6AA4, W0
0091C8  78480E     MOV.B W14, [W0]
2494:              
2495:                          gDataBuffer[13] = disk->SecPerClus;   //Sectors per cluster
0091CA  26AA50     MOV #0x6AA5, W0
0091CC  97DB3F     MOV.B [W15-37], W6
0091CE  784806     MOV.B W6, [W0]
2496:              
2497:                          if ((disk->type == FAT12) || (disk->type == FAT16))
0091D0  97D84F     MOV.B [W15-36], W0
0091D2  E94000     DEC.B W0, W0
0091D4  9FEF80     MOV.B W0, [W15-24]
0091D6  26AA72     MOV #0x6AA7, W2
0091D8  DD2B48     SL W5, #8, W6
0091DA  DE2048     LSR W4, #8, W0
0091DC  730000     IOR W6, W0, W0
0091DE  DE28C8     LSR W5, #8, W1
0091E0  9FB7F0     MOV W0, [W15-18]
0091E2  9FBF81     MOV W1, [W15-16]
0091E4  DD5848     SL W11, #8, W0
0091E6  DE5448     LSR W10, #8, W8
0091E8  700408     IOR W0, W8, W8
0091EA  DE5CC8     LSR W11, #8, W9
0091EC  DE5840     LSR W11, #0, W0
0091EE  200001     MOV #0x0, W1
0091F0  9FB780     MOV W0, [W15-32]
0091F2  9FB791     MOV W1, [W15-30]
0091F4  DE5848     LSR W11, #8, W0
0091F6  200001     MOV #0x0, W1
0091F8  9FB7A0     MOV W0, [W15-28]
0091FA  9FB7B1     MOV W1, [W15-26]
0091FC  97E88F     MOV.B [W15-24], W1
0091FE  50CFE1     SUB.B W1, #0x1, [W15]
009200  3E00A3     BRA GTU, 0x9348
2498:                          {
2499:                              gDataBuffer[14] = 0x08;         //Reserved sector count
009202  B3C080     MOV #0x8, W0
009204  26AA63     MOV #0x6AA6, W3
009206  784980     MOV.B W0, [W3]
2500:                              gDataBuffer[15] = 0x00;
009208  EB4900     CLR.B [W2]
2501:                              disk->fat = 0x08 + disk->firsts;
00920A  97996F     MOV [W15-68], W2
00920C  9799FF     MOV [W15-66], W3
00920E  410068     ADD W2, #0x8, W0
009210  4980E0     ADDC W3, #0x0, W1
009212  9FA780     MOV W0, [W15-64]
009214  9FA791     MOV W1, [W15-62]
2502:              
2503:                              gDataBuffer[16] = 0x02;         //number of FATs
009216  26AA86     MOV #0x6AA8, W6
009218  784B0E     MOV.B W14, [W6]
2504:              
2505:                              gDataBuffer[17] = 0x00;          //Max number of root directory entries - 512 files allowed
00921A  26AA90     MOV #0x6AA9, W0
00921C  EB4800     CLR.B [W0]
2506:                              gDataBuffer[18] = 0x02;
00921E  26AAA1     MOV #0x6AAA, W1
009220  78488E     MOV.B W14, [W1]
2507:              
2508:                              gDataBuffer[19] = 0x00;         //total sectors
009222  26AAB6     MOV #0x6AAB, W6
009224  EB4B00     CLR.B [W6]
2509:                              gDataBuffer[20] = 0x00;
009226  26AAC0     MOV #0x6AAC, W0
009228  EB4800     CLR.B [W0]
2510:              
2511:                              gDataBuffer[21] = 0xF8;         //Media Descriptor
00922A  B3CF80     MOV #0xF8, W0
00922C  26AAD1     MOV #0x6AAD, W1
00922E  784880     MOV.B W0, [W1]
2512:              
2513:                              gDataBuffer[22] = fatsize & 0xFF;         //Sectors per FAT
009230  26AAE6     MOV #0x6AAE, W6
009232  784B04     MOV.B W4, [W6]
2514:                              gDataBuffer[23] = (fatsize >> 8) & 0xFF;
009234  97E8EF     MOV.B [W15-18], W1
009236  26AAF0     MOV #0x6AAF, W0
009238  784801     MOV.B W1, [W0]
2515:              
2516:                              gDataBuffer[24] = 0x3F;           //Sectors per track
00923A  B3C3F0     MOV #0x3F, W0
00923C  26AB04     MOV #0x6AB0, W4
00923E  784A00     MOV.B W0, [W4]
2517:                              gDataBuffer[25] = 0x00;
009240  26AB15     MOV #0x6AB1, W5
009242  EB4A80     CLR.B [W5]
2518:                  
2519:                              gDataBuffer[26] = 0xFF;         //Number of heads
009244  26AB26     MOV #0x6AB2, W6
009246  EBCB00     SETM.B [W6]
2520:                              gDataBuffer[27] = 0x00;
009248  26AB30     MOV #0x6AB3, W0
00924A  EB4800     CLR.B [W0]
2521:                  
2522:                              // Hidden sectors = sectors between the MBR and the boot sector
2523:                              gDataBuffer[28] = (BYTE)(disk->firsts & 0xFF);
00924C  97986F     MOV [W15-68], W0
00924E  780083     MOV W3, W1
009250  26AB42     MOV #0x6AB4, W2
009252  784900     MOV.B W0, [W2]
2524:                              gDataBuffer[29] = (BYTE)((disk->firsts / 0x100) & 0xFF);
009254  DE09C8     LSR W1, #8, W3
009256  DD0A48     SL W1, #8, W4
009258  DE0148     LSR W0, #8, W2
00925A  720102     IOR W4, W2, W2
00925C  26AB55     MOV #0x6AB5, W5
00925E  784A82     MOV.B W2, [W5]
2525:                              gDataBuffer[30] = (BYTE)((disk->firsts / 0x10000) & 0xFF);
009260  DE0940     LSR W1, #0, W2
009262  200003     MOV #0x0, W3
009264  26AB66     MOV #0x6AB6, W6
009266  784B02     MOV.B W2, [W6]
2526:                              gDataBuffer[31] = (BYTE)((disk->firsts / 0x1000000) & 0xFF);
009268  DE0848     LSR W1, #8, W0
00926A  26AB72     MOV #0x6AB7, W2
00926C  784900     MOV.B W0, [W2]
2527:                  
2528:                              // Total Sectors = same as sectors in the partition from MBR
2529:                              gDataBuffer[32] = (BYTE)(secCount & 0xFF);
00926E  26AB83     MOV #0x6AB8, W3
009270  78498A     MOV.B W10, [W3]
2530:                              gDataBuffer[33] = (BYTE)((secCount / 0x100) & 0xFF);
009272  26AB94     MOV #0x6AB9, W4
009274  784A08     MOV.B W8, [W4]
2531:                              gDataBuffer[34] = (BYTE)((secCount / 0x10000) & 0xFF);
009276  97E30F     MOV.B [W15-32], W6
009278  26ABA5     MOV #0x6ABA, W5
00927A  784A86     MOV.B W6, [W5]
2532:                              gDataBuffer[35] = (BYTE)((secCount / 0x1000000) & 0xFF);
00927C  97E04F     MOV.B [W15-28], W0
00927E  26ABB8     MOV #0x6ABB, W8
009280  784C00     MOV.B W0, [W8]
2533:              
2534:                              gDataBuffer[36] = 0x00;         // Physical drive number
009282  26ABC1     MOV #0x6ABC, W1
009284  EB4880     CLR.B [W1]
2535:              
2536:                              gDataBuffer[37] = 0x00;         // Reserved (current head)
009286  26ABD2     MOV #0x6ABD, W2
009288  EB4900     CLR.B [W2]
2537:              
2538:                              gDataBuffer[38] = 0x29;         // Signature code
00928A  B3C290     MOV #0x29, W0
00928C  26ABE3     MOV #0x6ABE, W3
00928E  784980     MOV.B W0, [W3]
2539:              
2540:                              gDataBuffer[39] = (BYTE)(serialNumber & 0xFF);
009290  26ABF4     MOV #0x6ABF, W4
009292  784A0C     MOV.B W12, [W4]
2541:                              gDataBuffer[40] = (BYTE)((serialNumber / 0x100) & 0xFF);
009294  BE000C     MOV.D W12, W0
009296  560FE0     SUB W12, #0x0, [W15]
009298  5E8FE0     SUBB W13, #0x0, [W15]
00929A  3D0002     BRA GE, 0x92A0
00929C  B00FF0     ADD #0xFF, W0
00929E  B08001     ADDC #0x0, W1
0092A0  DD0AC8     SL W1, #8, W5
0092A2  DE0048     LSR W0, #8, W0
0092A4  728000     IOR W5, W0, W0
0092A6  DE88C8     ASR W1, #8, W1
0092A8  26AC06     MOV #0x6AC0, W6
0092AA  784B00     MOV.B W0, [W6]
2542:                              gDataBuffer[41] = (BYTE)((serialNumber / 0x10000) & 0xFF);
0092AC  BE000C     MOV.D W12, W0
0092AE  560FE0     SUB W12, #0x0, [W15]
0092B0  5E8FE0     SUBB W13, #0x0, [W15]
0092B2  3D0004     BRA GE, 0x92BC
0092B4  2FFFF0     MOV #0xFFFF, W0
0092B6  200001     MOV #0x0, W1
0092B8  40000C     ADD W0, W12, W0
0092BA  48808D     ADDC W1, W13, W1
0092BC  DE8840     ASR W1, #0, W0
0092BE  DE80CF     ASR W0, #15, W1
0092C0  26AC12     MOV #0x6AC1, W2
0092C2  784900     MOV.B W0, [W2]
2543:                              gDataBuffer[42] = (BYTE)((serialNumber / 0x1000000) & 0xFF);
0092C4  BE000C     MOV.D W12, W0
0092C6  560FE0     SUB W12, #0x0, [W15]
0092C8  5E8FE0     SUBB W13, #0x0, [W15]
0092CA  3D0004     BRA GE, 0x92D4
0092CC  2FFFF0     MOV #0xFFFF, W0
0092CE  200FF1     MOV #0xFF, W1
0092D0  40000C     ADD W0, W12, W0
0092D2  48808D     ADDC W1, W13, W1
0092D4  DE8848     ASR W1, #8, W0
0092D6  DE80CF     ASR W0, #15, W1
0092D8  26AC22     MOV #0x6AC2, W2
0092DA  784900     MOV.B W0, [W2]
2544:              
2545:                              // Volume ID
2546:                              if (volumeID != NULL)
0092DC  97AC7F     MOV [W15-34], W8
0092DE  E00008     CP0 W8
0092E0  32001B     BRA Z, 0x9318
0092E2  B81160     MUL.UU W2, #0, W2
0092E4  26AC31     MOV #0x6AC3, W1
0092E6  26A984     MOV #0x6A98, W4
0092E8  370003     BRA 0x92F0
2547:                              {
2548:                                  for (Index = 0; (*(volumeID + Index) != 0) && (Index < 11); Index++)
0092EC  410161     ADD W2, #0x1, W2
0092EE  4981E0     ADDC W3, #0x0, W3
0092F0  97AAFF     MOV [W15-34], W5
0092F2  794065     MOV.B [W5+W2], W0
0092F4  E00400     CP0.B W0
0092F6  3A0004     BRA NZ, 0x9300
0092F8  2002B0     MOV #0x2B, W0
0092FA  400002     ADD W0, W2, W0
0092FC  400084     ADD W0, W4, W1
0092FE  370008     BRA 0x9310
009300  510FEB     SUB W2, #0xB, [W15]
009302  598FE0     SUBB W3, #0x0, [W15]
009304  3AFFF2     BRA NZ, 0x92EA
009306  37000D     BRA 0x9322
2549:                                  {
2550:                                      gDataBuffer[Index + 43] = *(volumeID + Index);
0092EA  785880     MOV.B W0, [W1++]
2551:                                  }
2552:                                  while (Index < 11)
009310  510FEA     SUB W2, #0xA, [W15]
009312  598FE0     SUBB W3, #0x0, [W15]
009314  36FFF9     BRA LEU, 0x9308
009316  370005     BRA 0x9322
009318  26AC30     MOV #0x6AC3, W0
00931A  26ACE1     MOV #0x6ACE, W1
2553:                                  {
2554:                                      gDataBuffer[43 + Index++] = 0x20;
009308  B3C200     MOV #0x20, W0
00930A  785880     MOV.B W0, [W1++]
00930C  410161     ADD W2, #0x1, W2
00930E  4981E0     ADDC W3, #0x0, W3
2555:                                  }
2556:                              }
2557:                              else
2558:                              {
2559:                                  for (Index = 0; Index < 11; Index++)
00931E  500F81     SUB W0, W1, [W15]
009320  3AFFFD     BRA NZ, 0x931C
2560:                                  {
2561:                                      gDataBuffer[Index+43] = 0;
00931C  EB5800     CLR.B [W0++]
2562:                                  }
2563:                              }
2564:              
2565:                              gDataBuffer[54] = 'F';
009322  B3C461     MOV #0x46, W1
009324  26ACE0     MOV #0x6ACE, W0
009326  784801     MOV.B W1, [W0]
2566:                              gDataBuffer[55] = 'A';
009328  50C0E5     SUB.B W1, #0x5, W1
00932A  26ACF0     MOV #0x6ACF, W0
00932C  784801     MOV.B W1, [W0]
2567:                              gDataBuffer[56] = 'T';
00932E  40C0F3     ADD.B W1, #0x13, W1
009330  26AD00     MOV #0x6AD0, W0
009332  784801     MOV.B W1, [W0]
2568:                              gDataBuffer[57] = '1';
009334  B3C311     MOV #0x31, W1
009336  26AD10     MOV #0x6AD1, W0
009338  784801     MOV.B W1, [W0]
2569:                              gDataBuffer[59] = ' ';
00933A  50C0F1     SUB.B W1, #0x11, W1
00933C  26AD30     MOV #0x6AD3, W0
00933E  784801     MOV.B W1, [W0]
2570:                              gDataBuffer[60] = ' ';
009340  26AD40     MOV #0x6AD4, W0
009342  784801     MOV.B W1, [W0]
2571:                              gDataBuffer[61] = ' ';
009344  26AD50     MOV #0x6AD5, W0
009346  3700E2     BRA 0x950C
2572:              
2573:                          }
2574:                          else //FAT32
2575:                          {
2576:                              gDataBuffer[14] = 0x20;         //Reserved sector count
009348  26AA66     MOV #0x6AA6, W6
00934A  784B03     MOV.B W3, [W6]
2577:                              gDataBuffer[15] = 0x00;
00934C  EB4900     CLR.B [W2]
2578:                              disk->fat = 0x20 + disk->firsts;
00934E  97996F     MOV [W15-68], W2
009350  9799FF     MOV [W15-66], W3
009352  BE0002     MOV.D W2, W0
009354  B00200     ADD #0x20, W0
009356  B08001     ADDC #0x0, W1
009358  9FA780     MOV W0, [W15-64]
00935A  9FA791     MOV W1, [W15-62]
2579:              
2580:                              gDataBuffer[16] = 0x02;         //number of FATs
00935C  26AA80     MOV #0x6AA8, W0
00935E  78480E     MOV.B W14, [W0]
2581:              
2582:                              gDataBuffer[17] = 0x00;          //Max number of root directory entries - 512 files allowed
009360  26AA91     MOV #0x6AA9, W1
009362  EB4880     CLR.B [W1]
2583:                              gDataBuffer[18] = 0x00;
009364  26AAA6     MOV #0x6AAA, W6
009366  EB4B00     CLR.B [W6]
2584:              
2585:                              gDataBuffer[19] = 0x00;         //total sectors
009368  26AAB0     MOV #0x6AAB, W0
00936A  EB4800     CLR.B [W0]
2586:                              gDataBuffer[20] = 0x00;
00936C  26AAC1     MOV #0x6AAC, W1
00936E  EB4880     CLR.B [W1]
2587:              
2588:                              gDataBuffer[21] = 0xF8;         //Media Descriptor
009370  B3CF80     MOV #0xF8, W0
009372  26AAD6     MOV #0x6AAD, W6
009374  784B00     MOV.B W0, [W6]
2589:              
2590:                              gDataBuffer[22] = 0x00;         //Sectors per FAT
009376  26AAE0     MOV #0x6AAE, W0
009378  EB4800     CLR.B [W0]
2591:                              gDataBuffer[23] = 0x00;
00937A  26AAF1     MOV #0x6AAF, W1
00937C  EB4880     CLR.B [W1]
2592:              
2593:                              gDataBuffer[24] = 0x3F;         //Sectors per track
00937E  B3C3F0     MOV #0x3F, W0
009380  26AB06     MOV #0x6AB0, W6
009382  784B00     MOV.B W0, [W6]
2594:                              gDataBuffer[25] = 0x00;
009384  26AB10     MOV #0x6AB1, W0
009386  EB4800     CLR.B [W0]
2595:                  
2596:                              gDataBuffer[26] = 0xFF;         //Number of heads
009388  26AB21     MOV #0x6AB2, W1
00938A  EBC880     SETM.B [W1]
2597:                              gDataBuffer[27] = 0x00;
00938C  26AB36     MOV #0x6AB3, W6
00938E  EB4B00     CLR.B [W6]
2598:                  
2599:                              // Hidden sectors = sectors between the MBR and the boot sector
2600:                              gDataBuffer[28] = (BYTE)(disk->firsts & 0xFF);
009390  97986F     MOV [W15-68], W0
009392  780083     MOV W3, W1
009394  26AB42     MOV #0x6AB4, W2
009396  784900     MOV.B W0, [W2]
2601:                              gDataBuffer[29] = (BYTE)((disk->firsts / 0x100) & 0xFF);
009398  DE09C8     LSR W1, #8, W3
00939A  DD0B48     SL W1, #8, W6
00939C  DE0148     LSR W0, #8, W2
00939E  730102     IOR W6, W2, W2
0093A0  26AB53     MOV #0x6AB5, W3
0093A2  784982     MOV.B W2, [W3]
2602:                              gDataBuffer[30] = (BYTE)((disk->firsts / 0x10000) & 0xFF);
0093A4  DE0940     LSR W1, #0, W2
0093A6  200003     MOV #0x0, W3
0093A8  26AB63     MOV #0x6AB6, W3
0093AA  784982     MOV.B W2, [W3]
2603:                              gDataBuffer[31] = (BYTE)((disk->firsts / 0x1000000) & 0xFF);
0093AC  DE0848     LSR W1, #8, W0
0093AE  26AB76     MOV #0x6AB7, W6
0093B0  784B00     MOV.B W0, [W6]
2604:                  
2605:                              // Total Sectors = same as sectors in the partition from MBR
2606:                              gDataBuffer[32] = (BYTE)(secCount & 0xFF);
0093B2  26AB80     MOV #0x6AB8, W0
0093B4  78480A     MOV.B W10, [W0]
2607:                              gDataBuffer[33] = (BYTE)((secCount / 0x100) & 0xFF);
0093B6  26AB91     MOV #0x6AB9, W1
0093B8  784888     MOV.B W8, [W1]
2608:                              gDataBuffer[34] = (BYTE)((secCount / 0x10000) & 0xFF);
0093BA  97E18F     MOV.B [W15-32], W3
0093BC  26ABA2     MOV #0x6ABA, W2
0093BE  784903     MOV.B W3, [W2]
2609:                              gDataBuffer[35] = (BYTE)((secCount / 0x1000000) & 0xFF);
0093C0  97E44F     MOV.B [W15-28], W8
0093C2  26ABB6     MOV #0x6ABB, W6
0093C4  784B08     MOV.B W8, [W6]
2610:              
2611:                              gDataBuffer[36] = fatsize & 0xFF;         //Sectors per FAT
0093C6  26ABC0     MOV #0x6ABC, W0
0093C8  784804     MOV.B W4, [W0]
2612:                              gDataBuffer[37] = (fatsize >>  8) & 0xFF;
0093CA  97E96F     MOV.B [W15-18], W2
0093CC  26ABD1     MOV #0x6ABD, W1
0093CE  784882     MOV.B W2, [W1]
2613:                              gDataBuffer[38] = (fatsize >> 16) & 0xFF;         
0093D0  DE2840     LSR W5, #0, W0
0093D2  200001     MOV #0x0, W1
0093D4  26ABE3     MOV #0x6ABE, W3
0093D6  784980     MOV.B W0, [W3]
2614:                              gDataBuffer[39] = (fatsize >> 24) & 0xFF;
0093D8  DE2848     LSR W5, #8, W0
0093DA  200001     MOV #0x0, W1
0093DC  26ABF4     MOV #0x6ABF, W4
0093DE  784A00     MOV.B W0, [W4]
2615:              
2616:                              gDataBuffer[40] = 0x00;         //Active FAT
0093E0  26AC05     MOV #0x6AC0, W5
0093E2  EB4A80     CLR.B [W5]
2617:                              gDataBuffer[41] = 0x00;
0093E4  26AC10     MOV #0x6AC1, W0
0093E6  EB4800     CLR.B [W0]
2618:              
2619:                              gDataBuffer[42] = 0x00;         //File System version  
0093E8  26AC20     MOV #0x6AC2, W0
0093EA  EB4800     CLR.B [W0]
2620:                              gDataBuffer[43] = 0x00;
0093EC  26AC30     MOV #0x6AC3, W0
0093EE  EB4800     CLR.B [W0]
2621:              
2622:                              gDataBuffer[44] = 0x02;         //First cluster of the root directory
0093F0  26AC40     MOV #0x6AC4, W0
0093F2  78480E     MOV.B W14, [W0]
2623:                              gDataBuffer[45] = 0x00;
0093F4  26AC50     MOV #0x6AC5, W0
0093F6  EB4800     CLR.B [W0]
2624:                              gDataBuffer[46] = 0x00;
0093F8  26AC60     MOV #0x6AC6, W0
0093FA  EB4800     CLR.B [W0]
2625:                              gDataBuffer[47] = 0x00;
0093FC  26AC70     MOV #0x6AC7, W0
0093FE  EB4800     CLR.B [W0]
2626:              
2627:                              gDataBuffer[48] = 0x01;         //FSInfo
009400  B3C011     MOV #0x1, W1
009402  26AC80     MOV #0x6AC8, W0
009404  784801     MOV.B W1, [W0]
2628:                              gDataBuffer[49] = 0x00;
009406  26AC90     MOV #0x6AC9, W0
009408  EB4800     CLR.B [W0]
2629:              
2630:                              gDataBuffer[50] = 0x00;         //Backup Boot Sector
00940A  26ACA0     MOV #0x6ACA, W0
00940C  EB4800     CLR.B [W0]
2631:                              gDataBuffer[51] = 0x00;
00940E  26ACB0     MOV #0x6ACB, W0
009410  EB4800     CLR.B [W0]
2632:              
2633:                              gDataBuffer[52] = 0x00;         //Reserved for future expansion
009412  26ACC0     MOV #0x6ACC, W0
009414  EB4800     CLR.B [W0]
2634:                              gDataBuffer[53] = 0x00;
009416  26ACD0     MOV #0x6ACD, W0
009418  EB4800     CLR.B [W0]
2635:                              gDataBuffer[54] = 0x00;                   
00941A  26ACE0     MOV #0x6ACE, W0
00941C  EB4800     CLR.B [W0]
2636:                              gDataBuffer[55] = 0x00;
00941E  26ACF0     MOV #0x6ACF, W0
009420  EB4800     CLR.B [W0]
2637:                              gDataBuffer[56] = 0x00;                   
009422  26AD00     MOV #0x6AD0, W0
009424  EB4800     CLR.B [W0]
2638:                              gDataBuffer[57] = 0x00;
009426  26AD10     MOV #0x6AD1, W0
009428  EB4800     CLR.B [W0]
2639:                              gDataBuffer[58] = 0x00;                   
00942A  26AD20     MOV #0x6AD2, W0
00942C  EB4800     CLR.B [W0]
2640:                              gDataBuffer[59] = 0x00;
00942E  26AD30     MOV #0x6AD3, W0
009430  EB4800     CLR.B [W0]
2641:                              gDataBuffer[60] = 0x00;                   
009432  26AD40     MOV #0x6AD4, W0
009434  EB4800     CLR.B [W0]
2642:                              gDataBuffer[61] = 0x00;
009436  26AD50     MOV #0x6AD5, W0
009438  EB4800     CLR.B [W0]
2643:                              gDataBuffer[62] = 0x00;                   
00943A  26AD60     MOV #0x6AD6, W0
00943C  EB4800     CLR.B [W0]
2644:                              gDataBuffer[63] = 0x00;
00943E  26AD70     MOV #0x6AD7, W0
009440  EB4800     CLR.B [W0]
2645:              
2646:                              gDataBuffer[64] = 0x00;         // Physical drive number
009442  26AD80     MOV #0x6AD8, W0
009444  EB4800     CLR.B [W0]
2647:              
2648:                              gDataBuffer[65] = 0x00;         // Reserved (current head)
009446  26AD90     MOV #0x6AD9, W0
009448  EB4800     CLR.B [W0]
2649:              
2650:                              gDataBuffer[66] = 0x29;         // Signature code
00944A  B3C291     MOV #0x29, W1
00944C  26ADA0     MOV #0x6ADA, W0
00944E  784801     MOV.B W1, [W0]
2651:              
2652:                              gDataBuffer[67] = (BYTE)(serialNumber & 0xFF);
009450  26ADB0     MOV #0x6ADB, W0
009452  78480C     MOV.B W12, [W0]
2653:                              gDataBuffer[68] = (BYTE)((serialNumber / 0x100) & 0xFF);
009454  BE000C     MOV.D W12, W0
009456  560FE0     SUB W12, #0x0, [W15]
009458  5E8FE0     SUBB W13, #0x0, [W15]
00945A  3D0002     BRA GE, 0x9460
00945C  B00FF0     ADD #0xFF, W0
00945E  B08001     ADDC #0x0, W1
009460  DD0B48     SL W1, #8, W6
009462  DE0048     LSR W0, #8, W0
009464  730000     IOR W6, W0, W0
009466  DE88C8     ASR W1, #8, W1
009468  26ADC2     MOV #0x6ADC, W2
00946A  784900     MOV.B W0, [W2]
2654:                              gDataBuffer[69] = (BYTE)((serialNumber / 0x10000) & 0xFF);
00946C  BE000C     MOV.D W12, W0
00946E  560FE0     SUB W12, #0x0, [W15]
009470  5E8FE0     SUBB W13, #0x0, [W15]
009472  3D0004     BRA GE, 0x947C
009474  2FFFF0     MOV #0xFFFF, W0
009476  200001     MOV #0x0, W1
009478  40000C     ADD W0, W12, W0
00947A  48808D     ADDC W1, W13, W1
00947C  DE8840     ASR W1, #0, W0
00947E  DE80CF     ASR W0, #15, W1
009480  26ADD2     MOV #0x6ADD, W2
009482  784900     MOV.B W0, [W2]
2655:                              gDataBuffer[70] = (BYTE)((serialNumber / 0x1000000) & 0xFF);
009484  BE010C     MOV.D W12, W2
009486  560FE0     SUB W12, #0x0, [W15]
009488  5E8FE0     SUBB W13, #0x0, [W15]
00948A  3D0004     BRA GE, 0x9494
00948C  2FFFF0     MOV #0xFFFF, W0
00948E  200FF1     MOV #0xFF, W1
009490  40010C     ADD W0, W12, W2
009492  48818D     ADDC W1, W13, W3
009494  DE9848     ASR W3, #8, W0
009496  DE80CF     ASR W0, #15, W1
009498  26ADE2     MOV #0x6ADE, W2
00949A  784900     MOV.B W0, [W2]
2656:              
2657:                              // Volume ID
2658:                              if (volumeID != NULL)
00949C  97AC7F     MOV [W15-34], W8
00949E  E00008     CP0 W8
0094A0  32001B     BRA Z, 0x94D8
0094A2  B81160     MUL.UU W2, #0, W2
0094A4  26ADF1     MOV #0x6ADF, W1
0094A6  26A984     MOV #0x6A98, W4
0094A8  370003     BRA 0x94B0
2659:                              {
2660:                                  for (Index = 0; (*(volumeID + Index) != 0) && (Index < 11); Index++)
0094AC  410161     ADD W2, #0x1, W2
0094AE  4981E0     ADDC W3, #0x0, W3
0094B0  97AAFF     MOV [W15-34], W5
0094B2  794065     MOV.B [W5+W2], W0
0094B4  E00400     CP0.B W0
0094B6  3A0004     BRA NZ, 0x94C0
0094B8  200470     MOV #0x47, W0
0094BA  400002     ADD W0, W2, W0
0094BC  400084     ADD W0, W4, W1
0094BE  370008     BRA 0x94D0
0094C0  510FEB     SUB W2, #0xB, [W15]
0094C2  598FE0     SUBB W3, #0x0, [W15]
0094C4  3AFFF2     BRA NZ, 0x94AA
0094C6  37000D     BRA 0x94E2
2661:                                  {
2662:                                      gDataBuffer[Index + 71] = *(volumeID + Index);
0094AA  785880     MOV.B W0, [W1++]
2663:                                  }
2664:                                  while (Index < 11)
0094D0  510FEA     SUB W2, #0xA, [W15]
0094D2  598FE0     SUBB W3, #0x0, [W15]
0094D4  36FFF9     BRA LEU, 0x94C8
0094D6  370005     BRA 0x94E2
0094D8  26ADF0     MOV #0x6ADF, W0
0094DA  26AEA1     MOV #0x6AEA, W1
2665:                                  {
2666:                                      gDataBuffer[71 + Index++] = 0x20;
0094C8  B3C200     MOV #0x20, W0
0094CA  785880     MOV.B W0, [W1++]
0094CC  410161     ADD W2, #0x1, W2
0094CE  4981E0     ADDC W3, #0x0, W3
2667:                                  }
2668:                              }
2669:                              else
2670:                              {
2671:                                  for (Index = 0; Index < 11; Index++)
0094DE  500F81     SUB W0, W1, [W15]
0094E0  3AFFFD     BRA NZ, 0x94DC
2672:                                  {
2673:                                      gDataBuffer[Index+71] = 0;
0094DC  EB5800     CLR.B [W0++]
2674:                                  }
2675:                              }
2676:              
2677:                              gDataBuffer[82] = 'F';
0094E2  B3C461     MOV #0x46, W1
0094E4  26AEA0     MOV #0x6AEA, W0
0094E6  784801     MOV.B W1, [W0]
2678:                              gDataBuffer[83] = 'A';
0094E8  50C0E5     SUB.B W1, #0x5, W1
0094EA  26AEB0     MOV #0x6AEB, W0
0094EC  784801     MOV.B W1, [W0]
2679:                              gDataBuffer[84] = 'T';
0094EE  40C0F3     ADD.B W1, #0x13, W1
0094F0  26AEC0     MOV #0x6AEC, W0
0094F2  784801     MOV.B W1, [W0]
2680:                              gDataBuffer[85] = '3';
0094F4  B3C331     MOV #0x33, W1
0094F6  26AED0     MOV #0x6AED, W0
0094F8  784801     MOV.B W1, [W0]
2681:                              gDataBuffer[86] = '2';
0094FA  E94081     DEC.B W1, W1
0094FC  26AEE0     MOV #0x6AEE, W0
0094FE  784801     MOV.B W1, [W0]
2682:                              gDataBuffer[87] = ' ';
009500  50C0F2     SUB.B W1, #0x12, W1
009502  26AEF0     MOV #0x6AEF, W0
009504  784801     MOV.B W1, [W0]
2683:                              gDataBuffer[88] = ' ';
009506  26AF00     MOV #0x6AF0, W0
009508  784801     MOV.B W1, [W0]
2684:                              gDataBuffer[89] = ' ';
00950A  26AF10     MOV #0x6AF1, W0
00950C  784801     MOV.B W1, [W0]
2685:              
2686:              
2687:                          }
2688:              
2689:              #ifdef __18CXX
2690:                          // C18 can't reference a value greater than 256
2691:                          // using an array name pointer
2692:                          *(dataBufferPointer + 510) = 0x55;
2693:                          *(dataBufferPointer + 511) = 0xAA;
2694:              #else
2695:                          gDataBuffer[510] = 0x55;
00950E  B3C551     MOV #0x55, W1
009510  26C960     MOV #0x6C96, W0
009512  784801     MOV.B W1, [W0]
2696:                          gDataBuffer[511] = 0xAA;
009514  B3CAA1     MOV #0xAA, W1
009516  26C970     MOV #0x6C97, W0
009518  784801     MOV.B W1, [W0]
2697:              #endif
2698:              
2699:                          disk->root = disk->fat + (disk->fatcopy * disk->fatsize);
00951A  97A40F     MOV [W15-64], W8
00951C  97A49F     MOV [W15-62], W9
00951E  97D82F     MOV.B [W15-38], W0
009520  FB8000     ZE W0, W0
009522  200001     MOV #0x0, W1
009524  97A93F     MOV [W15-42], W2
009526  97A9CF     MOV [W15-40], W3
009528  07DF4C     RCALL __mulp32eds3
00952A  400408     ADD W0, W8, W8
00952C  488489     ADDC W1, W9, W9
00952E  9FA7A8     MOV W8, [W15-60]
009530  9FA7B9     MOV W9, [W15-58]
2700:              
2701:                          if (MDD_SectorWrite (disk->firsts, gDataBuffer, FALSE) == FALSE)
009532  97986F     MOV [W15-68], W0
009534  9798FF     MOV [W15-66], W1
009536  EB4180     CLR.B W3
009538  26A982     MOV #0x6A98, W2
00953A  0720CF     RCALL MDD_SDSPI_SectorWrite
00953C  E00400     CP0.B W0
00953E  3A000B     BRA NZ, 0x9556
2702:                          {
2703:                              FSerrno = CE_WRITE_ERROR;
009540  B3C091     MOV #0x9, W1
009542  370006     BRA 0x9550
2704:                              return EOF;
2705:                          }
2706:              
2707:                          break;
2708:                      case 0:
2709:                          if (LoadBootSector (disk) != CE_GOOD)
009544  2FFBA0     MOV #0xFFBA, W0
009546  40000F     ADD W0, W15, W0
009548  07FB24     RCALL LoadBootSector
00954C  E00400     CP0.B W0
00954E  320003     BRA Z, 0x9556
2710:                          {
2711:                              FSerrno = CE_BADCACHEREAD;
00954A  B3C1B1     MOV #0x1B, W1
2712:                              return EOF;
2713:                          }
2714:                          break;
2715:                      default:
2716:                          FSerrno = CE_INVALID_ARGUMENT;
009058  B3C1F1     MOV #0x1F, W1
009550  249380     MOV #0x4938, W0
009552  784801     MOV.B W1, [W0]
009554  37FD43     BRA 0x8FDC
2717:                          return EOF;
2718:                  }
2719:              
2720:                  // Erase the FAT
2721:                  memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE);
009556  26A988     MOV #0x6A98, W8
009558  202002     MOV #0x200, W2
00955A  EB0080     CLR W1
00955C  780008     MOV W8, W0
00955E  07E0E0     RCALL memset
2722:              
2723:                  if (disk->type == FAT32)
009560  97D8CF     MOV.B [W15-36], W1
009562  26A992     MOV #0x6A99, W2
009564  26A9A3     MOV #0x6A9A, W3
009566  50CFE3     SUB.B W1, #0x3, [W15]
009568  3A0084     BRA NZ, 0x9672
2724:                  {
2725:                      gDataBuffer[0] = 0xF8;          //BPB_Media byte value in its low 8 bits, and all other bits are set to 1
00956A  B3CF80     MOV #0xF8, W0
00956C  784C00     MOV.B W0, [W8]
2726:                      gDataBuffer[1] = 0xFF;
00956E  EBC900     SETM.B [W2]
2727:                      gDataBuffer[2] = 0xFF;
009570  EBC980     SETM.B [W3]
2728:                      gDataBuffer[3] = 0xFF;
009572  26A9B0     MOV #0x6A9B, W0
009574  EBC800     SETM.B [W0]
2729:              
2730:                      gDataBuffer[4] = 0x00;          //Disk is clean and no read/write errors were encountered
009576  26A9C0     MOV #0x6A9C, W0
009578  EB4800     CLR.B [W0]
2731:                      gDataBuffer[5] = 0x00;
00957A  26A9D0     MOV #0x6A9D, W0
00957C  EB4800     CLR.B [W0]
2732:                      gDataBuffer[6] = 0x00;
00957E  26A9E0     MOV #0x6A9E, W0
009580  EB4800     CLR.B [W0]
2733:                      gDataBuffer[7] = 0x0C;
009582  B3C0C1     MOV #0xC, W1
009584  26A9F0     MOV #0x6A9F, W0
009586  784801     MOV.B W1, [W0]
2734:              
2735:                      gDataBuffer[8]  = 0xFF;         //Root Directory EOF  
009588  26AA00     MOV #0x6AA0, W0
00958A  EBC800     SETM.B [W0]
2736:                      gDataBuffer[9]  = 0xFF;
00958C  26AA10     MOV #0x6AA1, W0
00958E  EBC800     SETM.B [W0]
2737:                      gDataBuffer[10] = 0xFF;
009590  26AA20     MOV #0x6AA2, W0
009592  EBC800     SETM.B [W0]
2738:                      gDataBuffer[11] = 0xFF;
009594  26AA30     MOV #0x6AA3, W0
009596  EBC800     SETM.B [W0]
2739:              
2740:                      for (j = disk->fatcopy - 1; j != 0xFFFF; j--)
009598  97D82F     MOV.B [W15-38], W0
00959A  FB8000     ZE W0, W0
00959C  E90580     DEC W0, W11
00959E  78050B     MOV W11, W10
0095A0  37000F     BRA 0x95C0
0095BE  E9050A     DEC W10, W10
0095C0  450FE1     ADD W10, #0x1, [W15]
0095C2  3AFFEF     BRA NZ, 0x95A2
2741:                      {
2742:                          if (MDD_SectorWrite (disk->fat + (j * disk->fatsize), gDataBuffer, FALSE) == FALSE)
0095A2  97A40F     MOV [W15-64], W8
0095A4  97A49F     MOV [W15-62], W9
0095A6  B85061     MUL.UU W10, #1, W0
0095A8  97A93F     MOV [W15-42], W2
0095AA  97A9CF     MOV [W15-40], W3
0095AC  07DF0A     RCALL __mulp32eds3
0095AE  400408     ADD W0, W8, W8
0095B0  488489     ADDC W1, W9, W9
0095B2  EB4180     CLR.B W3
0095B4  26A982     MOV #0x6A98, W2
0095B6  BE0008     MOV.D W8, W0
0095B8  072090     RCALL MDD_SDSPI_SectorWrite
0095BA  E00400     CP0.B W0
0095BC  32FD0F     BRA Z, 0x8FDC
2743:                              return EOF;
2744:                      }
2745:                  
2746:                      memset (gDataBuffer, 0x00, 12);
0095C4  2000C2     MOV #0xC, W2
0095C6  EB0080     CLR W1
0095C8  26A980     MOV #0x6A98, W0
0095CA  07E0AA     RCALL memset
2747:                  
2748:                      for (Index = disk->fat + 1; Index < (disk->fat + disk->fatsize); Index++)
0095CC  97A00F     MOV [W15-64], W0
0095CE  97A09F     MOV [W15-62], W1
0095D0  400461     ADD W0, #0x1, W8
0095D2  4884E0     ADDC W1, #0x0, W9
0095D4  370015     BRA 0x9600
0095FC  440461     ADD W8, #0x1, W8
0095FE  4C84E0     ADDC W9, #0x0, W9
009600  97A10F     MOV [W15-64], W2
009602  97A19F     MOV [W15-62], W3
009604  97A83F     MOV [W15-42], W0
009606  97A8CF     MOV [W15-40], W1
009608  400102     ADD W0, W2, W2
00960A  488183     ADDC W1, W3, W3
00960C  540F82     SUB W8, W2, [W15]
00960E  5C8F83     SUBB W9, W3, [W15]
009610  39FFE2     BRA NC, 0x95D6
009612  200018     MOV #0x1, W8
009614  200009     MOV #0x0, W9
009616  37000B     BRA 0x962E
2749:                      {
2750:                          for (j = disk->fatcopy - 1; j != 0xFFFF; j--)
0095D6  97D82F     MOV.B [W15-38], W0
0095D8  FB8000     ZE W0, W0
0095DA  E90580     DEC W0, W11
0095DC  78050B     MOV W11, W10
0095DE  37000C     BRA 0x95F8
0095F6  E9050A     DEC W10, W10
0095F8  450FE1     ADD W10, #0x1, [W15]
0095FA  3AFFF2     BRA NZ, 0x95E0
2751:                          {
2752:                              if (MDD_SectorWrite (Index + (j * disk->fatsize), gDataBuffer, FALSE) == FALSE)
0095E0  B85061     MUL.UU W10, #1, W0
0095E2  97A93F     MOV [W15-42], W2
0095E4  97A9CF     MOV [W15-40], W3
0095E6  07DEED     RCALL __mulp32eds3
0095E8  400008     ADD W0, W8, W0
0095EA  488089     ADDC W1, W9, W1
0095EC  EB4180     CLR.B W3
0095EE  26A982     MOV #0x6A98, W2
0095F0  072074     RCALL MDD_SDSPI_SectorWrite
0095F2  E00400     CP0.B W0
0095F4  32FCF3     BRA Z, 0x8FDC
2753:                                  return EOF;
2754:                          }
2755:                      }
2756:                  
2757:                      // Erase the root directory
2758:                      for (Index = 1; Index < disk->SecPerClus; Index++)
00962A  440461     ADD W8, #0x1, W8
00962C  4C84E0     ADDC W9, #0x0, W9
00962E  97D83F     MOV.B [W15-37], W0
009630  FB8000     ZE W0, W0
009632  200001     MOV #0x0, W1
009634  540F80     SUB W8, W0, [W15]
009636  5C8F81     SUBB W9, W1, [W15]
009638  39FFEF     BRA NC, 0x9618
2759:                      {
2760:                          if (MDD_SectorWrite (disk->root + Index, gDataBuffer, FALSE) == FALSE)
009618  97A02F     MOV [W15-60], W0
00961A  97A0BF     MOV [W15-58], W1
00961C  440000     ADD W8, W0, W0
00961E  4C8081     ADDC W9, W1, W1
009620  EB4180     CLR.B W3
009622  26A982     MOV #0x6A98, W2
009624  07205A     RCALL MDD_SDSPI_SectorWrite
009626  E00400     CP0.B W0
009628  32FCD9     BRA Z, 0x8FDC
2761:                              return EOF;
2762:                      }
2763:                  
2764:                      if (volumeID != NULL)
00963A  97AB7F     MOV [W15-34], W6
00963C  E00006     CP0 W6
00963E  3200A4     BRA Z, 0x9788
009640  B81160     MUL.UU W2, #0, W2
009642  26A981     MOV #0x6A98, W1
009644  780201     MOV W1, W4
009646  370003     BRA 0x964E
2765:                      {
2766:                          // Create a drive name entry in the root dir
2767:                          Index = 0;
2768:                          while ((*(volumeID + Index) != 0) && (Index < 11))
00964E  97AC7F     MOV [W15-34], W8
009650  794068     MOV.B [W8+W2], W0
009652  E00400     CP0.B W0
009654  3A0002     BRA NZ, 0x965A
009656  420082     ADD W4, W2, W1
009658  370008     BRA 0x966A
00965A  510FEB     SUB W2, #0xB, [W15]
00965C  598FE0     SUBB W3, #0x0, [W15]
00965E  3AFFF4     BRA NZ, 0x9648
009660  370085     BRA 0x976C
2769:                          {
2770:                              gDataBuffer[Index] = *(volumeID + Index);
009648  785880     MOV.B W0, [W1++]
2771:                              Index++;
00964A  410161     ADD W2, #0x1, W2
00964C  4981E0     ADDC W3, #0x0, W3
2772:                          }
2773:                          while (Index < 11)
00966A  510FEA     SUB W2, #0xA, [W15]
00966C  598FE0     SUBB W3, #0x0, [W15]
00966E  36FFF9     BRA LEU, 0x9662
009670  37007D     BRA 0x976C
2774:                          {
2775:                              gDataBuffer[Index++] = ' ';
009662  B3C200     MOV #0x20, W0
009664  785880     MOV.B W0, [W1++]
009666  410161     ADD W2, #0x1, W2
009668  4981E0     ADDC W3, #0x0, W3
2776:                          }
2777:                          gDataBuffer[11] = 0x08;
2778:                          gDataBuffer[17] = 0x11;
2779:                          gDataBuffer[19] = 0x11;
2780:                          gDataBuffer[23] = 0x11;
2781:                  
2782:                          if (MDD_SectorWrite (disk->root, gDataBuffer, FALSE) == FALSE)
2783:                              return EOF;
2784:                      }
2785:                      else
2786:                      {
2787:                          if (MDD_SectorWrite (disk->root, gDataBuffer, FALSE) == FALSE)
2788:                              return EOF;
2789:                      }
2790:                  
2791:                      return 0;
2792:                  }
2793:                  else
2794:                  {
2795:                      gDataBuffer[0] = 0xF8;
009672  B3CF80     MOV #0xF8, W0
009674  784C00     MOV.B W0, [W8]
2796:                      gDataBuffer[1] = 0xFF;
009676  EBC900     SETM.B [W2]
2797:                      gDataBuffer[2] = 0xFF;
009678  EBC980     SETM.B [W3]
2798:                      if (disk->type == FAT16)
00967A  50CFE2     SUB.B W1, #0x2, [W15]
00967C  3A0002     BRA NZ, 0x9682
2799:                          gDataBuffer[3] = 0xFF;
00967E  26A9B0     MOV #0x6A9B, W0
009680  EBC800     SETM.B [W0]
2800:                  
2801:                      for (j = disk->fatcopy - 1; j != 0xFFFF; j--)
009682  97D82F     MOV.B [W15-38], W0
009684  FB8000     ZE W0, W0
009686  E90580     DEC W0, W11
009688  78050B     MOV W11, W10
00968A  37000F     BRA 0x96AA
0096A8  E9050A     DEC W10, W10
0096AA  450FE1     ADD W10, #0x1, [W15]
0096AC  3AFFEF     BRA NZ, 0x968C
2802:                      {
2803:                          if (MDD_SectorWrite (disk->fat + (j * disk->fatsize), gDataBuffer, FALSE) == FALSE)
00968C  97A40F     MOV [W15-64], W8
00968E  97A49F     MOV [W15-62], W9
009690  B85061     MUL.UU W10, #1, W0
009692  97A93F     MOV [W15-42], W2
009694  97A9CF     MOV [W15-40], W3
009696  07DE95     RCALL __mulp32eds3
009698  400408     ADD W0, W8, W8
00969A  488489     ADDC W1, W9, W9
00969C  EB4180     CLR.B W3
00969E  26A982     MOV #0x6A98, W2
0096A0  BE0008     MOV.D W8, W0
0096A2  07201B     RCALL MDD_SDSPI_SectorWrite
0096A4  E00400     CP0.B W0
0096A6  32FC9A     BRA Z, 0x8FDC
2804:                              return EOF;
2805:                      }
2806:                  
2807:                      memset (gDataBuffer, 0x00, 4);
0096AE  26A980     MOV #0x6A98, W0
0096B0  EB0800     CLR [W0]
0096B2  781030     MOV [W0++], [W0--]
2808:                  
2809:                      for (Index = disk->fat + 1; Index < (disk->fat + disk->fatsize); Index++)
0096B4  97A00F     MOV [W15-64], W0
0096B6  97A09F     MOV [W15-62], W1
0096B8  400461     ADD W0, #0x1, W8
0096BA  4884E0     ADDC W1, #0x0, W9
0096BC  370015     BRA 0x96E8
0096E4  440461     ADD W8, #0x1, W8
0096E6  4C84E0     ADDC W9, #0x0, W9
0096E8  97A10F     MOV [W15-64], W2
0096EA  97A19F     MOV [W15-62], W3
0096EC  97A83F     MOV [W15-42], W0
0096EE  97A8CF     MOV [W15-40], W1
0096F0  400102     ADD W0, W2, W2
0096F2  488183     ADDC W1, W3, W3
0096F4  540F82     SUB W8, W2, [W15]
0096F6  5C8F83     SUBB W9, W3, [W15]
0096F8  39FFE2     BRA NC, 0x96BE
2810:                      {
2811:                          for (j = disk->fatcopy - 1; j != 0xFFFF; j--)
0096BE  97D82F     MOV.B [W15-38], W0
0096C0  FB8000     ZE W0, W0
0096C2  E90580     DEC W0, W11
0096C4  78050B     MOV W11, W10
0096C6  37000C     BRA 0x96E0
0096DE  E9050A     DEC W10, W10
0096E0  450FE1     ADD W10, #0x1, [W15]
0096E2  3AFFF2     BRA NZ, 0x96C8
2812:                          {
2813:                              if (MDD_SectorWrite (Index + (j * disk->fatsize), gDataBuffer, FALSE) == FALSE)
0096C8  B85061     MUL.UU W10, #1, W0
0096CA  97A93F     MOV [W15-42], W2
0096CC  97A9CF     MOV [W15-40], W3
0096CE  07DE79     RCALL __mulp32eds3
0096D0  400008     ADD W0, W8, W0
0096D2  488089     ADDC W1, W9, W1
0096D4  EB4180     CLR.B W3
0096D6  26A982     MOV #0x6A98, W2
0096D8  072000     RCALL MDD_SDSPI_SectorWrite
0096DA  E00400     CP0.B W0
0096DC  32FC7F     BRA Z, 0x8FDC
2814:                                  return EOF;
2815:                          }
2816:                      }
2817:                  
2818:              		// Initialize the sector size
2819:                      disk->sectorSize = MEDIA_SECTOR_SIZE;
0096FA  202000     MOV #0x200, W0
0096FC  200001     MOV #0x0, W1
0096FE  9FAF90     MOV W0, [W15-46]
009700  9FAFA1     MOV W1, [W15-44]
2820:              
2821:                      // Erase the root directory
2822:                      RootDirSectors = ((disk->maxroot * 32) + (disk->sectorSize - 1)) / disk->sectorSize;
009702  97A06F     MOV [W15-52], W0
009704  DD0045     SL W0, #5, W0
009706  200001     MOV #0x0, W1
009708  B01FF0     ADD #0x1FF, W0
00970A  B08001     ADDC #0x0, W1
00970C  DE0DC9     LSR W1, #9, W11
00970E  DD0947     SL W1, #7, W2
009710  DE0549     LSR W0, #9, W10
009712  71050A     IOR W2, W10, W10
009714  200018     MOV #0x1, W8
009716  200009     MOV #0x0, W9
009718  37000B     BRA 0x9730
2823:                  
2824:                      for (Index = 1; Index < RootDirSectors; Index++)
00972C  440461     ADD W8, #0x1, W8
00972E  4C84E0     ADDC W9, #0x0, W9
009730  540F8A     SUB W8, W10, [W15]
009732  5C8F8B     SUBB W9, W11, [W15]
009734  39FFF2     BRA NC, 0x971A
2825:                      {
2826:                          if (MDD_SectorWrite (disk->root + Index, gDataBuffer, FALSE) == FALSE)
00971A  97A02F     MOV [W15-60], W0
00971C  97A0BF     MOV [W15-58], W1
00971E  440000     ADD W8, W0, W0
009720  4C8081     ADDC W9, W1, W1
009722  EB4180     CLR.B W3
009724  26A982     MOV #0x6A98, W2
009726  071FD9     RCALL MDD_SDSPI_SectorWrite
009728  E00400     CP0.B W0
00972A  32FC58     BRA Z, 0x8FDC
2827:                              return EOF;
2828:                      }
2829:                  
2830:                      if (volumeID != NULL)
009736  97A9FF     MOV [W15-34], W3
009738  E00003     CP0 W3
00973A  320026     BRA Z, 0x9788
00973C  B81160     MUL.UU W2, #0, W2
00973E  26A981     MOV #0x6A98, W1
009740  780201     MOV W1, W4
009742  370003     BRA 0x974A
2831:                      {
2832:                          // Create a drive name entry in the root dir
2833:                          Index = 0;
2834:                          while ((*(volumeID + Index) != 0) && (Index < 11))
00974A  97AAFF     MOV [W15-34], W5
00974C  794065     MOV.B [W5+W2], W0
00974E  E00400     CP0.B W0
009750  3A0002     BRA NZ, 0x9756
009752  420082     ADD W4, W2, W1
009754  370008     BRA 0x9766
009756  510FEB     SUB W2, #0xB, [W15]
009758  598FE0     SUBB W3, #0x0, [W15]
00975A  3AFFF4     BRA NZ, 0x9744
00975C  370007     BRA 0x976C
2835:                          {
2836:                              gDataBuffer[Index] = *(volumeID + Index);
009744  785880     MOV.B W0, [W1++]
2837:                              Index++;
009746  410161     ADD W2, #0x1, W2
009748  4981E0     ADDC W3, #0x0, W3
2838:                          }
2839:                          while (Index < 11)
009766  510FEA     SUB W2, #0xA, [W15]
009768  598FE0     SUBB W3, #0x0, [W15]
00976A  36FFF9     BRA LEU, 0x975E
2840:                          {
2841:                              gDataBuffer[Index++] = ' ';
00975E  B3C200     MOV #0x20, W0
009760  785880     MOV.B W0, [W1++]
009762  410161     ADD W2, #0x1, W2
009764  4981E0     ADDC W3, #0x0, W3
2842:                          }
2843:                          gDataBuffer[11] = 0x08;
00976C  B3C081     MOV #0x8, W1
00976E  26AA30     MOV #0x6AA3, W0
009770  784801     MOV.B W1, [W0]
2844:                          gDataBuffer[17] = 0x11;
009772  B3C111     MOV #0x11, W1
009774  26AA90     MOV #0x6AA9, W0
009776  784801     MOV.B W1, [W0]
2845:                          gDataBuffer[19] = 0x11;
009778  26AAB0     MOV #0x6AAB, W0
00977A  784801     MOV.B W1, [W0]
2846:                          gDataBuffer[23] = 0x11;
00977C  26AAF0     MOV #0x6AAF, W0
00977E  784801     MOV.B W1, [W0]
2847:                  
2848:                          if (MDD_SectorWrite (disk->root, gDataBuffer, FALSE) == FALSE)
009780  97A02F     MOV [W15-60], W0
009782  97A0BF     MOV [W15-58], W1
009784  EB4180     CLR.B W3
009786  370003     BRA 0x978E
2849:                              return EOF;
2850:                      }
2851:                      else
2852:                      {
2853:                          if (MDD_SectorWrite (disk->root, gDataBuffer, FALSE) == FALSE)
009788  97A02F     MOV [W15-60], W0
00978A  97A0BF     MOV [W15-58], W1
00978C  97D9EF     MOV.B [W15-34], W3
00978E  26A982     MOV #0x6A98, W2
009790  071FA4     RCALL MDD_SDSPI_SectorWrite
009792  E00400     CP0.B W0
009794  32FC23     BRA Z, 0x8FDC
009796  EB0000     CLR W0
2854:                              return EOF;
2855:                      }
2856:                  
2857:                      return 0;
2858:                  }
2859:              }
0097A4  BE9F88     MOV.D W8, [W15++]
0097A6  BE9F8A     MOV.D W10, [W15++]
0097A8  BE9F8C     MOV.D W12, [W15++]
0097AA  780500     MOV W0, W10
0097AC  780681     MOV W1, W13
2860:              #endif
2861:              #endif
2862:              
2863:              
2864:              /*******************************************************
2865:                Function:
2866:                  BYTE Write_File_Entry( FILEOBJ fo, WORD * curEntry)
2867:                Summary:
2868:                  Write dir entry info into a specified entry
2869:                Conditions:
2870:                  This function should not be called by the user.
2871:                Input:
2872:                  fo -        \File structure
2873:                  curEntry -  Write destination
2874:                Return Values:
2875:                  TRUE - Operation successful
2876:                  FALSE - Operation failed
2877:                Side Effects:
2878:                  None
2879:                Description:
2880:                  This function will calculate the sector of the
2881:                  directory (whose base sector is pointed to by the
2882:                  dirccls value in the FSFILE object 'fo') that contains
2883:                  a directory entry whose offset is indicated by the
2884:                  curEntry parameter.  It will then write the data
2885:                  in the global data buffer (which should already
2886:                  contain the entries for that sector) to the device.
2887:                Remarks:
2888:                  None
2889:                *******************************************************/
2890:              
2891:              #ifdef ALLOW_WRITES
2892:              BYTE Write_File_Entry( FILEOBJ fo, WORD * curEntry)
2893:              {
2894:                  DISK   *dsk;
2895:                  BYTE   status;
2896:                  BYTE   offset2;
2897:                  DWORD   sector;
2898:                  DWORD   ccls;
2899:              
2900:                  dsk = fo->dsk;
0070B4  780410     MOV [W0], W8
2901:              
2902:                  // get the cluster of this entry
2903:                  ccls = fo->dirccls;
0070B6  901E40     MOV [W0+56], W12
0070B8  901ED0     MOV [W0+58], W13
2904:              
2905:                   // figure out the offset from the base sector
2906:                  offset2  = (*curEntry / (dsk->sectorSize/32));
0070BA  780011     MOV [W1], W0
0070BC  200001     MOV #0x0, W1
0070BE  905A88     MOV.B [W8+24], W5
0070C0  FB8285     ZE W5, W5
0070C2  905A18     MOV.B [W8+25], W4
0070C4  DD2248     SL W4, #8, W4
0070C6  720105     IOR W4, W5, W2
0070C8  905AA8     MOV.B [W8+26], W5
0070CA  FB8285     ZE W5, W5
0070CC  905A38     MOV.B [W8+27], W4
0070CE  DD2248     SL W4, #8, W4
0070D0  720185     IOR W4, W5, W3
0070D2  DD1A4B     SL W3, #11, W4
0070D4  DE1145     LSR W2, #5, W2
0070D6  720102     IOR W4, W2, W2
0070D8  DE19C5     LSR W3, #5, W3
0070DA  07F1E3     RCALL __udivsi3
0070DC  784480     MOV.B W0, W9
2907:              
2908:                  /* Settings based on FAT type */
2909:                  switch (dsk->type)
0070DE  906028     MOV.B [W8+34], W0
0070E0  504FE1     SUB.B W0, #0x1, [W15]
0070E2  390010     BRA NC, 0x7104
0070E4  504FE2     SUB.B W0, #0x2, [W15]
0070E6  360003     BRA LEU, 0x70EE
0070E8  504FE3     SUB.B W0, #0x3, [W15]
0070EA  3A000C     BRA NZ, 0x7104
0070EC  370005     BRA 0x70F8
2910:                  {
2911:              #ifdef SUPPORT_FAT32 // If FAT32 supported.
2912:                      case FAT32:
2913:                          // Root is always cluster-based in FAT32
2914:                          offset2 = offset2 % (dsk->SecPerClus);
2915:                          break;
2916:              #endif
2917:                      case FAT12:
2918:                      case FAT16:
2919:                          if(ccls != FatRootDirClusterValue)
0070EE  8249D0     MOV FatRootDirClusterValue, W0
0070F0  8249E1     MOV 0x493C, W1
0070F2  560F80     SUB W12, W0, [W15]
0070F4  5E8F81     SUBB W13, W1, [W15]
0070F6  320006     BRA Z, 0x7104
2920:                              offset2 = offset2 % (dsk->SecPerClus);
0070F8  FB8009     ZE W9, W0
0070FA  906118     MOV.B [W8+33], W2
0070FC  FB8102     ZE W2, W2
0070FE  090011     REPEAT #0x11
007100  D88002     DIV.UW W0, W2
007102  784481     MOV.B W1, W9
2921:                          break;
2922:                  }
2923:              
2924:                  sector = Cluster2Sector(dsk,ccls);
00710C  BE010C     MOV.D W12, W2
00710E  780008     MOV W8, W0
007110  07FEBA     RCALL Cluster2Sector
007112  FB8109     ZE W9, W2
007114  200003     MOV #0x0, W3
007116  410000     ADD W2, W0, W0
007118  498081     ADDC W3, W1, W1
00711A  EB4180     CLR.B W3
00711C  78010A     MOV W10, W2
00711E  0732DD     RCALL MDD_SDSPI_SectorWrite
007120  FB8000     ZE W0, W0
007122  E90000     DEC W0, W0
007124  DE004F     LSR W0, #15, W0
007126  A20400     BTG.B W0, #0
007128  FB8000     ZE W0, W0
2925:              
2926:                  // Now write it
2927:                  // "Offset" ensures writing of data belonging to a file entry only. Hence it doesn't change other file entries.
2928:                  if ( !MDD_SectorWrite( sector + offset2, dsk->buffer, FALSE))
007104  FB8018     ZE [W8], W0
007106  904098     MOV.B [W8+1], W1
007108  DD08C8     SL W1, #8, W1
00710A  708500     IOR W1, W0, W10
2929:                      status = FALSE;
2930:                  else
2931:                      status = TRUE;
2932:              
2933:                  return(status);
2934:              } // Write_File_Entry
007132  4787EE     ADD W15, #0xE, W15
007134  BE9F88     MOV.D W8, [W15++]
007136  BE9F8A     MOV.D W10, [W15++]
007138  BE9F8C     MOV.D W12, [W15++]
00713A  781F8E     MOV W14, [W15++]
00713C  780700     MOV W0, W14
00713E  BE0302     MOV.D W2, W6
007140  9FB7F4     MOV W4, [W15-18]
007142  9FBF85     MOV W5, [W15-16]
2935:              #endif
2936:              
2937:              
2938:              /**********************************************************
2939:                Function:
2940:                  BYTE FAT_erase_cluster_chain (WORD cluster, DISK * dsk)
2941:                Summary:
2942:                  Erase a chain of clusters
2943:                Conditions:
2944:                  This function should not be called by the user.
2945:                Input:
2946:                  cluster -  The cluster number
2947:                  dsk -      The disk structure
2948:                Return Values:
2949:                  TRUE -  Operation successful
2950:                  FALSE - Operation failed
2951:                Side Effects:
2952:                  None
2953:                Description:
2954:                  This function will parse through a cluster chain
2955:                  starting with the cluster pointed to by 'cluster' and
2956:                  mark all of the FAT entries as empty until the end of
2957:                  the chain has been reached or an error occurs.
2958:                Remarks:
2959:                  None
2960:                **********************************************************/
2961:              
2962:              #ifdef ALLOW_WRITES
2963:              BYTE FAT_erase_cluster_chain (DWORD cluster, DISK * dsk)
2964:              {
2965:                  DWORD     c,c2,ClusterFailValue;
2966:                  enum    _status {Good, Fail, Exit}status;
2967:              
2968:                  status = Good;
2969:              
2970:                  /* Settings based on FAT type */
2971:                  switch (dsk->type)
007848  906022     MOV.B [W2+34], W0
00784A  504FE1     SUB.B W0, #0x1, [W15]
00784C  320003     BRA Z, 0x7854
00784E  504FE3     SUB.B W0, #0x3, [W15]
007850  3A0008     BRA NZ, 0x7862
007852  37000E     BRA 0x7870
007854  2FFFF0     MOV #0xFFFF, W0
007856  200001     MOV #0x0, W1
007858  9FB7E0     MOV W0, [W15-20]
00785A  9FB7F1     MOV W1, [W15-18]
00785C  20FF82     MOV #0xFF8, W2
00785E  200003     MOV #0x0, W3
007860  37000D     BRA 0x787C
007862  2FFFF0     MOV #0xFFFF, W0
007864  200001     MOV #0x0, W1
007866  9FB7E0     MOV W0, [W15-20]
007868  9FB7F1     MOV W1, [W15-18]
00786A  2FFF82     MOV #0xFFF8, W2
00786C  200003     MOV #0x0, W3
00786E  370006     BRA 0x787C
007870  2FFFF0     MOV #0xFFFF, W0
007872  20FFF1     MOV #0xFFF, W1
007874  9FB7E0     MOV W0, [W15-20]
007876  9FB7F1     MOV W1, [W15-18]
007878  2FFF82     MOV #0xFFF8, W2
00787A  20FFF3     MOV #0xFFF, W3
00787C  9FBF82     MOV W2, [W15-16]
00787E  9FBF93     MOV W3, [W15-14]
2972:                  {
2973:              
2974:              #ifdef SUPPORT_FAT32 // If FAT32 supported.
2975:                      case FAT32:
2976:                          ClusterFailValue = CLUSTER_FAIL_FAT32;
2977:                          c2 =  LAST_CLUSTER_FAT32;
2978:                          break;
2979:              #endif
2980:                      case FAT12:
2981:                          ClusterFailValue = CLUSTER_FAIL_FAT16; // FAT16 value itself
2982:                          c2 =  LAST_CLUSTER_FAT12;
2983:                          break;
2984:                      case FAT16:
2985:                      default:
2986:                          ClusterFailValue = CLUSTER_FAIL_FAT16;
2987:                          c2 =  LAST_CLUSTER_FAT16;
2988:                          break;
2989:                  }
2990:              
2991:                  // Make sure there is actually a cluster assigned
2992:                  if((cluster == 0) || (cluster == 1))  // Cluster assigned can't be "0" and "1"
007880  550FE1     SUB W10, #0x1, [W15]
007882  5D8FE0     SUBB W11, #0x0, [W15]
007884  360021     BRA LEU, 0x78C8
2993:                  {
2994:                      status = Exit;
2995:                  }
2996:                  else
2997:                  {
2998:                      while(status == Good)
0078C2  E0000C     CP0 W12
0078C4  3A0004     BRA NZ, 0x78CE
0078C6  37FFDF     BRA 0x7886
0078C8  20002C     MOV #0x2, W12
0078CA  370001     BRA 0x78CE
0078CC  20001C     MOV #0x1, W12
2999:                      {
3000:                          // Get the FAT entry
3001:                          if((c = ReadFAT( dsk, cluster)) == ClusterFailValue)
007886  BE010A     MOV.D W10, W2
007888  78000D     MOV W13, W0
00788A  07FD7F     RCALL ReadFAT
00788C  BE0400     MOV.D W0, W8
00788E  97B06F     MOV [W15-20], W0
007890  97B0FF     MOV [W15-18], W1
007892  540F80     SUB W8, W0, [W15]
007894  5C8F81     SUBB W9, W1, [W15]
007896  32001A     BRA Z, 0x78CC
3002:                              status = Fail;
3003:                          else
3004:                          {
3005:                              if((c == 0) || (c == 1))  // Cluster assigned can't be "0" and "1"
007898  540FE1     SUB W8, #0x1, [W15]
00789A  5C8FE0     SUBB W9, #0x0, [W15]
00789C  360015     BRA LEU, 0x78C8
3006:                              {
3007:                                  status = Exit;
3008:                              }
3009:                              else
3010:                              {
3011:                                  // compare against max value of a cluster in FATxx
3012:                                  // look for the last cluster in the chain
3013:                                  if ( c >= c2)
00789E  20002C     MOV #0x2, W12
0078A0  97B90F     MOV [W15-16], W2
0078A2  97B99F     MOV [W15-14], W3
0078A4  540F82     SUB W8, W2, [W15]
0078A6  5C8F83     SUBB W9, W3, [W15]
0078A8  310001     BRA C, 0x78AC
0078AA  EB0600     CLR W12
3014:                                      status = Exit;
3015:              
3016:                                  // Now erase this FAT entry
3017:                                  if(WriteFAT(dsk, cluster, CLUSTER_EMPTY, FALSE) == ClusterFailValue)
0078AC  EB4080     CLR.B W1
0078AE  B82260     MUL.UU W4, #0, W4
0078B0  BE010A     MOV.D W10, W2
0078B2  78000D     MOV W13, W0
0078B4  07FC3E     RCALL WriteFAT
0078B6  97B16F     MOV [W15-20], W2
0078B8  97B1FF     MOV [W15-18], W3
0078BA  500F82     SUB W0, W2, [W15]
0078BC  588F83     SUBB W1, W3, [W15]
0078BE  320006     BRA Z, 0x78CC
0078C0  BE0508     MOV.D W8, W10
3018:                                      status = Fail;
3019:              
3020:                                  // now update what the current cluster is
3021:                                  cluster = c;
3022:                              }
3023:                          }
3024:                      }// while status
3025:                  }// cluster == 0
3026:              
3027:                  WriteFAT (dsk, 0, 0, TRUE);
0078CE  B3C011     MOV #0x1, W1
0078D0  B82260     MUL.UU W4, #0, W4
0078D2  BE0104     MOV.D W4, W2
0078D4  78000D     MOV W13, W0
0078D6  07FC2D     RCALL WriteFAT
0078D8  A2100C     BTG W12, #1
0078DA  EA000C     NEG W12, W0
0078DC  DE004F     LSR W0, #15, W0
0078DE  100061     SUBR W0, #0x1, W0
3028:              
3029:                  if(status == Exit)
3030:                      return(TRUE);
3031:                  else
3032:                      return(FALSE);
3033:              } // Erase cluster
0078EA  BE9F88     MOV.D W8, [W15++]
0078EC  780480     MOV W0, W9
0078EE  780401     MOV W1, W8
3034:              #endif
3035:              
3036:              /**************************************************************************
3037:                Function:
3038:                  DIRENTRY Cache_File_Entry( FILEOBJ fo, WORD * curEntry, BYTE ForceRead)
3039:                Summary:
3040:                  Load a file entry
3041:                Conditions:
3042:                  This function should not be called by the user.
3043:                Input:
3044:                  fo -         File information
3045:                  curEntry -   Offset of the directory entry to load.
3046:                  ForceRead -  Forces loading of a new sector of the directory.
3047:                Return:
3048:                  DIRENTRY - Pointer to the directory entry that was loaded.
3049:                Side Effects:
3050:                  Any unwritten data in the data buffer will be written to the device.
3051:                Description:
3052:                  Load the sector containing the file entry pointed to by 'curEntry'
3053:                  from the directory pointed to by the variables in 'fo.'
3054:                Remarks:
3055:                  Any modification of this function is extremely likely to
3056:                  break something.
3057:                **************************************************************************/
3058:              
3059:              DIRENTRY Cache_File_Entry( FILEOBJ fo, WORD * curEntry, BYTE ForceRead)
3060:              {
3061:                  DIRENTRY dir;
3062:                  DISK *dsk;
3063:                  DWORD sector;
3064:                  DWORD cluster, LastClusterLimit;
3065:                  DWORD ccls;
3066:                  BYTE offset2;
3067:                  BYTE numofclus;
3068:              	BYTE dirEntriesPerSector;
3069:              
3070:                  dsk = fo->dsk;
0075BA  780490     MOV [W0], W9
3071:              
3072:                  // get the base sector of this directory
3073:                  cluster = fo->dirclus;
0075BC  901B20     MOV [W0+52], W6
0075BE  901BB0     MOV [W0+54], W7
3074:                  ccls = fo->dirccls;
0075C0  901D40     MOV [W0+56], W10
0075C2  901DD0     MOV [W0+58], W11
3075:              
3076:              	dirEntriesPerSector = dsk->sectorSize/32;
3077:              
3078:                   // figure out the offset from the base sector
3079:                  offset2  = (*curEntry / dirEntriesPerSector);
0075C4  780211     MOV [W1], W4
0075C6  905889     MOV.B [W9+24], W1
0075C8  FB8081     ZE W1, W1
0075CA  905819     MOV.B [W9+25], W0
0075CC  DD0048     SL W0, #8, W0
0075CE  700101     IOR W0, W1, W2
0075D0  9058A9     MOV.B [W9+26], W1
0075D2  FB8081     ZE W1, W1
0075D4  905839     MOV.B [W9+27], W0
0075D6  DD0048     SL W0, #8, W0
0075D8  700181     IOR W0, W1, W3
0075DA  DD184B     SL W3, #11, W0
0075DC  DE1145     LSR W2, #5, W2
0075DE  700102     IOR W0, W2, W2
0075E0  DE19C5     LSR W3, #5, W3
0075E2  FB8682     ZE W2, W13
0075E4  090011     REPEAT #0x11
0075E6  D8820D     DIV.UW W4, W13
0075E8  784600     MOV.B W0, W12
3080:              
3081:                  /* Settings based on FAT type */
3082:                  switch (dsk->type)
0075EA  906029     MOV.B [W9+34], W0
0075EC  504FE3     SUB.B W0, #0x3, [W15]
0075EE  3A000B     BRA NZ, 0x7606
3083:                  {
3084:              #ifdef SUPPORT_FAT32 // If FAT32 supported.
3085:                      case FAT32:
3086:                          // the ROOT is always cluster based in FAT32
3087:                          /* In FAT32: There is no ROOT region. Root etries are made in DATA region only.
3088:                          Every cluster of DATA which is accupied by ROOT is tracked by FAT table/entry so the ROOT can grow
3089:                          to an amount which is restricted only by available free DATA region. */
3090:                          offset2  = offset2 % (dsk->SecPerClus);   // figure out the offset
0075F0  FB800C     ZE W12, W0
0075F2  906119     MOV.B [W9+33], W2
0075F4  FB8102     ZE W2, W2
0075F6  090011     REPEAT #0x11
0075F8  D88002     DIV.UW W0, W2
0075FA  784601     MOV.B W1, W12
0075FC  2FFF80     MOV #0xFFF8, W0
0075FE  20FFF1     MOV #0xFFF, W1
007600  9FB7B0     MOV W0, [W15-26]
007602  9FB7C1     MOV W1, [W15-24]
007604  37000D     BRA 0x7620
3091:                          LastClusterLimit = LAST_CLUSTER_FAT32;
3092:                          break;
3093:              #endif
3094:                      case FAT12:
3095:                      case FAT16:
3096:                      default:
3097:                          // if its the root its not cluster based
3098:                          if(cluster != 0)
007606  2FFF80     MOV #0xFFF8, W0
007608  200001     MOV #0x0, W1
00760A  9FB7B0     MOV W0, [W15-26]
00760C  9FB7C1     MOV W1, [W15-24]
00760E  530FE0     SUB W6, #0x0, [W15]
007610  5B8FE0     SUBB W7, #0x0, [W15]
007612  320006     BRA Z, 0x7620
3099:                              offset2  = offset2 % (dsk->SecPerClus);   // figure out the offset
007614  FB800C     ZE W12, W0
007616  906119     MOV.B [W9+33], W2
007618  FB8102     ZE W2, W2
00761A  090011     REPEAT #0x11
00761C  D88002     DIV.UW W0, W2
00761E  784601     MOV.B W1, W12
3100:                          LastClusterLimit = LAST_CLUSTER_FAT16;
3101:                          break;
3102:                  }
3103:              
3104:                  // check if a new sector of the root must be loaded
3105:                  if (ForceRead || ((*curEntry & MASK_MAX_FILE_ENTRY_LIMIT_BITS) == 0))     // only 16 entries per sector
007620  97E8CF     MOV.B [W15-20], W1
007622  E00401     CP0.B W1
007624  3A0002     BRA NZ, 0x762A
007626  62006F     AND W4, #0xF, W0
007628  3A0083     BRA NZ, 0x7730
3106:                  {
3107:                      // see if we have to load a new cluster
3108:                      if(((offset2 == 0) && (*curEntry >= dirEntriesPerSector)) || ForceRead)
00762A  E0040C     CP0.B W12
00762C  3A0002     BRA NZ, 0x7632
00762E  520F8D     SUB W4, W13, [W15]
007630  310003     BRA C, 0x7638
007632  97E94F     MOV.B [W15-20], W2
007634  E00402     CP0.B W2
007636  32001D     BRA Z, 0x7672
3109:                      {
3110:                          if(cluster == 0)
007638  530FE0     SUB W6, #0x0, [W15]
00763A  5B8FE0     SUBB W7, #0x0, [W15]
00763C  3A0002     BRA NZ, 0x7642
00763E  BE0506     MOV.D W6, W10
007640  370018     BRA 0x7672
3111:                          {
3112:                              ccls = 0;
3113:                          }
3114:                          else
3115:                          {
3116:                              // If ForceRead, read the number of sectors from 0
3117:                              if(ForceRead)
007642  97EACF     MOV.B [W15-20], W5
007644  E00405     CP0.B W5
007646  320008     BRA Z, 0x7658
3118:                                  numofclus = ((WORD)(*curEntry) / (WORD)(((WORD)dirEntriesPerSector) * (WORD)dsk->SecPerClus));
007648  906119     MOV.B [W9+33], W2
00764A  FB8102     ZE W2, W2
00764C  B9E902     MUL.SS W13, W2, W2
00764E  090011     REPEAT #0x11
007650  D88202     DIV.UW W4, W2
007652  780100     MOV W0, W2
007654  784402     MOV.B W2, W8
007656  37000B     BRA 0x766E
007658  B3C018     MOV #0x1, W8
3119:                              // Otherwise just read the next sector
3120:                              else
3121:                                  numofclus = 1;
3122:              
3123:                              // move to the correct cluster
3124:                              while(numofclus)
00766E  E00408     CP0.B W8
007670  3AFFF4     BRA NZ, 0x765A
3125:                              {
3126:                                  ccls = ReadFAT(dsk, ccls);
00765A  BE010A     MOV.D W10, W2
00765C  780009     MOV W9, W0
00765E  07FE95     RCALL ReadFAT
007660  BE0500     MOV.D W0, W10
3127:              
3128:                                  if(ccls >= LastClusterLimit)
007662  97B03F     MOV [W15-26], W0
007664  97B0CF     MOV [W15-24], W1
007666  550F80     SUB W10, W0, [W15]
007668  5D8F81     SUBB W11, W1, [W15]
00766A  31005D     BRA C, 0x7726
3129:                                      break;
3130:                                  else
3131:                                      numofclus--;
00766C  E94408     DEC.B W8, W8
3132:                              }
3133:                          }
3134:                      }
3135:              
3136:                      // see if that we have a valid cluster number
3137:                      if(ccls < LastClusterLimit)
007672  97B23F     MOV [W15-26], W4
007674  97B2CF     MOV [W15-24], W5
007676  550F84     SUB W10, W4, [W15]
007678  5D8F85     SUBB W11, W5, [W15]
00767A  310055     BRA C, 0x7726
3138:                      {
3139:                          fo->dirccls = ccls; // write it back
00767C  981F4A     MOV W10, [W14+56]
00767E  981F5B     MOV W11, [W14+58]
3140:              
3141:                          sector = Cluster2Sector(dsk,ccls);
007680  BE010A     MOV.D W10, W2
007682  780009     MOV W9, W0
007684  07FC00     RCALL Cluster2Sector
007686  9FB7F0     MOV W0, [W15-18]
007688  9FBF81     MOV W1, [W15-16]
3142:              
3143:                          /* see if we are root and about to go pass our boundaries
3144:                          FAT32 stores the root directory in the Data Region along with files and other directories,
3145:                          allowing it to grow without such a restraint */
3146:                          if((ccls == FatRootDirClusterValue) && ((sector + offset2) >= dsk->data) && (FAT32 != dsk->type))
00768A  8249D0     MOV FatRootDirClusterValue, W0
00768C  8249E1     MOV 0x493C, W1
00768E  550F80     SUB W10, W0, [W15]
007690  5D8F81     SUBB W11, W1, [W15]
007692  3A0017     BRA NZ, 0x76C2
007694  FB820C     ZE W12, W4
007696  200005     MOV #0x0, W5
007698  97B07F     MOV [W15-18], W0
00769A  97B88F     MOV [W15-16], W1
00769C  420200     ADD W4, W0, W4
00769E  4A8281     ADDC W5, W1, W5
0076A0  9048E9     MOV.B [W9+14], W1
0076A2  FB8081     ZE W1, W1
0076A4  904879     MOV.B [W9+15], W0
0076A6  DD0048     SL W0, #8, W0
0076A8  700101     IOR W0, W1, W2
0076AA  905089     MOV.B [W9+16], W1
0076AC  FB8081     ZE W1, W1
0076AE  905019     MOV.B [W9+17], W0
0076B0  DD0048     SL W0, #8, W0
0076B2  700181     IOR W0, W1, W3
0076B4  520F82     SUB W4, W2, [W15]
0076B6  5A8F83     SUBB W5, W3, [W15]
0076B8  390004     BRA NC, 0x76C2
0076BA  906029     MOV.B [W9+34], W0
0076BC  EB0100     CLR W2
0076BE  504FE3     SUB.B W0, #0x3, [W15]
0076C0  3A0042     BRA NZ, 0x7746
3147:                          {
3148:                              dir = ((DIRENTRY)NULL);   // reached the end of the root
3149:                          }
3150:                          else
3151:                          {
3152:              #ifdef ALLOW_WRITES
3153:                              if (gNeedDataWrite)
0076C2  270BB0     MOV #0x70BB, W0
0076C4  E00410     CP0.B [W0]
0076C6  320004     BRA Z, 0x76D0
3154:                                  if (flushData())
0076C8  07FC2D     RCALL flushData
0076CA  EB0100     CLR W2
0076CC  E00400     CP0.B W0
0076CE  3A003B     BRA NZ, 0x7746
3155:                                      return NULL;
3156:              #endif
3157:                              gBufferOwner = NULL;
0076D0  EB0400     CLR W8
0076D2  8B8608     MOV W8, gBufferOwner
3158:                              gBufferZeroed = FALSE;
0076D4  270B90     MOV #0x70B9, W0
0076D6  784808     MOV.B W8, [W0]
3159:              
3160:                              if ( MDD_SectorRead( sector + offset2, dsk->buffer) != TRUE) // if FALSE: sector could not be read.
0076D8  FB8019     ZE [W9], W0
0076DA  904119     MOV.B [W9+1], W2
0076DC  DD1148     SL W2, #8, W2
0076DE  710100     IOR W2, W0, W2
0076E0  FB800C     ZE W12, W0
0076E2  200001     MOV #0x0, W1
0076E4  97B27F     MOV [W15-18], W4
0076E6  97BA8F     MOV [W15-16], W5
0076E8  400004     ADD W0, W4, W0
0076EA  488085     ADDC W1, W5, W1
0076EC  072EFA     RCALL MDD_SDSPI_SectorRead
0076EE  504FE1     SUB.B W0, #0x1, [W15]
0076F0  320002     BRA Z, 0x76F6
0076F2  780108     MOV W8, W2
0076F4  370013     BRA 0x771C
0076F6  904019     MOV.B [W9+1], W0
0076F8  FB8099     ZE [W9], W1
3161:                              {
3162:                                  dir = ((DIRENTRY)NULL);
3163:                              }
3164:                              else // Sector has been read properly, Copy the root entry info of the file searched.
3165:                              {
3166:                                  if(ForceRead)    // Buffer holds all 16 root entry info. Point to the one required.
0076FA  97EACF     MOV.B [W15-20], W5
0076FC  E00405     CP0.B W5
0076FE  32000C     BRA Z, 0x7718
3167:                                      dir = (DIRENTRY)((DIRENTRY)dsk->buffer) + ((*curEntry)%dirEntriesPerSector);
007700  DD0048     SL W0, #8, W0
007702  700001     IOR W0, W1, W0
007704  97B15F     MOV [W15-22], W2
007706  780092     MOV [W2], W1
007708  781F80     MOV W0, [W15++]
00770A  090011     REPEAT #0x11
00770C  D8808D     DIV.UW W1, W13
00770E  780101     MOV W1, W2
007710  78004F     MOV [--W15], W0
007712  DD1145     SL W2, #5, W2
007714  400102     ADD W0, W2, W2
007716  370002     BRA 0x771C
3168:                                  else
3169:                                      dir = (DIRENTRY)dsk->buffer;
007718  DD0048     SL W0, #8, W0
00771A  700101     IOR W0, W1, W2
3170:                              }
3171:                              gLastDataSectorRead = 0xFFFFFFFF;
00771C  EB8000     SETM W0
00771E  EB8080     SETM W1
007720  8B85E0     MOV W0, gLastDataSectorRead
007722  8B85F1     MOV W1, 0x70BE
007724  370010     BRA 0x7746
3172:                          }
3173:                      }
3174:                      else
3175:                      {
3176:                          nextClusterIsLast = TRUE;
007726  B3C011     MOV #0x1, W1
007728  270BA0     MOV #0x70BA, W0
00772A  784801     MOV.B W1, [W0]
00772C  EB0100     CLR W2
00772E  37000B     BRA 0x7746
3177:                          dir = ((DIRENTRY)NULL);
3178:                      }
3179:                  }
3180:                  else
3181:                      dir = (DIRENTRY)((DIRENTRY)dsk->buffer) + ((*curEntry)%dirEntriesPerSector);
007730  FB8019     ZE [W9], W0
007732  904099     MOV.B [W9+1], W1
007734  DD08C8     SL W1, #8, W1
007736  708080     IOR W1, W0, W1
007738  781F81     MOV W1, [W15++]
00773A  090011     REPEAT #0x11
00773C  D8820D     DIV.UW W4, W13
00773E  780001     MOV W1, W0
007740  7800CF     MOV [--W15], W1
007742  DD0045     SL W0, #5, W0
007744  408100     ADD W1, W0, W2
3182:              
3183:                  return(dir);
3184:              } // Cache_File_Entry
007754  781F88     MOV W8, [W15++]
007756  780180     MOV W0, W3
007758  780401     MOV W1, W8
00775A  780082     MOV W2, W1
3185:              
3186:              
3187:              /*************************************************************************
3188:                Function:
3189:                  CETYPE CreateFileEntry(FILEOBJ fo, WORD *fHandle, BYTE mode, BOOL createFirstCluster)
3190:                Summary:
3191:                  Create a new file entry
3192:                Conditions:
3193:                  Should not be called by the user.
3194:                Input:
3195:                  fo -       Pointer to file structure
3196:                  fHandle -  Location to create file
3197:                  mode - DIRECTORY mode or ARCHIVE mode
3198:                  createFirstCluster - If set to TRUE, first cluster is created
3199:                Return Values:
3200:                  CE_GOOD -        File Creation successful
3201:                  CE_DIR_FULL -    All root directory entries are taken
3202:                  CE_WRITE_ERROR - The head cluster of the file could not be created.
3203:                Side Effects:
3204:                  Modifies the FSerrno variable.
3205:                Description:
3206:                  With the data passed within fo, create a new file entry in the current
3207:                  directory.  This function will first search for empty file entries.
3208:                  Once an empty entry is found, the entry will be populated with data
3209:                  for a file or directory entry.  Finally, the first cluster of the
3210:                  new file will be located and allocated, and its value will be
3211:                  written into the file entry.
3212:                Remarks:
3213:                  None
3214:                *************************************************************************/
3215:              
3216:              #ifdef ALLOW_WRITES
3217:              CETYPE CreateFileEntry(FILEOBJ fo, WORD *fHandle, BYTE mode, BOOL createFirstCluster)
3218:              {
3219:                  CETYPE  error = CE_GOOD;
3220:              
3221:              	#if defined(SUPPORT_LFN)
3222:              	LFN_ENTRY *lfno;
3223:              	unsigned short int   *templfnPtr = (unsigned short int *)fo -> utf16LFNptr,*dest;
00A64C  901650     MOV [W0+42], W12
3224:              	unsigned short int	tempString[MAX_UTF16_CHARS_IN_LFN_ENTRY];
3225:              	UINT16_VAL tempShift;
3226:                  BOOL    firstTime = TRUE;
3227:              	BYTE	checksum,sequenceNumber,reminder,tempCalc1,numberOfFileEntries;
3228:                  char    index;
3229:              	char    *src;
3230:              	#endif
3231:              
3232:              	FSerrno = CE_GOOD;
00A64E  24938A     MOV #0x4938, W10
00A650  EB4D00     CLR.B [W10]
3233:              
3234:                 *fHandle = 0;
00A652  EB0880     CLR [W1]
3235:              
3236:                  // figure out where to put this file in the directory stucture
3237:                  if(FindEmptyEntries(fo, fHandle) == FOUND)
00A654  07EB18     RCALL FindEmptyEntries
00A656  784400     MOV.B W0, W8
00A658  200141     MOV #0x14, W1
00A65A  E00400     CP0.B W0
00A65C  3A00C4     BRA NZ, 0xA7E6
3238:                  {
3239:              		#if defined(SUPPORT_LFN)
3240:              		// If LFN entry
3241:              		if(fo->utf16LFNlength)
00A65E  901069     MOV [W9+44], W0
00A660  E00000     CP0 W0
00A662  3200B4     BRA Z, 0xA7CC
3242:              		{
3243:              			// Alias the LFN to short file name
3244:              			if(!Alias_LFN_Object(fo))
00A664  780009     MOV W9, W0
00A666  07FE8F     RCALL Alias_LFN_Object
00A668  E00000     CP0 W0
00A66A  3A0004     BRA NZ, 0xA674
3245:              			{
3246:              				// If Aliasing of LFN is unsucessful
3247:              				error = FSerrno = CE_FILENAME_EXISTS;
00A66C  B3C110     MOV #0x11, W0
00A66E  784D00     MOV.B W0, [W10]
00A670  200111     MOV #0x11, W1
00A672  3700BB     BRA 0xA7EA
3248:              				return(error);
3249:              			}
3250:              
3251:              			src = fo -> name;
00A674  4481FC     ADD W9, #0x1C, W3
00A676  9FEF88     MOV.B W8, [W15-24]
00A678  B3C0B1     MOV #0xB, W1
3252:              
3253:                  	    // Find the checksum for Short file name of LFN
3254:                  	    checksum = 0;
3255:                  	 	for (index = 11; index != 0; index--)
00A690  E94081     DEC.B W1, W1
00A692  3AFFF3     BRA NZ, 0xA67A
3256:                  	    {
3257:              				checksum = ((checksum & 1) ? 0x80 : 0) + (checksum >> 1) + *src++;
00A67A  97E90F     MOV.B [W15-24], W2
00A67C  610061     AND W2, #0x1, W0
00A67E  B3C802     MOV #0x80, W2
00A680  3A0001     BRA NZ, 0xA684
00A682  784100     MOV.B W0, W2
00A684  97EA0F     MOV.B [W15-24], W4
00A686  FB8004     ZE W4, W0
00A688  D10000     LSR W0, W0
00A68A  414000     ADD.B W2, W0, W0
00A68C  404033     ADD.B W0, [W3++], W0
00A68E  9FEF80     MOV.B W0, [W15-24]
3258:              			}
3259:              
3260:              			// File Name + NULL character is file name length in LFN
3261:              			fileNameLength = fo->utf16LFNlength;
00A694  9011E9     MOV [W9+44], W3
00A696  8A42B3     MOV W3, fileNameLength
3262:              
3263:              			// Determine the number of entries for LFN
3264:              			reminder = tempCalc1 = fileNameLength % MAX_UTF16_CHARS_IN_LFN_ENTRY;
00A698  2000D2     MOV #0xD, W2
00A69A  090011     REPEAT #0x11
00A69C  D88182     DIV.UW W3, W2
00A69E  780100     MOV W0, W2
00A6A0  780001     MOV W1, W0
00A6A2  784700     MOV.B W0, W14
3265:              
3266:              			numberOfFileEntries = fileNameLength/MAX_UTF16_CHARS_IN_LFN_ENTRY;
00A6A4  9FE7E2     MOV.B W2, [W15-26]
3267:              
3268:              			if(tempCalc1 || (fileNameLength < MAX_UTF16_CHARS_IN_LFN_ENTRY))
00A6A6  E00400     CP0.B W0
00A6A8  3A0002     BRA NZ, 0xA6AE
00A6AA  518FEC     SUB W3, #0xC, [W15]
00A6AC  3E0003     BRA GTU, 0xA6B4
3269:              			{
3270:              				numberOfFileEntries++;
00A6AE  97E2EF     MOV.B [W15-26], W5
00A6B0  E84285     INC.B W5, W5
00A6B2  9FE7E5     MOV.B W5, [W15-26]
3271:              			}
3272:              
3273:              			// Max sequence number for LFN root entry
3274:              			sequenceNumber = numberOfFileEntries | 0x40;
00A6B4  97E6EF     MOV.B [W15-26], W13
00A6B6  A0640D     BSET.B W13, #6
3275:              
3276:              			// Store the max sequence number entries in tempString
3277:              			if(tempCalc1)
00A6B8  E0040E     CP0.B W14
00A6BA  320024     BRA Z, 0xA704
00A6BC  EB4100     CLR.B W2
3278:              			{
3279:              				index = 0;
3280:              				while(tempCalc1)
00A6D4  504F8E     SUB.B W0, W14, [W15]
00A6D6  320002     BRA Z, 0xA6DC
00A6D8  784100     MOV.B W0, W2
00A6DA  37FFF1     BRA 0xA6BE
3281:              				{
3282:              					tempString[(BYTE)index++] = templfnPtr[fileNameLength - tempCalc1];
00A6BE  FB8082     ZE W2, W1
00A6C0  408081     ADD W1, W1, W1
00A6C2  574002     SUB.B W14, W2, W0
00A6C4  FB8000     ZE W0, W0
00A6C6  518000     SUB W3, W0, W0
00A6C8  400000     ADD W0, W0, W0
00A6CA  7E02E0     MOV [W0+W12], W5
00A6CC  2FFCC4     MOV #0xFFCC, W4
00A6CE  42020F     ADD W4, W15, W4
00A6D0  78B205     MOV W5, [W4+W1]
00A6D2  E84002     INC.B W2, W0
3283:              					tempCalc1--;
3284:              				}				 
3285:              
3286:              				tempString[(BYTE)index++] = 0x0000;
00A6DC  FB8000     ZE W0, W0
00A6DE  400000     ADD W0, W0, W0
00A6E0  EB0080     CLR W1
00A6E2  2FFCC3     MOV #0xFFCC, W3
00A6E4  41818F     ADD W3, W15, W3
00A6E6  783181     MOV W1, [W3+W0]
00A6E8  E8C082     INC2.B W2, W1
00A6EA  EB8100     SETM W2
00A6EC  370006     BRA 0xA6FA
3287:              				
3288:              				// Store the remaining bytes of max sequence number entries with 0xFF
3289:              				for(;index < MAX_UTF16_CHARS_IN_LFN_ENTRY;index++)
00A6F8  E84081     INC.B W1, W1
00A6FA  50CFEC     SUB.B W1, #0xC, [W15]
00A6FC  34FFF8     BRA LE, 0xA6EE
00A6FE  37000B     BRA 0xA716
00A704  418003     ADD W3, W3, W0
00A706  460000     ADD W12, W0, W0
00A708  50007A     SUB W0, #0x1A, W0
00A70A  2FFCC1     MOV #0xFFCC, W1
00A70C  40808F     ADD W1, W15, W1
00A70E  57817A     SUB W15, #0x1A, W2
3290:              				{
3291:              					tempString[(BYTE)index] = 0xFFFF;
00A6EE  FB8001     ZE W1, W0
00A6F0  400000     ADD W0, W0, W0
00A6F2  2FFCC5     MOV #0xFFCC, W5
00A6F4  42828F     ADD W5, W15, W5
00A6F6  783282     MOV W2, [W5+W0]
3292:              				}				 
3293:              			}
3294:              			else
3295:              			{
3296:              				// Store the remaining bytes of max sequence number entries with 0xFF
3297:              				for(index = MAX_UTF16_CHARS_IN_LFN_ENTRY;index > 0;index--)
00A712  508F82     SUB W1, W2, [W15]
00A714  3AFFFD     BRA NZ, 0xA710
3298:              				{
3299:              					tempString[MAX_UTF16_CHARS_IN_LFN_ENTRY - (BYTE)index] = templfnPtr[fileNameLength - (BYTE)index];
00A710  7818B0     MOV [W0++], [W1++]
3300:              				}
3301:              			}
3302:              
3303:              			dest = &tempString[12];
3304:              
3305:              			while(numberOfFileEntries)
00A7C8  E0040C     CP0.B W12
00A7CA  3AFFAD     BRA NZ, 0xA726
3306:              			{
3307:              				fo->dirccls = fo->dirclus;
00A726  901829     MOV [W9+52], W0
00A728  9018B9     MOV [W9+54], W1
00A72A  981CC0     MOV W0, [W9+56]
00A72C  981CD1     MOV W1, [W9+58]
3308:              			    lfno = (LFN_ENTRY *)Cache_File_Entry( fo, fHandle, TRUE);
00A72E  B3C012     MOV #0x1, W2
00A730  78008B     MOV W11, W1
00A732  780009     MOV W9, W0
00A734  07E73A     RCALL Cache_File_Entry
00A736  780080     MOV W0, W1
3309:              
3310:              			    if (lfno == NULL)
00A700  2001B1     MOV #0x1B, W1
00A702  370073     BRA 0xA7EA
00A738  E00000     CP0 W0
00A73A  32FFE2     BRA Z, 0xA700
3311:              				{
3312:              			        return CE_BADCACHEREAD;
3313:              				}
3314:              
3315:              				// Write the 32 byte LFN Object as per FAT specification
3316:              				lfno->LFN_SequenceNo = sequenceNumber--;   // Sequence number,
00A73C  78480D     MOV.B W13, [W0]
00A73E  E9468D     DEC.B W13, W13
3317:              
3318:              				lfno->LFN_Part3[1] = *dest--;
00A740  780118     MOV [W8], W2
00A742  980872     MOV W2, [W0+30]
3319:              				lfno->LFN_Part3[0] = *dest--;
00A744  97B9F8     MOV [W8-2], W3
00A746  980863     MOV W3, [W0+28]
3320:              
3321:              				lfno->LFN_Part2[5] = *dest--;
00A748  97BA68     MOV [W8-4], W4
00A74A  980844     MOV W4, [W0+24]
3322:              				lfno->LFN_Part2[4] = *dest--;
00A74C  97BAD8     MOV [W8-6], W5
00A74E  980835     MOV W5, [W0+22]
3323:              				lfno->LFN_Part2[3] = *dest--;
00A750  97B848     MOV [W8-8], W0
00A752  9808A0     MOV W0, [W1+20]
3324:              				lfno->LFN_Part2[2] = *dest--;
00A754  97B938     MOV [W8-10], W2
00A756  980892     MOV W2, [W1+18]
3325:              				lfno->LFN_Part2[1] = *dest--;
00A758  97B9A8     MOV [W8-12], W3
00A75A  980883     MOV W3, [W1+16]
3326:              				lfno->LFN_Part2[0] = *dest--;
00A75C  97BA18     MOV [W8-14], W4
00A75E  9800F4     MOV W4, [W1+14]
3327:              
3328:              				tempShift.Val = *dest--;
00A760  97B908     MOV [W8-16], W2
3329:              				lfno->LFN_Part1[9] = tempShift.byte.HB;
00A762  DE1048     LSR W2, #8, W0
00A764  9848A0     MOV.B W0, [W1+10]
3330:              				lfno->LFN_Part1[8] = tempShift.byte.LB;
00A766  984892     MOV.B W2, [W1+9]
3331:              				tempShift.Val = *dest--;
00A768  97B178     MOV [W8-18], W2
3332:              				lfno->LFN_Part1[7] = tempShift.byte.HB;
00A76A  DE1048     LSR W2, #8, W0
00A76C  984880     MOV.B W0, [W1+8]
3333:              				lfno->LFN_Part1[6] = tempShift.byte.LB;
00A76E  9840F2     MOV.B W2, [W1+7]
3334:              				tempShift.Val = *dest--;
00A770  97B168     MOV [W8-20], W2
3335:              				lfno->LFN_Part1[5] = tempShift.byte.HB;
00A772  DE1048     LSR W2, #8, W0
00A774  9840E0     MOV.B W0, [W1+6]
3336:              				lfno->LFN_Part1[4] = tempShift.byte.LB;
00A776  9840D2     MOV.B W2, [W1+5]
3337:              				tempShift.Val = *dest--;
00A778  97B158     MOV [W8-22], W2
3338:              				lfno->LFN_Part1[3] = tempShift.byte.HB;
00A77A  DE1048     LSR W2, #8, W0
00A77C  9840C0     MOV.B W0, [W1+4]
3339:              				lfno->LFN_Part1[2] = tempShift.byte.LB;
00A77E  9840B2     MOV.B W2, [W1+3]
3340:              				tempShift.Val = *dest--;
00A780  97B148     MOV [W8-24], W2
00A782  54047A     SUB W8, #0x1A, W8
3341:              				lfno->LFN_Part1[1] = tempShift.byte.HB;
00A784  DE1048     LSR W2, #8, W0
00A786  9840A0     MOV.B W0, [W1+2]
3342:              				lfno->LFN_Part1[0] = tempShift.byte.LB;
00A788  984092     MOV.B W2, [W1+1]
3343:              
3344:              				lfno->LFN_Attribute = ATTR_LONG_NAME;
00A78A  B3C0F0     MOV #0xF, W0
00A78C  9848B0     MOV.B W0, [W1+11]
3345:              				lfno->LFN_Type = 0;
00A78E  EB4000     CLR.B W0
00A790  9848C0     MOV.B W0, [W1+12]
3346:              				lfno->LFN_Checksum = checksum;
00A792  97EA8F     MOV.B [W15-24], W5
00A794  9848D5     MOV.B W5, [W1+13]
3347:              				lfno->LFN_Reserved2 = 0;
00A796  EB0500     CLR W10
00A798  9808DA     MOV W10, [W1+26]
3348:              
3349:              			    // just write the last entry in
3350:              			    if (Write_File_Entry(fo,fHandle) != TRUE)
00A79A  78008B     MOV W11, W1
00A79C  780009     MOV W9, W0
00A79E  07E487     RCALL Write_File_Entry
3351:              			        error = CE_WRITE_ERROR;
3352:              
3353:                      	    // 0x40 should be ORed with only max sequence number & in
3354:              				// all other cases it should not be present
3355:                      	    sequenceNumber &= (~0x40);
00A7A0  A1640D     BCLR.B W13, #6
3356:                      	    *fHandle = *fHandle + 1;
00A7A2  E80D9B     INC [W11], [W11]
3357:              				numberOfFileEntries--;
00A7A4  E9460C     DEC.B W12, W12
3358:              
3359:              				// Load the destination address only once and during first time,
3360:              				if(firstTime)
00A7A6  97B05F     MOV [W15-22], W0
00A7A8  E00000     CP0 W0
00A7AA  32000E     BRA Z, 0xA7C8
00A7AC  8242B0     MOV fileNameLength, W0
00A7AE  9010D9     MOV [W9+42], W1
3361:              				{
3362:              					if(reminder)
00A7B0  E0040E     CP0.B W14
00A7B2  320006     BRA Z, 0xA7C0
3363:              						dest = (unsigned short int *)(fo -> utf16LFNptr + fileNameLength - reminder - 1);
00A716  FB800E     ZE W14, W0
00A718  400000     ADD W0, W0, W0
00A71A  9FBF80     MOV W0, [W15-16]
00A71C  97E66F     MOV.B [W15-26], W12
00A71E  200014     MOV #0x1, W4
00A720  9FB7D4     MOV W4, [W15-22]
00A722  57847C     SUB W15, #0x1C, W8
00A724  370051     BRA 0xA7C8
00A7B4  400000     ADD W0, W0, W0
00A7B6  400001     ADD W0, W1, W0
00A7B8  97B88F     MOV [W15-16], W1
00A7BA  500001     SUB W0, W1, W0
00A7BC  E98400     DEC2 W0, W8
00A7BE  370003     BRA 0xA7C6
3364:              					else
3365:              						dest = (unsigned short int *)(fo -> utf16LFNptr + fileNameLength - MAX_UTF16_CHARS_IN_LFN_ENTRY - 1);
00A7C0  400000     ADD W0, W0, W0
00A7C2  400001     ADD W0, W1, W0
00A7C4  50047C     SUB W0, #0x1C, W8
00A7C6  9FB7DA     MOV W10, [W15-22]
3366:              					firstTime = FALSE;
3367:              				}
3368:              			}
3369:              		}
3370:              		#endif
3371:              
3372:                      // found the entry, now populate it
3373:                      if((error = PopulateEntries(fo, fHandle, mode)) == CE_GOOD)
00A7CC  97E94F     MOV.B [W15-20], W2
00A7CE  78008B     MOV W11, W1
00A7D0  780009     MOV W9, W0
00A7D2  07E8F8     RCALL PopulateEntries
00A7D4  FB8080     ZE W0, W1
00A7D6  E00400     CP0.B W0
00A7D8  3A0006     BRA NZ, 0xA7E6
3374:                      {
3375:              			if(createFirstCluster)
00A7DA  97B17F     MOV [W15-18], W2
00A7DC  E00002     CP0 W2
00A7DE  320003     BRA Z, 0xA7E6
3376:                          	// if everything is ok, create a first cluster
3377:                          	error = CreateFirstCluster(fo);
00A7E0  780009     MOV W9, W0
00A7E2  07EA01     RCALL CreateFirstCluster
00A7E4  780080     MOV W0, W1
3378:              			else
3379:              			{
3380:              
3381:              			}
3382:                      }
3383:                  }
3384:                  else
3385:                  {
3386:                      error = CE_DIR_FULL;
3387:                  }
3388:              
3389:                  FSerrno = error;
00A7E6  249380     MOV #0x4938, W0
00A7E8  784801     MOV.B W1, [W0]
3390:              
3391:                  return(error);
3392:              }
00A7F8  4787E8     ADD W15, #0x8, W15
00A7FA  BE9F88     MOV.D W8, [W15++]
00A7FC  BE9F8A     MOV.D W10, [W15++]
00A7FE  BE9F8C     MOV.D W12, [W15++]
00A800  781F8E     MOV W14, [W15++]
00A802  780480     MOV W0, W9
00A804  780581     MOV W1, W11
00A806  9FF782     MOV.B W2, [W15-16]
3393:              #endif
3394:              
3395:              /******************************************************
3396:                Function:
3397:                  CETYPE CreateFirstCluster(FILEOBJ fo)
3398:                Summary:
3399:                  Create the first cluster for a file
3400:                Conditions:
3401:                  This function should not be called by the user.
3402:                Input:
3403:                  fo -  The file that contains the first cluster
3404:                Return Values:
3405:                  CE_GOOD -        First cluster created successfully
3406:                  CE_WRITE_ERROR - Cluster creation failed
3407:                Side Effects:
3408:                  None
3409:                Description:
3410:                  This function will find an unused cluster, link it to
3411:                  a file's directory entry, and write the entry back
3412:                  to the device.
3413:                Remarks:
3414:                  None.
3415:                ******************************************************/
3416:              
3417:              #ifdef ALLOW_WRITES
3418:              CETYPE CreateFirstCluster(FILEOBJ fo)
3419:              {
3420:                  CETYPE       error;
3421:                  DWORD      cluster,TempMsbCluster;
3422:                  WORD        fHandle;
3423:                  DIRENTRY   dir;
3424:                  fHandle = fo->entry;
007BEC  5780EA     SUB W15, #0xA, W1
007BEE  901070     MOV [W0+46], W0
007BF0  781880     MOV W0, [W1++]
3425:              
3426:                  // Now create the first cluster (head cluster)
3427:                  if((error = FILECreateHeadCluster(fo,&cluster)) == CE_GOOD)
007BF2  780008     MOV W8, W0
007BF4  07FFCA     RCALL FILECreateHeadCluster
007BF6  780480     MOV W0, W9
007BF8  E00000     CP0 W0
007BFA  3A000F     BRA NZ, 0x7C1A
3428:                  {
3429:                      // load the file entry so the new cluster can be linked to it
3430:                      dir = LoadDirAttrib(fo, &fHandle);
007BFC  5780EA     SUB W15, #0xA, W1
007BFE  780008     MOV W8, W0
007C00  07FE74     RCALL LoadDirAttrib
3431:              
3432:                      // Now update the new cluster
3433:                      dir->DIR_FstClusLO = (cluster & 0x0000FFFF);
007C02  97B8CF     MOV [W15-8], W1
007C04  980851     MOV W1, [W0+26]
3434:              
3435:              
3436:              #ifdef SUPPORT_FAT32 // If FAT32 supported.
3437:                      // Get the higher part of cluster and store it in directory entry.
3438:                     TempMsbCluster = (cluster & 0x0FFF0000);    // Since only 28 bits usedin FAT32. Mask the higher MSB nibble.
007C06  97B8DF     MOV [W15-6], W1
007C08  20FFF2     MOV #0xFFF, W2
007C0A  608082     AND W1, W2, W1
3439:                     TempMsbCluster = TempMsbCluster >> 16;      // Get the date into Lsb place.
3440:                     dir->DIR_FstClusHI = TempMsbCluster;
007C0C  980821     MOV W1, [W0+20]
3441:              #else // If FAT32 support not enabled
3442:                     TempMsbCluster = 0;                         // Just to avoid compiler warnigng.
3443:                     dir->DIR_FstClusHI = 0;
3444:              #endif
3445:              
3446:                      // now write it
3447:                      if(Write_File_Entry(fo, &fHandle) != TRUE)
007C0E  5780EA     SUB W15, #0xA, W1
007C10  780008     MOV W8, W0
007C12  07FA4D     RCALL Write_File_Entry
007C14  504FE1     SUB.B W0, #0x1, [W15]
007C16  320001     BRA Z, 0x7C1A
007C18  200099     MOV #0x9, W9
3448:                          error = CE_WRITE_ERROR;
3449:                  } // Create Cluster
3450:              
3451:                  return(error);
3452:              }// End of CreateFirstCluster
007C22  BE9F88     MOV.D W8, [W15++]
007C24  BE9F8A     MOV.D W10, [W15++]
007C26  781F8C     MOV W12, [W15++]
007C28  780580     MOV W0, W11
007C2A  784601     MOV.B W1, W12
3453:              #endif
3454:              
3455:              /**********************************************************
3456:                Function:
3457:                  BYTE FindEmptyEntries(FILEOBJ fo, WORD *fHandle)
3458:                Summary:
3459:                  Find an empty dir entry
3460:                Conditions:
3461:                  This function should not be called by the user.
3462:                Input:
3463:                  fo -       Pointer to file structure
3464:                  fHandle -  Start of entries
3465:                Return Values:
3466:                  TRUE - One found
3467:                  FALSE - None found
3468:                Side Effects:
3469:                  None
3470:                Description:
3471:                  This function will cache directory entries, starting
3472:                  with the one pointed to by the fHandle argument.  It will
3473:                  then search through the entries until an unused one
3474:                  is found.  If the end of the cluster chain for the
3475:                  directory is reached, a new cluster will be allocated
3476:                  to the directory (unless it's a FAT12 or FAT16 root)
3477:                  and the first entry of the new cluster will be used.
3478:                Remarks:
3479:                  None.
3480:                **********************************************************/
3481:              
3482:              #ifdef ALLOW_WRITES
3483:              BYTE FindEmptyEntries(FILEOBJ fo, WORD *fHandle)
3484:              {
3485:                  BYTE   status = NOT_FOUND;
3486:                  BYTE   amountfound,numberOfFileEntries;
3487:                  BYTE   a = 0;
3488:                  WORD   bHandle = *fHandle;
007C92  780711     MOV [W1], W14
3489:                  DWORD b;
3490:                  DIRENTRY    dir;
3491:              
3492:                  fo->dirccls = fo->dirclus;
007C94  9018B0     MOV [W0+54], W1
007C96  901820     MOV [W0+52], W0
007C98  981C40     MOV W0, [W8+56]
007C9A  981C51     MOV W1, [W8+58]
3493:                  if((dir = Cache_File_Entry( fo, fHandle, TRUE)) != NULL)
007C9C  B3C012     MOV #0x1, W2
007C9E  78008B     MOV W11, W1
007CA0  780008     MOV W8, W0
007CA2  07FC83     RCALL Cache_File_Entry
007CA6  E00000     CP0 W0
007CA8  320047     BRA Z, 0x7D38
3494:                  {
3495:              		#if defined(SUPPORT_LFN)
3496:              		// If LFN entry
3497:              		if(fo->utf16LFNlength)
007CAA  9010E8     MOV [W8+44], W1
007CAC  E00001     CP0 W1
007CAE  3A0003     BRA NZ, 0x7CB6
007CB0  784681     MOV.B W1, W13
007CB2  B3C01C     MOV #0x1, W12
007CB4  370037     BRA 0x7D24
3498:              		{
3499:              			// File Name + NULL character is file name length in LFN
3500:              			fileNameLength = fo->utf16LFNlength;
007CB6  8A42B1     MOV W1, fileNameLength
3501:              
3502:              			// Determine the number of entries for LFN
3503:              			a = fileNameLength % MAX_UTF16_CHARS_IN_LFN_ENTRY;
007CB8  2000D2     MOV #0xD, W2
007CBA  781F81     MOV W1, [W15++]
007CBC  090011     REPEAT #0x11
007CBE  D88082     DIV.UW W1, W2
007CC0  780100     MOV W0, W2
007CC2  780001     MOV W1, W0
007CC4  7800CF     MOV [--W15], W1
007CC6  784680     MOV.B W0, W13
3504:              
3505:              			numberOfFileEntries = fileNameLength/MAX_UTF16_CHARS_IN_LFN_ENTRY;
3506:              
3507:              			if(a || (fileNameLength < MAX_UTF16_CHARS_IN_LFN_ENTRY))
007CC8  E00400     CP0.B W0
007CCA  3A0002     BRA NZ, 0x7CD0
007CCC  508FEC     SUB W1, #0xC, [W15]
007CCE  3E0001     BRA GTU, 0x7CD2
3508:              			{
3509:              				numberOfFileEntries++;
007CD0  E84102     INC.B W2, W2
3510:              			}
3511:              
3512:                          // Increment by 1 so that you have space to store for assosciated short file name
3513:                          numberOfFileEntries = numberOfFileEntries + 1;
007CD2  E84602     INC.B W2, W12
007CD4  370027     BRA 0x7D24
007CD6  784509     MOV.B W9, W10
3514:              		}
3515:              		else
3516:              		#endif
3517:                          numberOfFileEntries = 1;
3518:              
3519:                      // while its still not found
3520:                      while(status == NOT_FOUND)
3521:                      {
3522:                          amountfound = 0;
3523:                          bHandle = *fHandle;
007CA4  B3C011     MOV #0x1, W1
007D24  78071B     MOV [W11], W14
007D26  EB0480     CLR W9
007D28  37FFD6     BRA 0x7CD6
007D2A  B3C021     MOV #0x2, W1
007D2C  370005     BRA 0x7D38
007D2E  EB4080     CLR.B W1
007D30  370003     BRA 0x7D38
3524:              
3525:                          // find (number) continuous entries
3526:                          do
3527:                          {
3528:                              // Get the entry
3529:                              dir = Cache_File_Entry( fo, fHandle, FALSE);
007CD8  EB4100     CLR.B W2
007CDA  78008B     MOV W11, W1
007CDC  780008     MOV W8, W0
007CDE  07FC65     RCALL Cache_File_Entry
3530:              
3531:                              // Read the first char of the file name
3532:                              if(dir != NULL) // Last entry of the cluster
007CE0  E00000     CP0 W0
007CE2  320001     BRA Z, 0x7CE6
3533:                              {
3534:                                  a = dir->DIR_Name[0];
007CE4  784690     MOV.B [W0], W13
3535:                              }
3536:                              // increase number
3537:                              (*fHandle)++;
007CE6  E80D9B     INC [W11], [W11]
3538:                          }while((dir != (DIRENTRY)NULL) && ((a == DIR_DEL) || (a == DIR_EMPTY)) && (++amountfound < numberOfFileEntries));
007CE8  E00000     CP0 W0
007CEA  320009     BRA Z, 0x7CFE
007CEC  46CFFB     ADD.B W13, #0x1B, [W15]
007CEE  320002     BRA Z, 0x7CF4
007CF0  E0040D     CP0.B W13
007CF2  3A001F     BRA NZ, 0x7D32
007CF4  E8450A     INC.B W10, W10
007CF6  E80489     INC W9, W9
007CF8  564F89     SUB.B W12, W9, [W15]
007CFA  36001B     BRA LEU, 0x7D32
007CFC  37FFEC     BRA 0x7CD6
3539:              
3540:                          // --- now why did we exit?
3541:                          if(dir == NULL) // Last entry of the cluster
3542:                          {
3543:                              //setup the current cluster
3544:                              b = fo->dirccls; // write it back
007CFE  901948     MOV [W8+56], W2
007D00  9019D8     MOV [W8+58], W3
3545:              
3546:                              // make sure we are not the root directory
3547:                              if(b == FatRootDirClusterValue)
007D02  8249D0     MOV FatRootDirClusterValue, W0
007D04  8249E1     MOV 0x493C, W1
007D06  510F80     SUB W2, W0, [W15]
007D08  598F81     SUBB W3, W1, [W15]
007D0A  3A0004     BRA NZ, 0x7D14
3548:                              {
3549:                                  if (fo->dsk->type != FAT32)
007D0C  780018     MOV [W8], W0
007D0E  906020     MOV.B [W0+34], W0
007D10  504FE3     SUB.B W0, #0x3, [W15]
007D12  3A000B     BRA NZ, 0x7D2A
3550:                                      status = NO_MORE;
3551:                                  else
3552:                                  {
3553:                                      fo->ccls = b;
3554:              
3555:                                      if(FILEallocate_new_cluster(fo, 1) == CE_DISK_FULL)
3556:                                          status = NO_MORE;
3557:                                      else
3558:                                          status = FOUND;     // a new cluster will surely hold a new file name
3559:                                  }
3560:                              }
3561:                              else
3562:                              {
3563:                                  fo->ccls = b;
007D14  980432     MOV W2, [W8+6]
007D16  980443     MOV W3, [W8+8]
3564:              
3565:                                  if(FILEallocate_new_cluster(fo, 1) == CE_DISK_FULL)
007D18  B3C011     MOV #0x1, W1
007D1A  780008     MOV W8, W0
007D1C  07FF82     RCALL FILEallocate_new_cluster
007D1E  504FF5     SUB.B W0, #0x15, [W15]
007D20  3A0006     BRA NZ, 0x7D2E
007D22  370003     BRA 0x7D2A
3566:                                      status = NO_MORE;
3567:                                  else
3568:                                  {
3569:                                      status = FOUND;     // a new cluster will surely hold a new file name
3570:                                  }
3571:                              }
3572:                          }
3573:                          else
3574:                          {
3575:                              if(amountfound == numberOfFileEntries)
007D32  554F8C     SUB.B W10, W12, [W15]
007D34  32FFFC     BRA Z, 0x7D2E
007D36  37FFF6     BRA 0x7D24
3576:                                  status = FOUND;
3577:                          }
3578:                      }// while
3579:                  }
3580:              
3581:                  // copy the base handle over
3582:              	*fHandle = bHandle;
007D38  780D8E     MOV W14, [W11]
007D3A  FB8001     ZE W1, W0
3583:              
3584:              	return(status);
3585:              }
007D46  FA0002     LNK #0x2
007D48  BE9F88     MOV.D W8, [W15++]
007D4A  780480     MOV W0, W9
3586:              #endif
3587:              
3588:              /**************************************************************************
3589:                Function:
3590:                  BYTE PopulateEntries(FILEOBJ fo, WORD *fHandle, BYTE mode)
3591:                Summary:
3592:                  Populate a dir entry with data
3593:                Conditions:
3594:                  Should not be called by the user.
3595:                Input:
3596:                  fo -      Pointer to file structure
3597:                  fHandle - Location of the file
3598:                  mode - DIRECTORY mode or ARCHIVE mode
3599:                Return Values:
3600:                  CE_GOOD - Population successful
3601:                Side Effects:
3602:                  None
3603:                Description:
3604:                  This function will write data into a new file entry.  It will also
3605:                  load timestamp data (based on the method selected by the user) and
3606:                  update the timestamp variables.
3607:                Remarks:
3608:                  None.
3609:                **************************************************************************/
3610:              
3611:              #ifdef ALLOW_WRITES
3612:              BYTE PopulateEntries(FILEOBJ fo, WORD *fHandle, BYTE mode)
3613:              {
3614:                  BYTE error = CE_GOOD;
3615:                  DIRENTRY    dir;
3616:              
3617:                  fo->dirccls = fo->dirclus;
0079CE  9018B0     MOV [W0+54], W1
0079D0  901820     MOV [W0+52], W0
0079D2  981CC0     MOV W0, [W9+56]
0079D4  981CD1     MOV W1, [W9+58]
3618:                  dir = Cache_File_Entry( fo, fHandle, TRUE);
0079D6  B3C012     MOV #0x1, W2
0079D8  78008A     MOV W10, W1
0079DA  780009     MOV W9, W0
0079DC  07FDE6     RCALL Cache_File_Entry
0079DE  780400     MOV W0, W8
3619:              
3620:                  if (dir == NULL)
0079E0  2001B0     MOV #0x1B, W0
0079E2  E00008     CP0 W8
0079E4  320034     BRA Z, 0x7A4E
3621:                      return CE_BADCACHEREAD;
3622:              
3623:                  // copy the contents over
3624:                  strncpy(dir->DIR_Name,fo->name,DIR_NAMECOMP);
0079E6  4480FC     ADD W9, #0x1C, W1
0079E8  2000B2     MOV #0xB, W2
0079EA  780008     MOV W8, W0
0079EC  07EEB7     RCALL strncpy
3625:              
3626:                  // setup no attributes
3627:                  if (mode == DIRECTORY)
0079F0  55CFF2     SUB.B W11, #0x12, [W15]
0079F2  320001     BRA Z, 0x79F6
3628:                      dir->DIR_Attr = ATTR_DIRECTORY;
0079EE  B3C100     MOV #0x10, W0
3629:                  else
3630:                      dir->DIR_Attr   = ATTR_ARCHIVE;
0079F4  B3C200     MOV #0x20, W0
0079F6  984C30     MOV.B W0, [W8+11]
3631:              
3632:                  dir->DIR_NTRes  = 0x00;              // nt reserved
0079F8  EB4000     CLR.B W0
0079FA  984C40     MOV.B W0, [W8+12]
3633:                  dir->DIR_FstClusHI =    0x0000;      // high word of this enty's first cluster number
0079FC  EB0580     CLR W11
0079FE  980C2B     MOV W11, [W8+20]
3634:                  dir->DIR_FstClusLO =    0x0000;      // low word of this entry's first cluster number
007A00  980C5B     MOV W11, [W8+26]
3635:                  dir->DIR_FileSize =     0x0;         // file size in DWORD
007A02  B80060     MUL.UU W0, #0, W0
007A04  980C60     MOV W0, [W8+28]
007A06  980C71     MOV W1, [W8+30]
3636:              
3637:                 // Timing information for uncontrolled clock mode
3638:              #ifdef INCREMENTTIMESTAMP
3639:                  dir->DIR_CrtTimeTenth = 0xB2;        // millisecond stamp
3640:                  dir->DIR_CrtTime =      0x7278;      // time created
3641:                  dir->DIR_CrtDate =      0x32B0;      // date created
3642:                  dir->DIR_LstAccDate =   0x32B0;      // Last Access date
3643:                  dir->DIR_WrtTime =      0x7279;      // last update time
3644:                  dir->DIR_WrtDate =      0x32B0;      // last update date
3645:              #endif
3646:              
3647:              #ifdef USEREALTIMECLOCK
3648:                  CacheTime();
007A08  07FF91     RCALL CacheTime
3649:                  dir->DIR_CrtTimeTenth = gTimeCrtMS;        // millisecond stamp
007A0A  249480     MOV #0x4948, W0
007A0C  784010     MOV.B [W0], W0
007A0E  984C50     MOV.B W0, [W8+13]
3650:                  dir->DIR_CrtTime =      gTimeCrtTime;      // time created //
007A10  824A31     MOV gTimeCrtTime, W1
007A12  980471     MOV W1, [W8+14]
3651:                  dir->DIR_CrtDate =      gTimeCrtDate;      // date created (1/1/2004)
007A14  824A20     MOV gTimeCrtDate, W0
007A16  980C00     MOV W0, [W8+16]
3652:                  dir->DIR_LstAccDate =   gTimeAccDate;      // Last Access date
007A18  824A11     MOV gTimeAccDate, W1
007A1A  980C11     MOV W1, [W8+18]
3653:                  dir->DIR_WrtTime =      gTimeWrtTime;      // last update time
007A1C  824A00     MOV gTimeWrtTime, W0
007A1E  980C30     MOV W0, [W8+22]
3654:                  dir->DIR_WrtDate =      gTimeWrtDate;      // last update date
007A20  8249F1     MOV gTimeWrtDate, W1
007A22  980C41     MOV W1, [W8+24]
3655:              #endif
3656:              
3657:              #ifdef USERDEFINEDCLOCK
3658:                  // The user will have set the time before this funciton is called
3659:                  dir->DIR_CrtTimeTenth = gTimeCrtMS;
3660:                  dir->DIR_CrtTime =      gTimeCrtTime;
3661:                  dir->DIR_CrtDate =       gTimeCrtDate;
3662:                  dir->DIR_LstAccDate =   gTimeAccDate;
3663:                  dir->DIR_WrtTime =       gTimeWrtTime;
3664:                  dir->DIR_WrtDate =      gTimeWrtDate;
3665:              #endif
3666:              
3667:                  fo->size        = dir->DIR_FileSize;
007A24  900868     MOV [W8+28], W0
007A26  9008F8     MOV [W8+30], W1
007A28  980C90     MOV W0, [W9+18]
007A2A  980CA1     MOV W1, [W9+20]
3668:                  fo->time        = dir->DIR_CrtTime;
007A2C  824A31     MOV gTimeCrtTime, W1
007A2E  980CC1     MOV W1, [W9+24]
3669:                  fo->date        = dir->DIR_CrtDate;
007A30  900808     MOV [W8+16], W0
007A32  980CD0     MOV W0, [W9+26]
3670:                  fo->attributes  = dir->DIR_Attr;
007A34  904838     MOV.B [W8+11], W0
007A36  FB8000     ZE W0, W0
007A38  981C90     MOV W0, [W9+50]
3671:                  fo->entry       = *fHandle;
007A3A  78009A     MOV [W10], W1
007A3C  9814F1     MOV W1, [W9+46]
3672:              
3673:                  // just write the last entry in
3674:                  if (Write_File_Entry(fo,fHandle) != TRUE)
007A3E  78008A     MOV W10, W1
007A40  780009     MOV W9, W0
007A42  07FB35     RCALL Write_File_Entry
007A44  B3C091     MOV #0x9, W1
007A46  504FE1     SUB.B W0, #0x1, [W15]
007A48  3A0001     BRA NZ, 0x7A4C
007A4A  78408B     MOV.B W11, W1
3675:                      error = CE_WRITE_ERROR;
3676:              
3677:                  return(error);
007A4C  FB8001     ZE W1, W0
3678:              }
3679:              
3680:              /*****************************************************************
3681:                Function:
3682:                  BOOL Alias_LFN_Object(FILEOBJ fo)
3683:                Summary:
3684:                  Find the Short file name of the LFN entry
3685:                Conditions:
3686:                  Long file name should be present.
3687:                Input:
3688:                  fo -       Pointer to file structure
3689:                Return Values:
3690:                  FOUND -     Operation successful
3691:                  NOT_FOUND - Operation failed
3692:                Side Effects:
3693:                  None
3694:                Description:
3695:                  This function will find the short file name
3696:                  of the long file name as mentioned in the FAT
3697:                  specs.
3698:                Remarks:
3699:                  None.
3700:                *****************************************************************/
3701:              #if defined(SUPPORT_LFN)
3702:              BOOL Alias_LFN_Object(FILEOBJ fo)
3703:              {
00A5AA  E80002     INC W2, W0
00A5AC  440080     ADD W8, W0, W1
00A5AE  510000     SUB W2, W0, W0
00A5B0  370003     BRA 0xA5B8
3704:              	FSFILE		filePtr1;
3705:              	FSFILE		filePtr2;
3706:              	unsigned long int index4;
3707:              	short int   lfnIndex,index1,index2;
3708:                  BYTE  tempVariable,index;
3709:              	char  tempString[8];
3710:              	char  *lfnAliasPtr;
3711:              	unsigned short int  *templfnPtr;
3712:              	BOOL result = FALSE;
3713:              
3714:                  // copy file object over
3715:                  FileObjectCopy(&filePtr1, fo);
00A392  2FF7A0     MOV #0xFF7A, W0
00A394  478400     ADD W15, W0, W8
00A396  78008E     MOV W14, W1
00A398  780008     MOV W8, W0
00A39A  07EB5C     RCALL FileObjectCopy
3716:              
3717:              	lfnAliasPtr = (char *)&filePtr1.name[0];
3718:              
3719:              	templfnPtr = (unsigned short int *)filePtr1.utf16LFNptr;
00A39C  9793AF     MOV [W15-92], W7
3720:              
3721:              	fileNameLength = fo->utf16LFNlength;
00A39E  90116E     MOV [W14+44], W2
00A3A0  8A42B2     MOV W2, fileNameLength
00A3A2  44007C     ADD W8, #0x1C, W0
00A3A4  B3C202     MOV #0x20, W2
00A3A6  4000EB     ADD W0, #0xB, W1
3722:              
3723:              	// Initially fill the alias name with space characters
3724:              	for(index1 = 0;index1 < FILE_NAME_SIZE_8P3;index1++)
00A3AA  500F81     SUB W0, W1, [W15]
00A3AC  3AFFFD     BRA NZ, 0xA3A8
3725:              	{
3726:              		lfnAliasPtr[index1] = ' ';
00A3A8  785802     MOV.B W2, [W0++]
3727:              	}
3728:              
3729:              	// find the location where '.' is present
3730:              	for(lfnIndex = fileNameLength - 1;lfnIndex > 0;lfnIndex--)
00A3AE  8242B1     MOV fileNameLength, W1
00A3B0  E90101     DEC W1, W2
00A3B2  410002     ADD W2, W2, W0
00A3B4  438000     ADD W7, W0, W0
00A3B6  2002E3     MOV #0x2E, W3
00A3B8  370003     BRA 0xA3C0
00A3BE  E90102     DEC W2, W2
00A3C0  E00002     CP0 W2
00A3C2  3CFFFB     BRA GT, 0xA3BA
3731:              	{
3732:              		if (templfnPtr[lfnIndex] == '.')
00A3BA  118FA0     SUBR W3, [W0--], [W15]
00A3BC  320003     BRA Z, 0xA3C4
3733:              		{
3734:              		    break;
3735:              		}
3736:              	}
3737:              
3738:              	index1 = lfnIndex + 1;
00A3C4  E80202     INC W2, W4
3739:              
3740:              	tempVariable = 0;
3741:              	if(lfnIndex)
00A3C6  E00002     CP0 W2
00A3C8  320031     BRA Z, 0xA42C
00A3CA  420004     ADD W4, W4, W0
00A3CC  438280     ADD W7, W0, W5
00A3CE  EB4400     CLR.B W8
00A3D0  2FF9E6     MOV #0xFF9E, W6
00A3D2  478306     ADD W15, W6, W6
00A3D4  370025     BRA 0xA420
3742:              	{
3743:              		index2 = 8;
3744:              		// Complete the extension part as per the FAT specifications
3745:              		for(;((index1 < fileNameLength) && (tempVariable < 3));index1++)
00A41C  E80204     INC W4, W4
00A41E  E88285     INC2 W5, W5
00A420  8242B0     MOV fileNameLength, W0
00A422  520F80     SUB W4, W0, [W15]
00A424  310005     BRA C, 0xA430
00A426  544FE2     SUB.B W8, #0x2, [W15]
00A428  36FFD6     BRA LEU, 0xA3D6
00A42A  370002     BRA 0xA430
3746:              		{
3747:              			// Convert lower-case to upper-case
3748:              			index = (BYTE)templfnPtr[index1];
00A3D6  780195     MOV [W5], W3
3749:              			if ((index >= 0x61) && (index <= 0x7A))
00A3D8  B3C9F0     MOV #0x9F, W0
00A3DA  41C000     ADD.B W3, W0, W0
00A3DC  504FF9     SUB.B W0, #0x19, [W15]
00A3DE  3E0003     BRA GTU, 0xA3E6
3750:              			{
3751:              			    lfnAliasPtr[index2++] = index - 0x20;
00A3E0  B3CE00     MOV #0xE0, W0
00A3E2  41DB00     ADD.B W3, W0, [W6++]
00A3E4  37001A     BRA 0xA41A
3752:              			}
3753:              			else if(index == ' ')
00A3E6  B3C200     MOV #0x20, W0
00A3E8  51CF80     SUB.B W3, W0, [W15]
00A3EA  320018     BRA Z, 0xA41C
3754:              			{
3755:              				continue;
3756:              			}
3757:              			else if ((index == 0x2B) || (index == 0x2C) || (index == 0x3B) || 
00A3EC  B3CD50     MOV #0xD5, W0
00A3EE  41C000     ADD.B W3, W0, W0
00A3F0  504FE1     SUB.B W0, #0x1, [W15]
00A3F2  36000F     BRA LEU, 0xA412
00A3F4  B3C3B0     MOV #0x3B, W0
00A3F6  51CF80     SUB.B W3, W0, [W15]
00A3F8  32000C     BRA Z, 0xA412
00A3FA  E8C000     INC2.B W0, W0
00A3FC  51CF80     SUB.B W3, W0, [W15]
00A3FE  320009     BRA Z, 0xA412
00A400  40407E     ADD.B W0, #0x1E, W0
00A402  51CF80     SUB.B W3, W0, [W15]
00A404  320006     BRA Z, 0xA412
00A406  E8C000     INC2.B W0, W0
00A408  51CF80     SUB.B W3, W0, [W15]
00A40A  320003     BRA Z, 0xA412
00A40C  200FF0     MOV #0xFF, W0
00A40E  518F80     SUB W3, W0, [W15]
00A410  360003     BRA LEU, 0xA418
3758:              					(index == 0x3D) || (index == 0x5B) || (index == 0x5D) || 
3759:              					(templfnPtr[index1] > 0xFF))
3760:              			{
3761:              			    lfnAliasPtr[index2++] = '_';
00A412  B3C5F0     MOV #0x5F, W0
00A414  785B00     MOV.B W0, [W6++]
00A416  370001     BRA 0xA41A
3762:              			}
3763:              			else
3764:              			{
3765:              			    lfnAliasPtr[index2++] = index;
00A418  785B03     MOV.B W3, [W6++]
3766:              			}
3767:              			
3768:              			tempVariable++;
00A41A  E84408     INC.B W8, W8
3769:              		}
3770:              
3771:              		index2 = lfnIndex;
3772:              		tempVariable = 0;
3773:              	}
3774:              	else
3775:              	{
3776:              		index2 = fileNameLength;
00A42C  780301     MOV W1, W6
00A42E  370001     BRA 0xA432
00A430  780302     MOV W2, W6
00A432  780187     MOV W7, W3
00A434  EB0200     CLR W4
00A436  784684     MOV.B W4, W13
00A438  2FF7A8     MOV #0xFF7A, W8
00A43A  478288     ADD W15, W8, W5
00A43C  37002C     BRA 0xA496
3777:              	}
3778:              
3779:              	// Fill the base part as per the FAT specifications
3780:              	for(index1 = 0;((index1 < index2) && (tempVariable < 6));index1++)
00A492  E80204     INC W4, W4
00A494  E88183     INC2 W3, W3
00A496  520F86     SUB W4, W6, [W15]
00A498  3D0002     BRA GE, 0xA49E
00A49A  56CFE5     SUB.B W13, #0x5, [W15]
00A49C  36FFD0     BRA LEU, 0xA43E
3781:              	{
3782:              		// Convert lower-case to upper-case
3783:              		index = (BYTE)templfnPtr[index1];
00A43E  780093     MOV [W3], W1
00A440  784101     MOV.B W1, W2
3784:              		if ((index >= 0x61) && (index <= 0x7A))
00A442  B3C9F0     MOV #0x9F, W0
00A444  40C000     ADD.B W1, W0, W0
00A446  504FF9     SUB.B W0, #0x19, [W15]
00A448  3E0006     BRA GTU, 0xA456
3785:              		{
3786:              		    lfnAliasPtr[tempVariable] = index - 0x20;
00A44A  FB808D     ZE W13, W1
00A44C  428081     ADD W5, W1, W1
00A44E  B3CE00     MOV #0xE0, W0
00A450  414000     ADD.B W2, W0, W0
00A452  9858C0     MOV.B W0, [W1+28]
00A454  37001D     BRA 0xA490
3787:              		}
3788:              		else if(index == ' ')
00A456  B3C200     MOV #0x20, W0
00A458  50CF80     SUB.B W1, W0, [W15]
00A45A  32001B     BRA Z, 0xA492
3789:              		{
3790:              			continue;
3791:              		}
3792:              		else if ((index == 0x2B) || (index == 0x2C) || (index == 0x3B) || 
00A45C  B3CD50     MOV #0xD5, W0
00A45E  40C000     ADD.B W1, W0, W0
00A460  504FE1     SUB.B W0, #0x1, [W15]
00A462  36000F     BRA LEU, 0xA482
00A464  B3C3B0     MOV #0x3B, W0
00A466  50CF80     SUB.B W1, W0, [W15]
00A468  32000C     BRA Z, 0xA482
00A46A  E8C000     INC2.B W0, W0
00A46C  50CF80     SUB.B W1, W0, [W15]
00A46E  320009     BRA Z, 0xA482
00A470  40407E     ADD.B W0, #0x1E, W0
00A472  50CF80     SUB.B W1, W0, [W15]
00A474  320006     BRA Z, 0xA482
00A476  E8C000     INC2.B W0, W0
00A478  50CF80     SUB.B W1, W0, [W15]
00A47A  320003     BRA Z, 0xA482
00A47C  200FF0     MOV #0xFF, W0
00A47E  508F80     SUB W1, W0, [W15]
00A480  360004     BRA LEU, 0xA48A
3793:              				(index == 0x3D) || (index == 0x5B) || (index == 0x5D) || 
3794:              				(templfnPtr[index1] > 0xFF))
3795:              		{
3796:              		    lfnAliasPtr[tempVariable] = '_';
00A482  FB800D     ZE W13, W0
00A484  428000     ADD W5, W0, W0
00A486  B3C5F1     MOV #0x5F, W1
00A488  370002     BRA 0xA48E
3797:              		}
3798:              		else
3799:              		{
3800:              		    lfnAliasPtr[tempVariable] = index;
00A48A  FB800D     ZE W13, W0
00A48C  428000     ADD W5, W0, W0
00A48E  985841     MOV.B W1, [W0+28]
3801:              		}
3802:              		tempVariable++;
00A490  E8468D     INC.B W13, W13
3803:              	}
3804:              
3805:              	// Aliasing of the predicted name should append ~1
3806:              	lfnAliasPtr[tempVariable] = '~';
00A49E  FB808D     ZE W13, W1
00A4A0  2FF7A2     MOV #0xFF7A, W2
00A4A2  478002     ADD W15, W2, W0
00A4A4  400001     ADD W0, W1, W0
00A4A6  B3C7E1     MOV #0x7E, W1
00A4A8  985841     MOV.B W1, [W0+28]
3807:              	lfnAliasPtr[tempVariable + 1] = '1';
00A4AA  B3C311     MOV #0x31, W1
00A4AC  985851     MOV.B W1, [W0+29]
3808:              
3809:                  filePtr1.attributes = ATTR_ARCHIVE;
00A4AE  200200     MOV #0x20, W0
00A4B0  9F97E0     MOV W0, [W15-84]
3810:              
3811:              	filePtr1.utf16LFNlength = 0;
00A4B2  EB0000     CLR W0
00A4B4  9F97B0     MOV W0, [W15-90]
00A4B6  20001A     MOV #0x1, W10
00A4B8  20000B     MOV #0x0, W11
3812:              
3813:              	// Try for 9999999 combinations before telling error to the user
3814:              	for(index4 = 1;index4 < (unsigned long int)10000000;index4++)
00A61E  450561     ADD W10, #0x1, W10
00A620  4D85E0     ADDC W11, #0x0, W11
00A622  296800     MOV #0x9680, W0
00A624  200981     MOV #0x98, W1
00A626  550F80     SUB W10, W0, [W15]
00A628  5D8F81     SUBB W11, W1, [W15]
00A62A  3AFF47     BRA NZ, 0xA4BA
00A62C  EB0000     CLR W0
3815:              	{
3816:              	    filePtr1.cluster = 0;
00A4BA  2FF7A3     MOV #0xFF7A, W3
00A4BC  478603     ADD W15, W3, W12
00A4BE  B80060     MUL.UU W0, #0, W0
00A4C0  9F3FE0     MOV W0, [W15-132]
00A4C2  9F3FF1     MOV W1, [W15-130]
3817:              	    filePtr1.ccls    = 0;
00A4C4  9F8780     MOV W0, [W15-128]
00A4C6  9F8791     MOV W1, [W15-126]
3818:              	    filePtr1.entry = 0;
00A4C8  EB0480     CLR W9
00A4CA  9F97C9     MOV W9, [W15-88]
3819:              
3820:              		    // start at the current directory
3821:              		#ifdef ALLOW_DIRS
3822:              		    filePtr1.dirclus    = cwdptr->dirclus;
00A4CC  8385B0     MOV cwdptr, W0
00A4CE  901920     MOV [W0+52], W2
00A4D0  9019B0     MOV [W0+54], W3
00A4D2  9F97F2     MOV W2, [W15-82]
00A4D4  9F9F83     MOV W3, [W15-80]
3823:              		    filePtr1.dirccls    = cwdptr->dirccls;
00A4D6  901940     MOV [W0+56], W2
00A4D8  9019D0     MOV [W0+58], W3
00A4DA  9F9F92     MOV W2, [W15-78]
00A4DC  9F9FA3     MOV W3, [W15-76]
3824:              		#else
3825:              		    filePtr1.dirclus = FatRootDirClusterValue;
3826:              		    filePtr1.dirccls = FatRootDirClusterValue;
3827:              		#endif
3828:              
3829:              	    // copy file object over
3830:              	    FileObjectCopy(&filePtr2, &filePtr1);
00A4DE  2FFB68     MOV #0xFFB6, W8
00A4E0  478408     ADD W15, W8, W8
00A4E2  78008C     MOV W12, W1
00A4E4  780008     MOV W8, W0
00A4E6  07EAB6     RCALL FileObjectCopy
3831:              
3832:              	    // See if the file is found
3833:              	    if(FILEfind (&filePtr2, &filePtr1, LOOK_FOR_MATCHING_ENTRY, 0) == CE_GOOD)
00A4E8  784189     MOV.B W9, W3
00A4EA  B3C012     MOV #0x1, W2
00A4EC  78008C     MOV W12, W1
00A4EE  780008     MOV W8, W0
00A4F0  07FA15     RCALL FILEfind
00A4F2  780400     MOV W0, W8
00A4F4  E00000     CP0 W0
00A4F6  3A008A     BRA NZ, 0xA60C
3834:              		{
3835:              			tempString[7] = index4 % (BYTE)10 + '0';
00A4F8  2000A2     MOV #0xA, W2
00A4FA  200003     MOV #0x0, W3
00A4FC  BE000A     MOV.D W10, W0
00A4FE  07D7E1     RCALL __umodsi3
00A500  B04300     ADD.B #0x30, W0
00A502  9EFF90     MOV.B W0, [W15-135]
3836:              			tempString[6] = (index4 % (BYTE)100)/10 + '0';
00A504  200642     MOV #0x64, W2
00A506  200003     MOV #0x0, W3
00A508  BE000A     MOV.D W10, W0
00A50A  07D7DB     RCALL __umodsi3
00A50C  2000A2     MOV #0xA, W2
00A50E  200003     MOV #0x0, W3
00A510  07D7C8     RCALL __udivsi3
00A512  B04300     ADD.B #0x30, W0
00A514  9EFF80     MOV.B W0, [W15-136]
3837:              			tempString[5] = (index4 % 1000)/100 + '0';
00A516  203E82     MOV #0x3E8, W2
00A518  200003     MOV #0x0, W3
00A51A  BE000A     MOV.D W10, W0
00A51C  07D7D2     RCALL __umodsi3
00A51E  200642     MOV #0x64, W2
00A520  200003     MOV #0x0, W3
00A522  07D7BF     RCALL __udivsi3
00A524  B04300     ADD.B #0x30, W0
00A526  9EF7F0     MOV.B W0, [W15-137]
3838:              			tempString[4] = (index4 % 10000)/1000 + '0';
00A528  227102     MOV #0x2710, W2
00A52A  200003     MOV #0x0, W3
00A52C  BE000A     MOV.D W10, W0
00A52E  07D7C9     RCALL __umodsi3
00A530  203E82     MOV #0x3E8, W2
00A532  200003     MOV #0x0, W3
00A534  07D7B6     RCALL __udivsi3
00A536  B04300     ADD.B #0x30, W0
00A538  9EF7E0     MOV.B W0, [W15-138]
3839:              			tempString[3] = (index4 % 100000)/10000 + '0';
00A53A  286A02     MOV #0x86A0, W2
00A53C  200013     MOV #0x1, W3
00A53E  BE000A     MOV.D W10, W0
00A540  07D7C0     RCALL __umodsi3
00A542  227102     MOV #0x2710, W2
00A544  200003     MOV #0x0, W3
00A546  07D7AD     RCALL __udivsi3
00A548  B04300     ADD.B #0x30, W0
00A54A  9EF7D0     MOV.B W0, [W15-139]
3840:              			tempString[2] = (index4 % 1000000)/100000 + '0';
00A54C  242402     MOV #0x4240, W2
00A54E  2000F3     MOV #0xF, W3
00A550  BE000A     MOV.D W10, W0
00A552  07D7B7     RCALL __umodsi3
00A554  286A02     MOV #0x86A0, W2
00A556  200013     MOV #0x1, W3
00A558  07D7A4     RCALL __udivsi3
00A55A  B04300     ADD.B #0x30, W0
00A55C  9EF7C0     MOV.B W0, [W15-140]
3841:              			if((tempString[1] = ((index4 % 10000000)/1000000 + '0')) != '0')
00A55E  296802     MOV #0x9680, W2
00A560  200983     MOV #0x98, W3
00A562  BE000A     MOV.D W10, W0
00A564  07D7AE     RCALL __umodsi3
00A566  242402     MOV #0x4240, W2
00A568  2000F3     MOV #0xF, W3
00A56A  07D79B     RCALL __udivsi3
00A56C  B3C303     MOV #0x30, W3
00A56E  404083     ADD.B W0, W3, W1
00A570  9EF7B1     MOV.B W1, [W15-141]
00A572  50CF83     SUB.B W1, W3, [W15]
00A574  320004     BRA Z, 0xA57E
3842:              			{
3843:              					tempString[index = 0] = '~';
00A576  B3C7E0     MOV #0x7E, W0
00A578  9EF7A0     MOV.B W0, [W15-142]
00A57A  784188     MOV.B W8, W3
00A57C  370029     BRA 0xA5D0
00A57E  200052     MOV #0x5, W2
00A580  200065     MOV #0x6, W5
00A582  784381     MOV.B W1, W7
00A584  97931F     MOV [W15-94], W6
00A586  2FF728     MOV #0xFF72, W8
00A588  44040F     ADD W8, W15, W8
00A58A  440205     ADD W8, W5, W4
00A58C  784185     MOV.B W5, W3
3844:              			}
3845:              			else
3846:              			{
3847:              				for(index = 6;index > 0;index--)
00A5CC  410FE1     ADD W2, #0x1, [W15]
00A5CE  3AFFDE     BRA NZ, 0xA58C
3848:              				{
3849:              					if((tempString[index] == '0') && (tempString[index - 1] == '0'))
00A58E  784094     MOV.B [W4], W1
00A590  50CF87     SUB.B W1, W7, [W15]
00A592  3A0018     BRA NZ, 0xA5C4
00A594  2FF728     MOV #0xFF72, W8
00A596  44040F     ADD W8, W15, W8
00A598  794068     MOV.B [W8+W2], W0
00A59A  504F81     SUB.B W0, W1, [W15]
00A59C  3A0013     BRA NZ, 0xA5C4
3850:              					{
3851:              						tempString[index] = '~';
00A59E  B3C7E0     MOV #0x7E, W0
00A5A0  784A00     MOV.B W0, [W4]
3852:              						if(!filePtr1.AsciiEncodingType)
00A5A2  E00006     CP0 W6
00A5A4  3A0015     BRA NZ, 0xA5D0
3853:              						{
3854:              							if(index % 2)
00A5A6  A30805     BTST.Z W5, #0
00A5A8  320013     BRA Z, 0xA5D0
3855:              							{
3856:              								for(index2 = index - 1;index2 < 7;index2++)
00A5B4  E80102     INC W2, W2
00A5B6  E80081     INC W1, W1
00A5B8  510FE6     SUB W2, #0x6, [W15]
00A5BA  34FFFB     BRA LE, 0xA5B2
3857:              								{
3858:              									tempString[index2] = tempString[index2 + 1];
00A5B2  787091     MOV.B [W1], [W1+W0]
3859:              								}
3860:              								tempString[7] = ' ';
00A5BC  B3C200     MOV #0x20, W0
00A5BE  9EFF90     MOV.B W0, [W15-135]
3861:              								index--;
00A5C0  E94183     DEC.B W3, W3
00A5C2  370006     BRA 0xA5D0
00A5C4  784182     MOV.B W2, W3
00A5C6  E90102     DEC W2, W2
00A5C8  E90285     DEC W5, W5
00A5CA  E90204     DEC W4, W4
3862:              							}
3863:              						}
3864:              						break;
3865:              					}
3866:              				}
3867:              			}
3868:              
3869:              			if(index >= tempVariable)
00A5D0  51CF8D     SUB.B W3, W13, [W15]
00A5D2  390007     BRA NC, 0xA5E2
3870:              			{
3871:              				index1 = tempVariable;
00A5D4  FB808D     ZE W13, W1
00A5D6  2FF722     MOV #0xFF72, W2
00A5D8  41010F     ADD W2, W15, W2
00A5DA  410001     ADD W2, W1, W0
00A5DC  200242     MOV #0x24, W2
00A5DE  410100     ADD W2, W0, W2
00A5E0  370008     BRA 0xA5F2
3872:              			}
3873:              			else
3874:              			{
3875:              				index1 = index;
00A5E2  FB8083     ZE W3, W1
00A5E4  37FFF8     BRA 0xA5D6
3876:              			}
3877:              
3878:              			while(index < 8)
00A5F2  51CFE7     SUB.B W3, #0x7, [W15]
00A5F4  36FFF8     BRA LEU, 0xA5E6
00A5F6  2FF728     MOV #0xFF72, W8
00A5F8  44040F     ADD W8, W15, W8
00A5FA  440001     ADD W8, W1, W0
00A5FC  B00240     ADD #0x24, W0
00A5FE  B3C202     MOV #0x20, W2
00A600  370002     BRA 0xA606
3879:              			{
3880:              				filePtr1.name[index1++] = tempString[index++];
00A5E6  FB8003     ZE W3, W0
00A5E8  2FF724     MOV #0xFF72, W4
00A5EA  42020F     ADD W4, W15, W4
00A5EC  785964     MOV.B [W4+W0], [W2++]
00A5EE  E80081     INC W1, W1
00A5F0  E84183     INC.B W3, W3
3881:              			}
3882:              
3883:              			// Store the remaining bytes with leading spaces
3884:              			while(index1 < 8)
00A606  508FE7     SUB W1, #0x7, [W15]
00A608  34FFFC     BRA LE, 0xA602
00A60A  370009     BRA 0xA61E
00A60C  47007C     ADD W14, #0x1C, W0
00A60E  4600FC     ADD W12, #0x1C, W1
00A610  2FFA12     MOV #0xFFA1, W2
00A612  478102     ADD W15, W2, W2
3885:              			{
3886:              				filePtr1.name[index1++] = ' ';
00A602  785802     MOV.B W2, [W0++]
00A604  E80081     INC W1, W1
3887:              			}
3888:              
3889:              		}
3890:              		else
3891:              		{
3892:              			// short file name is found.Store it & quit
3893:              			lfnAliasPtr = &fo->name[0];
3894:              
3895:              			for(index = 0;index < FILE_NAME_SIZE_8P3;index++)
00A616  508F82     SUB W1, W2, [W15]
00A618  3AFFFD     BRA NZ, 0xA614
00A61A  200010     MOV #0x1, W0
00A61C  370008     BRA 0xA62E
3896:              			{
3897:              				lfnAliasPtr[index] = filePtr1.name[index];
00A614  785831     MOV.B [W1++], [W0++]
3898:              			}
3899:              
3900:              			result = TRUE;
3901:              			break;
3902:              		}
3903:              	}
3904:              
3905:              	return(result);
3906:              
3907:              } // Alias_LFN_Object
00A63A  B0028F     ADD #0x28, W15
00A63C  BE9F88     MOV.D W8, [W15++]
00A63E  BE9F8A     MOV.D W10, [W15++]
00A640  BE9F8C     MOV.D W12, [W15++]
00A642  781F8E     MOV W14, [W15++]
00A644  780480     MOV W0, W9
00A646  780581     MOV W1, W11
00A648  9FEFC2     MOV.B W2, [W15-20]
00A64A  9FB7F3     MOV W3, [W15-18]
3908:              #endif
3909:              
3910:              #ifdef USEREALTIMECLOCK
3911:              
3912:              /*************************************************************************
3913:                Function:
3914:                  void CacheTime (void)
3915:                Summary:
3916:                  Automatically store timestamp information from the RTCC
3917:                Conditions:
3918:                  RTCC module enabled.  Should not be called by the user.
3919:                Return Values:
3920:                  None
3921:                Side Effects:
3922:                  Modifies global timing variables
3923:                Description:
3924:                  This function will automatically load information from an RTCC
3925:                  module and use it to update the global timing variables.  These can
3926:                  then be used to update file timestamps.
3927:                Remarks:
3928:                  None.
3929:                *************************************************************************/
3930:              
3931:              void CacheTime (void)
3932:              {
3933:                  WORD    year, monthday, weekhour, minsec, c, result;
3934:              
3935:              #if defined (__PIC32MX__)   // Added support for PIC32. -Bud (3/4/2008)
3936:              
3937:              	unsigned int	t0, t1;
3938:              	unsigned int	d0, d1;
3939:              
3940:              	do  // Get the time
3941:              	{
3942:              		t0=RTCTIME;
3943:              		t1=RTCTIME;
3944:              	}while(t0!=t1);
3945:              
3946:              	do  // Get the date
3947:              	{
3948:              		d0=RTCDATE;
3949:              		d1=RTCDATE;
3950:              	}while(d0!=d1);
3951:              
3952:                  // Put them in place.
3953:                  year        = (WORD)(d0 >> 24);
3954:                  monthday    = (WORD)(d0 >> 8);
3955:                  weekhour    = (WORD)((d0 & 0x0F) << 8);
3956:                  weekhour   |= (WORD)(t0 >> 24);
3957:                  minsec      = (WORD)(t0 >> 8);
3958:              
3959:              #else
3960:                  BYTE    ptr1, ptr0;
3961:                  if(RCFGCALbits.RTCPTR0)
00792E  206271     MOV #0x627, W1
007930  784091     MOV.B [W1], W1
3962:                      ptr0 = 1;
3963:                  else
3964:                      ptr0 = 0;
3965:                  if (RCFGCALbits.RTCPTR1)
007932  BFC627     MOV.B 0x627, WREG
007934  604062     AND.B W0, #0x2, W0
3966:                      ptr1 = 1;
3967:                  else
3968:                      ptr1 = 0;
3969:              
3970:                  RCFGCALbits.RTCPTR0 = 1;
007936  A80627     BSET 0x627, #0
3971:                  RCFGCALbits.RTCPTR1 = 1;
007938  A82627     BSET 0x627, #1
3972:                  year = RTCVAL;
00793A  803122     MOV RTCVAL, W2
3973:                  monthday = RTCVAL;
00793C  803125     MOV RTCVAL, W5
3974:                  weekhour = RTCVAL;
00793E  803127     MOV RTCVAL, W7
3975:                  minsec = RTCVAL;
007940  803126     MOV RTCVAL, W6
3976:              
3977:                  if (ptr0 == 1)
007942  A30801     BTST.Z W1, #0
007944  320001     BRA Z, 0x7948
3978:                      RCFGCALbits.RTCPTR0 = 1;
007946  A80627     BSET 0x627, #0
3979:              
3980:                  if (ptr1 == 1)
007948  E00400     CP0.B W0
00794A  320001     BRA Z, 0x794E
3981:                      RCFGCALbits.RTCPTR1 = 1;
00794C  A82627     BSET 0x627, #1
3982:              
3983:              #endif
3984:              
3985:                  c = 0;
3986:                  c += (year & 0x0F);
3987:                  c += ((year & 0xF0) >> 4) * 10;
00794E  61006F     AND W2, #0xF, W0
007950  B20F02     AND #0xF0, W2
007952  DE1144     LSR W2, #4, W2
007954  B9116A     MUL.SU W2, #10, W2
007956  400002     ADD W0, W2, W0
3988:                  // c equals the last 2 digits of the year from 2000 to 2099
3989:                  // Add 20 to adjust it to FAT time (from 1980 to 2107)
3990:                  c += 20;
3991:                  // shift the result to bits
3992:                  result = c << 9;
007958  400074     ADD W0, #0x14, W0
00795A  DD0149     SL W0, #9, W2
3993:              
3994:                  if ((monthday & 0x1000) == 0x1000)
00795C  210000     MOV #0x1000, W0
00795E  628000     AND W5, W0, W0
007960  2000A1     MOV #0xA, W1
007962  3A0001     BRA NZ, 0x7966
007964  780080     MOV W0, W1
007966  249488     MOV #0x4948, W8
3995:                  {
3996:                      c = 10;
3997:                  }
3998:                  else
3999:                  {
4000:                      c = 0;
4001:                  }
4002:                  c += ((monthday & 0x0F00) >> 8);
007968  20F004     MOV #0xF00, W4
00796A  628184     AND W5, W4, W3
00796C  DE19C8     LSR W3, #8, W3
00796E  408183     ADD W1, W3, W3
4003:                  c <<= 5;
4004:                  result |= c;
007970  DD19C5     SL W3, #5, W3
007972  710183     IOR W2, W3, W3
4005:              
4006:                  c = (monthday & 0x00F0) >> 4;
007974  780005     MOV W5, W0
007976  B20F00     AND #0xF0, W0
007978  DE0044     LSR W0, #4, W0
4007:                  c *= 10;
00797A  B9006A     MUL.SU W0, #10, W0
4008:                  c += (monthday & 0x000F);
4009:              
4010:                  result |= c;
00797C  62816F     AND W5, #0xF, W2
00797E  410100     ADD W2, W0, W2
007980  718182     IOR W3, W2, W3
4011:              
4012:                  gTimeCrtDate = result;
007982  8A4A23     MOV W3, gTimeCrtDate
4013:                  gTimeWrtDate = result;
007984  8A49F3     MOV W3, gTimeWrtDate
4014:                  gTimeAccDate = result;
007986  8A4A13     MOV W3, gTimeAccDate
4015:              
4016:                  c = ((weekhour & 0x00F0) >> 4) * 10;
007988  780007     MOV W7, W0
00798A  B20F00     AND #0xF0, W0
00798C  DE0044     LSR W0, #4, W0
00798E  B9006A     MUL.SU W0, #10, W0
4017:                  c += (weekhour & 0x000F);
4018:                  result = c << 11;
007990  63816F     AND W7, #0xF, W2
007992  410100     ADD W2, W0, W2
007994  DD114B     SL W2, #11, W2
4019:                  c = ((minsec & 0xF000) >> 12) * 10;
007996  DE304C     LSR W6, #12, W0
007998  B9006A     MUL.SU W0, #10, W0
4020:                  c += (minsec & 0x0F00) >> 8;
4021:                  result |= (c << 5);
00799A  630204     AND W6, W4, W4
00799C  DE2248     LSR W4, #8, W4
00799E  420200     ADD W4, W0, W4
0079A0  DD2245     SL W4, #5, W4
0079A2  710184     IOR W2, W4, W3
4022:                  c = ((minsec & 0x00F0) >> 4) * 10;
0079A4  780006     MOV W6, W0
0079A6  B20F00     AND #0xF0, W0
0079A8  DE0044     LSR W0, #4, W0
0079AA  B9006A     MUL.SU W0, #10, W0
4023:                  c += (minsec & 0x000F);
0079AC  63016F     AND W6, #0xF, W2
0079AE  410080     ADD W2, W0, W1
4024:              
4025:                  // If seconds mod 2 is 1, add 1000 ms
4026:                  if (c % 2)
0079B0  608061     AND W1, #0x1, W0
0079B2  320001     BRA Z, 0x79B6
4027:                      gTimeCrtMS = 100;
0079B4  B3C640     MOV #0x64, W0
4028:                  else
4029:                      gTimeCrtMS = 0;
0079B6  784C00     MOV.B W0, [W8]
4030:              
4031:                  c >>= 1;
4032:                  result |= c;
0079B8  D10001     LSR W1, W0
0079BA  718000     IOR W3, W0, W0
4033:              
4034:                  gTimeCrtTime = result;
0079BC  8A4A30     MOV W0, gTimeCrtTime
4035:                  gTimeWrtTime = result;
0079BE  8A4A00     MOV W0, gTimeWrtTime
4036:              }
0079C4  BE9F88     MOV.D W8, [W15++]
0079C6  BE9F8A     MOV.D W10, [W15++]
0079C8  780480     MOV W0, W9
0079CA  780501     MOV W1, W10
0079CC  784582     MOV.B W2, W11
4037:              #endif
4038:              
4039:              #ifdef USERDEFINEDCLOCK
4040:              
4041:              /***********************************************************************************************************
4042:                Function:
4043:                  int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second)
4044:                Summary:
4045:                  Manually set timestamp variables
4046:                Conditions:
4047:                  USERDEFINEDCLOCK macro defined in FSconfig.h.
4048:                Input:
4049:                  year -     The year (1980\-2107)
4050:                  month -   The month (1\-12)
4051:                  day -     The day of the month (1\-31)
4052:                  hour -    The hour (0\-23)
4053:                  minute -  The minute (0\-59)
4054:                  second -  The second (0\-59)
4055:                Return Values:
4056:                  None
4057:                Side Effects:
4058:                  Modifies global timing variables
4059:                Description:
4060:                  Lets the user manually set the timing variables.  The values passed in will be converted to the format
4061:                  used by the FAT timestamps.
4062:                Remarks:
4063:                  Call this before creating a file or directory (set create time) and
4064:                  before closing a file (set last access time, last modified time)
4065:                ***********************************************************************************************************/
4066:              
4067:              int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second)
4068:              {
4069:                  unsigned int result;
4070:              
4071:                  if ((year < 1980) || (year > 2107) || (month < 1) || (month > 12) ||
4072:                      (day < 1) || (day > 31) || (hour > 23) || (minute > 59) || (second > 59))
4073:                  {
4074:                      FSerrno = CE_INVALID_ARGUMENT;
4075:                      return -1;
4076:                  }
4077:              
4078:                  result = (year - 1980) << 9;
4079:                  result |= (unsigned int)((unsigned int)month << 5);
4080:                  result |= (day);
4081:              
4082:                  gTimeAccDate = result;
4083:                  gTimeCrtDate = result;
4084:                  gTimeWrtDate = result;
4085:              
4086:                  result = ((unsigned int)hour << 11);
4087:                  result |= (unsigned int)((unsigned int)minute << 5);
4088:                  result |= (second/2);
4089:              
4090:                  gTimeCrtTime = result;
4091:                  gTimeWrtTime = result;
4092:              
4093:                  if (second % 2)
4094:                      gTimeCrtMS = 100;
4095:                  else
4096:                      gTimeCrtMS = 0;
4097:              
4098:                  FSerrno = CE_GOOD;
4099:                  return 0;
4100:              }
4101:              #endif
4102:              
4103:              #endif
4104:              
4105:              /***********************************************************************
4106:                Function:
4107:                  BYTE FILEallocate_new_cluster( FILEOBJ fo, BYTE mode)
4108:                Summary;
4109:                  Allocate a new cluster to a file
4110:                Conditions:
4111:                  Should not be called by the user.
4112:                Input:
4113:                  fo -    Pointer to file structure
4114:                  mode -
4115:                       - 0 - Allocate a cluster to a file
4116:                       - 1 - Allocate a cluster to a directory
4117:                Return Values:
4118:                  CE_GOOD -      Cluster allocated
4119:                  CE_DISK_FULL - No clusters available
4120:                Side Effects:
4121:                  None
4122:                Description:
4123:                  This function will find an empty cluster on the device using the
4124:                  FATfindEmptyCluster function.  It will then mark it as the last
4125:                  cluster in the file in the FAT chain, and link the current last
4126:                  cluster of the passed file to the new cluster.  If the new
4127:                  cluster is a directory cluster, it will be erased (so there are no
4128:                  extraneous directory entries).  If it's allocated to a non-directory
4129:                  file, it doesn't need to be erased; extraneous data in the cluster
4130:                  will be unviewable because of the file size parameter.
4131:                Remarks:
4132:                  None.
4133:                ***********************************************************************/
4134:              
4135:              #ifdef ALLOW_WRITES
4136:              BYTE FILEallocate_new_cluster( FILEOBJ fo, BYTE mode)
4137:              {
4138:                  DISK *      dsk;
4139:                  DWORD c,curcls;
4140:              
4141:                  dsk = fo->dsk;
007C2C  780510     MOV [W0], W10
4142:                  c = fo->ccls;
4143:              
4144:                  // find the next empty cluster
4145:                  c = FATfindEmptyCluster(fo);
007C2E  07FF19     RCALL FATfindEmptyCluster
007C30  BE0400     MOV.D W0, W8
4146:                  if (c == 0)      // "0" is just an indication as Disk full in the fn "FATfindEmptyCluster()"
007C32  200150     MOV #0x15, W0
007C34  540FE0     SUB W8, #0x0, [W15]
007C36  5C8FE0     SUBB W9, #0x0, [W15]
007C38  320022     BRA Z, 0x7C7E
4147:                      return CE_DISK_FULL;
4148:              
4149:              
4150:                  // mark the cluster as taken, and last in chain
4151:                  if(dsk->type == FAT12)
007C3A  90602A     MOV.B [W10+34], W0
007C3C  504FE1     SUB.B W0, #0x1, [W15]
007C3E  3A0004     BRA NZ, 0x7C48
4152:                      WriteFAT( dsk, c, LAST_CLUSTER_FAT12, FALSE);
007C40  EB4080     CLR.B W1
007C42  20FF84     MOV #0xFF8, W4
007C44  200005     MOV #0x0, W5
007C46  370009     BRA 0x7C5A
4153:                  else if (dsk->type == FAT16)
007C48  504FE2     SUB.B W0, #0x2, [W15]
007C4A  3A0004     BRA NZ, 0x7C54
4154:                      WriteFAT( dsk, c, LAST_CLUSTER_FAT16, FALSE);
007C4C  EB4080     CLR.B W1
007C4E  2FFF84     MOV #0xFFF8, W4
007C50  200005     MOV #0x0, W5
007C52  370003     BRA 0x7C5A
4155:              
4156:              #ifdef SUPPORT_FAT32 // If FAT32 supported.
4157:                  else
4158:                      WriteFAT( dsk, c, LAST_CLUSTER_FAT32, FALSE);
007C54  EB4080     CLR.B W1
007C56  2FFF84     MOV #0xFFF8, W4
007C58  20FFF5     MOV #0xFFF, W5
007C5A  BE0108     MOV.D W8, W2
007C5C  78000A     MOV W10, W0
007C5E  07FA69     RCALL WriteFAT
4159:              #endif
4160:              
4161:                  // link current cluster to the new one
4162:                  curcls = fo->ccls;
4163:              
4164:                  WriteFAT( dsk, curcls, c, FALSE);
007C60  90013B     MOV [W11+6], W2
007C62  9001CB     MOV [W11+8], W3
007C64  EB4080     CLR.B W1
007C66  BE0208     MOV.D W8, W4
007C68  78000A     MOV W10, W0
007C6A  07FA63     RCALL WriteFAT
4165:              
4166:                  // update the FILE structure
4167:                  fo->ccls = c;
007C6C  9805B8     MOV W8, [W11+6]
007C6E  9805C9     MOV W9, [W11+8]
4168:              
4169:                  // IF this is a dir, we need to erase the cluster
4170:                  // If it's a file, we can leave it- the file size
4171:                  // will limit the data we see to the data that's been
4172:                  // written
4173:                  if (mode == 1)
007C70  EB0000     CLR W0
007C72  564FE1     SUB.B W12, #0x1, [W15]
007C74  3A0004     BRA NZ, 0x7C7E
4174:                      return (EraseCluster(dsk, c));
007C76  BE0108     MOV.D W8, W2
007C78  78000A     MOV W10, W0
007C7A  07FF4D     RCALL EraseCluster
007C7C  FB8000     ZE W0, W0
4175:                  else
4176:                      return CE_GOOD;
4177:              
4178:              } // allocate new cluster
007C86  BE9F88     MOV.D W8, [W15++]
007C88  BE9F8A     MOV.D W10, [W15++]
007C8A  BE9F8C     MOV.D W12, [W15++]
007C8C  781F8E     MOV W14, [W15++]
007C8E  780400     MOV W0, W8
007C90  780581     MOV W1, W11
4179:              #endif
4180:              
4181:              /***********************************************
4182:                Function:
4183:                  DWORD FATfindEmptyCluster(FILEOBJ fo)
4184:                Summary:
4185:                  Find the next available cluster on the device
4186:                Conditions:
4187:                  This function should not be called by the
4188:                  user.
4189:                Input:
4190:                  fo -  Pointer to file structure
4191:                Return Values:
4192:                  DWORD - Address of empty cluster
4193:                  0 -     Could not find empty cluster
4194:                Side Effects:
4195:                  None
4196:                Description:
4197:                  This function will search through the FAT to
4198:                  find the next available cluster on the device.
4199:                Remarks:
4200:                  Should not be called by user
4201:                ***********************************************/
4202:              
4203:              #ifdef ALLOW_WRITES
4204:              DWORD FATfindEmptyCluster(FILEOBJ fo)
4205:              {
4206:                  DISK *   disk;
4207:                  DWORD    value = 0x0;
4208:                  DWORD    c,curcls, EndClusterLimit, ClusterFailValue;
4209:              
4210:                  disk = fo->dsk;
007A6A  780610     MOV [W0], W12
4211:                  c = fo->ccls;
007A6C  900530     MOV [W0+6], W10
007A6E  9005C0     MOV [W0+8], W11
4212:              
4213:                  /* Settings based on FAT type */
4214:                  switch (disk->type)
007A70  90602C     MOV.B [W12+34], W0
007A72  504FE1     SUB.B W0, #0x1, [W15]
007A74  320003     BRA Z, 0x7A7C
007A76  504FE3     SUB.B W0, #0x3, [W15]
007A78  3A0004     BRA NZ, 0x7A82
007A7A  37000A     BRA 0x7A90
007A7C  20FF70     MOV #0xFF7, W0
007A7E  200001     MOV #0x0, W1
007A80  370002     BRA 0x7A86
007A82  2FFF70     MOV #0xFFF7, W0
007A84  200001     MOV #0x0, W1
007A86  9FBF90     MOV W0, [W15-14]
007A88  9FBFA1     MOV W1, [W15-12]
007A8A  2FFFF2     MOV #0xFFFF, W2
007A8C  200003     MOV #0x0, W3
007A8E  370006     BRA 0x7A9C
007A90  2FFF70     MOV #0xFFF7, W0
007A92  20FFF1     MOV #0xFFF, W1
007A94  9FBF90     MOV W0, [W15-14]
007A96  9FBFA1     MOV W1, [W15-12]
007A98  2FFFF2     MOV #0xFFFF, W2
007A9A  20FFF3     MOV #0xFFF, W3
007A9C  9FB7F2     MOV W2, [W15-18]
007A9E  9FBF83     MOV W3, [W15-16]
4215:                  {
4216:              #ifdef SUPPORT_FAT32 // If FAT32 supported.
4217:                      case FAT32:
4218:                          EndClusterLimit = END_CLUSTER_FAT32;
4219:                          ClusterFailValue = CLUSTER_FAIL_FAT32;
4220:                          break;
4221:              #endif
4222:                      case FAT12:
4223:                          EndClusterLimit = END_CLUSTER_FAT12;
4224:                          ClusterFailValue = CLUSTER_FAIL_FAT16;
4225:                          break;
4226:                      case FAT16:
4227:                      default:
4228:                          EndClusterLimit = END_CLUSTER_FAT16;
4229:                          ClusterFailValue = CLUSTER_FAIL_FAT16;
4230:                          break;
4231:                  }
4232:              
4233:                  // just in case
4234:                  if(c < 2)
007AA0  550FE1     SUB W10, #0x1, [W15]
007AA2  5D8FE0     SUBB W11, #0x0, [W15]
007AA4  3E0002     BRA GTU, 0x7AAA
007AA6  20002A     MOV #0x2, W10
007AA8  20000B     MOV #0x0, W11
4235:                      c = 2;
4236:              
4237:                  curcls = c;
4238:                  ReadFAT(disk, c);
007AAA  BE010A     MOV.D W10, W2
007AAC  78000C     MOV W12, W0
007AAE  07FC6D     RCALL ReadFAT
007AB0  BE040A     MOV.D W10, W8
007AB2  370026     BRA 0x7B00
4239:              
4240:                  // sequentially scan through the FAT looking for an empty cluster
4241:                  while(c)
007B00  540FE0     SUB W8, #0x0, [W15]
007B02  5C8FE0     SUBB W9, #0x0, [W15]
007B04  3AFFD7     BRA NZ, 0x7AB4
007B06  370001     BRA 0x7B0A
007B08  B84460     MUL.UU W8, #0, W8
4242:                  {
4243:                      // look at its value
4244:                      if ( (value = ReadFAT(disk, c)) == ClusterFailValue)
007AB4  BE0108     MOV.D W8, W2
007AB6  78000C     MOV W12, W0
007AB8  07FC68     RCALL ReadFAT
007ABA  97B17F     MOV [W15-18], W2
007ABC  97B98F     MOV [W15-16], W3
007ABE  500F82     SUB W0, W2, [W15]
007AC0  588F83     SUBB W1, W3, [W15]
007AC2  320022     BRA Z, 0x7B08
4245:                      {
4246:                          c = 0;
4247:                          break;
4248:                      }
4249:              
4250:                      // check if empty cluster found
4251:                      if (value == CLUSTER_EMPTY)
007AC4  500FE0     SUB W0, #0x0, [W15]
007AC6  588FE0     SUBB W1, #0x0, [W15]
007AC8  320020     BRA Z, 0x7B0A
4252:                          break;
4253:              
4254:                      c++;    // check next cluster in FAT
007ACA  440461     ADD W8, #0x1, W8
007ACC  4C84E0     ADDC W9, #0x0, W9
4255:                      // check if reached last cluster in FAT, re-start from top
4256:                      if ((value == EndClusterLimit) || (c >= (disk->maxcls+2)))
007ACE  97B91F     MOV [W15-14], W2
007AD0  97B9AF     MOV [W15-12], W3
007AD2  500F82     SUB W0, W2, [W15]
007AD4  588F83     SUBB W1, W3, [W15]
007AD6  32000F     BRA Z, 0x7AF6
007AD8  9050CC     MOV.B [W12+20], W1
007ADA  FB8081     ZE W1, W1
007ADC  90505C     MOV.B [W12+21], W0
007ADE  DD0048     SL W0, #8, W0
007AE0  700101     IOR W0, W1, W2
007AE2  9050EC     MOV.B [W12+22], W1
007AE4  FB8081     ZE W1, W1
007AE6  90507C     MOV.B [W12+23], W0
007AE8  DD0048     SL W0, #8, W0
007AEA  700181     IOR W0, W1, W3
007AEC  410162     ADD W2, #0x2, W2
007AEE  4981E0     ADDC W3, #0x0, W3
007AF0  540F82     SUB W8, W2, [W15]
007AF2  5C8F83     SUBB W9, W3, [W15]
007AF4  390002     BRA NC, 0x7AFA
007AF6  200028     MOV #0x2, W8
007AF8  200009     MOV #0x0, W9
4257:                          c = 2;
4258:              
4259:                      // check if full circle done, disk full
4260:                      if ( c == curcls)
007AFA  540F8A     SUB W8, W10, [W15]
007AFC  5C8F8B     SUBB W9, W11, [W15]
007AFE  320004     BRA Z, 0x7B08
4261:                      {
4262:                          c = 0;
4263:                          break;
4264:                      }
4265:                  }  // scanning for an empty cluster
4266:              
4267:                  return(c);
4268:              }
007B16  BE9F88     MOV.D W8, [W15++]
007B18  BE9F8A     MOV.D W10, [W15++]
007B1A  BE9F8C     MOV.D W12, [W15++]
007B1C  780400     MOV W0, W8
4269:              #endif
4270:              
4271:              
4272:              /*********************************************************************************
4273:                Function:
4274:                  void FSGetDiskProperties(FS_DISK_PROPERTIES* properties)
4275:                Summary:
4276:                  Allows user to get the disk properties (size of disk, free space, etc)
4277:                Conditions:
4278:                  1) ALLOW_GET_DISK_PROPERTIES must be defined in FSconfig.h
4279:                  2) a FS_DISK_PROPERTIES object must be created before the function is called
4280:                  3) the new_request member of the FS_DISK_PROPERTIES object must be set before
4281:                      calling the function for the first time.  This will start a new search.
4282:                  4) this function should not be called while there is a file open.  Close all
4283:                      files before calling this function.
4284:                Input:
4285:                  properties - a pointer to a FS_DISK_PROPERTIES object where the results should
4286:                    be stored.
4287:                Return Values:
4288:                  This function returns void.  The properties_status of the previous call of this 
4289:                    function is located in the properties.status field.  This field has the 
4290:                    following possible values:
4291:              
4292:                  FS_GET_PROPERTIES_NO_ERRORS - operation completed without error.  Results
4293:                    are in the properties object passed into the function.
4294:                  FS_GET_PROPERTIES_DISK_NOT_MOUNTED - there is no mounted disk.  Results in
4295:                    properties object is not valid
4296:                  FS_GET_PROPERTIES_CLUSTER_FAILURE - there was a failure trying to read a 
4297:                    cluster from the drive.  The results in the properties object is a partial
4298:                    result up until the point of the failure.
4299:                  FS_GET_PROPERTIES_STILL_WORKING - the search for free sectors is still in
4300:                    process.  Continue calling this function with the same properties pointer 
4301:                    until either the function completes or until the partial results meets the
4302:                    application needs.  The properties object contains the partial results of
4303:                    the search and can be used by the application.  
4304:                Side Effects:
4305:                  Can cause errors if called when files are open.  Close all files before
4306:                  calling this function.
4307:              
4308:                  Calling this function without setting the new_request member on the first
4309:                  call can result in undefined behavior and results.
4310:              
4311:                  Calling this function after a result is returned other than
4312:                  FS_GET_PROPERTIES_STILL_WORKING can result in undefined behavior and results.
4313:                Description:  
4314:                  This function returns the information about the mounted drive.  The results 
4315:                  member of the properties object passed into the function is populated with 
4316:                  the information about the drive.    
4317:              
4318:                  Before starting a new request, the new_request member of the properties
4319:                  input parameter should be set to TRUE.  This will initiate a new search
4320:                  request.
4321:              
4322:                  This function will return before the search is complete with partial results.
4323:                  All of the results except the free_clusters will be correct after the first
4324:                  call.  The free_clusters will contain the number of free clusters found up
4325:                  until that point, thus the free_clusters result will continue to grow until
4326:                  the entire drive is searched.  If an application only needs to know that a 
4327:                  certain number of bytes is available and doesn't need to know the total free 
4328:                  size, then this function can be called until the required free size is
4329:                  verified.  To continue a search, pass a pointer to the same FS_DISK_PROPERTIES
4330:                  object that was passed in to create the search.
4331:              
4332:                  A new search request sould be made once this function has returned a value 
4333:                  other than FS_GET_PROPERTIES_STILL_WORKING.  Continuing a completed search
4334:                  can result in undefined behavior or results.
4335:              
4336:                  Typical Usage:
4337:                  <code>
4338:                  FS_DISK_PROPERTIES disk_properties;
4339:              
4340:                  disk_properties.new_request = TRUE;
4341:              
4342:                  do
4343:                  {
4344:                      FSGetDiskProperties(&disk_properties);
4345:                  } while (disk_properties.properties_status == FS_GET_PROPERTIES_STILL_WORKING);
4346:                  </code>
4347:              
4348:                  results.disk_format - contains the format of the drive.  Valid results are 
4349:                    FAT12(1), FAT16(2), or FAT32(3).
4350:              
4351:                  results.sector_size - the sector size of the mounted drive.  Valid values are
4352:                    512, 1024, 2048, and 4096.
4353:              
4354:                  results.sectors_per_cluster - the number sectors per cluster.
4355:              
4356:                  results.total_clusters - the number of total clusters on the drive.  This 
4357:                    can be used to calculate the total disk size (total_clusters * 
4358:                    sectors_per_cluster * sector_size = total size of drive in bytes)
4359:              
4360:                  results.free_clusters - the number of free (unallocated) clusters on the drive.
4361:                    This can be used to calculate the total free disk size (free_clusters * 
4362:                    sectors_per_cluster * sector_size = total size of drive in bytes)
4363:              
4364:                Remarks:
4365:                  PIC24F size estimates:
4366:                    Flash - 400 bytes (-Os setting)
4367:              
4368:                  PIC24F speed estimates:
4369:                    Search takes approximately 7 seconds per Gigabyte of drive space.  Speed
4370:                      will vary based on the number of sectors per cluster and the sector size.
4371:                *********************************************************************************/
4372:              #if defined(ALLOW_GET_DISK_PROPERTIES)
4373:              void FSGetDiskProperties(FS_DISK_PROPERTIES* properties)
4374:              {
4375:                  BYTE    i;
4376:                  DWORD   value = 0x0;
4377:              
4378:                  if(properties->new_request == TRUE)
4379:                  {
4380:                      properties->disk = &gDiskData;
4381:                      properties->results.free_clusters = 0;
4382:                      properties->new_request = FALSE;
4383:              
4384:                      if(properties->disk->mount != TRUE)
4385:                      {
4386:                          properties->properties_status = FS_GET_PROPERTIES_DISK_NOT_MOUNTED;
4387:                          return;
4388:                      }
4389:              
4390:                      properties->properties_status = FS_GET_PROPERTIES_STILL_WORKING;
4391:                 
4392:                      properties->results.disk_format = properties->disk->type;
4393:                      properties->results.sector_size = properties->disk->sectorSize;
4394:                      properties->results.sectors_per_cluster = properties->disk->SecPerClus;
4395:                      properties->results.total_clusters = properties->disk->maxcls;
4396:              
4397:                      /* Settings based on FAT type */
4398:                      switch (properties->disk->type)
4399:                      {
4400:                  #ifdef SUPPORT_FAT32 // If FAT32 supported.
4401:                          case FAT32:
4402:                              properties->private.EndClusterLimit = END_CLUSTER_FAT32;
4403:                              properties->private.ClusterFailValue = CLUSTER_FAIL_FAT32;
4404:                              break;
4405:                  #endif
4406:                          case FAT16:
4407:                              properties->private.EndClusterLimit = END_CLUSTER_FAT16;
4408:                              properties->private.ClusterFailValue = CLUSTER_FAIL_FAT16;
4409:                              break;
4410:                          case FAT12:
4411:                              properties->private.EndClusterLimit = END_CLUSTER_FAT12;
4412:                              properties->private.ClusterFailValue = CLUSTER_FAIL_FAT16;
4413:                              break;
4414:                      }
4415:                  
4416:                      properties->private.c = 2;
4417:              
4418:                      properties->private.curcls = properties->private.c;
4419:                      ReadFAT(properties->disk, properties->private.c);
4420:                  }
4421:              
4422:                  if(properties->disk == NULL)
4423:                  {
4424:                      properties->properties_status = FS_GET_PROPERTIES_DISK_NOT_MOUNTED;
4425:                      return;
4426:                  }
4427:              
4428:                  if(properties->properties_status != FS_GET_PROPERTIES_STILL_WORKING)
4429:                  {
4430:                      return;
4431:                  }
4432:              
4433:                  // sequentially scan through the FAT looking for an empty cluster
4434:                  for(i=0;i<255;i++)
4435:                  {
4436:                      // look at its value
4437:                      if ( (value = ReadFAT(properties->disk, properties->private.c)) == properties->private.ClusterFailValue)
4438:                      {
4439:                          properties->properties_status = FS_GET_PROPERTIES_CLUSTER_FAILURE;
4440:                          return;
4441:                      }
4442:              
4443:                      // check if empty cluster found
4444:                      if (value == CLUSTER_EMPTY)
4445:                      {
4446:                          properties->results.free_clusters++;
4447:                      }
4448:              
4449:                      properties->private.c++;    // check next cluster in FAT
4450:                      // check if reached last cluster in FAT, re-start from top
4451:                      if ((value == properties->private.EndClusterLimit) || (properties->private.c >= (properties->results.total_clusters + 2)))
4452:                          properties->private.c = 2;
4453:              
4454:                      // check if full circle done, disk full
4455:                      if ( properties->private.c == properties->private.curcls)
4456:                      {
4457:                          properties->properties_status = FS_GET_PROPERTIES_NO_ERRORS;
4458:                          return;
4459:                      }
4460:                  }  // scanning for an empty cluster
4461:              
4462:                  properties->properties_status = FS_GET_PROPERTIES_STILL_WORKING;
4463:                  return;
4464:              }
4465:              #endif
4466:              
4467:              /************************************************************
4468:                Function:
4469:                  int FSfclose(FSFILE *fo)
4470:                Summary:
4471:                  Update file information and free FSFILE objects
4472:                Conditions:
4473:                  File opened
4474:                Input:
4475:                  fo -  Pointer to the file to close
4476:                Return Values:
4477:                  0 -   File closed successfully
4478:                  EOF - Error closing the file
4479:                Side Effects:
4480:                  The FSerrno variable will be changed.
4481:                Description:
4482:                  This function will update the directory entry for the
4483:                  file pointed to by 'fo' with the information contained
4484:                  in 'fo,' including the new file size and attributes.
4485:                  Timestamp information will also be loaded based on the
4486:                  method selected by the user and written to the entry
4487:                  as the last modified time and date.  The file entry will
4488:                  then be written to the device.  Finally, the memory
4489:                  used for the specified file object will be freed from
4490:                  the dynamic heap or the array of FSFILE objects.
4491:                Remarks:
4492:                  A function to flush data to the device without closing the
4493:                  file can be created by removing the portion of this
4494:                  function that frees the memory and the line that clears
4495:                  the write flag.
4496:                ************************************************************/
4497:              
4498:              int FSfclose(FSFILE   *fo)
4499:              {
4500:                  WORD        fHandle;
4501:              #ifndef FS_DYNAMIC_MEM
4502:                  WORD        fIndex;
4503:              #endif
4504:                  int        error = 72;
4505:              #ifdef ALLOW_WRITES
4506:                  DIRENTRY    dir;
4507:              #endif
4508:              
4509:                  FSerrno = CE_GOOD;
007D4C  249388     MOV #0x4938, W8
007D4E  EB4C00     CLR.B [W8]
4510:                  fHandle = fo->entry;
007D50  901070     MOV [W0+46], W0
007D52  9FBFD0     MOV W0, [W15-6]
4511:              
4512:              #ifdef ALLOW_WRITES
4513:                  if(fo->flags.write)
007D54  900839     MOV [W9+22], W0
007D56  200483     MOV #0x48, W3
007D58  A30800     BTST.Z W0, #0
007D5A  320040     BRA Z, 0x7DDC
4514:                  {
4515:                      if (gNeedDataWrite)
007D5C  270BB0     MOV #0x70BB, W0
007D5E  E00410     CP0.B [W0]
007D60  320006     BRA Z, 0x7D6E
4516:                      {
4517:                          if (flushData())
007D62  07F8E0     RCALL flushData
007D64  E00400     CP0.B W0
007D66  320003     BRA Z, 0x7D6E
4518:                          {
4519:                              FSerrno = CE_WRITE_ERROR;
007D68  B3C090     MOV #0x9, W0
007D6A  784C00     MOV.B W0, [W8]
007D6C  370015     BRA 0x7D98
4520:                              return EOF;
4521:                          }
4522:                      }
4523:              
4524:                      // Write the current FAT sector to the disk
4525:                      WriteFAT (fo->dsk, 0, 0, TRUE);
007D6E  B3C011     MOV #0x1, W1
007D70  B82260     MUL.UU W4, #0, W4
007D72  BE0104     MOV.D W4, W2
007D74  780019     MOV [W9], W0
007D76  07F9DD     RCALL WriteFAT
4526:              
4527:                      // Invalidate the currently cached FAT entry so that the next read will
4528:                      //   result in an acutal read from the physical media instead of a read
4529:                      //   from the RAM cache.
4530:                      gLastFATSectorRead = 0;
007D78  B80060     MUL.UU W0, #0, W0
007D7A  8B8620     MOV W0, gLastFATSectorRead
007D7C  8B8631     MOV W1, 0x70C6
4531:              
4532:                      // Read the FAT entry from the physical media.  This is required because
4533:                      //   some physical media cache the entries in RAM and only write them 
4534:                      //   after a time expires for until the sector is accessed again.
4535:                      ReadFAT (fo->dsk, fo->ccls);
007D7E  900139     MOV [W9+6], W2
007D80  9001C9     MOV [W9+8], W3
007D82  780019     MOV [W9], W0
007D84  07FB02     RCALL ReadFAT
4536:              
4537:                      // Get the file entry
4538:                      dir = LoadDirAttrib(fo, &fHandle);
007D86  5780E6     SUB W15, #0x6, W1
007D88  780009     MOV W9, W0
007D8A  07FDAF     RCALL LoadDirAttrib
007D8C  780400     MOV W0, W8
4539:              
4540:                      if (dir == NULL)
007D8E  E00000     CP0 W0
007D90  3A0005     BRA NZ, 0x7D9C
4541:                      {
4542:                          FSerrno = CE_BADCACHEREAD;
007D92  B3C1B1     MOV #0x1B, W1
007D94  249380     MOV #0x4938, W0
007D96  784801     MOV.B W1, [W0]
007D98  EB8180     SETM W3
007D9A  37002F     BRA 0x7DFA
4543:                          error = EOF;
4544:                          return error;
4545:                      }
4546:              
4547:                    // update the time
4548:              #ifdef INCREMENTTIMESTAMP
4549:                      IncrementTimeStamp(dir);
4550:              #elif defined USERDEFINEDCLOCK
4551:                      dir->DIR_WrtTime = gTimeWrtTime;
4552:                      dir->DIR_WrtDate = gTimeWrtDate;
4553:              #elif defined USEREALTIMECLOCK
4554:                      CacheTime();
007D9C  07FDC7     RCALL CacheTime
4555:                      dir->DIR_WrtTime = gTimeWrtTime;
007D9E  824A01     MOV gTimeWrtTime, W1
007DA0  980C31     MOV W1, [W8+22]
4556:                      dir->DIR_WrtDate = gTimeWrtDate;
007DA2  8249F0     MOV gTimeWrtDate, W0
007DA4  980C40     MOV W0, [W8+24]
4557:              #endif
4558:              
4559:                      dir->DIR_FileSize = fo->size;
007DA6  900819     MOV [W9+18], W0
007DA8  9008A9     MOV [W9+20], W1
007DAA  980C60     MOV W0, [W8+28]
007DAC  980C71     MOV W1, [W8+30]
4560:              
4561:                      dir->DIR_Attr = fo->attributes;
007DAE  9070A9     MOV.B [W9+50], W1
007DB0  984C31     MOV.B W1, [W8+11]
4562:              
4563:                      // just write the last entry in
4564:                      if(Write_File_Entry(fo,&fHandle))
007DB2  5780E6     SUB W15, #0x6, W1
007DB4  780009     MOV W9, W0
007DB6  07F97B     RCALL Write_File_Entry
007DB8  E00400     CP0.B W0
007DBA  320009     BRA Z, 0x7DCE
4565:                      {
4566:                          // Read the folder entry from the physical media.  This is required because
4567:                          //   some physical media cache the entries in RAM and only write them 
4568:                          //   after a time expires for until the sector is accessed again.
4569:                          dir = LoadDirAttrib(fo, &fHandle);
007DBC  5780E6     SUB W15, #0x6, W1
007DBE  780009     MOV W9, W0
007DC0  07FD94     RCALL LoadDirAttrib
007DC2  EB0180     CLR W3
007DC4  370008     BRA 0x7DD6
4570:                          error = 0;
4571:                      }
4572:                      else
4573:                      {
4574:                          FSerrno = CE_WRITE_ERROR;
007DCE  B3C091     MOV #0x9, W1
007DD0  249380     MOV #0x4938, W0
007DD2  784801     MOV.B W1, [W0]
007DD4  EB8180     SETM W3
4575:                          error = EOF;
4576:                      }
4577:              
4578:                      // Clear the write acess to file
4579:                      fo->flags.write = FALSE;
007DD6  900839     MOV [W9+22], W0
007DD8  A10000     BCLR W0, #0
007DDA  980CB0     MOV W0, [W9+22]
4580:                  }
4581:              #endif
4582:              
4583:                  // Clear the read acess to file
4584:                  fo->flags.read = FALSE;
007DDC  900839     MOV [W9+22], W0
007DDE  A11000     BCLR W0, #1
007DE0  980CB0     MOV W0, [W9+22]
007DE2  EB0100     CLR W2
007DE4  253600     MOV #0x5360, W0
4585:              
4586:              #ifdef FS_DYNAMIC_MEM
4587:                  #ifdef	SUPPORT_LFN
4588:              		FS_free((unsigned char *)fo->utf16LFNptr);
4589:              	#endif
4590:              	FS_free((unsigned char *)fo);
4591:              #else
4592:              
4593:                  for( fIndex = 0; fIndex < FS_MAX_FILES_OPEN; fIndex++ )
007DEA  E80102     INC W2, W2
007DEC  B003C0     ADD #0x3C, W0
007DEE  510FE2     SUB W2, #0x2, [W15]
007DF0  3AFFFA     BRA NZ, 0x7DE6
4594:                  {
4595:                      if( fo == &gFileArray[fIndex] )
007DE6  548F80     SUB W9, W0, [W15]
007DE8  32FFEE     BRA Z, 0x7DC6
4596:                      {
4597:                          gFileSlotOpen[fIndex] = TRUE;
007DC6  B3C011     MOV #0x1, W1
007DC8  2535E0     MOV #0x535E, W0
007DCA  797001     MOV.B W1, [W0+W2]
007DCC  370012     BRA 0x7DF2
4598:                          break;
4599:                      }
4600:                  }
4601:              
4602:              	// Set Null pointer to close the file, to prevent inadvertent acess
4603:                  fo = NULL;
4604:              #endif
4605:              
4606:                  // File opened in read mode
4607:                  if (error == 72)
007DF2  200480     MOV #0x48, W0
007DF4  518F80     SUB W3, W0, [W15]
007DF6  3A0001     BRA NZ, 0x7DFA
007DF8  EB0180     CLR W3
4608:                      error = 0;
4609:              
4610:                  return(error);
4611:              } // FSfclose
007E02  4787E4     ADD W15, #0x4, W15
007E04  BE9F88     MOV.D W8, [W15++]
007E06  BE9F8A     MOV.D W10, [W15++]
007E08  BE9F8C     MOV.D W12, [W15++]
007E0A  781F8E     MOV W14, [W15++]
007E0C  780700     MOV W0, W14
4612:              
4613:              
4614:              /*******************************************************
4615:                Function:
4616:                  void IncrementTimeStamp(DIRENTRY dir)
4617:                Summary:
4618:                  Automatically set the timestamp to "don't care" data
4619:                Conditions:
4620:                  Should not be called by the user.
4621:                Input:
4622:                  dir -  Pointer to directory structure
4623:                Return Values:
4624:                  None
4625:                Side Effects:
4626:                  None
4627:                Description:
4628:                  This function will increment the timestamp variable in
4629:                  the 'dir' directory entry.  This is used for the
4630:                  don't-care timing method.
4631:                Remarks:
4632:                  None
4633:                *******************************************************/
4634:              #ifdef INCREMENTTIMESTAMP
4635:              void IncrementTimeStamp(DIRENTRY dir)
4636:              {
4637:                  BYTE          seconds;
4638:                  BYTE          minutes;
4639:                  BYTE          hours;
4640:              
4641:                  BYTE          day;
4642:                  BYTE          month;
4643:                  BYTE          year;
4644:              
4645:                  seconds = (dir->DIR_WrtTime & 0x1f);
4646:                  minutes = ((dir->DIR_WrtTime & 0x07E0) >> 5);
4647:                  hours   = ((dir->DIR_WrtTime & 0xF800) >> 11);
4648:              
4649:                  day     = (dir->DIR_WrtDate & 0x1f);
4650:                  month   = ((dir->DIR_WrtDate & 0x01E0) >> 5);
4651:                  year    = ((dir->DIR_WrtDate & 0xFE00) >> 9);
4652:              
4653:                  if(seconds < 29)
4654:                  {
4655:                      // Increment number of seconds by 2
4656:                      // This clock method isn't intended to be accurate anyway
4657:                      seconds++;
4658:                  }
4659:                  else
4660:                  {
4661:                      seconds = 0x00;
4662:              
4663:                      if(minutes < 59)
4664:                      {
4665:                          minutes++;
4666:                      }
4667:                      else
4668:                      {
4669:                          minutes = 0;
4670:              
4671:                          if(hours < 23)
4672:                          {
4673:                              hours++;
4674:                          }
4675:                          else
4676:                          {
4677:                              hours = 0;
4678:                              if(day < 30)
4679:                              {
4680:                                  day++;
4681:                              }
4682:                              else
4683:                              {
4684:                                  day = 1;
4685:              
4686:                                  if(month < 12)
4687:                                  {
4688:                                      month++;
4689:                                  }
4690:                                  else
4691:                                  {
4692:                                      month = 1;
4693:                                      // new year
4694:                                      year++;
4695:                                      // This is only valid until 2107
4696:                                  }
4697:                              }
4698:                          }
4699:                      }
4700:                  }
4701:              
4702:                  dir->DIR_WrtTime = (WORD)(seconds);
4703:                  dir->DIR_WrtTime |= ((WORD)(minutes) << 5);
4704:                  dir->DIR_WrtTime |= ((WORD)(hours) << 11);
4705:              
4706:                  dir->DIR_WrtDate = (WORD)(day);
4707:                  dir->DIR_WrtDate |= ((WORD)(month) << 5);
4708:                  dir->DIR_WrtDate |= ((WORD)(year) << 9);
4709:              }
4710:              #endif
4711:              
4712:              /*****************************************************************
4713:                Function:
4714:                  BYTE Fill_File_Object(FILEOBJ fo, WORD *fHandle)
4715:                Summary:
4716:                  Fill a file object with specified dir entry data
4717:                Conditions:
4718:                  This function should not be called by the user.
4719:                Input:
4720:                  fo -       Pointer to file structure
4721:                  fHandle -  Passed member's location
4722:                Return Values:
4723:                  FOUND -     Operation successful
4724:                  NOT_FOUND - Operation failed
4725:                Side Effects:
4726:                  None
4727:                Description:
4728:                  This function will cache the sector of directory entries
4729:                  in the directory pointed to by the dirclus value in
4730:                  the FSFILE object 'fo' that contains the entry that
4731:                  corresponds to the fHandle offset.  It will then copy
4732:                  the file information for that entry into the 'fo' FSFILE
4733:                  object.
4734:                Remarks:
4735:                  None.
4736:                *****************************************************************/
4737:              
4738:              BYTE Fill_File_Object(FILEOBJ fo, WORD *fHandle)
4739:              {
4740:                  DIRENTRY    dir;
4741:                  BYTE        index, a;
4742:                  BYTE        character;
4743:                  BYTE        status;
4744:                  BYTE        test = 0;
4745:              
4746:                  // Get the entry
4747:                  if (((*fHandle & MASK_MAX_FILE_ENTRY_LIMIT_BITS) == 0) && (*fHandle != 0)) // 4-bit mask because 16-root entries max per sector
0097AE  780091     MOV [W1], W1
0097B0  60806F     AND W1, #0xF, W0
0097B2  3A0008     BRA NZ, 0x97C4
0097B4  E00001     CP0 W1
0097B6  320006     BRA Z, 0x97C4
4748:                  {
4749:                      fo->dirccls = fo->dirclus;
0097B8  90182A     MOV [W10+52], W0
0097BA  9018BA     MOV [W10+54], W1
0097BC  981D40     MOV W0, [W10+56]
0097BE  981D51     MOV W1, [W10+58]
4750:                      dir = Cache_File_Entry(fo, fHandle, TRUE);
0097C0  B3C012     MOV #0x1, W2
0097C2  370001     BRA 0x97C6
4751:                  }
4752:                  else
4753:                  {
4754:                      dir = Cache_File_Entry (fo, fHandle, FALSE);
0097C4  EB4100     CLR.B W2
0097C6  78008D     MOV W13, W1
0097C8  78000A     MOV W10, W0
0097CA  07EEEF     RCALL Cache_File_Entry
0097CC  780480     MOV W0, W9
4755:                  }
4756:              
4757:              
4758:                  // Make sure there is a directory left
4759:                  if(dir == (DIRENTRY)NULL)
0097CE  E00000     CP0 W0
0097D0  32003E     BRA Z, 0x984E
4760:                  {
4761:                      status = NO_MORE;
4762:                  }
4763:                  else
4764:                  {
4765:                      // Read the first char of the file name
4766:                      a = dir->DIR_Name[0];
0097D2  784010     MOV.B [W0], W0
4767:              
4768:                      // Check for empty or deleted directory
4769:                      if ( a == DIR_DEL)
0097D4  B3C014     MOV #0x1, W4
0097D6  404FFB     ADD.B W0, #0x1B, [W15]
0097D8  32003B     BRA Z, 0x9850
4770:              		{
4771:                          status = NOT_FOUND;
4772:              		}
4773:              		else if ( a == DIR_EMPTY)
0097DA  E00400     CP0.B W0
0097DC  320038     BRA Z, 0x984E
0097DE  780609     MOV W9, W12
0097E0  4505FC     ADD W10, #0x1C, W11
0097E2  EB4400     CLR.B W8
4774:              		{
4775:              			status = NO_MORE;
4776:              		}
4777:                      else
4778:                      {
4779:                          // Get the attributes
4780:                          a = dir->DIR_Attr;
4781:              
4782:                          // print the file name and extension
4783:                          for (index=0; index < DIR_NAMESIZE; index++)
0097EC  544FE8     SUB.B W8, #0x8, [W15]
0097EE  3AFFFA     BRA NZ, 0x97E4
0097F0  448668     ADD W9, #0x8, W12
0097F2  EB0580     CLR W11
4784:                          {
4785:                              character = dir->DIR_Name[index];
4786:                              character = (BYTE)toupper(character);
0097E4  FB803C     ZE [W12++], W0
0097E6  07DDF3     RCALL toupper
0097E8  785D80     MOV.B W0, [W11++]
4787:                              fo->name[test++] = character;
0097EA  E84408     INC.B W8, W8
4788:                          }
4789:              
4790:                          // Get the attributes
4791:                          a = dir->DIR_Attr;
4792:              
4793:                          // its possible to have an extension in a directory
4794:                          character = dir->DIR_Extension[0];
4795:              
4796:                          // Get the file extension if its there
4797:                          for (index=0; index < DIR_EXTENSION; index++)
009804  558FE3     SUB W11, #0x3, [W15]
009806  3AFFF6     BRA NZ, 0x97F4
4798:                          {
4799:                              character = dir->DIR_Extension[index];
4800:                              character = (BYTE)toupper(character);
0097FC  FB803C     ZE [W12++], W0
0097FE  07DDE7     RCALL toupper
009800  784C00     MOV.B W0, [W8]
009802  E8058B     INC W11, W11
4801:                              fo->name[test++] = character;
0097F4  45C468     ADD.B W11, #0x8, W8
0097F6  FB8408     ZE W8, W8
0097F8  44047C     ADD W8, #0x1C, W8
0097FA  450408     ADD W10, W8, W8
4802:                          }
4803:              
4804:                          // done and done with the name
4805:                          //         fo->name[++test] = (BYTE)'\0';
4806:              
4807:                          // Now store the identifier
4808:                          fo->entry = *fHandle;
009808  78069D     MOV [W13], W13
00980A  98157D     MOV W13, [W10+46]
00980C  B3CE50     MOV #0xE5, W0
00980E  684019     XOR.B W0, [W9], W0
009810  FB8000     ZE W0, W0
009812  E90000     DEC W0, W0
009814  DE024F     LSR W0, #15, W4
4809:              
4810:                          // see if we are still a good file
4811:                          a = dir->DIR_Name[0];
4812:              
4813:                          if(a == DIR_DEL)
4814:                              status = NOT_FOUND;
4815:                          else
4816:                              status = FOUND;
4817:              
4818:                          // Now store the size
4819:                          fo->size = (dir->DIR_FileSize);
009816  900869     MOV [W9+28], W0
009818  9008F9     MOV [W9+30], W1
00981A  980D10     MOV W0, [W10+18]
00981C  980D21     MOV W1, [W10+20]
4820:              
4821:                          fo->cluster = GetFullClusterNumber(dir); // Get Complete Cluster number.
009826  900959     MOV [W9+26], W2
009828  200003     MOV #0x0, W3
00982A  700002     IOR W0, W2, W0
00982C  708083     IOR W1, W3, W1
00982E  980510     MOV W0, [W10+2]
009830  980521     MOV W1, [W10+4]
4822:              
4823:                          /// -Get and store the attributes
4824:                          a = dir->DIR_Attr;
009832  904839     MOV.B [W9+11], W0
4825:                          fo->attributes = a;
009834  FB8000     ZE W0, W0
009836  981D10     MOV W0, [W10+50]
4826:              
4827:                          // get the date and time
4828:                          if ((a & ATTR_DIRECTORY) != 0)
009838  A34800     BTST.Z W0, #4
00983A  320004     BRA Z, 0x9844
4829:                          {
4830:                              fo->time = dir->DIR_CrtTime;
00983C  9000F9     MOV [W9+14], W1
00983E  980D41     MOV W1, [W10+24]
4831:                              fo->date = dir->DIR_CrtDate;
009840  900C89     MOV [W9+16], W9
009842  370003     BRA 0x984A
4832:                          }
4833:                          else
4834:                          {
4835:                              fo->time = dir->DIR_WrtTime;
009844  900839     MOV [W9+22], W0
009846  980D40     MOV W0, [W10+24]
4836:                              fo->date = dir->DIR_WrtDate;
009848  900CC9     MOV [W9+24], W9
00984A  980D59     MOV W9, [W10+26]
00984C  370001     BRA 0x9850
00984E  B3C024     MOV #0x2, W4
009850  FB8004     ZE W4, W0
4837:                          }
4838:              
4839:                      }// deleted directory
4840:                  }// Ensure we are still good
4841:                  return(status);
4842:              } // Fill_File_Object
00985A  BE9F88     MOV.D W8, [W15++]
00985C  BE9F8A     MOV.D W10, [W15++]
00985E  BE9F8C     MOV.D W12, [W15++]
009860  780400     MOV W0, W8
009862  780501     MOV W1, W10
009864  784682     MOV.B W2, W13
4843:              
4844:              /*****************************************************************
4845:                Function:
4846:                  BYTE Fill_LFN_Object(FILEOBJ fo, LFN_ENTRY *lfno, WORD *fHandle)
4847:                Summary:
4848:                  Fill a LFN object with specified entry data
4849:                Conditions:
4850:                  This function should not be called by the user.
4851:                Input:
4852:                  fo -   Pointer to file structure
4853:                  lfno - Pointer to Long File Name Object
4854:                  fHandle -  Passed member's location
4855:                Return Values:
4856:                  FOUND -     Operation successful
4857:                  NOT_FOUND - Operation failed
4858:                Side Effects:
4859:                  None
4860:                Description:
4861:                  This function will cache the sector of LFN entries
4862:                  in the directory pointed to by the dirclus value in
4863:                  the FSFILE object 'fo' that contains the entry that
4864:                  corresponds to the fHandle offset.  It will then copy
4865:                  the file information for that entry into the 'fo' FSFILE
4866:                  object.
4867:                Remarks:
4868:                  None.
4869:                *****************************************************************/
4870:              #if defined(SUPPORT_LFN)
4871:              BYTE Fill_LFN_Object(FILEOBJ fo, LFN_ENTRY *lfno, WORD *fHandle)
4872:              {
4873:                  DIRENTRY    dir;
4874:                  BYTE        tempVariable;
4875:                  BYTE        *src,*dst;
4876:                  BYTE        status;
4877:              
4878:                  // Get the entry
4879:                  if (((*fHandle & MASK_MAX_FILE_ENTRY_LIMIT_BITS) == 0) && (*fHandle != 0)) // 4-bit mask because 16-root entries max per sector
00775C  780112     MOV [W2], W2
00775E  61006F     AND W2, #0xF, W0
007760  3A0008     BRA NZ, 0x7772
007762  E00002     CP0 W2
007764  320006     BRA Z, 0x7772
4880:                  {
4881:                      fo->dirccls = fo->dirclus;
007766  901A23     MOV [W3+52], W4
007768  901AB3     MOV [W3+54], W5
00776A  9819C4     MOV W4, [W3+56]
00776C  9819D5     MOV W5, [W3+58]
4882:                      dir = Cache_File_Entry(fo, fHandle, TRUE);
00776E  B3C012     MOV #0x1, W2
007770  370001     BRA 0x7774
4883:                  }
4884:                  else
4885:                  {
4886:                      dir = Cache_File_Entry (fo, fHandle, FALSE);
007772  EB4100     CLR.B W2
007774  780003     MOV W3, W0
007776  07FF19     RCALL Cache_File_Entry
4887:                  }
4888:              
4889:              
4890:                  // Make sure there is a directory left
4891:                  if(dir == (DIRENTRY)NULL)
007778  E00000     CP0 W0
00777A  32000E     BRA Z, 0x7798
4892:                  {
4893:                      status = NO_MORE;
4894:                  }
4895:                  else
4896:                  {
4897:                      // Read the first char of the file name
4898:                      tempVariable = dir->DIR_Name[0];
00777C  784090     MOV.B [W0], W1
4899:              
4900:                      // Check for empty or deleted directory
4901:                      if ( tempVariable == DIR_DEL)
00777E  B3C012     MOV #0x1, W2
007780  40CFFB     ADD.B W1, #0x1B, [W15]
007782  32000B     BRA Z, 0x779A
4902:              		{
4903:                          status = NOT_FOUND;
4904:              		}
4905:              		else if ( tempVariable == DIR_EMPTY)
007784  E00401     CP0.B W1
007786  320008     BRA Z, 0x7798
4906:              		{
4907:              			status = NO_MORE;
4908:              		}
4909:                      else
4910:                      {
4911:                          status = FOUND;
4912:              
4913:              			dst = (BYTE *)lfno;
007788  780088     MOV W8, W1
4914:              			src = (BYTE *)dir;
00778A  780100     MOV W0, W2
00778C  B3C200     MOV #0x20, W0
4915:              
4916:              			// Copy the entry in the lfno object
4917:              			for(tempVariable = 0;tempVariable < 32;tempVariable++)
007792  3AFFFD     BRA NZ, 0x778E
007794  784100     MOV.B W0, W2
007796  370001     BRA 0x779A
007798  B3C022     MOV #0x2, W2
00779A  FB8002     ZE W2, W0
4918:              			{
4919:              				*dst++ = *src++;
00778E  7858B2     MOV.B [W2++], [W1++]
007790  E94000     DEC.B W0, W0
4920:              			}
4921:                      }// deleted directory
4922:                  }// Ensure we are still good
4923:                  return(status);
4924:              } // Fill_File_Object
0077A0  4787EA     ADD W15, #0xA, W15
0077A2  BE9F88     MOV.D W8, [W15++]
0077A4  BE9F8A     MOV.D W10, [W15++]
0077A6  BE9F8C     MOV.D W12, [W15++]
0077A8  781F8E     MOV W14, [W15++]
0077AA  780700     MOV W0, W14
0077AC  9FB7F2     MOV W2, [W15-18]
0077AE  9FBF83     MOV W3, [W15-16]
4925:              #endif
4926:              /************************************************************************
4927:                Function:
4928:                  DIRENTRY LoadDirAttrib(FILEOBJ fo, WORD *fHandle)
4929:                Summary:
4930:                  Load file information from a directory entry and cache the entry
4931:                Conditions:
4932:                  This function should not be called by the user.
4933:                Input:
4934:                  fo -       Pointer to file structure
4935:                  fHandle -  Information location
4936:                Return Values:
4937:                  DIRENTRY - Pointer to the directory entry
4938:                  NULL -     Directory entry could not be loaded
4939:                Side Effects:
4940:                  None
4941:                Description:
4942:                  This function will cache the sector of directory entries
4943:                  in the directory pointed to by the dirclus value in
4944:                  the FSFILE object 'fo' that contains the entry that
4945:                  corresponds to the fHandle offset.  It will then return a pointer
4946:                  to the directory entry in the global data buffer.
4947:                Remarks:
4948:                  None.
4949:                ************************************************************************/
4950:              
4951:              DIRENTRY LoadDirAttrib(FILEOBJ fo, WORD *fHandle)
4952:              {
4953:                  DIRENTRY    dir;
4954:                  BYTE      a;
4955:              
4956:                  fo->dirccls = fo->dirclus;
0078F0  9018B0     MOV [W0+54], W1
0078F2  901820     MOV [W0+52], W0
0078F4  981CC0     MOV W0, [W9+56]
0078F6  981CD1     MOV W1, [W9+58]
4957:                  // Get the entry
4958:                  dir = Cache_File_Entry( fo, fHandle, TRUE);
0078F8  B3C012     MOV #0x1, W2
0078FA  780088     MOV W8, W1
0078FC  780009     MOV W9, W0
0078FE  07FE55     RCALL Cache_File_Entry
4959:                  if (dir == NULL)
007900  E00000     CP0 W0
007902  320011     BRA Z, 0x7926
4960:                      return NULL;
4961:              
4962:                  // Read the first char of the file name
4963:                  a = dir->DIR_Name[0];
007904  784090     MOV.B [W0], W1
4964:              
4965:                  // Make sure there is a directory left
4966:                  if(a == DIR_EMPTY)
007906  E00401     CP0.B W1
007908  32000E     BRA Z, 0x7926
4967:                      dir = (DIRENTRY)NULL;
4968:              
4969:                  if(dir != (DIRENTRY)NULL)
4970:                  {
4971:                      // Check for empty or deleted directory
4972:                      if ( a == DIR_DEL)
00790A  40CFFB     ADD.B W1, #0x1B, [W15]
00790C  32000C     BRA Z, 0x7926
00790E  370007     BRA 0x791E
4973:                          dir = (DIRENTRY)NULL;
4974:                      else
4975:                      {
4976:                          // Get the attributes
4977:                          a = dir->DIR_Attr;
4978:              
4979:                          // scan through all the long dir entries
4980:                          while(a == ATTR_LONG_NAME)
007920  50CFEF     SUB.B W1, #0xF, [W15]
007922  32FFF6     BRA Z, 0x7910
007924  370001     BRA 0x7928
007926  EB0000     CLR W0
4981:                          {
4982:                              (*fHandle)++;
007910  E80C18     INC [W8], [W8]
4983:                              dir = Cache_File_Entry( fo, fHandle, FALSE);
007912  EB4100     CLR.B W2
007914  780088     MOV W8, W1
007916  780009     MOV W9, W0
007918  07FE48     RCALL Cache_File_Entry
4984:                              if (dir == NULL)
00791A  E00000     CP0 W0
00791C  320004     BRA Z, 0x7926
4985:                                  return NULL;
4986:                              a = dir->DIR_Attr;
00791E  9048B0     MOV.B [W0+11], W1
4987:                          } // long file name while loop
4988:                      } // deleted dir
4989:                  }// Ensure we are still good
4990:              
4991:                  return(dir);
4992:              } // LoadDirAttrib
00792C  781F88     MOV W8, [W15++]
4993:              
4994:              
4995:              /**************************************************************************
4996:                Function:
4997:                  CETYPE FILEerase( FILEOBJ fo, WORD *fHandle, BYTE EraseClusters)
4998:                Summary:
4999:                  Erase a file
5000:                Conditions:
5001:                  This function should not be called by the user.
5002:                Input:
5003:                  fo -            Pointer to file structure
5004:                  fHandle -       Location of file information
5005:                  EraseClusters - If set to TRUE, delete the corresponding cluster of file
5006:                Return Values:
5007:                  CE_GOOD - File erased successfully
5008:                  CE_FILE_NOT_FOUND - Could not find the file on the card
5009:                  CE_ERASE_FAIL - Internal Card erase failed
5010:                Side Effects:
5011:                  None
5012:                Description:
5013:                  This function will cache the sector of directory entries in the directory
5014:                  pointed to by the dirclus value in the FSFILE object 'fo' that contains
5015:                  the entry that corresponds to the fHandle offset.  It will then mark that
5016:                  entry as deleted.  If the EraseClusters argument is TRUE, the chain of
5017:                  clusters for that file will be marked as unused in the FAT by the
5018:                  FAT_erase_cluster_chain function.
5019:                Remarks:
5020:                  None.
5021:                **************************************************************************/
5022:              
5023:              #ifdef ALLOW_WRITES
5024:              CETYPE FILEerase( FILEOBJ fo, WORD *fHandle, BYTE EraseClusters)
5025:              {
5026:                  DIRENTRY    dir;
5027:                  BYTE        a;
5028:                  CETYPE      status = CE_GOOD;
5029:                  DWORD       clus = 0;
5030:                  DISK *      disk;
5031:              
5032:                  BYTE	numberOfFileEntries;
5033:              	BOOL	forFirstTime = TRUE;
5034:              	#if defined(SUPPORT_LFN)
5035:              		BYTE	tempCalc1;
5036:              	#endif
5037:              
5038:                  disk = fo->dsk;
00A808  780010     MOV [W0], W0
00A80A  9FB7F0     MOV W0, [W15-18]
5039:              
5040:              	#if defined(SUPPORT_LFN)
5041:              
5042:              	fileNameLength = fo->utf16LFNlength;
00A80C  9010E9     MOV [W9+44], W1
00A80E  8A42B1     MOV W1, fileNameLength
5043:              
5044:              	// Find the number of entries of LFN in the root directory
5045:              	if(fileNameLength)
00A810  B3C01E     MOV #0x1, W14
00A812  E00001     CP0 W1
00A814  32000E     BRA Z, 0xA832
5046:              	{
5047:              		tempCalc1 = fileNameLength % 13;
5048:              
5049:              		numberOfFileEntries = fileNameLength/13;
00A816  2000D2     MOV #0xD, W2
00A818  781F81     MOV W1, [W15++]
00A81A  090011     REPEAT #0x11
00A81C  D88082     DIV.UW W1, W2
00A81E  780100     MOV W0, W2
00A820  780001     MOV W1, W0
00A822  7800CF     MOV [--W15], W1
5050:              
5051:              		if(tempCalc1 || (fileNameLength < 13))
00A824  E00400     CP0.B W0
00A826  3A0002     BRA NZ, 0xA82C
00A828  508FEC     SUB W1, #0xC, [W15]
00A82A  3E0002     BRA GTU, 0xA830
5052:              		{
5053:              			numberOfFileEntries = numberOfFileEntries + 2;
00A82C  E8C702     INC2.B W2, W14
00A82E  370001     BRA 0xA832
5054:              		}
5055:              		else
5056:              		{
5057:              			numberOfFileEntries++;
00A830  E84702     INC.B W2, W14
5058:              		}
5059:              	}
5060:              	else
5061:              	#endif
5062:              	{
5063:              		numberOfFileEntries = 1;
5064:              	}
5065:              
5066:              	FSerrno = CE_ERASE_FAIL;
00A832  B3C011     MOV #0x1, W1
00A834  249380     MOV #0x4938, W0
00A836  784801     MOV.B W1, [W0]
00A838  78450E     MOV.B W14, W10
00A83A  B86660     MUL.UU W12, #0, W12
00A83C  200011     MOV #0x1, W1
00A83E  9FB7E1     MOV W1, [W15-20]
00A840  370025     BRA 0xA88C
5067:              
5068:              	// delete all the entries of LFN in root directory
5069:              	while(numberOfFileEntries--)
00A88C  E9450A     DEC.B W10, W10
00A88E  454FE1     ADD.B W10, #0x1, [W15]
00A890  3AFFD8     BRA NZ, 0xA842
00A892  370011     BRA 0xA8B6
5070:              	{
5071:              	    // reset the cluster
5072:              	    fo->dirccls = fo->dirclus;
00A842  901829     MOV [W9+52], W0
00A844  9018B9     MOV [W9+54], W1
00A846  981CC0     MOV W0, [W9+56]
00A848  981CD1     MOV W1, [W9+58]
5073:              
5074:              	    // load the sector
5075:              	    dir = Cache_File_Entry(fo, fHandle, TRUE);
00A84A  B3C012     MOV #0x1, W2
00A84C  78008B     MOV W11, W1
00A84E  780009     MOV W9, W0
00A850  07E6AC     RCALL Cache_File_Entry
00A852  780400     MOV W0, W8
5076:              
5077:              	    if (dir == NULL)
00A854  E00000     CP0 W0
00A856  320037     BRA Z, 0xA8C6
00A8C6  2001B1     MOV #0x1B, W1
5078:              	    {
5079:              	        return CE_BADCACHEREAD;
5080:              	    }
5081:              
5082:              	    // Fill up the File Object with the information pointed to by fHandle
5083:              	    a = dir->DIR_Name[0];
00A858  784010     MOV.B [W0], W0
5084:              
5085:              	    // see if there is something in the dir
5086:              	    if((dir == (DIRENTRY)NULL) || (a == DIR_EMPTY) || (a == DIR_DEL))
00A85A  E00400     CP0.B W0
00A85C  32002A     BRA Z, 0xA8B2
00A85E  404FFB     ADD.B W0, #0x1B, [W15]
00A860  320028     BRA Z, 0xA8B2
5087:              	    {
5088:              	        status = CE_FILE_NOT_FOUND;
5089:              			break;
5090:              	    }
5091:              		else
5092:              		{
5093:                          /* 8.3 File Name - entry*/
5094:                          dir->DIR_Name[0] = DIR_DEL; // mark as deleted
00A862  B3CE50     MOV #0xE5, W0
00A864  784C00     MOV.B W0, [W8]
5095:              
5096:              			if(!(Write_File_Entry( fo, fHandle)))
00A866  78008B     MOV W11, W1
00A868  780009     MOV W9, W0
00A86A  07E421     RCALL Write_File_Entry
00A86C  E00400     CP0.B W0
00A86E  320029     BRA Z, 0xA8C2
00A8C2  200011     MOV #0x1, W1
00A8C4  370001     BRA 0xA8C8
5097:                   		{
5098:                   		    status = CE_ERASE_FAIL;
5099:              				break;
5100:                   		}
5101:              		}
5102:              
5103:              		if(forFirstTime)
00A870  97B0EF     MOV [W15-20], W1
00A872  E00001     CP0 W1
00A874  32000A     BRA Z, 0xA88A
5104:              		{
5105:              			// Get the starting cluster
5106:              			clus = GetFullClusterNumber(dir); // Get Complete Cluster number.
5107:              			forFirstTime = FALSE;
5108:              		}
5109:              
5110:              		*fHandle = *fHandle - 1;
00A88A  E90D9B     DEC [W11], [W11]
5111:              	}
5112:              
5113:              	if(status == CE_GOOD)
5114:              	{
5115:              		if (clus != FatRootDirClusterValue) //
00A8B6  8249D0     MOV FatRootDirClusterValue, W0
00A8B8  8249E1     MOV 0x493C, W1
00A8BA  560F80     SUB W12, W0, [W15]
00A8BC  5E8F81     SUBB W13, W1, [W15]
00A8BE  3AFFEA     BRA NZ, 0xA894
00A8C0  37FFF4     BRA 0xA8AA
5116:              		{
5117:              			// If 'EraseClusters' is set to TRUE, erase the cluster chain corresponding to file
5118:              		    if(EraseClusters)
00A894  97F08F     MOV.B [W15-16], W1
00A896  E00401     CP0.B W1
00A898  320008     BRA Z, 0xA8AA
5119:              		    {
5120:              		        /* Now remove the cluster allocation from the FAT */
5121:              		        status = ((FAT_erase_cluster_chain(clus, disk)) ? CE_GOOD : CE_ERASE_FAIL);
00A89A  97B17F     MOV [W15-18], W2
00A89C  BE000C     MOV.D W12, W0
00A89E  07E7CE     RCALL FAT_erase_cluster_chain
00A8A0  EB0080     CLR W1
00A8A2  E00400     CP0.B W0
00A8A4  3A0003     BRA NZ, 0xA8AC
00A8A6  200011     MOV #0x1, W1
00A8A8  370001     BRA 0xA8AC
00A8AA  EB0080     CLR W1
5122:              		    }
5123:              		}
5124:              
5125:              		FSerrno = status;
00A8AC  249380     MOV #0x4938, W0
00A8AE  784801     MOV.B W1, [W0]
00A8B0  37000B     BRA 0xA8C8
00A8B2  2000B1     MOV #0xB, W1
00A8B4  370009     BRA 0xA8C8
5126:              	}
5127:              
5128:                  return (status);
5129:              }
00A8D6  FA003C     LNK #0x3C
00A8D8  BE9F88     MOV.D W8, [W15++]
00A8DA  780480     MOV W0, W9
5130:              #endif
5131:              
5132:              /***************************************************************
5133:                Function:
5134:                  int FSrename (const rom char * fileName, FSFILE * fo)
5135:                Summary:
5136:                  Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices
5137:                Conditions:
5138:                  File opened.
5139:                Input:
5140:                  fileName -  The new name of the file
5141:                  fo -        The file to rename
5142:                Return Values:
5143:                  0 -   File was renamed successfully
5144:                  EOF - File was not renamed
5145:                Side Effects:
5146:                  The FSerrno variable will be changed.
5147:                Description:
5148:                  Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices.
5149:                  First, it will search through the current working directory to ensure the
5150:                  specified new filename is not already in use. If it isn't, the new filename
5151:                  will be written to the file entry of the file pointed to by 'fo.'
5152:                Remarks:
5153:                  None                                                        
5154:                ***************************************************************/
5155:              
5156:              #ifdef ALLOW_WRITES
5157:              
5158:              int FSrename (const char * fileName, FSFILE * fo)
5159:              {
5160:                  WORD fHandle;
5161:              	FSFILE	tempFo1,tempFo2;
5162:                  DIRENTRY dir;
5163:                  #ifdef SUPPORT_LFN
5164:                  DWORD  TempMsbCluster;
5165:                  #else
5166:                  BYTE j;
5167:                  #endif
5168:              
5169:                  FSerrno = CE_GOOD;
00AC96  24938D     MOV #0x4938, W13
00AC98  EB4E80     CLR.B [W13]
5170:              
5171:                  if (MDD_WriteProtectState())
00AC9A  071539     RCALL MDD_SDSPI_WriteProtectState
00AC9C  784580     MOV.B W0, W11
00ACA0  E0040B     CP0.B W11
00ACA2  3A0056     BRA NZ, 0xAD50
5172:                  {
5173:                      FSerrno = CE_WRITE_PROTECTED;
00AC9E  B3C180     MOV #0x18, W0
5174:                      return (-1);
5175:                  }
5176:              
5177:                   // copy file object over
5178:                  FileObjectCopy(&tempFo1, fo);
00ACA4  2FF7C0     MOV #0xFF7C, W0
00ACA6  478600     ADD W15, W0, W12
00ACA8  78008A     MOV W10, W1
00ACAA  78000C     MOV W12, W0
00ACAC  07E6D3     RCALL FileObjectCopy
5179:              
5180:                  //Format the source string
5181:                  if(!FormatFileName(fileName, &tempFo1, 0) )
00ACAE  78410B     MOV.B W11, W2
00ACB0  78008C     MOV W12, W1
00ACB2  780008     MOV W8, W0
00ACB4  07EC5F     RCALL FormatFileName
00ACB6  E00400     CP0.B W0
00ACB8  3A0002     BRA NZ, 0xACBE
5182:                  {
5183:                      FSerrno = CE_INVALID_FILENAME;
00ACBA  B3C120     MOV #0x12, W0
00ACBC  370049     BRA 0xAD50
5184:                      return -1;
5185:                  }
5186:              
5187:              	tempFo1.entry  = 0;
00ACBE  EB0480     CLR W9
00ACC0  9F97D9     MOV W9, [W15-86]
5188:              
5189:              	// start at the current directory
5190:              	tempFo1.dirclus  = cwdptr->dirclus;
00ACC2  8385B0     MOV cwdptr, W0
00ACC4  901920     MOV [W0+52], W2
00ACC6  9019B0     MOV [W0+54], W3
00ACC8  9F9F82     MOV W2, [W15-80]
00ACCA  9F9F93     MOV W3, [W15-78]
5191:              	tempFo1.dirccls  = cwdptr->dirccls;
00ACCC  901940     MOV [W0+56], W2
00ACCE  9019D0     MOV [W0+58], W3
00ACD0  9F9FA2     MOV W2, [W15-76]
00ACD2  9F9FB3     MOV W3, [W15-74]
5192:              
5193:                  // copy file object over
5194:                  FileObjectCopy(&tempFo2, &tempFo1);
00ACD4  2FFB88     MOV #0xFFB8, W8
00ACD6  478408     ADD W15, W8, W8
00ACD8  78008C     MOV W12, W1
00ACDA  780008     MOV W8, W0
00ACDC  07E6BB     RCALL FileObjectCopy
5195:              
5196:                  // See if the file is found
5197:                  if(FILEfind (&tempFo2, &tempFo1, LOOK_FOR_MATCHING_ENTRY, 0) == CE_FILE_NOT_FOUND)
00ACDE  784189     MOV.B W9, W3
00ACE0  B3C012     MOV #0x1, W2
00ACE2  78008C     MOV W12, W1
00ACE4  780008     MOV W8, W0
00ACE6  07F61A     RCALL FILEfind
00ACE8  500FEB     SUB W0, #0xB, [W15]
00ACEA  3A0031     BRA NZ, 0xAD4E
5198:              	{
5199:              		fHandle = fo->entry;
00ACEC  9011FA     MOV [W10+46], W3
00ACEE  9F3FD3     MOV W3, [W15-134]
5200:              
5201:              		#ifdef SUPPORT_LFN
5202:              
5203:              		if(CE_GOOD != FILEerase(fo, &fHandle, FALSE))
00ACF0  78410B     MOV.B W11, W2
00ACF2  2FF7A1     MOV #0xFF7A, W1
00ACF4  40808F     ADD W1, W15, W1
00ACF6  78000A     MOV W10, W0
00ACF8  07FD7F     RCALL FILEerase
00ACFA  780400     MOV W0, W8
00ACFE  E00008     CP0 W8
00AD00  3A0027     BRA NZ, 0xAD50
5204:              		{
5205:              			FSerrno = CE_ERASE_FAIL;
00ACFC  B3C010     MOV #0x1, W0
5206:              			return -1;
5207:              		}
5208:              
5209:              	   	// Create the new entry as per the user requested name
5210:              	   	FSerrno = CreateFileEntry (&tempFo1, &fHandle, tempFo1.attributes, FALSE);
00AD02  780188     MOV W8, W3
00AD04  97696F     MOV.B [W15-82], W2
00AD06  2FF7A1     MOV #0xFF7A, W1
00AD08  40808F     ADD W1, W15, W1
00AD0A  78000C     MOV W12, W0
00AD0C  07FC96     RCALL CreateFileEntry
00AD0E  784E80     MOV.B W0, [W13]
5211:              
5212:              	   	// load the file entry so the new cluster can be linked to it
5213:              	   	dir = LoadDirAttrib(&tempFo1, &fHandle);
00AD10  2FF7A1     MOV #0xFF7A, W1
00AD12  40808F     ADD W1, W15, W1
00AD14  78000C     MOV W12, W0
00AD16  07E5E9     RCALL LoadDirAttrib
5214:              
5215:              	   	// Now update the new cluster
5216:              	   	dir->DIR_FstClusLO = (fo->cluster & 0x0000FFFF);
00AD18  90009A     MOV [W10+2], W1
00AD1A  980851     MOV W1, [W0+26]
5217:              
5218:              	   	#ifdef SUPPORT_FAT32 // If FAT32 supported.
5219:              	   	// Get the higher part of cluster and store it in directory entry.
5220:              	   	TempMsbCluster = (fo->cluster & 0x0FFF0000);    // Since only 28 bits usedin FAT32. Mask the higher MSB nibble.
00AD1C  9000AA     MOV [W10+4], W1
00AD1E  20FFF2     MOV #0xFFF, W2
00AD20  608082     AND W1, W2, W1
5221:              	   	TempMsbCluster = TempMsbCluster >> 16;      // Get the date into Lsb place.
5222:              	   	dir->DIR_FstClusHI = TempMsbCluster;
00AD22  980821     MOV W1, [W0+20]
5223:              	   	#else // If FAT32 support not enabled
5224:              	   	TempMsbCluster = 0;                         // Just to avoid compiler warnigng.
5225:              	   	dir->DIR_FstClusHI = 0;
5226:              	   	#endif
5227:              	   
5228:              		// Update the file size
5229:                      dir->DIR_FileSize = fo->size;
00AD24  90091A     MOV [W10+18], W2
00AD26  9009AA     MOV [W10+20], W3
00AD28  980862     MOV W2, [W0+28]
00AD2A  980873     MOV W3, [W0+30]
5230:              
5231:              	   	// now write it
5232:              	   	if(Write_File_Entry(&tempFo1, &fHandle) != TRUE)
00AD2C  2FF7A1     MOV #0xFF7A, W1
00AD2E  40808F     ADD W1, W15, W1
00AD30  78000C     MOV W12, W0
00AD32  07E1BD     RCALL Write_File_Entry
00AD34  504FE1     SUB.B W0, #0x1, [W15]
00AD36  320002     BRA Z, 0xAD3C
5233:              		{
5234:              	    	FSerrno = CE_WRITE_ERROR;
00AD38  B3C090     MOV #0x9, W0
00AD3A  37000A     BRA 0xAD50
5235:              	    	return -1;
5236:              		}
5237:              	   	
5238:                 		tempFo1.size = fo->size;
00AD3C  90081A     MOV [W10+18], W0
00AD3E  9008AA     MOV [W10+20], W1
00AD40  9F87F0     MOV W0, [W15-114]
00AD42  9F8F81     MOV W1, [W15-112]
5239:              
5240:              		// copy file object over
5241:              		FileObjectCopy(fo, &tempFo1);
00AD44  78008C     MOV W12, W1
00AD46  78000A     MOV W10, W0
00AD48  07E685     RCALL FileObjectCopy
00AD4A  780008     MOV W8, W0
00AD4C  370003     BRA 0xAD54
5242:              		
5243:              		#else
5244:              
5245:                      // Get the file entry
5246:                      dir = LoadDirAttrib(fo, &fHandle);
5247:              
5248:                      for (j = 0; j < 11; j++)
5249:                      {
5250:                          fo->name[j] = tempFo1.name[j];
5251:                          if (j < 8)
5252:                          {
5253:                              dir->DIR_Name[j] = tempFo1.name[j];
5254:                          }
5255:                          else
5256:                          {
5257:                              dir->DIR_Extension[j-8] = tempFo1.name[j];
5258:                          }
5259:                      }
5260:              
5261:                      // just write the last entry in
5262:                      if(!Write_File_Entry(fo,&fHandle))
5263:                      {
5264:                          FSerrno = CE_WRITE_ERROR;
5265:                          return -1;
5266:                      }
5267:              
5268:              		#endif
5269:              	}
5270:              	else
5271:              	{
5272:                      FSerrno = CE_FILENAME_EXISTS;
00AD4E  B3C110     MOV #0x11, W0
00AD50  784E80     MOV.B W0, [W13]
00AD52  EB8000     SETM W0
5273:                      return -1;
5274:              	}
5275:              
5276:                  return 0;
5277:              }
5278:              
5279:              /***************************************************************
5280:                Function:
5281:                  int wFSrename (const rom unsigned short int * fileName, FSFILE * fo)
5282:                Summary:
5283:                  Renames the name of the file or directory to the UTF16 input fileName
5284:                  on PIC24/PIC32/dsPIC devices
5285:                Conditions:
5286:                  File opened.
5287:                Input:
5288:                  fileName -  The new name of the file
5289:                  fo -        The file to rename
5290:                Return Values:
5291:                  0 -   File was renamed successfully
5292:                  EOF - File was not renamed
5293:                Side Effects:
5294:                  The FSerrno variable will be changed.
5295:                Description:
5296:                  Renames the name of the file or directory to the UTF16 input fileName
5297:                  on PIC24/PIC32/dsPIC devices. First, it will search through the current
5298:                  working directory to ensure the specified new UTF16 filename is not
5299:                  already in use.  If it isn't, the new filename will be written to the
5300:                  file entry of the file pointed to by 'fo.'
5301:                Remarks:
5302:                  None
5303:                ***************************************************************/
5304:              #ifdef SUPPORT_LFN
5305:              int wFSrename (const unsigned short int * fileName, FSFILE * fo)
5306:              {
5307:              	int result;
5308:              	utfModeFileName = TRUE;
00AD5E  200012     MOV #0x1, W2
00AD60  8B85A2     MOV W2, utfModeFileName
5309:              	result = FSrename ((const char *)fileName,fo);
00AD62  07FF93     RCALL FSrename
5310:              	utfModeFileName = FALSE;
00AD64  EB0080     CLR W1
00AD66  8B85A1     MOV W1, utfModeFileName
5311:              	return result;
5312:              }
00AD6A  FA003E     LNK #0x3E
00AD6C  BE9F88     MOV.D W8, [W15++]
00AD6E  BE9F8A     MOV.D W10, [W15++]
00AD70  780501     MOV W1, W10
5313:              #endif
5314:              
5315:              #endif // Allow writes
5316:              
5317:              /*********************************************************************
5318:                Function:
5319:                  FSFILE * wFSfopen (const unsigned short int * fileName, const char *mode)
5320:                Summary:
5321:                  Opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's.
5322:                Conditions:
5323:                  For read modes, file exists; FSInit performed
5324:                Input:
5325:                  fileName -  The name of the file to open
5326:                  mode -
5327:                       - FS_WRITE -      Create a new file or replace an existing file
5328:                       - FS_READ -       Read data from an existing file
5329:                       - FS_APPEND -     Append data to an existing file
5330:                       - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled)
5331:                       - FS_READPLUS -   Read data from an existing file (writes also enabled)
5332:                       - FS_APPENDPLUS - Append data to an existing file (reads also enabled)
5333:                Return Values:
5334:                  FSFILE * - The pointer to the file object
5335:                  NULL -     The file could not be opened
5336:                Side Effects:
5337:                  The FSerrno variable will be changed.
5338:                Description:
5339:                  This function opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's.
5340:                  First, RAM in the dynamic heap or static array will be allocated to a
5341:                  new FSFILE object. Then, the specified file name will be formatted to
5342:                  ensure that it's in 8.3 format or LFN format. Next, the FILEfind function
5343:                  will be used to search for the specified file name. If the name is found,
5344:                  one of three things will happen: if the file was opened in read mode, its
5345:                  file info will be loaded using the FILEopen function; if it was opened in
5346:                  write mode, it will be erased, and a new file will be constructed in
5347:                  its place; if it was opened in append mode, its file info will be
5348:                  loaded with FILEopen and the current location will be moved to the
5349:                  end of the file using the FSfseek function.  If the file was not
5350:                  found by FILEfind, a new file will be created if the mode was specified as
5351:                  a write or append mode.  In these cases, a pointer to the heap or
5352:                  static FSFILE object array will be returned. If the file was not
5353:                  found and the mode was specified as a read mode, the memory
5354:                  allocated to the file will be freed and the NULL pointer value
5355:                  will be returned.
5356:                Remarks:
5357:                  None.
5358:                *********************************************************************/
5359:              #ifdef SUPPORT_LFN
5360:              FSFILE * wFSfopen( const unsigned short int * fileName, const char *mode )
5361:              {
5362:              	FSFILE *result;
5363:              	utfModeFileName = TRUE;
00AC7E  200012     MOV #0x1, W2
00AC80  8B85A2     MOV W2, utfModeFileName
5364:              	result = FSfopen((const char *)fileName,mode);
00AC82  07FECF     RCALL FSfopen
5365:              	utfModeFileName = FALSE;
00AC84  EB0080     CLR W1
00AC86  8B85A1     MOV W1, utfModeFileName
5366:              	return result;
5367:              }
00AC8A  FA007A     LNK #0x7A
00AC8C  BE9F88     MOV.D W8, [W15++]
00AC8E  BE9F8A     MOV.D W10, [W15++]
00AC90  BE9F8C     MOV.D W12, [W15++]
00AC92  780400     MOV W0, W8
00AC94  780501     MOV W1, W10
5368:              #endif
5369:              
5370:              /*********************************************************************
5371:                Function:
5372:                  FSFILE * FSfopen (const char * fileName, const char *mode)
5373:                Summary:
5374:                  Opens a file with ascii input 'fileName' on PIC24/PIC32/dsPIC MCU's.
5375:                Conditions:
5376:                  For read modes, file exists; FSInit performed
5377:                Input:
5378:                  fileName -  The name of the file to open
5379:                  mode -
5380:                       - FS_WRITE -      Create a new file or replace an existing file
5381:                       - FS_READ -       Read data from an existing file
5382:                       - FS_APPEND -     Append data to an existing file
5383:                       - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled)
5384:                       - FS_READPLUS -   Read data from an existing file (writes also enabled)
5385:                       - FS_APPENDPLUS - Append data to an existing file (reads also enabled)
5386:                Return Values:
5387:                  FSFILE * - The pointer to the file object
5388:                  NULL -     The file could not be opened
5389:                Side Effects:
5390:                  The FSerrno variable will be changed.
5391:                Description:
5392:                  This function will open a ascii name file or directory on PIC24/PIC32/dsPIC MCU's.
5393:                  First, RAM in the dynamic heap or static array will be allocated to a
5394:                  new FSFILE object. Then, the specified file name will be formatted to
5395:                  ensure that it's in 8.3 format or LFN format. Next, the FILEfind function
5396:                  will be used to search for the specified file name. If the name is found,
5397:                  one of three things will happen: if the file was opened in read mode, its
5398:                  file info will be loaded using the FILEopen function; if it was opened in
5399:                  write mode, it will be erased, and a new file will be constructed in
5400:                  its place; if it was opened in append mode, its file info will be
5401:                  loaded with FILEopen and the current location will be moved to the
5402:                  end of the file using the FSfseek function.  If the file was not
5403:                  found by FILEfind, a new file will be created if the mode was specified as
5404:                  a write or append mode.  In these cases, a pointer to the heap or
5405:                  static FSFILE object array will be returned. If the file was not
5406:                  found and the mode was specified as a read mode, the memory
5407:                  allocated to the file will be freed and the NULL pointer value
5408:                  will be returned.
5409:                Remarks:
5410:                  None.
5411:                *********************************************************************/
5412:              
5413:              FSFILE * FSfopen( const char * fileName, const char *mode )
5414:              {
5415:                  FILEOBJ    filePtr;
5416:              #ifndef FS_DYNAMIC_MEM
5417:                  int      fIndex;
5418:              #endif
5419:                  BYTE   ModeC;
5420:                  WORD    fHandle;
5421:                  CETYPE   final;
5422:              
5423:                  //Read the mode character
5424:                  ModeC = mode[0];
00AA2E  784511     MOV.B [W1], W10
5425:              
5426:                  if(MDD_WriteProtectState() && (ModeC != 'r') && (ModeC != 'R')) 
00AA30  07166E     RCALL MDD_SDSPI_WriteProtectState
00AA32  E00400     CP0.B W0
00AA34  320007     BRA Z, 0xAA44
00AA36  B3C720     MOV #0x72, W0
00AA38  554F80     SUB.B W10, W0, [W15]
00AA3A  320004     BRA Z, 0xAA44
00AA3C  B3C520     MOV #0x52, W0
00AA40  554F80     SUB.B W10, W0, [W15]
00AA42  3A0010     BRA NZ, 0xAA64
5427:                  { 
5428:                      FSerrno = CE_WRITE_PROTECTED; 
00AA3E  B3C181     MOV #0x18, W1
5429:                      return NULL; 
00AA44  EB0680     CLR W13
00AA46  2535E0     MOV #0x535E, W0
5430:                  } 
5431:              
5432:              #ifdef FS_DYNAMIC_MEM
5433:                  filePtr = (FILEOBJ) FS_malloc(sizeof(FSFILE));
5434:              #else
5435:              
5436:                  filePtr = NULL;
5437:              
5438:                  //Pick available file structure
5439:                  for( fIndex = 0; fIndex < FS_MAX_FILES_OPEN; fIndex++ )
00AA5A  E8068D     INC W13, W13
00AA5C  E80000     INC W0, W0
00AA5E  568FE2     SUB W13, #0x2, [W15]
00AA60  3AFFF3     BRA NZ, 0xAA48
5440:                  {
5441:                      if( gFileSlotOpen[fIndex] )   //this slot is available
00AA48  E00410     CP0.B [W0]
00AA4A  320007     BRA Z, 0xAA5A
5442:                      {
5443:                          gFileSlotOpen[fIndex] = FALSE;
00AA4C  EB4800     CLR.B [W0]
5444:                          filePtr = &gFileArray[fIndex];
00AA4E  2003C0     MOV #0x3C, W0
00AA50  B9E800     MUL.SS W13, W0, W0
00AA52  253602     MOV #0x5360, W2
00AA54  410480     ADD W2, W0, W9
5445:              			break;
5446:                      }
5447:                  }
5448:              
5449:                  if( filePtr == NULL )
00AA56  3A000A     BRA NZ, 0xAA6C
00AA58  370004     BRA 0xAA62
5450:                  {
5451:                      FSerrno = CE_TOO_MANY_FILES_OPEN;
00AA62  B3C201     MOV #0x20, W1
00AA64  249380     MOV #0x4938, W0
00AA66  784801     MOV.B W1, [W0]
00AA68  EB0480     CLR W9
00AA6A  370103     BRA 0xAC72
5452:                      return NULL;      //no file structure slot available
5453:                  }
5454:              #endif
5455:              
5456:              	#if defined(SUPPORT_LFN)
5457:              		#if defined(FS_DYNAMIC_MEM)
5458:              			filePtr -> utf16LFNptr = (unsigned short int *)FS_malloc(514);
5459:              		#else
5460:              			filePtr->utf16LFNptr = &lfnData[fIndex][0];
00AA6C  202020     MOV #0x202, W0
00AA6E  B9E800     MUL.SS W13, W0, W0
00AA70  24F5A2     MOV #0x4F5A, W2
00AA72  410100     ADD W2, W0, W2
00AA74  9814D2     MOV W2, [W9+42]
5461:              		#endif
5462:                  #endif
5463:              
5464:                  //Format the source string.
5465:                  if( !FormatFileName(fileName, filePtr, 0) )
00AA76  EB4100     CLR.B W2
00AA78  BE0008     MOV.D W8, W0
00AA7A  07ED7C     RCALL FormatFileName
00AA7C  E00400     CP0.B W0
00AA7E  3A0005     BRA NZ, 0xAA8A
5466:                  {
5467:              		#ifdef FS_DYNAMIC_MEM
5468:              			#if defined(SUPPORT_LFN)
5469:              				FS_free((unsigned char *)filePtr->utf16LFNptr);
5470:              			#endif
5471:                      	FS_free( (unsigned char *)filePtr );
5472:              		#else
5473:                      	gFileSlotOpen[fIndex] = TRUE;   //put this slot back to the pool
00AA80  B3C011     MOV #0x1, W1
00AA82  2535E0     MOV #0x535E, W0
00AA84  7EF001     MOV.B W1, [W0+W13]
5474:              		#endif
5475:                      
5476:              		FSerrno = CE_INVALID_FILENAME;
00AA86  B3C121     MOV #0x12, W1
00AA88  37FFED     BRA 0xAA64
5477:                      return NULL;   //bad filename
5478:                  }
5479:              
5480:                  filePtr->dsk = &gDiskData;
00AA8A  2485A0     MOV #0x485A, W0
00AA8C  780C80     MOV W0, [W9]
5481:                  filePtr->cluster = 0;
00AA8E  B80060     MUL.UU W0, #0, W0
00AA90  980490     MOV W0, [W9+2]
00AA92  9804A1     MOV W1, [W9+4]
5482:                  filePtr->ccls    = 0;
00AA94  9804B0     MOV W0, [W9+6]
00AA96  9804C1     MOV W1, [W9+8]
5483:                  filePtr->entry = 0;
00AA98  EB0400     CLR W8
00AA9A  9814F8     MOV W8, [W9+46]
5484:                  filePtr->attributes = ATTR_ARCHIVE;
00AA9C  200200     MOV #0x20, W0
00AA9E  981C90     MOV W0, [W9+50]
5485:              
5486:                  // start at the current directory
5487:              #ifdef ALLOW_DIRS
5488:                  filePtr->dirclus    = cwdptr->dirclus;
00AAA0  8385B0     MOV cwdptr, W0
00AAA2  901920     MOV [W0+52], W2
00AAA4  9019B0     MOV [W0+54], W3
00AAA6  981CA2     MOV W2, [W9+52]
00AAA8  981CB3     MOV W3, [W9+54]
5489:                  filePtr->dirccls    = cwdptr->dirccls;
00AAAA  901940     MOV [W0+56], W2
00AAAC  9019D0     MOV [W0+58], W3
00AAAE  981CC2     MOV W2, [W9+56]
00AAB0  981CD3     MOV W3, [W9+58]
5490:              #else
5491:                  filePtr->dirclus = FatRootDirClusterValue;
5492:                  filePtr->dirccls = FatRootDirClusterValue;
5493:              #endif
5494:              
5495:                  // copy file object over
5496:                  FileObjectCopy(&gFileTemp, filePtr);
00AAB2  780089     MOV W9, W1
00AAB4  248BA0     MOV #0x48BA, W0
00AAB6  07E7CE     RCALL FileObjectCopy
5497:              
5498:                  // See if the file is found
5499:                  if(FILEfind (filePtr, &gFileTemp, LOOK_FOR_MATCHING_ENTRY, 0) == CE_GOOD)
00AAB8  784188     MOV.B W8, W3
00AABA  B3C012     MOV #0x1, W2
00AABC  248BA1     MOV #0x48BA, W1
00AABE  780009     MOV W9, W0
00AAC0  07F72D     RCALL FILEfind
00AAC2  E00000     CP0 W0
00AAC4  3A0088     BRA NZ, 0xABD6
5500:                  {
5501:                      // File is Found
5502:                      switch(ModeC)
00AAC6  B3C570     MOV #0x57, W0
00AAC8  554F80     SUB.B W10, W0, [W15]
00AACA  320012     BRA Z, 0xAAF0
00AACC  3E0007     BRA GTU, 0xAADC
00AACE  504076     SUB.B W0, #0x16, W0
00AAD0  554F80     SUB.B W10, W0, [W15]
00AAD2  32002F     BRA Z, 0xAB32
00AAD4  404071     ADD.B W0, #0x11, W0
00AAD6  554F80     SUB.B W10, W0, [W15]
00AAD8  3A009F     BRA NZ, 0xAC18
00AADA  370066     BRA 0xABA8
00AADC  B3C720     MOV #0x72, W0
00AADE  554F80     SUB.B W10, W0, [W15]
00AAE0  320063     BRA Z, 0xABA8
00AAE2  404065     ADD.B W0, #0x5, W0
00AAE4  554F80     SUB.B W10, W0, [W15]
00AAE6  320004     BRA Z, 0xAAF0
00AAE8  504076     SUB.B W0, #0x16, W0
00AAEA  554F80     SUB.B W10, W0, [W15]
00AAEC  3A0095     BRA NZ, 0xAC18
00AAEE  370021     BRA 0xAB32
5503:                      {
5504:              #ifdef ALLOW_WRITES
5505:                          case 'w':
5506:                          case 'W':
5507:                          {
5508:                              // File exists, we want to create a new one, remove it first
5509:                              fHandle = filePtr->entry;
00AAF0  9011F9     MOV [W9+46], W3
00AAF2  9FBF93     MOV W3, [W15-14]
5510:                              final = FILEerase(filePtr, &fHandle, TRUE);
00AAF4  B3C012     MOV #0x1, W2
00AAF6  5780EE     SUB W15, #0xE, W1
00AAF8  780009     MOV W9, W0
00AAFA  07FE7E     RCALL FILEerase
00AAFC  780400     MOV W0, W8
5511:              
5512:                              if (final == CE_GOOD)
00AAFE  E00000     CP0 W0
00AB00  3A00AA     BRA NZ, 0xAC56
5513:                              {
5514:                                  // now create a new one
5515:                                  final = CreateFileEntry (filePtr, &fHandle, 0, TRUE);
00AB02  200013     MOV #0x1, W3
00AB04  784100     MOV.B W0, W2
00AB06  5780EE     SUB W15, #0xE, W1
00AB08  780009     MOV W9, W0
00AB0A  07FD97     RCALL CreateFileEntry
00AB0C  780400     MOV W0, W8
5516:              
5517:                                  if (final == CE_GOOD)
00AB0E  E00000     CP0 W0
00AB10  3A00A2     BRA NZ, 0xAC56
5518:                                  {
5519:                                      final = FILEopen (filePtr, &fHandle, 'w');
00AB12  B3C772     MOV #0x77, W2
00AB14  5780EE     SUB W15, #0xE, W1
00AB16  780009     MOV W9, W0
00AB18  07F6A0     RCALL FILEopen
00AB1A  780400     MOV W0, W8
5520:              
5521:                                      if (filePtr->attributes & ATTR_DIRECTORY)
00AB1C  901819     MOV [W9+50], W0
00AB1E  A34800     BTST.Z W0, #4
00AB20  3A007B     BRA NZ, 0xAC18
5522:                                      {
5523:                                          FSerrno = CE_INVALID_ARGUMENT;
5524:                                          final = 0xFF;
5525:                                      }
5526:              
5527:                                      if (final == CE_GOOD)
00AB22  E00008     CP0 W8
00AB24  3A0098     BRA NZ, 0xAC56
5528:                                      {
5529:                                          final = FSfseek (filePtr, 0, SEEK_END);
00AB26  200021     MOV #0x2, W1
00AB28  B81160     MUL.UU W2, #0, W2
00AB2A  780009     MOV W9, W0
00AB2C  07E96A     RCALL FSfseek
00AB2E  780400     MOV W0, W8
00AB30  370084     BRA 0xAC3A
5530:                                          if (mode[1] == '+')
5531:                                              filePtr->flags.read = 1;
5532:                                      }
5533:                                  }
5534:                              }
5535:                              break;
5536:                          }
5537:              
5538:                          case 'A':
5539:                          case 'a':
5540:                          {
5541:                              if(filePtr->size != 0)
00AB32  900D19     MOV [W9+18], W10
00AB34  900DA9     MOV [W9+20], W11
00AB36  550FE0     SUB W10, #0x0, [W15]
00AB38  5D8FE0     SUBB W11, #0x0, [W15]
00AB3A  320018     BRA Z, 0xAB6C
5542:                              {
5543:                                  fHandle = filePtr->entry;
00AB3C  901079     MOV [W9+46], W0
00AB3E  9FBF90     MOV W0, [W15-14]
5544:              
5545:                                  final = FILEopen (filePtr, &fHandle, 'w');
00AB40  B3C772     MOV #0x77, W2
00AB42  5780EE     SUB W15, #0xE, W1
00AB44  780009     MOV W9, W0
00AB46  07F689     RCALL FILEopen
00AB48  780400     MOV W0, W8
5546:              
5547:                                  if (filePtr->attributes & ATTR_DIRECTORY)
00AB4A  901819     MOV [W9+50], W0
00AB4C  A34800     BTST.Z W0, #4
00AB4E  3A0064     BRA NZ, 0xAC18
5548:                                  {
5549:                                      FSerrno = CE_INVALID_ARGUMENT;
5550:                                      final = 0xFF;
5551:                                  }
5552:              
5553:                                  if (final == CE_GOOD)
00AB50  E00008     CP0 W8
00AB52  3A0081     BRA NZ, 0xAC56
5554:                                  {
5555:                                      final = FSfseek (filePtr, 0, SEEK_END);
00AB54  200021     MOV #0x2, W1
00AB56  B81160     MUL.UU W2, #0, W2
00AB58  780009     MOV W9, W0
00AB5A  07E953     RCALL FSfseek
00AB5C  780400     MOV W0, W8
5556:                                      if (final != CE_GOOD)
00AB5E  E00000     CP0 W0
00AB60  3A0069     BRA NZ, 0xAC34
5557:                                          FSerrno = CE_SEEK_ERROR;
5558:                                      else
5559:                                          ReadFAT (&gDiskData, filePtr->ccls);
00AB62  900139     MOV [W9+6], W2
00AB64  9001C9     MOV [W9+8], W3
00AB66  2485A0     MOV #0x485A, W0
00AB68  07E410     RCALL ReadFAT
00AB6A  370067     BRA 0xAC3A
5560:                                      if (mode[1] == '+')
5561:                                          filePtr->flags.read = 1;
5562:                                  }
5563:                              }
5564:                              else
5565:                              {
5566:                                  fHandle = filePtr->entry;
00AB6C  901179     MOV [W9+46], W2
00AB6E  9FBF92     MOV W2, [W15-14]
5567:                                  final = FILEerase(filePtr, &fHandle, TRUE);
00AB70  B3C012     MOV #0x1, W2
00AB72  5780EE     SUB W15, #0xE, W1
00AB74  780009     MOV W9, W0
00AB76  07FE40     RCALL FILEerase
00AB78  780400     MOV W0, W8
5568:              
5569:                                  if (final == CE_GOOD)
00AB7A  E00000     CP0 W0
00AB7C  3A006C     BRA NZ, 0xAC56
5570:                                  {
5571:                                      // now create a new one
5572:                                      final = CreateFileEntry (filePtr, &fHandle, 0, TRUE);
00AB7E  200013     MOV #0x1, W3
00AB80  784100     MOV.B W0, W2
00AB82  5780EE     SUB W15, #0xE, W1
00AB84  780009     MOV W9, W0
00AB86  07FD59     RCALL CreateFileEntry
00AB88  780400     MOV W0, W8
5573:              
5574:                                      if (final == CE_GOOD)
00AB8A  E00000     CP0 W0
00AB8C  3A0064     BRA NZ, 0xAC56
5575:                                      {
5576:                                          final = FILEopen (filePtr, &fHandle, 'w');
00AB8E  B3C772     MOV #0x77, W2
00AB90  5780EE     SUB W15, #0xE, W1
00AB92  780009     MOV W9, W0
00AB94  07F662     RCALL FILEopen
00AB96  780400     MOV W0, W8
5577:              
5578:                                          if (filePtr->attributes & ATTR_DIRECTORY)
00AB98  901819     MOV [W9+50], W0
00AB9A  A34800     BTST.Z W0, #4
00AB9C  3A003D     BRA NZ, 0xAC18
5579:                                          {
5580:                                              FSerrno = CE_INVALID_ARGUMENT;
5581:                                              final = 0xFF;
5582:                                          }
5583:              
5584:                                          if (final == CE_GOOD)
00AB9E  E00008     CP0 W8
00ABA0  3A005A     BRA NZ, 0xAC56
5585:                                          {
5586:                                              final = FSfseek (filePtr, 0, SEEK_END);
00ABA2  200021     MOV #0x2, W1
00ABA4  BE010A     MOV.D W10, W2
00ABA6  370041     BRA 0xAC2A
5587:                                              if (final != CE_GOOD)
5588:                                                  FSerrno = CE_SEEK_ERROR;
5589:                                              if (mode[1] == '+')
5590:                                                  filePtr->flags.read = 1;
5591:                                          }
5592:                                      }
5593:                                  }
5594:                              }
5595:                              break;
5596:                          }
5597:              #endif
5598:                          case 'R':
5599:                          case 'r':
5600:                          {
5601:                              fHandle = filePtr->entry;
00ABA8  9011F9     MOV [W9+46], W3
00ABAA  9FBF93     MOV W3, [W15-14]
5602:              
5603:                              final = FILEopen (filePtr, &fHandle, 'r');
00ABAC  B3C722     MOV #0x72, W2
00ABAE  5780EE     SUB W15, #0xE, W1
00ABB0  780009     MOV W9, W0
00ABB2  07F653     RCALL FILEopen
00ABB4  780400     MOV W0, W8
5604:              #ifdef ALLOW_WRITES
5605:                              if ((final == CE_GOOD) && (mode[1] == '+') )
00ABB6  E00000     CP0 W0
00ABB8  3A004E     BRA NZ, 0xAC56
00ABBA  90409C     MOV.B [W12+1], W1
00ABBC  B3C2B0     MOV #0x2B, W0
00ABBE  50CF80     SUB.B W1, W0, [W15]
00ABC0  3A0049     BRA NZ, 0xAC54
5606:                              {
5607:                                  // Refresh FAT Table Entry
5608:                                  ReadFAT (&gDiskData, filePtr->ccls);
00ABC2  900139     MOV [W9+6], W2
00ABC4  9001C9     MOV [W9+8], W3
00ABC6  2485A0     MOV #0x485A, W0
00ABC8  07E3E0     RCALL ReadFAT
5609:                                  // In r+ mode, allow write acess to file
5610:                                  if(!(filePtr->attributes & ATTR_DIRECTORY))
00ABCA  901819     MOV [W9+50], W0
00ABCC  A34800     BTST.Z W0, #4
00ABCE  3A0042     BRA NZ, 0xAC54
5611:                                      filePtr->flags.write = 1;
00ABD0  900839     MOV [W9+22], W0
00ABD2  A00000     BSET W0, #0
00ABD4  370038     BRA 0xAC46
5612:                              }
5613:              #endif
5614:                              break;
5615:                          }
5616:              
5617:                          default:
5618:                              FSerrno = CE_INVALID_ARGUMENT;
5619:                              final = 0xFF;;  //indicate error condition
5620:                              break;
5621:                      }
5622:                  }
5623:                  else
5624:                  {
5625:              #ifdef ALLOW_WRITES
5626:                      // the file was not found, reset to the default asked
5627:                      FileObjectCopy(filePtr, &gFileTemp);
00ABD6  248BA1     MOV #0x48BA, W1
00ABD8  780009     MOV W9, W0
00ABDA  07E73C     RCALL FileObjectCopy
5628:              
5629:                      // File is not Found
5630:                      if((ModeC == 'w') || (ModeC == 'W') || (ModeC == 'a') || (ModeC == 'A'))
00ABDC  B3C770     MOV #0x77, W0
00ABDE  554F80     SUB.B W10, W0, [W15]
00ABE0  320009     BRA Z, 0xABF4
00ABE2  B3C570     MOV #0x57, W0
00ABE4  554F80     SUB.B W10, W0, [W15]
00ABE6  320006     BRA Z, 0xABF4
00ABE8  40406A     ADD.B W0, #0xA, W0
00ABEA  554F80     SUB.B W10, W0, [W15]
00ABEC  320003     BRA Z, 0xABF4
00ABEE  B3C410     MOV #0x41, W0
00ABF0  554F80     SUB.B W10, W0, [W15]
00ABF2  3A002B     BRA NZ, 0xAC4A
5631:                      {
5632:                          // use the user requested name
5633:                          fHandle = 0;
00ABF4  EB0000     CLR W0
00ABF6  9FBF90     MOV W0, [W15-14]
5634:                          final = CreateFileEntry (filePtr, &fHandle, 0, TRUE);
00ABF8  200013     MOV #0x1, W3
00ABFA  EB4100     CLR.B W2
00ABFC  5780EE     SUB W15, #0xE, W1
00ABFE  780009     MOV W9, W0
00AC00  07FD1C     RCALL CreateFileEntry
00AC02  780400     MOV W0, W8
5635:              
5636:                          if (final == CE_GOOD)
00AC04  E00000     CP0 W0
00AC06  3A0027     BRA NZ, 0xAC56
5637:                          {
5638:                              final = FILEopen (filePtr, &fHandle, 'w');
00AC08  B3C772     MOV #0x77, W2
00AC0A  5780EE     SUB W15, #0xE, W1
00AC0C  780009     MOV W9, W0
00AC0E  07F625     RCALL FILEopen
00AC10  780400     MOV W0, W8
5639:                              if (filePtr->attributes & ATTR_DIRECTORY)
00AC12  901819     MOV [W9+50], W0
00AC14  A34800     BTST.Z W0, #4
00AC16  320005     BRA Z, 0xAC22
5640:                              {
5641:                                  FSerrno = CE_INVALID_ARGUMENT;
00AC18  B3C1F1     MOV #0x1F, W1
00AC1A  249380     MOV #0x4938, W0
00AC1C  784801     MOV.B W1, [W0]
00AC1E  200FF8     MOV #0xFF, W8
00AC20  37001A     BRA 0xAC56
5642:                                  final = 0xFF;
5643:                              }
5644:              
5645:                              if (final == CE_GOOD)
00AC22  E00008     CP0 W8
00AC24  3A0018     BRA NZ, 0xAC56
5646:                              {
5647:                                  final = FSfseek (filePtr, 0, SEEK_END);
00AC26  200021     MOV #0x2, W1
00AC28  B81160     MUL.UU W2, #0, W2
00AC2A  780009     MOV W9, W0
00AC2C  07E8EA     RCALL FSfseek
00AC2E  780400     MOV W0, W8
5648:                                  if (final != CE_GOOD)
00AC30  E00000     CP0 W0
00AC32  320003     BRA Z, 0xAC3A
5649:                                      FSerrno = CE_SEEK_ERROR;
00AC34  B3C1A1     MOV #0x1A, W1
00AC36  249380     MOV #0x4938, W0
00AC38  784801     MOV.B W1, [W0]
5650:                                  if (mode[1] == '+')
00AC3A  90409C     MOV.B [W12+1], W1
00AC3C  B3C2B0     MOV #0x2B, W0
00AC3E  50CF80     SUB.B W1, W0, [W15]
00AC40  3A000A     BRA NZ, 0xAC56
5651:                                      filePtr->flags.read = 1;
00AC42  900839     MOV [W9+22], W0
00AC44  A01000     BSET W0, #1
00AC46  980CB0     MOV W0, [W9+22]
00AC48  370006     BRA 0xAC56
5652:                              }
5653:                          }
5654:                      }
5655:                      else
5656:              #endif
5657:              		{
5658:                          final = CE_FILE_NOT_FOUND;
5659:                      	FSerrno = CE_FILE_NOT_FOUND;
00AC4A  B3C0B1     MOV #0xB, W1
00AC4C  249380     MOV #0x4938, W0
00AC4E  784801     MOV.B W1, [W0]
00AC50  2000B8     MOV #0xB, W8
00AC52  370001     BRA 0xAC56
00AC54  EB0400     CLR W8
5660:                  	}
5661:                  }
5662:              
5663:                  if (MDD_WriteProtectState())
00AC56  07155B     RCALL MDD_SDSPI_WriteProtectState
00AC58  E00400     CP0.B W0
00AC5A  320003     BRA Z, 0xAC62
5664:                  {
5665:                      filePtr->flags.write = 0;;
00AC5C  900839     MOV [W9+22], W0
00AC5E  A10000     BCLR W0, #0
00AC60  980CB0     MOV W0, [W9+22]
5666:                  }
5667:              
5668:              #ifdef FS_DYNAMIC_MEM
5669:                  if( final != CE_GOOD )
5670:                  {
5671:                      #ifdef	SUPPORT_LFN
5672:              			FS_free((unsigned char *)filePtr->utf16LFNptr);
5673:              		#endif
5674:              		FS_free( (unsigned char *)filePtr );
5675:                      filePtr = NULL;
5676:                  }
5677:              #else
5678:                  if( final != CE_GOOD )
00AC62  E00008     CP0 W8
00AC64  320004     BRA Z, 0xAC6E
5679:                  {
5680:                      gFileSlotOpen[fIndex] = TRUE;   //put this slot back to the pool
00AC66  B3C011     MOV #0x1, W1
00AC68  2535E0     MOV #0x535E, W0
00AC6A  7EF001     MOV.B W1, [W0+W13]
00AC6C  37FEFD     BRA 0xAA68
5681:                      filePtr = NULL;
5682:                  }
5683:              #endif
5684:                  else
5685:                  {
5686:                      FSerrno = CE_GOOD;
00AC6E  249380     MOV #0x4938, W0
00AC70  784808     MOV.B W8, [W0]
5687:                  }
5688:              
5689:                  return filePtr;
5690:              }
5691:              
5692:              /*******************************************************************
5693:                Function:
5694:                  long FSftell (FSFILE * fo)
5695:                Summary:
5696:                  Determine the current location in a file
5697:                Conditions:
5698:                  File opened
5699:                Input:
5700:                  fo -  Pointer to file structure
5701:                Return: Current location in the file
5702:                Side Effects:
5703:                  The FSerrno variable will be changed
5704:                Description:
5705:                  The FSftell function will return the current position in the
5706:                  file pointed to by 'fo' by returning the 'seek' variable in the
5707:                  FSFILE object, which is used to keep track of the absolute
5708:                  location of the current position in the file.
5709:                Remarks:
5710:                  None
5711:                *******************************************************************/
5712:              
5713:              long FSftell (FSFILE * fo)
5714:              {
5715:                  FSerrno = CE_GOOD;
007F5C  249381     MOV #0x4938, W1
007F5E  EB4880     CLR.B [W1]
007F60  900880     MOV [W0+16], W1
007F62  900070     MOV [W0+14], W0
5716:                  return (fo->seek);
5717:              }
007F66  781F88     MOV W8, [W15++]
007F68  780400     MOV W0, W8
5718:              
5719:              
5720:              #ifdef ALLOW_WRITES
5721:              
5722:              /*********************************************************************
5723:                Function:
5724:                  int FSremove (const char * fileName)
5725:                Summary:
5726:                  Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format.
5727:                Conditions:
5728:                  File not opened, file exists
5729:                Input:
5730:                  fileName -  Name of the file to erase
5731:                Return Values:
5732:                  0 -   File removed 
5733:                  EOF - File was not removed
5734:                Side Effects:
5735:                  The FSerrno variable will be changed.
5736:                Description:
5737:                  Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format.
5738:                  The FSremove function will attempt to find the specified file with the FILEfind
5739:                  function.  If the file is found, it will be erased using the FILEerase function.
5740:                  The user can also provide ascii alias name of the ascii long file name as the
5741:                  input to this function to get it erased from the memory.
5742:                Remarks:
5743:                  None                                       
5744:                **********************************************************************/
5745:              
5746:              int FSremove (const char * fileName)
5747:              {
5748:                  FILEOBJ fo = &tempCWDobj;
5749:              
5750:              	#ifdef SUPPORT_LFN
5751:              		FSFILE cwdTemp;
5752:              		char tempArray[514];
5753:              		LFN_ENTRY *lfno;
5754:              		WORD prevHandle;
5755:              		unsigned short int i = 0;
5756:              	#endif
5757:                  FSerrno = CE_GOOD;
00A944  24938A     MOV #0x4938, W10
00A946  EB4D00     CLR.B [W10]
5758:              
5759:                  if (MDD_WriteProtectState())
00A948  0716E2     RCALL MDD_SDSPI_WriteProtectState
00A94A  784400     MOV.B W0, W8
00A94E  E00408     CP0.B W8
00A950  3A000A     BRA NZ, 0xA966
5760:                  {
5761:                      FSerrno = CE_WRITE_PROTECTED;
00A94C  B3C180     MOV #0x18, W0
5762:                      return (-1);
5763:                  }
5764:              
5765:                  //Format the source string
5766:              	#if defined(SUPPORT_LFN)
5767:              		fo->utf16LFNptr = (unsigned short int *)&tempArray[0];
00A952  2FDF80     MOV #0xFDF8, W0
00A954  478000     ADD W15, W0, W0
00A956  8A4900     MOV W0, 0x4920
5768:              	#endif
5769:              
5770:                  if( !FormatFileName(fileName, fo, 0) )
00A958  784108     MOV.B W8, W2
00A95A  248F61     MOV #0x48F6, W1
00A95C  780009     MOV W9, W0
00A95E  07EE0A     RCALL FormatFileName
00A960  E00400     CP0.B W0
00A962  3A0003     BRA NZ, 0xA96A
5771:                  {
5772:                      FSerrno = CE_INVALID_FILENAME;
00A964  B3C120     MOV #0x12, W0
00A966  784D00     MOV.B W0, [W10]
00A968  370051     BRA 0xAA0C
5773:                      return -1;
5774:                  }
5775:              
5776:                  fo->dsk = &gDiskData;
00A96A  2485A0     MOV #0x485A, W0
00A96C  8A47B0     MOV W0, tempCWDobj
5777:                  fo->cluster = 0;
00A96E  248F80     MOV #0x48F8, W0
00A970  EB0800     CLR [W0]
00A972  781030     MOV [W0++], [W0--]
5778:                  fo->ccls    = 0;
00A974  248FC0     MOV #0x48FC, W0
00A976  EB0800     CLR [W0]
00A978  781030     MOV [W0++], [W0--]
5779:                  fo->entry = 0;
00A97A  249249     MOV #0x4924, W9
00A97C  EB0C80     CLR [W9]
5780:                  fo->attributes = ATTR_ARCHIVE;
00A97E  200200     MOV #0x20, W0
00A980  8A4940     MOV W0, 0x4928
5781:              
5782:              #ifndef ALLOW_DIRS
5783:                  // start at the root directory
5784:                  fo->dirclus    = FatRootDirClusterValue;
5785:                  fo->dirccls    = FatRootDirClusterValue;
5786:              #else
5787:                  fo->dirclus = cwdptr->dirclus;
00A982  8385B0     MOV cwdptr, W0
00A984  901920     MOV [W0+52], W2
00A986  9019B0     MOV [W0+54], W3
00A988  8A4952     MOV W2, 0x492A
00A98A  8A4963     MOV W3, 0x492C
5788:                  fo->dirccls = cwdptr->dirccls;
00A98C  901940     MOV [W0+56], W2
00A98E  9019D0     MOV [W0+58], W3
00A990  8A4972     MOV W2, 0x492E
00A992  8A4983     MOV W3, 0x4930
5789:              #endif
5790:              
5791:                  // copy file object over
5792:                  FileObjectCopy(&gFileTemp, fo);
00A994  248F61     MOV #0x48F6, W1
00A996  248BA0     MOV #0x48BA, W0
00A998  07E85D     RCALL FileObjectCopy
5793:              
5794:                  // See if the file is found
5795:                  if (FILEfind (fo, &gFileTemp, LOOK_FOR_MATCHING_ENTRY, 0) != CE_GOOD)
00A99A  784188     MOV.B W8, W3
00A99C  B3C012     MOV #0x1, W2
00A99E  248BA1     MOV #0x48BA, W1
00A9A0  248F60     MOV #0x48F6, W0
00A9A2  07F7BC     RCALL FILEfind
00A9A4  E00000     CP0 W0
00A9A6  320002     BRA Z, 0xA9AC
5796:                  {
5797:                      FSerrno = CE_FILE_NOT_FOUND;
00A9A8  B3C0B0     MOV #0xB, W0
00A9AA  37FFDD     BRA 0xA966
5798:                      return -1;
5799:                  }
5800:              
5801:                  if (fo->attributes & ATTR_DIRECTORY)
00A9AC  249280     MOV #0x4928, W0
00A9AE  780010     MOV [W0], W0
00A9B0  600470     AND W0, #0x10, W8
00A9B4  3AFFD8     BRA NZ, 0xA966
5802:                  {
5803:                      FSerrno = CE_DELETE_DIR;
00A9B2  B3C130     MOV #0x13, W0
5804:                      return -1;
5805:                  }
5806:              
5807:              	// Find the long file name assosciated with the short file name if present
5808:              	#ifdef SUPPORT_LFN
5809:              	if(!fo->utf16LFNlength)
00A9B6  249220     MOV #0x4922, W0
00A9B8  E00010     CP0 [W0]
00A9BA  3A001F     BRA NZ, 0xA9FA
5810:              	{
5811:              		FileObjectCopy (&cwdTemp, fo);
00A9BC  248F61     MOV #0x48F6, W1
00A9BE  2FDBC3     MOV #0xFDBC, W3
00A9C0  478003     ADD W15, W3, W0
00A9C2  07E848     RCALL FileObjectCopy
5812:              		prevHandle = fo->entry - 1;
00A9C4  E90499     DEC [W9], W9
00A9C6  9D9FD9     MOV W9, [W15-582]
5813:              
5814:              		lfno = (LFN_ENTRY *)Cache_File_Entry (fo, &prevHandle, FALSE);
00A9C8  784108     MOV.B W8, W2
00A9CA  370005     BRA 0xA9D6
5815:              
5816:              
5817:              	   	while((lfno->LFN_Attribute == ATTR_LONG_NAME) && (lfno->LFN_SequenceNo != DIR_DEL)
00A9E0  904830     MOV.B [W0+11], W0
00A9E2  504FEF     SUB.B W0, #0xF, [W15]
00A9E4  3A0005     BRA NZ, 0xA9F0
00A9E6  784011     MOV.B [W1], W0
00A9E8  404FFB     ADD.B W0, #0x1B, [W15]
00A9EA  320002     BRA Z, 0xA9F0
00A9EC  E00400     CP0.B W0
00A9EE  3AFFEE     BRA NZ, 0xA9CC
5818:              
5819:              	   			&& (lfno->LFN_SequenceNo != DIR_EMPTY))
5820:              
5821:              	   	{
5822:              
5823:              
5824:              			i = i + MAX_UTF16_CHARS_IN_LFN_ENTRY;
00A9CC  44046D     ADD W8, #0xD, W8
5825:              
5826:              	   		prevHandle = prevHandle - 1;
00A9CE  95985F     MOV [W15-582], W0
00A9D0  E90000     DEC W0, W0
00A9D2  9D9FD0     MOV W0, [W15-582]
5827:              
5828:              	   		lfno = (LFN_ENTRY *)Cache_File_Entry (fo, &prevHandle, FALSE);
00A9D4  EB4100     CLR.B W2
00A9D6  2FDBA1     MOV #0xFDBA, W1
00A9D8  40808F     ADD W1, W15, W1
00A9DA  248F60     MOV #0x48F6, W0
00A9DC  07E5E6     RCALL Cache_File_Entry
00A9DE  780080     MOV W0, W1
5829:              
5830:              	   	}
5831:              
5832:              
5833:              
5834:              	   	FileObjectCopy (fo, &cwdTemp);
00A9F0  2FDBC2     MOV #0xFDBC, W2
00A9F2  478082     ADD W15, W2, W1
00A9F4  248F60     MOV #0x48F6, W0
00A9F6  07E82E     RCALL FileObjectCopy
5835:              
5836:              		// Find the length of LFN file
5837:              		fo->utf16LFNlength = i;
00A9F8  8A4918     MOV W8, 0x4922
5838:              
5839:              	}
5840:              	#endif
5841:              
5842:              	// Erase the file
5843:                  if( FILEerase(fo, &fo->entry, TRUE) == CE_GOOD )
00A9FA  B3C012     MOV #0x1, W2
00A9FC  249241     MOV #0x4924, W1
00A9FE  248F60     MOV #0x48F6, W0
00AA00  07FEFB     RCALL FILEerase
00AA02  E00000     CP0 W0
00AA04  320004     BRA Z, 0xAA0E
5844:                      return 0;
5845:                  else
5846:                  {
5847:                      FSerrno = CE_ERASE_FAIL;
00AA06  B3C011     MOV #0x1, W1
00AA08  249380     MOV #0x4938, W0
00AA0A  784801     MOV.B W1, [W0]
00AA0C  EB8000     SETM W0
5848:                      return -1;
5849:                  }
5850:              }
5851:              
5852:              /*********************************************************************
5853:                Function:
5854:                  int wFSremove (const unsigned short int * fileName)
5855:                Summary:
5856:                  Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format.
5857:                Conditions:
5858:                  File not opened, file exists
5859:                Input:
5860:                  fileName -  Name of the file to erase
5861:                Return Values:
5862:                  0 -   File removed
5863:                  EOF - File was not removed
5864:                Side Effects:
5865:                  The FSerrno variable will be changed.
5866:                Description:
5867:                  Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format.
5868:                  The wFSremove function will attempt to find the specified UTF16 file
5869:                  name with the FILEfind function. If the file is found, it will be erased
5870:                  using the FILEerase function.
5871:                Remarks:
5872:                  None
5873:                **********************************************************************/
5874:              #ifdef SUPPORT_LFN
5875:              int wFSremove (const unsigned short int * fileName)
5876:              {
5877:              	int result;
5878:              	utfModeFileName = TRUE;
00AA16  200011     MOV #0x1, W1
00AA18  8B85A1     MOV W1, utfModeFileName
5879:              	result = FSremove ((const char *)fileName);
00AA1A  07FF90     RCALL FSremove
5880:              	utfModeFileName = FALSE;
00AA1C  EB0080     CLR W1
00AA1E  8B85A1     MOV W1, utfModeFileName
5881:              	return result;
5882:              }
00AA22  FA0002     LNK #0x2
00AA24  BE9F88     MOV.D W8, [W15++]
00AA26  BE9F8A     MOV.D W10, [W15++]
00AA28  BE9F8C     MOV.D W12, [W15++]
00AA2A  780400     MOV W0, W8
00AA2C  780601     MOV W1, W12
5883:              #endif
5884:              
5885:              #endif
5886:              
5887:              /*********************************************************
5888:                Function:
5889:                  void FSrewind (FSFILE * fo)
5890:                Summary:
5891:                  Set the current position in a file to the beginning
5892:                Conditions:
5893:                  File opened.
5894:                Input:
5895:                  fo -  Pointer to file structure
5896:                Return Values:
5897:                  None
5898:                Side Effects:
5899:                  None.
5900:                Description:
5901:                  The FSrewind funciton will reset the position of the
5902:                  specified file to the beginning of the file.  This
5903:                  functionality is faster than using FSfseek to reset
5904:                  the position in the file.
5905:                Remarks:
5906:                  None.
5907:                *********************************************************/
5908:              
5909:              void FSrewind (FSFILE * fo)
5910:              {
5911:              #ifdef ALLOW_WRITES
5912:                  if (gNeedDataWrite)
007F6A  270BB0     MOV #0x70BB, W0
007F6C  E00410     CP0.B [W0]
007F6E  320001     BRA Z, 0x7F72
5913:                      flushData();
007F70  07F7D9     RCALL flushData
5914:              #endif
5915:                  fo->seek = 0;
007F72  B80060     MUL.UU W0, #0, W0
007F74  980470     MOV W0, [W8+14]
007F76  980C01     MOV W1, [W8+16]
5916:                  fo->pos = 0;
007F78  EB0000     CLR W0
007F7A  980460     MOV W0, [W8+12]
5917:                  fo->sec = 0;
007F7C  980450     MOV W0, [W8+10]
5918:                  fo->ccls = fo->cluster;
007F7E  900118     MOV [W8+2], W2
007F80  9001A8     MOV [W8+4], W3
007F82  980432     MOV W2, [W8+6]
007F84  980443     MOV W3, [W8+8]
5919:                  gBufferOwner = NULL;
007F86  8B8600     MOV W0, gBufferOwner
5920:                  return;
5921:              }
5922:              
5923:              /**************************************************************************
5924:                Function:
5925:                  int FSerror (void)
5926:                Summary:
5927:                  Return an error code for the last function call
5928:                Conditions:
5929:                  The return value depends on the last function called.
5930:                Input:
5931:                  None
5932:                Side Effects:
5933:                  None.
5934:                Return Values:
5935:                  FSInit       -
5936:                               - CE_GOOD •À?                  No Error
5937:                               - CE_INIT_ERROR •À?            The physical media could not be initialized
5938:                               - CE_BAD_SECTOR_READ •À?       The MBR or the boot sector could not be
5939:                                                            read correctly
5940:                               - CE_BAD_PARITION •À?          The MBR signature code was incorrect.
5941:                               - CE_NOT_FORMATTED •À?         The boot sector signature code was incorrect or
5942:                                                            indicates an invalid number of bytes per sector.
5943:                               - CE_UNSUPPORTED_SECTOR_SIZE - The number of bytes per sector is unsupported
5944:                               - CE_CARDFAT32 •À?             The physical media is FAT32 type (only an error
5945:                                                            when FAT32 support is disabled).
5946:                               - CE_UNSUPPORTED_FS •À?        The device is formatted with an unsupported file
5947:                                                            system (not FAT12 or 16).
5948:                  FSfopen      -
5949:                               - CE_GOOD •À?                  No Error
5950:                               - CE_NOT_INIT •À?              The device has not been initialized.
5951:                               - CE_TOO_MANY_FILES_OPEN •À?   The function could not allocate any
5952:                                                            additional file information to the array
5953:                                                            of FSFILE structures or the heap.
5954:                               - CE_INVALID_FILENAME •À?      The file name argument was invalid.
5955:                               - CE_INVALID_ARGUMENT •À?      The user attempted to open a directory in a
5956:                                                            write mode or specified an invalid mode argument.
5957:                               - CE_FILE_NOT_FOUND •À?        The specified file (which was to be opened in read
5958:                                                            mode) does not exist on the device.
5959:                               - CE_BADCACHEREAD •À?          A read from the device failed.
5960:                               - CE_ERASE_FAIL •À?            The existing file could not be erased (when opening
5961:                                                            a file in FS_WRITE mode).
5962:                               - CE_DIR_FULL •À?              The directory is full.
5963:                               - CE_DISK_FULL•À?              The data memory section is full.
5964:                               - CE_WRITE_ERROR •À?           A write to the device failed.
5965:                               - CE_SEEK_ERROR •À?            The current position in the file could not be set to
5966:                                                            the end (when the file was opened in FS_APPEND mode).
5967:                  FSfclose     -
5968:                               - CE_GOOD •À?                  No Error
5969:                               - CE_WRITE_ERROR •À?           The existing data in the data buffer or the new file
5970:                                                            entry information could not be written to the device.
5971:                               - CE_BADCACHEREAD •À?          The file entry information could not be cached
5972:                  FSfread      -
5973:                               - CE_GOOD •À?                  No Error
5974:                               - CE_WRITEONLY •À?             The file was opened in a write-only mode.
5975:                               - CE_WRITE_ERROR •À?           The existing data in the data buffer could not be
5976:                                                            written to the device.
5977:                               - CE_BAD_SECTOR_READ •À?       The data sector could not be read.
5978:                               - CE_EOF •À?                   The end of the file was reached.
5979:                               - CE_COULD_NOT_GET_CLUSTER •À? Additional clusters in the file could not be loaded.
5980:                  FSfwrite     -
5981:                               - CE_GOOD •À?                  No Error
5982:                               - CE_READONLY •À?              The file was opened in a read-only mode.
5983:                               - CE_WRITE_PROTECTED •À?       The device write-protect check function indicated
5984:                                                            that the device has been write-protected.
5985:                               - CE_WRITE_ERROR •À?           There was an error writing data to the device.
5986:                               - CE_BADCACHEREAD •À?          The data sector to be modified could not be read from
5987:                                                            the device.
5988:                               - CE_DISK_FULL •À?             All data clusters on the device are in use.
5989:                  FSfseek      -
5990:                               - CE_GOOD •À?                  No Error
5991:                               - CE_WRITE_ERROR •À?           The existing data in the data buffer could not be
5992:                                                            written to the device.
5993:                               - CE_INVALID_ARGUMENT •À?      The specified offset exceeds the size of the file.
5994:                               - CE_BADCACHEREAD •À?          The sector that contains the new current position
5995:                                                            could not be loaded.
5996:                               - CE_COULD_NOT_GET_CLUSTER •À? Additional clusters in the file could not be
5997:                                                            loaded/allocated.
5998:                  FSftell      -
5999:                               - CE_GOOD •À?                  No Error
6000:                  FSattrib     -
6001:                               - CE_GOOD •À?                  No Error
6002:                               - CE_INVALID_ARGUMENT •À?      The attribute argument was invalid.
6003:                               - CE_BADCACHEREAD •À?          The existing file entry information could not be
6004:                                                            loaded.
6005:                               - CE_WRITE_ERROR •À?           The file entry information could not be written to
6006:                                                            the device.
6007:                  FSrename     -
6008:                               - CE_GOOD •À?                  No Error
6009:                               - CE_FILENOTOPENED •À?         A null file pointer was passed into the function.
6010:                               - CE_INVALID_FILENAME •À?      The file name passed into the function was invalid.
6011:                               - CE_BADCACHEREAD •À?          A read from the device failed.
6012:                               - CE_FILENAME_EXISTS •À?       A file with the specified name already exists.
6013:                               - CE_WRITE_ERROR •À?           The new file entry data could not be written to the
6014:                                                            device.
6015:                  FSfeof       -
6016:                               - CE_GOOD •À?                  No Error
6017:                  FSformat     -
6018:                               - CE_GOOD •À?                  No Error
6019:                               - CE_INIT_ERROR •À?            The device could not be initialized.
6020:                               - CE_BADCACHEREAD •À?          The master boot record or boot sector could not be
6021:                                                            loaded successfully.
6022:                               - CE_INVALID_ARGUMENT •À?      The user selected to create their own boot sector on
6023:                                                            a device that has no master boot record, or the mode
6024:                                                            argument was invalid.
6025:                               - CE_WRITE_ERROR •À?           The updated MBR/Boot sector could not be written to
6026:                                                            the device.
6027:                               - CE_BAD_PARTITION •À?         The calculated number of sectors per clusters was
6028:                                                            invalid.
6029:                               - CE_NONSUPPORTED_SIZE •À?     The card has too many sectors to be formatted as
6030:                                                            FAT12 or FAT16.
6031:                  FSremove     -
6032:                               - CE_GOOD •À?                  No Error
6033:                               - CE_WRITE_PROTECTED •À?       The device write-protect check function indicated
6034:                                                            that the device has been write-protected.
6035:                               - CE_INVALID_FILENAME •À?      The specified filename was invalid.
6036:                               - CE_FILE_NOT_FOUND •À?        The specified file could not be found.
6037:                               - CE_ERASE_FAIL •À?            The file could not be erased.
6038:                  FSchdir      -
6039:                               - CE_GOOD •À?                  No Error
6040:                               - CE_INVALID_ARGUMENT •À?      The path string was mis-formed or the user tried to
6041:                                                            change to a non-directory file.
6042:                               - CE_BADCACHEREAD •À?          A directory entry could not be cached.
6043:                               - CE_DIR_NOT_FOUND •À?         Could not find a directory in the path.
6044:                  FSgetcwd     -
6045:                               - CE_GOOD •À?                  No Error
6046:                               - CE_INVALID_ARGUMENT •À?      The user passed a 0-length buffer into the function.
6047:                               - CE_BADCACHEREAD •À?          A directory entry could not be cached.
6048:                               - CE_BAD_SECTOR_READ •À?       The function could not determine a previous directory
6049:                                                            of the current working directory.
6050:                  FSmkdir      -
6051:                               - CE_GOOD •À?                  No Error
6052:                               - CE_WRITE_PROTECTED •À?       The device write-protect check function indicated
6053:                                                            that the device has been write-protected.
6054:                               - CE_INVALID_ARGUMENT •À?      The path string was mis-formed.
6055:                               - CE_BADCACHEREAD •À?          Could not successfully change to a recently created
6056:                                                            directory to store its dir entry information, or
6057:                                                            could not cache directory entry information.
6058:                               - CE_INVALID_FILENAME •À?      One or more of the directory names has an invalid
6059:                                                            format.
6060:                               - CE_WRITE_ERROR •À?           The existing data in the data buffer could not be
6061:                                                            written to the device or the dot/dotdot entries could
6062:                                                            not be written to a newly created directory.
6063:                               - CE_DIR_FULL •À?              There are no available dir entries in the CWD.
6064:                               - CE_DISK_FULL •À?             There are no available clusters in the data region of
6065:                                                            the device.
6066:                  FSrmdir      -
6067:                               - CE_GOOD •À?                  No Error
6068:                               - CE_DIR_NOT_FOUND •À?         The directory specified could not be found or the
6069:                                                            function could not change to a subdirectory within
6070:                                                            the directory to be deleted (when recursive delete is
6071:                                                            enabled).
6072:                               - CE_INVALID_ARGUMENT •À?      The user tried to remove the CWD or root directory.
6073:                               - CE_BADCACHEREAD •À?          A directory entry could not be cached.
6074:                               - CE_DIR_NOT_EMPTY •À?         The directory to be deleted was not empty and
6075:                                                            recursive subdirectory removal was disabled.
6076:                               - CE_ERASE_FAIL •À?            The directory or one of the directories or files
6077:                                                            within it could not be deleted.
6078:                               - CE_BAD_SECTOR_READ •À?       The function could not determine a previous directory
6079:                                                            of the CWD.
6080:                  SetClockVars -
6081:                               - CE_GOOD •À?                  No Error
6082:                               - CE_INVALID_ARGUMENT •À?      The time values passed into the function were
6083:                                                            invalid.
6084:                  FindFirst    -
6085:                               - CE_GOOD •À?                  No Error
6086:                               - CE_INVALID_FILENAME •À?      The specified filename was invalid.
6087:                               - CE_FILE_NOT_FOUND •À?        No file matching the specified criteria was found.
6088:                               - CE_BADCACHEREAD •À?          The file information for the file that was found
6089:                                                            could not be cached.
6090:                  FindNext     -
6091:                               - CE_GOOD •À?                  No Error
6092:                               - CE_NOT_INIT •À?              The SearchRec object was not initialized by a call to
6093:                                                            FindFirst.
6094:                               - CE_INVALID_ARGUMENT •À?      The SearchRec object was initialized in a different
6095:                                                            directory from the CWD.
6096:                               - CE_INVALID_FILENAME •À?      The filename is invalid.
6097:                               - CE_FILE_NOT_FOUND •À?        No file matching the specified criteria was found.
6098:                  FSfprintf    -
6099:                               - CE_GOOD •À?                  No Error
6100:                               - CE_WRITE_ERROR •À?           Characters could not be written to the file.
6101:                Description:
6102:                  The FSerror function will return the FSerrno variable.  This global
6103:                  variable will have been set to an error value during the last call of a
6104:                  library function.
6105:                Remarks:
6106:                  None
6107:                **************************************************************************/
6108:              
6109:              int FSerror (void)
6110:              {
007F8C  249380     MOV #0x4938, W0
007F8E  FB8010     ZE [W0], W0
6111:                  return FSerrno;
6112:              }
007F92  FA0002     LNK #0x2
007F94  BE9F88     MOV.D W8, [W15++]
007F96  BE9F8A     MOV.D W10, [W15++]
007F98  780400     MOV W0, W8
007F9A  784481     MOV.B W1, W9
6113:              
6114:              
6115:              /**************************************************************
6116:                Function:
6117:                  void FileObjectCopy(FILEOBJ foDest,FILEOBJ foSource)
6118:                Summary:
6119:                  Copy a file object
6120:                Conditions:
6121:                  This function should not be called by the user.
6122:                Input:
6123:                  foDest -    The destination
6124:                  foSource -  the source
6125:                Return:
6126:                  None
6127:                Side Effects:
6128:                  None
6129:                Description:
6130:                  The FileObjectCopy function will make an exacy copy of
6131:                  a specified FSFILE object.
6132:                Remarks:
6133:                  None
6134:                **************************************************************/
6135:              
6136:              void FileObjectCopy(FILEOBJ foDest,FILEOBJ foSource)
6137:              {
6138:                  int size;
6139:                  BYTE *dest;
6140:                  BYTE *source;
6141:                  int Index;
6142:              
6143:                  dest = (BYTE *)foDest;
6144:                  source = (BYTE *)foSource;
007A54  EB0100     CLR W2
007A56  2003C3     MOV #0x3C, W3
6145:              
6146:                  size = sizeof(FSFILE);
6147:              
6148:                  for(Index=0;Index< size; Index++)
007A5A  E80102     INC W2, W2
007A5C  510F83     SUB W2, W3, [W15]
007A5E  3AFFFC     BRA NZ, 0x7A58
6149:                  {
6150:                      dest[Index] = source[Index];
007A58  797061     MOV.B [W1+W2], [W0+W2]
6151:                  }
6152:              }
007A62  FA0008     LNK #0x8
007A64  BE9F88     MOV.D W8, [W15++]
007A66  BE9F8A     MOV.D W10, [W15++]
007A68  781F8C     MOV W12, [W15++]
6153:              
6154:              /*************************************************************************
6155:                Function:
6156:                  CETYPE FILECreateHeadCluster( FILEOBJ fo, DWORD *cluster)
6157:                Summary:
6158:                  Create the first cluster of a file
6159:                Conditions:
6160:                  This function should not be called by the user.
6161:                Input:
6162:                  fo -       Pointer to file structure
6163:                  cluster -  Cluster location
6164:                Return Values:
6165:                  CE_GOOD - File closed successfully
6166:                  CE_WRITE_ERROR - Could not write to the sector
6167:                  CE_DISK_FULL - All clusters in partition are taken
6168:                Side Effects:
6169:                  None
6170:                Description:
6171:                  The FILECreateHeadCluster function will create the first cluster
6172:                  of a file.  First, it will find an empty cluster with the
6173:                  FATfindEmptyCluster function and mark it as the last cluster in the
6174:                  file.  It will then erase the cluster using the EraseCluster function.
6175:                Remarks:
6176:                  None.
6177:                *************************************************************************/
6178:              
6179:              #ifdef ALLOW_WRITES
6180:              CETYPE FILECreateHeadCluster( FILEOBJ fo, DWORD *cluster)
6181:              {
6182:                  DISK *      disk;
6183:                  CETYPE        error = CE_GOOD;
6184:              
6185:                  disk = fo->dsk;
007B8E  780410     MOV [W0], W8
6186:              
6187:                  // find the next empty cluster
6188:                  *cluster = FATfindEmptyCluster(fo);
007B90  07FF68     RCALL FATfindEmptyCluster
007B92  BE0100     MOV.D W0, W2
007B94  BE8C80     MOV.D W0, [W9]
6189:              
6190:                  if(*cluster == 0)  // "0" is just an indication as Disk full in the fn "FATfindEmptyCluster()"
007B96  200150     MOV #0x15, W0
007B98  510FE0     SUB W2, #0x0, [W15]
007B9A  598FE0     SUBB W3, #0x0, [W15]
007B9C  320022     BRA Z, 0x7BE2
6191:                  {
6192:                      error = CE_DISK_FULL;
6193:                  }
6194:                  else
6195:                  {
6196:                      // mark the cluster as taken, and last in chain
6197:                      if(disk->type == FAT12)
007B9E  906028     MOV.B [W8+34], W0
007BA0  504FE1     SUB.B W0, #0x1, [W15]
007BA2  3A0004     BRA NZ, 0x7BAC
6198:                      {
6199:                          if(WriteFAT( disk, *cluster, LAST_CLUSTER_FAT12, FALSE) == CLUSTER_FAIL_FAT16)
007BA4  EB4080     CLR.B W1
007BA6  20FF84     MOV #0xFF8, W4
007BA8  200005     MOV #0x0, W5
007BAA  370005     BRA 0x7BB6
6200:                          {
6201:                              error = CE_WRITE_ERROR;
6202:                          }
6203:                      }
6204:                      else if(disk->type == FAT16)
007BAC  504FE2     SUB.B W0, #0x2, [W15]
007BAE  3A0009     BRA NZ, 0x7BC2
6205:                      {
6206:                          if(WriteFAT( disk, *cluster, LAST_CLUSTER_FAT16, FALSE) == CLUSTER_FAIL_FAT16)
007BB0  EB4080     CLR.B W1
007BB2  2FFF84     MOV #0xFFF8, W4
007BB4  200005     MOV #0x0, W5
007BB6  780008     MOV W8, W0
007BB8  07FABC     RCALL WriteFAT
007BBA  400FE1     ADD W0, #0x1, [W15]
007BBC  588FE0     SUBB W1, #0x0, [W15]
007BBE  3A000D     BRA NZ, 0x7BDA
007BC0  37000A     BRA 0x7BD6
6207:                          {
6208:                              error = CE_WRITE_ERROR;
6209:                          }
6210:                      }
6211:              
6212:               #ifdef SUPPORT_FAT32 // If FAT32 supported.
6213:                      else
6214:                      {
6215:                          if(WriteFAT( disk, *cluster, LAST_CLUSTER_FAT32, FALSE) == CLUSTER_FAIL_FAT32)
007BC2  EB4080     CLR.B W1
007BC4  2FFF84     MOV #0xFFF8, W4
007BC6  20FFF5     MOV #0xFFF, W5
007BC8  780008     MOV W8, W0
007BCA  07FAB3     RCALL WriteFAT
007BCC  2FFFF2     MOV #0xFFFF, W2
007BCE  20FFF3     MOV #0xFFF, W3
007BD0  500F82     SUB W0, W2, [W15]
007BD2  588F83     SUBB W1, W3, [W15]
007BD4  3A0002     BRA NZ, 0x7BDA
007BD6  200090     MOV #0x9, W0
007BD8  370004     BRA 0x7BE2
6216:                          {
6217:                              error = CE_WRITE_ERROR;
6218:                          }
6219:                      }
6220:              #endif
6221:              
6222:                      // lets erase this cluster
6223:                      if(error == CE_GOOD)
6224:                      {
6225:                          error = EraseCluster(disk,*cluster);
007BDA  BE0119     MOV.D [W9], W2
007BDC  780008     MOV W8, W0
007BDE  07FF9B     RCALL EraseCluster
007BE0  FB8000     ZE W0, W0
6226:                      }
6227:                  }
6228:              
6229:                  return(error);
6230:              } // allocate head cluster
007BE6  FA0006     LNK #0x6
007BE8  BE9F88     MOV.D W8, [W15++]
007BEA  780400     MOV W0, W8
6231:              #endif
6232:              
6233:              /*************************************************************************
6234:                Function:
6235:                  BYTE EraseCluster(DISK *disk, DWORD cluster)
6236:                Summary:
6237:                  Erase a cluster
6238:                Conditions:
6239:                  This function should not be called by the user.
6240:                Input:
6241:                  dsk -      Disk structure
6242:                  cluster -  Cluster to be erased
6243:                Return Values:
6244:                  CE_GOOD - File closed successfully
6245:                  CE_WRITE_ERROR - Could not write to the sector
6246:                Side Effects:
6247:                  None
6248:                Description:
6249:                  The EraseCluster function will write a 0 value into every byte of
6250:                  the specified cluster.
6251:                Remarks:
6252:                  None.
6253:                *************************************************************************/
6254:              
6255:              #ifdef ALLOW_WRITES
6256:              BYTE EraseCluster(DISK *disk, DWORD cluster)
6257:              {
6258:                  BYTE index;
6259:                  DWORD SectorAddress;
6260:                  BYTE error = CE_GOOD;
6261:              
6262:                  SectorAddress = Cluster2Sector(disk,cluster);
007B1E  07F9B3     RCALL Cluster2Sector
007B20  BE0600     MOV.D W0, W12
6263:                  if (gNeedDataWrite)
007B22  270BB0     MOV #0x70BB, W0
007B24  E00410     CP0.B [W0]
007B26  320004     BRA Z, 0x7B30
6264:                      if (flushData())
007B28  07F9FD     RCALL flushData
007B2A  200091     MOV #0x9, W1
007B2C  E00400     CP0.B W0
007B2E  3A0028     BRA NZ, 0x7B80
6265:                          return CE_WRITE_ERROR;
6266:              
6267:                  gBufferOwner = NULL;
007B30  EB0480     CLR W9
007B32  8B8609     MOV W9, gBufferOwner
6268:              
6269:                  if (gBufferZeroed == FALSE)
007B34  270B9A     MOV #0x70B9, W10
007B36  E0041A     CP0.B [W10]
007B38  3A000D     BRA NZ, 0x7B54
6270:                  {
6271:                      // clear out the memory first
6272:                      memset(disk->buffer, 0x00, disk->sectorSize);
007B3A  905888     MOV.B [W8+24], W1
007B3C  FB8081     ZE W1, W1
007B3E  905818     MOV.B [W8+25], W0
007B40  DD0048     SL W0, #8, W0
007B42  700101     IOR W0, W1, W2
007B44  FB8098     ZE [W8], W1
007B46  904018     MOV.B [W8+1], W0
007B48  DD0048     SL W0, #8, W0
007B4A  700001     IOR W0, W1, W0
007B4C  780089     MOV W9, W1
007B4E  07EDE8     RCALL memset
6273:                      gBufferZeroed = TRUE;
007B50  B3C010     MOV #0x1, W0
007B52  784D00     MOV.B W0, [W10]
007B54  BE020C     MOV.D W12, W4
007B56  37000D     BRA 0x7B72
6274:                  }
6275:              
6276:                  // Now clear them out
6277:                  for(index = 0; (index < disk->SecPerClus) && (error == CE_GOOD); index++)
007B72  52408C     SUB.B W4, W12, W1
007B74  906018     MOV.B [W8+33], W0
007B76  50CF80     SUB.B W1, W0, [W15]
007B78  310002     BRA C, 0x7B7E
007B7A  E00409     CP0.B W9
007B7C  32FFED     BRA Z, 0x7B58
6278:                  {
6279:                      if (MDD_SectorWrite( SectorAddress++, disk->buffer, FALSE) != TRUE)
007B58  420561     ADD W4, #0x1, W10
007B5A  4A85E0     ADDC W5, #0x0, W11
007B5C  FB8018     ZE [W8], W0
007B5E  904118     MOV.B [W8+1], W2
007B60  DD1148     SL W2, #8, W2
007B62  710100     IOR W2, W0, W2
007B64  784189     MOV.B W9, W3
007B66  BE0004     MOV.D W4, W0
007B68  072DB8     RCALL MDD_SDSPI_SectorWrite
007B6A  504FE1     SUB.B W0, #0x1, [W15]
007B6C  320001     BRA Z, 0x7B70
007B6E  B3C099     MOV #0x9, W9
007B70  BE020A     MOV.D W10, W4
6280:                          error = CE_WRITE_ERROR;
6281:                  }
6282:              
6283:                  return(error);
007B7E  FB8089     ZE W9, W1
6284:              }
007B8A  BE9F88     MOV.D W8, [W15++]
007B8C  780481     MOV W1, W9
6285:              #endif
6286:              
6287:              
6288:              #if defined (__C30__) || defined (__PIC32MX__)
6289:              
6290:              /***************************************************
6291:                Function:
6292:                  BYTE ReadByte(BYTE * pBuffer, WORD index)
6293:                Summary:
6294:                  Read a byte from a buffer
6295:                Conditions:
6296:                  This function should not be called by the user.
6297:                Input:
6298:                  pBuffer -  pointer to a buffer to read from
6299:                  index -    index in the buffer to read to
6300:                Return:
6301:                  BYTE - the byte read
6302:                Side Effects:
6303:                  None
6304:                Description:
6305:                  Reads a byte from a buffer
6306:                Remarks:
6307:                  None.
6308:                ***************************************************/
6309:              
6310:              BYTE ReadByte( BYTE* pBuffer, WORD index )
6311:              {
006EDA  78C060     MOV.B [W0+W1], W0
006EDC  FB8000     ZE W0, W0
6312:                  return( pBuffer[index] );
6313:              }
6314:              
6315:              
6316:              /***************************************************
6317:                Function:
6318:                  BYTE ReadWord(BYTE * pBuffer, WORD index)
6319:                Summary:
6320:                  Read a 16-bit word from a buffer
6321:                Conditions:
6322:                  This function should not be called by the user.
6323:                Input:
6324:                  pBuffer -  pointer to a buffer to read from
6325:                  index -    index in the buffer to read to
6326:                Return:
6327:                  WORD - the word read
6328:                Side Effects:
6329:                  None
6330:                Description:
6331:                  Reads a 16-bit word from a buffer
6332:                Remarks:
6333:                  None.
6334:                ***************************************************/
6335:              
6336:              WORD ReadWord( BYTE* pBuffer, WORD index )
6337:              {
6338:                  BYTE loByte, hiByte;
6339:                  WORD res;
6340:              
6341:                  loByte = pBuffer[index];
6342:                  hiByte = pBuffer[index+1];
6343:                  res = hiByte;
006EE0  400081     ADD W0, W1, W1
006EE2  904011     MOV.B [W1+1], W0
6344:                  res *= 0x100;
006EE4  DD0048     SL W0, #8, W0
006EE6  FB8091     ZE [W1], W1
006EE8  700001     IOR W0, W1, W0
6345:                  res |= loByte;
6346:                  return( res );
6347:              }
006EEC  BE9F88     MOV.D W8, [W15++]
006EEE  BE9F8A     MOV.D W10, [W15++]
006EF0  780480     MOV W0, W9
006EF2  780401     MOV W1, W8
6348:              
6349:              
6350:              /****************************************************
6351:                Function:
6352:                  BYTE ReadDWord(BYTE * pBuffer, WORD index)
6353:                Summary:
6354:                  Read a 32-bit double word from a buffer
6355:                Conditions:
6356:                  This function should not be called by the user.
6357:                Input:
6358:                  pBuffer -  pointer to a buffer to read from
6359:                  index -    index in the buffer to read to
6360:                Return:
6361:                  DWORD - the double word read
6362:                Side Effects:
6363:                  None
6364:                Description:
6365:                  Reads a 32-bit double word from a buffer
6366:                Remarks:
6367:                  None.
6368:                ****************************************************/
6369:              
6370:              DWORD ReadDWord( BYTE* pBuffer, WORD index )
6371:              {
6372:                  WORD loWord, hiWord;
6373:                  DWORD result;
6374:              
6375:                  loWord = ReadWord( pBuffer, index );
006EFE  780088     MOV W8, W1
006F00  780009     MOV W9, W0
006F02  07FFEE     RCALL ReadWord
006F04  200001     MOV #0x0, W1
006F06  750000     IOR W10, W0, W0
006F08  758081     IOR W11, W1, W1
6376:                  hiWord = ReadWord( pBuffer, index+2 );
006EF4  E88081     INC2 W1, W1
006EF6  07FFF4     RCALL ReadWord
006EF8  200001     MOV #0x0, W1
6377:              
6378:                  result = hiWord;
6379:                  result *= 0x10000;
006EFA  DD05C0     SL W0, #0, W11
006EFC  20000A     MOV #0x0, W10
6380:                  result |= loWord;
6381:                  return result;
6382:              }
006F10  780100     MOV W0, W2
6383:              
6384:              #endif
6385:              
6386:              
6387:              
6388:              /****************************************************
6389:                Function:
6390:                  DWORD Cluster2Sector(DISK * dsk, DWORD cluster)
6391:                Summary:
6392:                  Convert a cluster number to the corresponding sector
6393:                Conditions:
6394:                  This function should not be called by the user.
6395:                Input:
6396:                  disk -     Disk structure
6397:                  cluster -  Cluster to be converted
6398:                Return:
6399:                  sector - Sector that corresponds to given cluster
6400:                Side Effects:
6401:                  None
6402:                Description:
6403:                  The Cluster2Sector function will calculate the
6404:                  sector number that corresponds to the first sector
6405:                  of the cluster whose value was passed into the
6406:                  function.
6407:                Remarks:
6408:                  None.
6409:                ****************************************************/
6410:              
6411:              DWORD Cluster2Sector(DISK * dsk, DWORD cluster)
6412:              {
6413:                  DWORD sector;
6414:              
6415:                  /* Rt: Settings based on FAT type */
6416:                  switch (dsk->type)
006E8C  906020     MOV.B [W0+34], W0
006E8E  504FE3     SUB.B W0, #0x3, [W15]
006E90  320010     BRA Z, 0x6EB2
6417:                  {
6418:              #ifdef SUPPORT_FAT32 // If FAT32 supported.
6419:                      case FAT32:
6420:                          /* In FAT32, there is no separate ROOT region. It is as well stored in DATA region */
6421:                          sector = (((DWORD)cluster-2) * dsk->SecPerClus) + dsk->data;
6422:                          break;
6423:              #endif
6424:                      case FAT12:
6425:                      case FAT16:
6426:                      default:
6427:                          // The root dir takes up cluster 0 and 1
6428:                          if((cluster == 0) || (cluster == 1))
006E92  510FE1     SUB W2, #0x1, [W15]
006E94  598FE0     SUBB W3, #0x0, [W15]
006E96  3E000D     BRA GTU, 0x6EB2
6429:                              sector = dsk->root + cluster;
006E98  9048A8     MOV.B [W8+10], W1
006E9A  FB8081     ZE W1, W1
006E9C  904838     MOV.B [W8+11], W0
006E9E  DD0048     SL W0, #8, W0
006EA0  700101     IOR W0, W1, W2
006EA2  9048C8     MOV.B [W8+12], W1
006EA4  FB8081     ZE W1, W1
006EA6  904858     MOV.B [W8+13], W0
006EA8  DD0048     SL W0, #8, W0
006EAA  700181     IOR W0, W1, W3
006EAC  420002     ADD W4, W2, W0
006EAE  4A8083     ADDC W5, W3, W1
006EB0  370012     BRA 0x6ED6
6430:                          else
6431:                              sector = (((DWORD)cluster-2) * dsk->SecPerClus) + dsk->data;
006EB2  520062     SUB W4, #0x2, W0
006EB4  5A80E0     SUBB W5, #0x0, W1
006EB6  906118     MOV.B [W8+33], W2
006EB8  FB8102     ZE W2, W2
006EBA  200003     MOV #0x0, W3
006EBC  07F282     RCALL __mulp32eds3
006EBE  9049E8     MOV.B [W8+14], W3
006EC0  FB8183     ZE W3, W3
006EC2  904978     MOV.B [W8+15], W2
006EC4  DD1148     SL W2, #8, W2
006EC6  710203     IOR W2, W3, W4
006EC8  905188     MOV.B [W8+16], W3
006ECA  FB8183     ZE W3, W3
006ECC  905118     MOV.B [W8+17], W2
006ECE  DD1148     SL W2, #8, W2
006ED0  710283     IOR W2, W3, W5
006ED2  420000     ADD W4, W0, W0
006ED4  4A8081     ADDC W5, W1, W1
6432:                          break;
6433:                  }
6434:              
6435:                  return(sector);
6436:              
6437:              }
6438:              
6439:              
6440:              /***************************************************************************
6441:                Function:
6442:                  int FSattrib (FSFILE * file, unsigned char attributes)
6443:                Summary:
6444:                  Change the attributes of a file
6445:                Conditions:
6446:                  File opened
6447:                Input:
6448:                  file -        Pointer to file structure
6449:                  attributes -  The attributes to set for the file
6450:                             -  Attribute -      Value - Indications
6451:                             -  ATTR_READ_ONLY - 0x01  - The read-only attribute
6452:                             -  ATTR_HIDDEN -    0x02  - The hidden attribute
6453:                             -  ATTR_SYSTEM -    0x04  - The system attribute
6454:                             -  ATTR_ARCHIVE -   0x20  - The archive attribute
6455:                Return Values:
6456:                  0 -  Attribute change was successful
6457:                  -1 - Attribute change was unsuccessful
6458:                Side Effects:
6459:                  The FSerrno variable will be changed.
6460:                Description:
6461:                  The FSattrib funciton will set the attributes of the specified file
6462:                  to the attributes passed in by the user.  This function will load the
6463:                  file entry, replace the attributes with the ones specified, and write
6464:                  the attributes back.  If the specified file is a directory, the
6465:                  directory attribute will be preserved.
6466:                Remarks:
6467:                  None
6468:                ***************************************************************************/
6469:              
6470:              #ifdef ALLOW_WRITES
6471:              int FSattrib (FSFILE * file, unsigned char attributes)
6472:              {
6473:                  WORD fHandle;
6474:                  DIRENTRY dir;
6475:              
6476:                  FSerrno = CE_GOOD;
007F9C  24938A     MOV #0x4938, W10
007F9E  EB4D00     CLR.B [W10]
6477:              
6478:                  // Check for valid attributes
6479:                  if ((attributes & ~0x27) != 0)
007FA0  FB8581     ZE W1, W11
007FA2  78000B     MOV W11, W0
007FA4  B20D80     AND #0xD8, W0
007FA6  3A0011     BRA NZ, 0x7FCA
6480:                  {
6481:                      FSerrno = CE_INVALID_ARGUMENT;
6482:                      return -1;
6483:                  }
6484:              
6485:                  fHandle = file->entry;
007FA8  901078     MOV [W8+46], W0
007FAA  9FBFB0     MOV W0, [W15-10]
6486:              
6487:                  file->dirccls = file->dirclus;
007FAC  901828     MOV [W8+52], W0
007FAE  9018B8     MOV [W8+54], W1
007FB0  981C40     MOV W0, [W8+56]
007FB2  981C51     MOV W1, [W8+58]
6488:              
6489:                  // Get the file entry
6490:                  dir = LoadDirAttrib(file, &fHandle);
007FB4  5780EA     SUB W15, #0xA, W1
007FB6  780008     MOV W8, W0
007FB8  07FC98     RCALL LoadDirAttrib
6491:              
6492:                  if (dir == NULL)
007FBA  E00000     CP0 W0
007FBC  3A0003     BRA NZ, 0x7FC4
6493:                  {
6494:                      FSerrno = CE_BADCACHEREAD;
007FBE  B3C1B0     MOV #0x1B, W0
007FC0  784D00     MOV.B W0, [W10]
007FC2  370016     BRA 0x7FF0
6495:                      return -1;
6496:                  }
6497:              
6498:                  // Ensure that we aren't trying to change the
6499:                  // attributes of a volume entry
6500:                  if (dir->DIR_Attr & ATTR_VOLUME)
007FC4  904830     MOV.B [W0+11], W0
007FC6  A33800     BTST.Z W0, #3
007FC8  320002     BRA Z, 0x7FCE
6501:                  {
6502:                      FSerrno = CE_INVALID_ARGUMENT;
007FCA  B3C1F0     MOV #0x1F, W0
007FCC  37FFF9     BRA 0x7FC0
6503:                      return -1;
6504:                  }
6505:              
6506:                  // Don't remove the directory attribute from DIR files
6507:                  if (file->attributes & ATTR_DIRECTORY)
007FCE  901818     MOV [W8+50], W0
007FD0  A34800     BTST.Z W0, #4
007FD2  320004     BRA Z, 0x7FDC
6508:                      file->attributes = attributes | ATTR_DIRECTORY;
007FD4  A04409     BSET.B W9, #4
007FD6  FB8009     ZE W9, W0
007FD8  981C10     MOV W0, [W8+50]
007FDA  370001     BRA 0x7FDE
6509:                  else
6510:                      file->attributes = attributes;
007FDC  981C1B     MOV W11, [W8+50]
6511:              
6512:                  // just write the last entry in
6513:                  if(!Write_File_Entry(file,&fHandle))
007FDE  5780EA     SUB W15, #0xA, W1
007FE0  780008     MOV W8, W0
007FE2  07F865     RCALL Write_File_Entry
007FE4  EB0080     CLR W1
007FE6  E00400     CP0.B W0
007FE8  3A0004     BRA NZ, 0x7FF2
6514:                  {
6515:                      FSerrno = CE_WRITE_ERROR;
007FEA  B3C091     MOV #0x9, W1
007FEC  249380     MOV #0x4938, W0
007FEE  784801     MOV.B W1, [W0]
007FF0  EB8080     SETM W1
6516:                      return -1;
6517:                  }
6518:              
6519:                  return 0;
6520:              }
007FFC  4787F6     ADD W15, #0x16, W15
007FFE  BE9F88     MOV.D W8, [W15++]
008000  BE9F8A     MOV.D W10, [W15++]
008002  BE9F8C     MOV.D W12, [W15++]
008004  781F8E     MOV W14, [W15++]
008006  780700     MOV W0, W14
008008  780681     MOV W1, W13
00800A  780503     MOV W3, W10
6521:              #endif
6522:              
6523:              
6524:              /*********************************************************************************
6525:                Function:
6526:                  size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream)
6527:                Summary:
6528:                  Write data to a file
6529:                Conditions:
6530:                  File opened in FS_WRITE, FS_APPEND, FS_WRITE+, FS_APPEND+, FS_READ+ mode
6531:                Input:
6532:                  data_to_write -     Pointer to source buffer
6533:                  size -              Size of units in bytes
6534:                  n -                 Number of units to transfer
6535:                  stream -  Pointer to file structure
6536:                Return:
6537:                  size_t - number of units written
6538:                Side Effects:
6539:                  The FSerrno variable will be changed.
6540:                Description:
6541:                  The FSfwrite function will write data to a file.  First, the sector that
6542:                  corresponds to the current position in the file will be loaded (if it hasn't
6543:                  already been cached in the global data buffer).  Data will then be written to
6544:                  the device from the specified buffer until the specified amount has been written.
6545:                  If the end of a cluster is reached, the next cluster will be loaded, unless
6546:                  the end-of-file flag for the specified file has been set.  If it has, a new
6547:                  cluster will be allocated to the file.  Finally, the new position and filesize
6548:                  will be stored in the FSFILE object.  The parameters 'size' and 'n' indicate how
6549:                  much data to write.  'Size' refers to the size of one object to write (in bytes),
6550:                  and 'n' will refer to the number of these objects to write.  The value returned
6551:                  will be equal  to 'n' unless an error occured.
6552:                Remarks:
6553:                  None.
6554:                *********************************************************************************/
6555:              
6556:              #ifdef ALLOW_WRITES
6557:              size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream)
6558:              {
6559:                  DWORD       count = size * n;
00800C  B98902     MUL.SS W1, W2, W2
00800E  B81061     MUL.UU W2, #1, W0
008010  9FB7F0     MOV W0, [W15-18]
008012  9FBF81     MOV W1, [W15-16]
6560:                  BYTE   *    src = (BYTE *) data_to_write;
6561:                  DISK   *    dsk;                 // pointer to disk structure
6562:                  CETYPE      error = CE_GOOD;
6563:                  WORD        pos;
6564:                  DWORD       l;                     // absolute lba of sector to load
6565:                  DWORD       seek, filesize;
6566:                  WORD        writeCount = 0;
6567:              
6568:                  // see if the file was opened in a write mode
6569:                  if(!(stream->flags.write))
008014  90083A     MOV [W10+22], W0
008016  600261     AND W0, #0x1, W4
008018  3A0005     BRA NZ, 0x8024
6570:                  {
6571:                      FSerrno = CE_READONLY;
00801A  B3C1D1     MOV #0x1D, W1
00801C  249380     MOV #0x4938, W0
00801E  784801     MOV.B W1, [W0]
008020  780084     MOV W4, W1
008022  3700E7     BRA 0x81F2
6572:                      error = CE_WRITE_ERROR;
6573:                      return 0;
6574:                  }
6575:              
6576:                  if (count == 0)
008024  E00002     CP0 W2
008026  3A0002     BRA NZ, 0x802C
008028  780082     MOV W2, W1
00802A  3700E3     BRA 0x81F2
6577:                      return 0;
6578:              
6579:                  if (MDD_WriteProtectState())
00802C  072B70     RCALL MDD_SDSPI_WriteProtectState
00802E  784080     MOV.B W0, W1
008030  E00400     CP0.B W0
008032  320002     BRA Z, 0x8038
6580:                  {
6581:                      FSerrno = CE_WRITE_PROTECTED;
008034  B3C181     MOV #0x18, W1
008036  370019     BRA 0x806A
6582:                      error = CE_WRITE_PROTECTED;
6583:                      return 0;
6584:                  }
6585:              
6586:                  gBufferZeroed = FALSE;
008038  270B90     MOV #0x70B9, W0
00803A  784801     MOV.B W1, [W0]
6587:                  dsk = stream->dsk;
00803C  78059A     MOV [W10], W11
6588:                  // get the stated position
6589:                  pos = stream->pos;
00803E  90066A     MOV [W10+12], W12
6590:                  seek = stream->seek;
008040  90017A     MOV [W10+14], W2
008042  90098A     MOV [W10+16], W3
008044  9FB7D2     MOV W2, [W15-22]
008046  9FB7E3     MOV W3, [W15-20]
6591:                  l = Cluster2Sector(dsk,stream->ccls);
008048  90013A     MOV [W10+6], W2
00804A  9001CA     MOV [W10+8], W3
00804C  78000B     MOV W11, W0
00804E  07F71B     RCALL Cluster2Sector
6592:                  l += (WORD)stream->sec;      // add the sector number to it
008050  90015A     MOV [W10+10], W2
008052  400402     ADD W0, W2, W8
008054  4884E0     ADDC W1, #0x0, W9
6593:              
6594:                  // Check if the current stream was the last one to use the
6595:                  // buffer. If not, check if we need to write data from the
6596:                  // old stream
6597:                  if (gBufferOwner != stream)
008056  838600     MOV gBufferOwner, W0
008058  500F8A     SUB W0, W10, [W15]
00805A  32000C     BRA Z, 0x8074
6598:                  {
6599:                      if (gNeedDataWrite)
00805C  270BB0     MOV #0x70BB, W0
00805E  E00410     CP0.B [W0]
008060  320008     BRA Z, 0x8072
6600:                      {
6601:                          if (flushData())
008062  07F760     RCALL flushData
008064  E00400     CP0.B W0
008066  320005     BRA Z, 0x8072
6602:                          {
6603:                              FSerrno = CE_WRITE_ERROR;
008068  B3C091     MOV #0x9, W1
00806A  249380     MOV #0x4938, W0
00806C  784801     MOV.B W1, [W0]
00806E  EB0080     CLR W1
008070  3700C0     BRA 0x81F2
6604:                              return 0;
6605:                          }
6606:                      }
6607:                      gBufferOwner = stream;
008072  8B860A     MOV W10, gBufferOwner
6608:                  }
6609:                  if (gLastDataSectorRead != l)
008074  EB0100     CLR W2
008076  8385E0     MOV gLastDataSectorRead, W0
008078  8385F1     MOV 0x70BE, W1
00807A  500F88     SUB W0, W8, [W15]
00807C  588F89     SUBB W1, W9, [W15]
00807E  320017     BRA Z, 0x80AE
6610:                  {
6611:                      if (gNeedDataWrite)
008080  270BB0     MOV #0x70BB, W0
008082  E00410     CP0.B [W0]
008084  320003     BRA Z, 0x808C
6612:                      {
6613:                          if (flushData())
008086  07F74E     RCALL flushData
008088  E00400     CP0.B W0
00808A  3AFFEE     BRA NZ, 0x8068
6614:                          {
6615:                              FSerrno = CE_WRITE_ERROR;
6616:                              return 0;
6617:                          }
6618:                      }
6619:              
6620:                      gBufferZeroed = FALSE;
00808C  270B90     MOV #0x70B9, W0
00808E  EB4800     CLR.B [W0]
6621:                      if(!MDD_SectorRead( l, dsk->buffer) )
008090  FB801B     ZE [W11], W0
008092  90411B     MOV.B [W11+1], W2
008094  DD1148     SL W2, #8, W2
008096  710100     IOR W2, W0, W2
008098  BE0008     MOV.D W8, W0
00809A  072A23     RCALL MDD_SDSPI_SectorRead
00809C  EB0100     CLR W2
00809E  E00400     CP0.B W0
0080A0  3A0004     BRA NZ, 0x80AA
6622:                      {
6623:                          FSerrno = CE_BADCACHEREAD;
0080A2  B3C1B1     MOV #0x1B, W1
0080A4  249380     MOV #0x4938, W0
0080A6  784801     MOV.B W1, [W0]
0080A8  200082     MOV #0x8, W2
6624:                          error = CE_BAD_SECTOR_READ;
6625:                      }
6626:                      gLastDataSectorRead = l;
0080AA  8B85E8     MOV W8, gLastDataSectorRead
0080AC  8B85F9     MOV W9, 0x70BE
6627:                  }
6628:                  // exit loop if EOF reached
6629:                  filesize = stream->size;
0080AE  90081A     MOV [W10+18], W0
0080B0  9008AA     MOV [W10+20], W1
0080B2  9FB7B0     MOV W0, [W15-26]
0080B4  9FB7C1     MOV W1, [W15-24]
6630:              
6631:                  // Loop while writing bytes
6632:                  while ((error == CE_GOOD) && (count > 0))
0080B6  E00002     CP0 W2
0080B8  320010     BRA Z, 0x80DA
0080BA  97B15F     MOV [W15-22], W2
0080BC  97B1EF     MOV [W15-20], W3
0080BE  9FAFF2     MOV W2, [W15-34]
0080C0  9FB783     MOV W3, [W15-32]
0080C2  EB0480     CLR W9
0080C4  37008A     BRA 0x81DA
0080DA  97B05F     MOV [W15-22], W0
0080DC  97B0EF     MOV [W15-20], W1
0080DE  9FAFF0     MOV W0, [W15-34]
0080E0  9FB781     MOV W1, [W15-32]
0080E2  B81160     MUL.UU W2, #0, W2
0080E4  9FB792     MOV W2, [W15-30]
0080E6  9FB7A3     MOV W3, [W15-28]
0080E8  97B49F     MOV [W15-30], W9
0081D0  97B17F     MOV [W15-18], W2
0081D2  97B98F     MOV [W15-16], W3
0081D4  500F82     SUB W0, W2, [W15]
0081D6  588F83     SUBB W1, W3, [W15]
0081D8  3AFF87     BRA NZ, 0x80E8
6633:                  {
6634:                      if( seek == filesize )
0080EA  97A87F     MOV [W15-34], W0
0080EC  97B08F     MOV [W15-32], W1
0080EE  97B13F     MOV [W15-26], W2
0080F0  97B1CF     MOV [W15-24], W3
0080F2  500F82     SUB W0, W2, [W15]
0080F4  588F83     SUBB W1, W3, [W15]
0080F6  3A0003     BRA NZ, 0x80FE
6635:                          stream->flags.FileWriteEOF = TRUE;
0080F8  90083A     MOV [W10+22], W0
0080FA  A02000     BSET W0, #2
0080FC  980D30     MOV W0, [W10+22]
6636:              
6637:                      // load a new sector if necessary, multiples of sector
6638:                      if (pos == dsk->sectorSize)
0080FE  B86261     MUL.UU W12, #1, W4
008100  90588B     MOV.B [W11+24], W1
008102  FB8081     ZE W1, W1
008104  90581B     MOV.B [W11+25], W0
008106  DD0048     SL W0, #8, W0
008108  700101     IOR W0, W1, W2
00810A  9058AB     MOV.B [W11+26], W1
00810C  FB8081     ZE W1, W1
00810E  90583B     MOV.B [W11+27], W0
008110  DD0048     SL W0, #8, W0
008112  700181     IOR W0, W1, W3
008114  520F82     SUB W4, W2, [W15]
008116  5A8F83     SUBB W5, W3, [W15]
008118  3A0038     BRA NZ, 0x818A
6639:                      {
6640:                          BYTE needRead = TRUE;
6641:              
6642:                          if (gNeedDataWrite)
00811A  270BB0     MOV #0x70BB, W0
00811C  E00410     CP0.B [W0]
00811E  320003     BRA Z, 0x8126
6643:                              if (flushData())
008120  07F701     RCALL flushData
008122  E00400     CP0.B W0
008124  3AFFA1     BRA NZ, 0x8068
6644:                              {
6645:                                  FSerrno = CE_WRITE_ERROR;
6646:                                  return 0;
6647:                              }
6648:              
6649:                          // reset position
6650:                          pos = 0;
6651:              
6652:                          // point to the next sector
6653:                          stream->sec++;
008126  9000DA     MOV [W10+10], W1
008128  E80081     INC W1, W1
00812A  980551     MOV W1, [W10+10]
6654:              
6655:                          // get a new cluster if necessary
6656:                          if (stream->sec == dsk->SecPerClus)
00812C  90601B     MOV.B [W11+33], W0
00812E  FB8000     ZE W0, W0
008130  B3C01C     MOV #0x1, W12
008132  508F80     SUB W1, W0, [W15]
008134  3A0015     BRA NZ, 0x8160
6657:                          {
6658:                              stream->sec = 0;
008136  EB0400     CLR W8
008138  980558     MOV W8, [W10+10]
6659:              
6660:                              if(stream->flags.FileWriteEOF)
00813A  90083A     MOV [W10+22], W0
00813C  A32800     BTST.Z W0, #2
00813E  320006     BRA Z, 0x814C
6661:                              {
6662:                                  error = FILEallocate_new_cluster(stream, 0);    // add new cluster to the file
008140  784088     MOV.B W8, W1
008142  78000A     MOV W10, W0
008144  07FD6E     RCALL FILEallocate_new_cluster
008146  FB8080     ZE W0, W1
008148  784608     MOV.B W8, W12
00814A  370006     BRA 0x8158
6663:                                  needRead = FALSE;
6664:                              }
6665:                              else
6666:                                  error = FILEget_next_cluster( stream, 1);
00814C  200012     MOV #0x1, W2
00814E  200003     MOV #0x0, W3
008150  78000A     MOV W10, W0
008152  07FB26     RCALL FILEget_next_cluster
008154  FB8080     ZE W0, W1
008156  B3C01C     MOV #0x1, W12
6667:                          }
6668:              
6669:                          if (error == CE_DISK_FULL)
008158  508FF5     SUB W1, #0x15, [W15]
00815A  32FF87     BRA Z, 0x806A
6670:                          {
6671:                              FSerrno = CE_DISK_FULL;
6672:                              return 0;
6673:                          }
6674:              
6675:                          if(error == CE_GOOD)
0080C6  EB0600     CLR W12
0080C8  370088     BRA 0x81DA
00815C  E00001     CP0 W1
00815E  3AFFB3     BRA NZ, 0x80C6
6676:                          {
6677:                              l = Cluster2Sector(dsk,stream->ccls);
008160  90013A     MOV [W10+6], W2
008162  9001CA     MOV [W10+8], W3
008164  78000B     MOV W11, W0
008166  07F68F     RCALL Cluster2Sector
6678:                              l += (WORD)stream->sec;      // add the sector number to it
008168  90015A     MOV [W10+10], W2
00816A  400402     ADD W0, W2, W8
00816C  4884E0     ADDC W1, #0x0, W9
6679:                              gBufferOwner = stream;
00816E  8B860A     MOV W10, gBufferOwner
6680:                              // If we just allocated a new cluster, then the cluster will
6681:                              // contain garbage data, so it doesn't matter what we write to it
6682:                              // Whatever is in the buffer will work fine
6683:                              if (needRead)
008170  E0040C     CP0.B W12
008172  320008     BRA Z, 0x8184
6684:                              {
6685:                                  if( !MDD_SectorRead( l, dsk->buffer) )
008174  FB801B     ZE [W11], W0
008176  90411B     MOV.B [W11+1], W2
008178  DD1148     SL W2, #8, W2
00817A  710100     IOR W2, W0, W2
00817C  BE0008     MOV.D W8, W0
00817E  0729B1     RCALL MDD_SDSPI_SectorRead
008180  E00400     CP0.B W0
008182  32FFA3     BRA Z, 0x80CA
6686:                                  {
6687:                                      FSerrno = CE_BADCACHEREAD;
0080CA  B3C1B1     MOV #0x1B, W1
0080CC  249380     MOV #0x4938, W0
0080CE  784801     MOV.B W1, [W0]
6688:                                      error = CE_BAD_SECTOR_READ;
6689:                                      gLastDataSectorRead = 0xFFFFFFFF;
0080D0  EB8000     SETM W0
0080D2  EB8080     SETM W1
0080D4  8B85E0     MOV W0, gLastDataSectorRead
0080D6  8B85F1     MOV W1, 0x70BE
0080D8  37FFCA     BRA 0x806E
6690:                                      return 0;
6691:                                  }
6692:                                  else
6693:                                  {
6694:                                      gLastDataSectorRead = l;
6695:                                  }
6696:                              }
6697:                              else
6698:                                  gLastDataSectorRead = l;
008184  8B85E8     MOV W8, gLastDataSectorRead
008186  8B85F9     MOV W9, 0x70BE
008188  EB0600     CLR W12
6699:                          }
6700:                      } //  load new sector
6701:              
6702:                      if(error == CE_GOOD)
6703:                      {
6704:                          // Write one byte at a time
6705:                          RAMwrite(dsk->buffer, pos++, *(char *)src);
00818A  FB801B     ZE [W11], W0
00818C  90409B     MOV.B [W11+1], W1
00818E  DD08C8     SL W1, #8, W1
008190  708080     IOR W1, W0, W1
008192  97B11F     MOV [W15-30], W2
008194  97B1AF     MOV [W15-28], W3
008196  7941EE     MOV.B [W14+W2], W3
008198  7E7083     MOV.B W3, [W1+W12]
00819A  E8060C     INC W12, W12
6706:                          src = src + 1; // compiler bug
6707:                          seek++;
00819C  97A87F     MOV [W15-34], W0
00819E  97B08F     MOV [W15-32], W1
0081A0  400061     ADD W0, #0x1, W0
0081A2  4880E0     ADDC W1, #0x0, W1
0081A4  9FAFF0     MOV W0, [W15-34]
0081A6  9FB781     MOV W1, [W15-32]
0081A8  97B0DF     MOV [W15-22], W1
0081AA  500481     SUB W0, W1, W9
6708:                          count--;
6709:                          writeCount++;
6710:                          // now increment the size of the part
6711:                          if(stream->flags.FileWriteEOF)
0081AC  90083A     MOV [W10+22], W0
0081AE  A32800     BTST.Z W0, #2
0081B0  320006     BRA Z, 0x81BE
6712:                              filesize++;
0081B2  97B13F     MOV [W15-26], W2
0081B4  97B1CF     MOV [W15-24], W3
0081B6  410161     ADD W2, #0x1, W2
0081B8  4981E0     ADDC W3, #0x0, W3
0081BA  9FB7B2     MOV W2, [W15-26]
0081BC  9FB7C3     MOV W3, [W15-24]
6713:                          gNeedDataWrite = TRUE;
0081BE  B3C011     MOV #0x1, W1
0081C0  270BB0     MOV #0x70BB, W0
0081C2  784801     MOV.B W1, [W0]
0081C4  97B01F     MOV [W15-30], W0
0081C6  97B0AF     MOV [W15-28], W1
0081C8  400061     ADD W0, #0x1, W0
0081CA  4880E0     ADDC W1, #0x0, W1
0081CC  9FB790     MOV W0, [W15-30]
0081CE  9FB7A1     MOV W1, [W15-28]
6714:                      }
6715:                  } // while count
6716:              
6717:                  // save off the positon
6718:                  stream->pos = pos;
0081DA  98056C     MOV W12, [W10+12]
6719:              
6720:                  // save off the seek
6721:                  stream->seek = seek;
0081DC  97A87F     MOV [W15-34], W0
0081DE  97B08F     MOV [W15-32], W1
0081E0  980570     MOV W0, [W10+14]
0081E2  980D01     MOV W1, [W10+16]
6722:              
6723:                  // now the new size
6724:                  stream->size = filesize;
0081E4  97B13F     MOV [W15-26], W2
0081E6  97B1CF     MOV [W15-24], W3
0081E8  980D12     MOV W2, [W10+18]
0081EA  980D23     MOV W3, [W10+20]
6725:              
6726:                  return(writeCount / size);
0081EC  090011     REPEAT #0x11
0081EE  D8848D     DIV.UW W9, W13
0081F0  FD0080     EXCH W0, W1
6727:              } // fwrite
6728:              #endif
6729:              
6730:              
6731:              /**********************************************************
6732:                Function:
6733:                  BYTE flushData (void)
6734:                Summary:
6735:                  Flush unwritten data to a file
6736:                Conditions:
6737:                  File opened in a write mode, data needs to be written
6738:                Return Values:
6739:                  CE_GOOD -        Data was updated successfully
6740:                  CE_WRITE_ERROR - Data could not be updated
6741:                Side Effects:
6742:                  None
6743:                Description:
6744:                  The flushData function is called when it is necessary to
6745:                  read new data into the global data buffer and the
6746:                  gNeedDataWrite variable indicates that there is data
6747:                  in the buffer that hasn't been written to the device.
6748:                  The flushData function will write the data from the
6749:                  buffer into the current cluster of the FSFILE object
6750:                  that is stored in the gBufferOwner global variable.
6751:                Remarks:
6752:                  None
6753:                **********************************************************/
6754:              
6755:              #ifdef ALLOW_WRITES
6756:              BYTE flushData (void)
6757:              {
6758:                  DWORD l;
6759:                  DISK * dsk;
6760:              
6761:                  // This will either be the pointer to the last file, or the handle
6762:                  FILEOBJ stream = gBufferOwner;
006F26  838609     MOV gBufferOwner, W9
6763:              
6764:                  dsk = stream->dsk;
006F28  780419     MOV [W9], W8
6765:              
6766:                  // figure out the lba
6767:                  l = Cluster2Sector(dsk,stream->ccls);
006F2A  900139     MOV [W9+6], W2
006F2C  9001C9     MOV [W9+8], W3
006F2E  780008     MOV W8, W0
006F30  07FFAA     RCALL Cluster2Sector
006F32  BE0200     MOV.D W0, W4
6768:                  l += (WORD)stream->sec;      // add the sector number to it
6769:              
6770:                  if(!MDD_SectorWrite( l, dsk->buffer, FALSE))
006F34  FB8018     ZE [W8], W0
006F36  904118     MOV.B [W8+1], W2
006F38  DD1148     SL W2, #8, W2
006F3A  710100     IOR W2, W0, W2
006F3C  900059     MOV [W9+10], W0
006F3E  420000     ADD W4, W0, W0
006F40  4A80E0     ADDC W5, #0x0, W1
006F42  EB4180     CLR.B W3
006F44  0733CA     RCALL MDD_SDSPI_SectorWrite
006F46  200091     MOV #0x9, W1
006F48  E00400     CP0.B W0
006F4A  320003     BRA Z, 0x6F52
6771:                  {
6772:                      return CE_WRITE_ERROR;
6773:                  }
6774:              
6775:                  gNeedDataWrite = FALSE;
006F4C  270BB0     MOV #0x70BB, W0
006F4E  EB4800     CLR.B [W0]
006F50  EB0080     CLR W1
6776:              
6777:                  return CE_GOOD;
6778:              }
006F58  4787E6     ADD W15, #0x6, W15
006F5A  BE9F88     MOV.D W8, [W15++]
006F5C  BE9F8A     MOV.D W10, [W15++]
006F5E  BE9F8C     MOV.D W12, [W15++]
006F60  781F8E     MOV W14, [W15++]
006F62  BE0600     MOV.D W0, W12
006F64  9FB7F2     MOV W2, [W15-18]
006F66  9FBF83     MOV W3, [W15-16]
6779:              #endif
6780:              
6781:              /****************************************************
6782:                Function:
6783:                  int FSfeof( FSFILE * stream )
6784:                Summary:
6785:                  Indicate whether the current file position is at the end
6786:                Conditions:
6787:                  File is open in a read mode
6788:                Input:
6789:                  stream -  Pointer to the target file
6790:                Return Values:
6791:                  Non-Zero - EOF reached
6792:                  0 - Not at end of File
6793:                Side Effects:
6794:                  The FSerrno variable will be changed.
6795:                Description:
6796:                  The FSfeof function will indicate that the end-of-
6797:                  file has been reached for the specified file by
6798:                  comparing the absolute location in the file to the
6799:                  size of the file.
6800:                Remarks:
6801:                  None.
6802:                ****************************************************/
6803:              
6804:              int FSfeof( FSFILE * stream )
6805:              {
6806:                  FSerrno = CE_GOOD;
008200  249381     MOV #0x4938, W1
008202  EB4880     CLR.B [W1]
008204  EB0200     CLR W4
008206  900170     MOV [W0+14], W2
008208  900980     MOV [W0+16], W3
00820A  9008A0     MOV [W0+20], W1
00820C  900810     MOV [W0+18], W0
00820E  510F80     SUB W2, W0, [W15]
008210  598F81     SUBB W3, W1, [W15]
008212  3A0001     BRA NZ, 0x8216
008214  200014     MOV #0x1, W4
6807:                  return( stream->seek == stream->size );
6808:              }
00821A  4787F0     ADD W15, #0x10, W15
00821C  BE9F88     MOV.D W8, [W15++]
00821E  BE9F8A     MOV.D W10, [W15++]
008220  BE9F8C     MOV.D W12, [W15++]
008222  781F8E     MOV W14, [W15++]
008224  9FBF80     MOV W0, [W15-16]
008226  780681     MOV W1, W13
008228  780483     MOV W3, W9
6809:              
6810:              
6811:              /**************************************************************************
6812:                Function:
6813:                  size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream)
6814:                Summary:
6815:                  Read data from a file
6816:                Conditions:
6817:                  File is opened in a read mode
6818:                Input:
6819:                  ptr -     Destination buffer for read bytes
6820:                  size -    Size of units in bytes
6821:                  n -       Number of units to be read
6822:                  stream -  File to be read from
6823:                Return:
6824:                  size_t - number of units read
6825:                Side Effects:
6826:                  The FSerrno variable will be changed.
6827:                Description:
6828:                  The FSfread function will read data from the specified file.  First,
6829:                  the appropriate sector of the file is loaded.  Then, data is read into
6830:                  the specified buffer until the specified number of bytes have been read.
6831:                  When a cluster boundary is reached, a new cluster will be loaded.  The
6832:                  parameters 'size' and 'n' indicate how much data to read.  'Size'
6833:                  refers to the size of one object to read (in bytes), and 'n' will refer
6834:                  to the number of these objects to read.  The value returned will be equal
6835:                  to 'n' unless an error occured or the user tried to read beyond the end
6836:                  of the file.
6837:                Remarks:
6838:                  None.
6839:                **************************************************************************/
6840:              
6841:              size_t FSfread (void *ptr, size_t size, size_t n, FSFILE *stream)
6842:              {
6843:                  DWORD   len = size * n;
00822A  B98802     MUL.SS W1, W2, W0
00822C  200001     MOV #0x0, W1
00822E  9FB7E0     MOV W0, [W15-20]
008230  9FB7F1     MOV W1, [W15-18]
6844:                  BYTE    *pointer = (BYTE *) ptr;
6845:                  DISK    *dsk;               // Disk structure
6846:                  DWORD    seek, sec_sel;
6847:                  WORD    pos;       //position within sector
6848:                  CETYPE   error = CE_GOOD;
6849:                  WORD    readCount = 0;
6850:              
6851:                  FSerrno = CE_GOOD;
008232  24938A     MOV #0x4938, W10
008234  EB4D00     CLR.B [W10]
6852:              
6853:                  dsk    = (DISK *)stream->dsk;
008236  780413     MOV [W3], W8
6854:                  pos    = stream->pos;
008238  900663     MOV [W3+12], W12
6855:                  seek    = stream->seek;
00823A  900073     MOV [W3+14], W0
00823C  900883     MOV [W3+16], W1
00823E  9FB7C0     MOV W0, [W15-24]
008240  9FB7D1     MOV W1, [W15-22]
6856:              
6857:                  if( !stream->flags.read )
008242  900833     MOV [W3+22], W0
008244  6000E2     AND W0, #0x2, W1
008246  3A0003     BRA NZ, 0x824E
6858:                  {
6859:                      FSerrno = CE_WRITEONLY;
008248  B3C1E0     MOV #0x1E, W0
00824A  784D00     MOV.B W0, [W10]
00824C  3700A4     BRA 0x8396
6860:                      return 0;   // CE_WRITEONLY
6861:                  }
6862:              
6863:              #ifdef ALLOW_WRITES
6864:                  if (gNeedDataWrite)
00824E  270BB0     MOV #0x70BB, W0
008250  E00410     CP0.B [W0]
008252  320006     BRA Z, 0x8260
6865:                      if (flushData() != CE_GOOD)
008254  07F667     RCALL flushData
008256  E00400     CP0.B W0
008258  320003     BRA Z, 0x8260
6866:                      {
6867:                          FSerrno = CE_WRITE_ERROR;
00825A  B3C090     MOV #0x9, W0
00825C  784D00     MOV.B W0, [W10]
00825E  370026     BRA 0x82AC
6868:                          return 0;
6869:                      }
6870:              #endif
6871:              
6872:                  // if it not my buffer, then get it from the disk.
6873:                  if( (gBufferOwner != stream) && (pos != dsk->sectorSize))
008260  838600     MOV gBufferOwner, W0
008262  500F89     SUB W0, W9, [W15]
008264  320035     BRA Z, 0x82D0
008266  B86261     MUL.UU W12, #1, W4
008268  905888     MOV.B [W8+24], W1
00826A  FB8081     ZE W1, W1
00826C  905818     MOV.B [W8+25], W0
00826E  DD0048     SL W0, #8, W0
008270  700101     IOR W0, W1, W2
008272  9058A8     MOV.B [W8+26], W1
008274  FB8081     ZE W1, W1
008276  905838     MOV.B [W8+27], W0
008278  DD0048     SL W0, #8, W0
00827A  700181     IOR W0, W1, W3
00827C  520F82     SUB W4, W2, [W15]
00827E  5A8F83     SUBB W5, W3, [W15]
008280  320027     BRA Z, 0x82D0
6874:                  {
6875:                      gBufferOwner = stream;
008282  8B8609     MOV W9, gBufferOwner
6876:                      sec_sel = Cluster2Sector(dsk,stream->ccls);
008284  900139     MOV [W9+6], W2
008286  9001C9     MOV [W9+8], W3
008288  780008     MOV W8, W0
00828A  07F5FD     RCALL Cluster2Sector
6877:                      sec_sel += (WORD)stream->sec;      // add the sector number to it
00828C  900159     MOV [W9+10], W2
00828E  400502     ADD W0, W2, W10
008290  4885E0     ADDC W1, #0x0, W11
6878:              
6879:                      gBufferZeroed = FALSE;
008292  270B90     MOV #0x70B9, W0
008294  EB4800     CLR.B [W0]
6880:                      if( !MDD_SectorRead( sec_sel, dsk->buffer) )
008296  FB8018     ZE [W8], W0
008298  904118     MOV.B [W8+1], W2
00829A  DD1148     SL W2, #8, W2
00829C  710100     IOR W2, W0, W2
00829E  BE000A     MOV.D W10, W0
0082A0  072920     RCALL MDD_SDSPI_SectorRead
0082A2  E00400     CP0.B W0
0082A4  3A0013     BRA NZ, 0x82CC
6881:                      {
6882:                          FSerrno = CE_BAD_SECTOR_READ;
0082A6  B3C081     MOV #0x8, W1
0082A8  249380     MOV #0x4938, W0
0082AA  784801     MOV.B W1, [W0]
0082AC  EB0080     CLR W1
0082AE  370073     BRA 0x8396
6883:                          error = CE_BAD_SECTOR_READ;
6884:                          return 0;
6885:                      }
6886:                      gLastDataSectorRead = sec_sel;
0082CC  8B85EA     MOV W10, gLastDataSectorRead
0082CE  8B85FB     MOV W11, 0x70BE
0082D0  B81160     MUL.UU W2, #0, W2
0082D2  9FB7A2     MOV W2, [W15-28]
0082D4  9FB7B3     MOV W3, [W15-26]
0082D6  37004F     BRA 0x8376
6887:                  }
6888:              
6889:                  //loop reading (count) bytes
6890:                  while( len )
008378  97B12F     MOV [W15-28], W2
00837A  97B1BF     MOV [W15-26], W3
00837C  97B06F     MOV [W15-20], W0
00837E  97B0FF     MOV [W15-18], W1
008380  510F80     SUB W2, W0, [W15]
008382  598F81     SUBB W3, W1, [W15]
008384  3AFFA9     BRA NZ, 0x82D8
6891:                  {
6892:                      if( seek == stream->size )
0082D8  900819     MOV [W9+18], W0
0082DA  9008A9     MOV [W9+20], W1
0082DC  97B14F     MOV [W15-24], W2
0082DE  97B1DF     MOV [W15-22], W3
0082E0  510F80     SUB W2, W0, [W15]
0082E2  598F81     SUBB W3, W1, [W15]
0082E4  32FFE5     BRA Z, 0x82B0
6893:                      {
6894:                          FSerrno = CE_EOF;
0082B0  B3C3D1     MOV #0x3D, W1
0082B2  249380     MOV #0x4938, W0
0082B4  784801     MOV.B W1, [W0]
0082B6  370067     BRA 0x8386
6895:                          error = CE_EOF;
6896:                          break;
6897:                      }
6898:              
6899:                      // In fopen, pos is init to 0 and the sect is loaded
6900:                      if( pos == dsk->sectorSize )
0082E6  B86261     MUL.UU W12, #1, W4
0082E8  905888     MOV.B [W8+24], W1
0082EA  FB8081     ZE W1, W1
0082EC  905818     MOV.B [W8+25], W0
0082EE  DD0048     SL W0, #8, W0
0082F0  700101     IOR W0, W1, W2
0082F2  9058A8     MOV.B [W8+26], W1
0082F4  FB8081     ZE W1, W1
0082F6  905838     MOV.B [W8+27], W0
0082F8  DD0048     SL W0, #8, W0
0082FA  700181     IOR W0, W1, W3
0082FC  520F82     SUB W4, W2, [W15]
0082FE  5A8F83     SUBB W5, W3, [W15]
008300  3A0024     BRA NZ, 0x834A
6901:                      {
6902:                          // reset position
6903:                          pos = 0;
6904:                          // point to the next sector
6905:                          stream->sec++;
008302  9000D9     MOV [W9+10], W1
008304  E80081     INC W1, W1
008306  9804D1     MOV W1, [W9+10]
6906:              
6907:                          // get a new cluster if necessary
6908:                          if( stream->sec == dsk->SecPerClus )
008308  906018     MOV.B [W8+33], W0
00830A  FB8000     ZE W0, W0
00830C  508F80     SUB W1, W0, [W15]
00830E  3A0008     BRA NZ, 0x8320
6909:                          {
6910:                              stream->sec = 0;
008310  EB0500     CLR W10
008312  9804DA     MOV W10, [W9+10]
6911:                              if( (error = FILEget_next_cluster( stream, 1)) != CE_GOOD )
008314  200012     MOV #0x1, W2
008316  200003     MOV #0x0, W3
008318  780009     MOV W9, W0
00831A  07FA42     RCALL FILEget_next_cluster
00831C  E00400     CP0.B W0
00831E  3AFFCC     BRA NZ, 0x82B8
6912:                              {
6913:                                  FSerrno = CE_COULD_NOT_GET_CLUSTER;
0082B8  B3C0F1     MOV #0xF, W1
0082BA  249380     MOV #0x4938, W0
0082BC  784801     MOV.B W1, [W0]
0082BE  78060A     MOV W10, W12
0082C0  370062     BRA 0x8386
6914:                                  break;
6915:                              }
6916:                          }
6917:              
6918:                          sec_sel = Cluster2Sector(dsk,stream->ccls);
008320  900139     MOV [W9+6], W2
008322  9001C9     MOV [W9+8], W3
008324  780008     MOV W8, W0
008326  07F5AF     RCALL Cluster2Sector
6919:                          sec_sel += (WORD)stream->sec;      // add the sector number to it
008328  900159     MOV [W9+10], W2
00832A  400502     ADD W0, W2, W10
00832C  4885E0     ADDC W1, #0x0, W11
6920:              
6921:              
6922:                          gBufferOwner = stream;
00832E  8B8609     MOV W9, gBufferOwner
6923:                          gBufferZeroed = FALSE;
008330  270B90     MOV #0x70B9, W0
008332  EB4800     CLR.B [W0]
6924:                          if( !MDD_SectorRead( sec_sel, dsk->buffer) )
008334  FB8018     ZE [W8], W0
008336  904118     MOV.B [W8+1], W2
008338  DD1148     SL W2, #8, W2
00833A  710100     IOR W2, W0, W2
00833C  BE000A     MOV.D W10, W0
00833E  0728D1     RCALL MDD_SDSPI_SectorRead
008340  E00400     CP0.B W0
008342  32FFBF     BRA Z, 0x82C2
6925:                          {
6926:                              FSerrno = CE_BAD_SECTOR_READ;
0082C2  B3C081     MOV #0x8, W1
0082C4  249380     MOV #0x4938, W0
0082C6  784801     MOV.B W1, [W0]
0082C8  EB0600     CLR W12
0082CA  37005D     BRA 0x8386
6927:                              error = CE_BAD_SECTOR_READ;
6928:                              break;
6929:                          }
6930:                          gLastDataSectorRead = sec_sel;
008344  8B85EA     MOV W10, gLastDataSectorRead
008346  8B85FB     MOV W11, 0x70BE
008348  EB0600     CLR W12
6931:                      }
6932:              
6933:                      // copy one byte at a time
6934:                      *pointer = RAMread( dsk->buffer, pos++ );
00834A  FB8098     ZE [W8], W1
00834C  904018     MOV.B [W8+1], W0
00834E  DD0048     SL W0, #8, W0
008350  700001     IOR W0, W1, W0
008352  7E4060     MOV.B [W0+W12], W0
008354  97B88F     MOV [W15-16], W1
008356  97B12F     MOV [W15-28], W2
008358  97B1BF     MOV [W15-26], W3
00835A  797080     MOV.B W0, [W1+W2]
00835C  E8060C     INC W12, W12
6935:                      pointer++;
6936:                      seek++;
00835E  97B14F     MOV [W15-24], W2
008360  97B1DF     MOV [W15-22], W3
008362  410161     ADD W2, #0x1, W2
008364  4981E0     ADDC W3, #0x0, W3
008366  9FB7C2     MOV W2, [W15-24]
008368  9FB7D3     MOV W3, [W15-22]
00836A  97B02F     MOV [W15-28], W0
00836C  97B0BF     MOV [W15-26], W1
00836E  400061     ADD W0, #0x1, W0
008370  4880E0     ADDC W1, #0x0, W1
008372  9FB7A0     MOV W0, [W15-28]
008374  9FB7B1     MOV W1, [W15-26]
008376  97B72F     MOV [W15-28], W14
6937:                      readCount++;
6938:                      len--;
6939:                  }
6940:              
6941:                  // save off the positon
6942:                  stream->pos = pos;
008386  9804EC     MOV W12, [W9+12]
6943:                  // save off the seek
6944:                  stream->seek = seek;
008388  97B14F     MOV [W15-24], W2
00838A  97B1DF     MOV [W15-22], W3
00838C  9804F2     MOV W2, [W9+14]
00838E  980C83     MOV W3, [W9+16]
6945:              
6946:                  return(readCount / size);
008390  090011     REPEAT #0x11
008392  D8870D     DIV.UW W14, W13
008394  FD0080     EXCH W0, W1
6947:              } // fread
0083A4  BE9F88     MOV.D W8, [W15++]
0083A6  BE9F8A     MOV.D W10, [W15++]
0083A8  BE9F8C     MOV.D W12, [W15++]
0083AA  781F8E     MOV W14, [W15++]
0083AC  784580     MOV.B W0, W11
6948:              
6949:              
6950:              /***************************************************************************
6951:                Function:
6952:                  BYTE FormatFileName( const char* fileName, FILEOBJ fptr, BYTE mode )
6953:                Summary:
6954:                  Format a file name into dir entry format
6955:                Conditions:
6956:                  This function should not be called by the user.
6957:                Input:
6958:                  fileName -  The name to be formatted
6959:                  fN2 -       The location the formatted name will be stored
6960:                  mode -      Non-zero if parital string search chars are allowed
6961:                Return Values:
6962:                  TRUE - Name formatted successfully
6963:                  FALSE - File name could not be formatted
6964:                Side Effects:
6965:                  None
6966:                Description:
6967:                  Format an 8.3 filename into FSFILE structure format. If filename is less
6968:                  than 8 chars, then it will be padded with spaces. If the extension name is
6969:                  fewer than 3 chars, then it will also be oadded with spaces. The
6970:                  ValidateChars function is used to ensure the characters in the specified
6971:                  filename are valid in this filesystem.
6972:                Remarks:
6973:                  None.
6974:                ***************************************************************************/
6975:              BYTE FormatFileName( const char* fileName, FILEOBJ fptr, BYTE mode)
6976:              {
6977:              	char *fN2;
6978:              	FILE_DIR_NAME_TYPE fileNameType;
6979:                  int temp,count1,count2,count3,count4;
6980:                  BOOL supportLFN = FALSE;
6981:              	char *localFileName = NULL;
6982:              
6983:              	// go with static allocation
6984:              	#if defined(SUPPORT_LFN)
6985:              		unsigned short int tempString[256];
6986:              		BOOL	AscciIndication = TRUE;
6987:              		count1 = 256;
6988:              	#else
6989:              		unsigned short int	tempString[13];
6990:              		count1 = 12;
6991:              	#endif
6992:              
6993:              	// Check whether the length of the file name is valid
6994:              	// for LFN support as well as Non LFN support
6995:              	#ifdef SUPPORT_LFN
6996:              	if(utfModeFileName)
008580  8385A9     MOV utfModeFileName, W9
008582  E00009     CP0 W9
008584  320023     BRA Z, 0x85CC
6997:              	{
6998:              		utf16Filename = (unsigned short int *)fileName;
008586  8A42A0     MOV W0, utf16Filename
6999:              		fileNameLength = 0;
008588  EB0000     CLR W0
00858A  370001     BRA 0x858E
7000:              		while(utf16Filename[fileNameLength])
008590  8242B2     MOV fileNameLength, W2
008592  410002     ADD W2, W2, W0
008594  400008     ADD W0, W8, W0
008596  E00010     CP0 [W0]
008598  3AFFF9     BRA NZ, 0x858C
7001:              		{
7002:              			fileNameLength++;
00858C  E80002     INC W2, W0
00858E  8A42B0     MOV W0, fileNameLength
7003:              		}
7004:              
7005:              		if((fileNameLength > count1) || (*utf16Filename == '.') ||
00859A  201000     MOV #0x100, W0
00859C  510F80     SUB W2, W0, [W15]
00859E  3E00DC     BRA GTU, 0x8758
0085A0  780098     MOV [W8], W1
0085A2  2002E0     MOV #0x2E, W0
0085A4  508F80     SUB W1, W0, [W15]
0085A6  3200D8     BRA Z, 0x8758
0085A8  E00001     CP0 W1
0085AA  3200D6     BRA Z, 0x8758
0085AC  780008     MOV W8, W0
0085AE  EB0080     CLR W1
0085B0  2FDF83     MOV #0xFDF8, W3
0085B2  41818F     ADD W3, W15, W3
0085B4  370002     BRA 0x85BA
7006:              			(*utf16Filename == 0))
7007:              		{
7008:              			return FALSE;
7009:              		}
7010:              		
7011:              		for (count1 = 0;count1 < fileNameLength; count1++)
0085B8  E80081     INC W1, W1
0085BA  508F82     SUB W1, W2, [W15]
0085BC  39FFFC     BRA NC, 0x85B6
7012:              		{
7013:              			tempString[count1] = utf16Filename[count1];
0085B6  7819B0     MOV [W0++], [W3++]
7014:              		}
7015:              		
7016:              		utf16Filename = tempString;
0085BE  2FDF80     MOV #0xFDF8, W0
0085C0  40000F     ADD W0, W15, W0
0085C2  8A42A0     MOV W0, utf16Filename
0085C4  370019     BRA 0x85F8
7017:              	}
7018:              	else
7019:              	#endif
7020:              	{
7021:              		fileNameLength = strlen(fileName);
0085CC  07E8DE     RCALL strlen
0085CE  8A42B0     MOV W0, fileNameLength
7022:              
7023:              		if((fileNameLength > count1) || (*fileName == '.') || (*fileName == 0))
0085D0  201001     MOV #0x100, W1
0085D2  500F81     SUB W0, W1, [W15]
0085D4  3E00C1     BRA GTU, 0x8758
0085D6  784098     MOV.B [W8], W1
0085D8  B3C2E0     MOV #0x2E, W0
0085DA  50CF80     SUB.B W1, W0, [W15]
0085DC  3200BD     BRA Z, 0x8758
0085DE  E00401     CP0.B W1
0085E0  3200BB     BRA Z, 0x8758
7024:              		{
7025:              			return FALSE;
7026:              		}
7027:              		
7028:              		asciiFilename = (char *)tempString;
0085E2  2FDF82     MOV #0xFDF8, W2
0085E4  41010F     ADD W2, W15, W2
0085E6  8A42C2     MOV W2, asciiFilename
0085E8  780089     MOV W9, W1
0085EA  370003     BRA 0x85F2
7029:              		for (count1 = 0;count1 < fileNameLength; count1++)
0085F0  E80081     INC W1, W1
0085F2  8242B0     MOV fileNameLength, W0
0085F4  508F80     SUB W1, W0, [W15]
0085F6  39FFFA     BRA NC, 0x85EC
7030:              		{
7031:              			asciiFilename[count1] = fileName[count1];
0085EC  8242C0     MOV asciiFilename, W0
0085EE  78F068     MOV.B [W8+W1], [W0+W1]
7032:              		}
7033:              	}
7034:              
7035:                  // Make sure the characters are valid
7036:                 	fileNameType = ValidateChars(mode);
0085F8  78400B     MOV.B W11, W0
0085FA  07FED4     RCALL ValidateChars
0085FC  780080     MOV W0, W1
7037:              
7038:                  // If the file name doesn't follow 8P3 or LFN format, then return FALSE
7039:                  if(NAME_ERROR == fileNameType)
0085FE  500FE7     SUB W0, #0x7, [W15]
008600  3200AB     BRA Z, 0x8758
7040:              	{
7041:              		return FALSE;
7042:              	}
7043:              
7044:              	temp = fileNameLength;
008602  8242B8     MOV fileNameLength, W8
7045:              
7046:              	#if defined(SUPPORT_LFN)
7047:              		fptr->AsciiEncodingType = TRUE;
008604  200010     MOV #0x1, W0
008606  981540     MOV W0, [W10+40]
7048:              		fptr->utf16LFNlength = 0;
008608  EB0180     CLR W3
00860A  981563     MOV W3, [W10+44]
7049:              	#endif
7050:              
7051:              	// If LFN is supported and the file name is UTF16 type or Ascii mixed type,
7052:              	// go for LFN support rather than trying to adjust in 8P3 format
7053:              	if(NAME_8P3_ASCII_MIXED_TYPE == fileNameType)
00860C  508F80     SUB W1, W0, [W15]
00860E  32007C     BRA Z, 0x8708
7054:              	{
7055:              		#if defined(SUPPORT_LFN)
7056:              			supportLFN = TRUE;
7057:              		#endif
7058:              	}
7059:              
7060:              	#if defined(SUPPORT_LFN)
7061:              	if(NAME_8P3_UTF16_TYPE == fileNameType)
008612  508FE2     SUB W1, #0x2, [W15]
008614  3A0017     BRA NZ, 0x8644
7062:              	{
7063:              		for (count3 = 0; count3 < temp; count3++)
008622  E80183     INC W3, W3
008624  518F88     SUB W3, W8, [W15]
008626  35FFFB     BRA LT, 0x861E
008628  EB0200     CLR W4
00862A  200021     MOV #0x2, W1
7064:              		{
7065:              			if(utf16Filename[count3] > 0xFF)
0085C6  200014     MOV #0x1, W4
0085C8  200051     MOV #0x5, W1
0085CA  370030     BRA 0x862C
008616  8242A2     MOV utf16Filename, W2
008618  780002     MOV W2, W0
00861A  200FF1     MOV #0xFF, W1
00861C  370003     BRA 0x8624
00861E  108FB0     SUBR W1, [W0++], [W15]
008620  3EFFD2     BRA GTU, 0x85C6
7066:              			{
7067:              				fileNameType = NAME_8P3_UTF16_NONASCII_TYPE;
7068:              				supportLFN = TRUE;
7069:              				break;
7070:              			}
7071:              		}
7072:              
7073:              		if(count3 == temp)
00862C  518F88     SUB W3, W8, [W15]
00862E  3A000A     BRA NZ, 0x8644
008630  EB0080     CLR W1
008632  2FF9F5     MOV #0xFF9F, W5
008634  370004     BRA 0x863E
7074:              		{
7075:              			fileNameType = NAME_8P3_UTF16_ASCII_CAPS_TYPE;
7076:              
7077:              			for (count3 = 0; count3 < temp; count3++)
008610  EB0200     CLR W4
00863C  E80081     INC W1, W1
00863E  508F83     SUB W1, W3, [W15]
008640  35FFFA     BRA LT, 0x8636
008642  370002     BRA 0x8648
7078:              			{
7079:              				if((utf16Filename[count3] >= 0x61) && (utf16Filename[count3] <= 0x7A))
008636  428032     ADD W5, [W2++], W0
008638  500FF9     SUB W0, #0x19, [W15]
00863A  360066     BRA LEU, 0x8708
7080:              				{
7081:              					fileNameType = NAME_8P3_UTF16_ASCII_MIXED_TYPE;
7082:              					supportLFN = TRUE;
7083:              					break;
7084:              				}
7085:              			}
7086:              		}
7087:              	}
7088:              	#endif
7089:              
7090:              	// If the file name follows 8P3 type
7091:              	if((NAME_LFN_TYPE != fileNameType) && (FALSE == supportLFN))
008644  508FE6     SUB W1, #0x6, [W15]
008646  320060     BRA Z, 0x8708
008648  E00004     CP0 W4
00864A  3A008D     BRA NZ, 0x8766
7092:              	{
7093:              		for (count3 = 0; count3 < temp; count3++)
008686  E80183     INC W3, W3
008688  E90081     DEC W1, W1
00868A  E88102     INC2 W2, W2
00868C  518F88     SUB W3, W8, [W15]
00868E  35FFE4     BRA LT, 0x8658
008690  370067     BRA 0x8760
7094:              		{
7095:              			#ifdef SUPPORT_LFN
7096:              			if(utfModeFileName)
00864C  8385A6     MOV utfModeFileName, W6
008658  E00006     CP0 W6
00865A  32000B     BRA Z, 0x8672
7097:              			{
7098:              				if(((utf16Filename[count3] == '.') && ((temp - count3) > 4)) ||
00865C  780012     MOV [W2], W0
00865E  2002E4     MOV #0x2E, W4
008660  500F84     SUB W0, W4, [W15]
008662  3A0002     BRA NZ, 0x8668
008664  508FE4     SUB W1, #0x4, [W15]
008666  3C0050     BRA GT, 0x8708
008668  518FE8     SUB W3, #0x8, [W15]
00866A  3C004E     BRA GT, 0x8708
7099:              					(count3 > 8))
7100:              				{
7101:              					// UTF File name extension greater then 3 characters or
7102:              				    // UTF File name greater then 8 charcters
7103:              					supportLFN = TRUE;
7104:              					break;
7105:              				}
7106:              				else if(utf16Filename[count3] == '.')
00866C  500F84     SUB W0, W4, [W15]
00866E  3A000B     BRA NZ, 0x8686
008670  370077     BRA 0x8760
7107:              				{
7108:              					break;
7109:              				}
7110:              			}
7111:              			else
7112:              			#endif
7113:              			{
7114:              				if(((asciiFilename[count3] == '.') && ((temp - count3) > 4)) ||
00864E  8242C5     MOV asciiFilename, W5
008650  780088     MOV W8, W1
008652  8242A2     MOV utf16Filename, W2
008654  780184     MOV W4, W3
008656  37001A     BRA 0x868C
008672  7AC063     MOV.B [W3+W5], W0
008674  B3C2E4     MOV #0x2E, W4
008676  504F84     SUB.B W0, W4, [W15]
008678  3A0002     BRA NZ, 0x867E
00867A  508FE4     SUB W1, #0x4, [W15]
00867C  3C0045     BRA GT, 0x8708
00867E  518FE8     SUB W3, #0x8, [W15]
008680  3C0043     BRA GT, 0x8708
7115:              					(count3 > 8))
7116:              				{
7117:              					// File extension greater then 3 characters or
7118:              					// File name greater then 8 charcters
7119:              					#if !defined(SUPPORT_LFN)
7120:              						return FALSE;
7121:              					#endif
7122:              					supportLFN = TRUE;
7123:              					break;
7124:              				}
7125:              				else if(asciiFilename[count3] == '.')
008682  504F84     SUB.B W0, W4, [W15]
008684  32006D     BRA Z, 0x8760
7126:              				{
7127:              					break;
7128:              				}
7129:              			}
7130:              		}
7131:              		
7132:              		// If LFN not supported try to adjust in 8P3 format
7133:              		if(FALSE == supportLFN)
7134:              		{
7135:              		    // point fN2 to short file name
7136:              		    fN2 = fptr -> name;
008760  4500FC     ADD W10, #0x1C, W1
008762  EB0100     CLR W2
008764  37FF96     BRA 0x8692
7137:              		    
7138:              		    // Load destination filename to be space intially.
7139:              		    for (count1 = 0; count1 < FILE_NAME_SIZE_8P3; count1++)
008696  E80102     INC W2, W2
008698  510FEB     SUB W2, #0xB, [W15]
00869A  3AFFFB     BRA NZ, 0x8692
7140:              		    {
7141:              		        *(fN2 + count1) = ' ';
008692  B3C200     MOV #0x20, W0
008694  78F100     MOV.B W0, [W2+W1]
7142:              		    }
7143:              
7144:              			// multiply the length by 2 as each UTF word has 2 byte
7145:              			#ifdef SUPPORT_LFN
7146:              			if(utfModeFileName)
00869C  8385A0     MOV utfModeFileName, W0
00869E  E00000     CP0 W0
0086A0  320004     BRA Z, 0x86AA
7147:              			{
7148:              				count4 = count3 * 2;
0086A2  418203     ADD W3, W3, W4
7149:              				temp = temp * 2;
0086A4  440408     ADD W8, W8, W8
7150:              				localFileName = (char *)utf16Filename;
0086A6  8242A6     MOV utf16Filename, W6
0086A8  370002     BRA 0x86AE
7151:              			}
7152:              			else
7153:              			#endif
7154:              			{
7155:              				count4 = count3;
7156:              				localFileName = asciiFilename;
0086AA  8242C6     MOV asciiFilename, W6
0086AC  780203     MOV W3, W4
0086AE  EB0280     CLR W5
0086B0  780385     MOV W5, W7
0086B2  B3C9FA     MOV #0x9F, W10
0086B4  B3CE09     MOV #0xE0, W9
0086B6  37000D     BRA 0x86D2
7157:              			}
7158:              
7159:              		    //copy only file name ( not the extension part )
7160:              		    for (count1 = 0,count2 = 0; (count2 < 8) && (count1 < count4);count1++ )
0086CC  E80285     INC W5, W5
0086CE  538FE7     SUB W7, #0x7, [W15]
0086D0  3C0002     BRA GT, 0x86D6
0086D2  528F84     SUB W5, W4, [W15]
0086D4  35FFF1     BRA LT, 0x86B8
7161:              		    {
7162:              				if(localFileName[count1])
0086B8  7B4165     MOV.B [W5+W6], W2
0086BA  E00402     CP0.B W2
0086BC  320007     BRA Z, 0x86CC
7163:              				{
7164:              					fN2[count2] = localFileName[count1]; // Destination filename initially filled with SPACE. Now copy only available chars.
0086BE  408187     ADD W1, W7, W3
0086C0  784982     MOV.B W2, [W3]
7165:              
7166:              	    			// Convert lower-case to upper-case
7167:              	    			if ((fN2[count2] >= 0x61) && (fN2[count2] <= 0x7A))
0086C2  41400A     ADD.B W2, W10, W0
0086C4  504FF9     SUB.B W0, #0x19, [W15]
0086C6  3E0001     BRA GTU, 0x86CA
7168:              	    			{
7169:              	    			    fN2[count2] -= 0x20;
0086C8  414989     ADD.B W2, W9, [W3]
7170:              					}
7171:              					count2++;
0086CA  E80387     INC W7, W7
7172:              				}
7173:              		    }
7174:              
7175:              			if(count4 < temp)
0086D6  520F88     SUB W4, W8, [W15]
0086D8  3D0041     BRA GE, 0x875C
7176:              			{
7177:              				// Discard the '.' part
7178:              				count4++;
0086DA  E80204     INC W4, W4
0086DC  430284     ADD W6, W4, W5
0086DE  200086     MOV #0x8, W6
0086E0  B3C9F9     MOV #0x9F, W9
0086E2  B3CE07     MOV #0xE0, W7
0086E4  37000E     BRA 0x8702
7179:              
7180:                  		    // Copy the extn to 8th position onwards. Ex: "FILE    .Tx "
7181:                  		    for (count3 = 8; (count3 < 11) && (count4 < temp);count4++ )
0086FA  E80204     INC W4, W4
0086FC  E80285     INC W5, W5
0086FE  530FEA     SUB W6, #0xA, [W15]
008700  3C002D     BRA GT, 0x875C
008702  520F88     SUB W4, W8, [W15]
008704  35FFF0     BRA LT, 0x86E6
008706  37002A     BRA 0x875C
7182:                  		    {
7183:              					if(localFileName[count4])
0086E6  784115     MOV.B [W5], W2
0086E8  E00402     CP0.B W2
0086EA  320007     BRA Z, 0x86FA
7184:              					{
7185:                  		        	fN2[count3] = localFileName[count4];
0086EC  408186     ADD W1, W6, W3
0086EE  784982     MOV.B W2, [W3]
7186:              
7187:              		   	 			// Convert lower-case to upper-case
7188:              		   	 			if ((fN2[count3] >= 0x61) && (fN2[count3] <= 0x7A))
0086F0  414009     ADD.B W2, W9, W0
0086F2  504FF9     SUB.B W0, #0x19, [W15]
0086F4  3E0001     BRA GTU, 0x86F8
7189:              		   	 			{
7190:              		   	 			    fN2[count3] -= 0x20;
0086F6  414987     ADD.B W2, W7, [W3]
7191:              						}
7192:              						count3++;
0086F8  E80306     INC W6, W6
7193:              					}
7194:                  		    }
7195:              			}
7196:              		}
7197:              	}
7198:              
7199:              	// If the file name follows LFN format
7200:                  if((NAME_LFN_TYPE == fileNameType) || (TRUE == supportLFN))
008766  520FE1     SUB W4, #0x1, [W15]
008768  3AFFF9     BRA NZ, 0x875C
00876A  37FFCE     BRA 0x8708
7201:              	{
7202:              		#if defined(SUPPORT_LFN)  	
7203:              
7204:              			// point fN2 to long file name
7205:              			fN2 = (char *)(fptr -> utf16LFNptr);
008708  9010DA     MOV [W10+42], W1
7206:              
7207:              			if(!utfModeFileName)
00870A  EB0380     CLR W7
00870C  8385A0     MOV utfModeFileName, W0
00870E  E00000     CP0 W0
008710  3A0001     BRA NZ, 0x8714
7208:              			{
7209:              				localFileName = asciiFilename;
008712  8242C7     MOV asciiFilename, W7
008714  200016     MOV #0x1, W6
008716  EB0100     CLR W2
008718  200FF9     MOV #0xFF, W9
00871A  780282     MOV W2, W5
00871C  780201     MOV W1, W4
00871E  370013     BRA 0x8746
7210:              			}
7211:              
7212:              			// Copy the LFN name in the adress specified by FSFILE pointer
7213:              			count2 = 0;
7214:              			for(count1 = 0;count1 < temp;count1++)
008744  E80102     INC W2, W2
008746  510F88     SUB W2, W8, [W15]
008748  35FFEB     BRA LT, 0x8720
7215:              			{
7216:              				if(utfModeFileName)
008720  8385A0     MOV utfModeFileName, W0
008722  E00000     CP0 W0
008724  32000C     BRA Z, 0x873E
008726  410002     ADD W2, W2, W0
7217:              				{
7218:              					fptr -> utf16LFNptr[count1] = utf16Filename[count1];
008728  8242A1     MOV utf16Filename, W1
00872A  400181     ADD W0, W1, W3
00872C  9010DA     MOV [W10+42], W1
00872E  783093     MOV [W3], [W1+W0]
7219:              					if(AscciIndication)
008730  E00006     CP0 W6
008732  320008     BRA Z, 0x8744
7220:              					{
7221:              						if(utf16Filename[count1] > 0xFF)
008734  148F93     SUBR W9, [W3], [W15]
008736  360006     BRA LEU, 0x8744
7222:              						{
7223:              							fptr->AsciiEncodingType = FALSE;
008738  981545     MOV W5, [W10+40]
00873A  780305     MOV W5, W6
00873C  370003     BRA 0x8744
7224:              							AscciIndication = FALSE;
7225:              						}
7226:              					}
7227:              				}
7228:              				else
7229:              				{
7230:              					fN2[count2++] = localFileName[count1];
00873E  7BCA62     MOV.B [W2+W7], [W4]
7231:              					fN2[count2++] = (BYTE)0x00;
008740  984210     MOV.B W0, [W4+1]
008742  E88204     INC2 W4, W4
7232:              				}
7233:              			}
7234:              			fptr -> utf16LFNptr[count1] = 0x0000;
00874A  9010DA     MOV [W10+42], W1
00874C  410002     ADD W2, W2, W0
00874E  400001     ADD W0, W1, W0
008750  EB0800     CLR [W0]
7235:              
7236:              			fptr->utf16LFNlength = fileNameLength;
008752  8242B0     MOV fileNameLength, W0
008754  981560     MOV W0, [W10+44]
008756  370002     BRA 0x875C
008758  EB0000     CLR W0
00875A  370008     BRA 0x876C
00875C  200010     MOV #0x1, W0
00875E  370006     BRA 0x876C
7237:              		#else
7238:              			return FALSE;
7239:              		#endif
7240:              	}
7241:              
7242:              	// Free the temporary heap used for intermediate execution
7243:              	return TRUE;
7244:              }
008774  FA000C     LNK #0xC
008776  BE9F88     MOV.D W8, [W15++]
008778  BE9F8A     MOV.D W10, [W15++]
00877A  BE0400     MOV.D W0, W8
00877C  784502     MOV.B W2, W10
7245:              
7246:              #ifdef ALLOW_DIRS
7247:              
7248:              /*************************************************************************
7249:                Function:
7250:                  BYTE FormatDirName (char * string,FILEOBJ fptr, BYTE mode)
7251:                Summary:
7252:                  Format a dir name into dir entry format
7253:                Conditions:
7254:                  This function should not be called by the user.
7255:                Input:
7256:                  string -  The name to be formatted
7257:                  mode -
7258:                       - TRUE -  Partial string search characters are allowed
7259:                       - FALSE - Partial string search characters are forbidden
7260:                Return Values:
7261:                  TRUE - The name was formatted correctly
7262:                  FALSE - The name contained invalid characters
7263:                Side Effects:
7264:                  None
7265:                Description:
7266:                  Format an 8.3 filename into directory structure format. If the name is less
7267:                  than 8 chars, then it will be padded with spaces. If the extension name is
7268:                  fewer than 3 chars, then it will also be oadded with spaces. The
7269:                  ValidateChars function is used to ensure the characters in the specified
7270:                  directory name are valid in this filesystem.
7271:                Remarks:
7272:                  None.
7273:                *************************************************************************/
7274:              
7275:              BYTE FormatDirName (char * string,FILEOBJ fptr, BYTE mode)
7276:              {
00877E  78058F     MOV W15, W11
008974  420181     ADD W4, W1, W3
7277:                  char tempString [12];
7278:              	FILE_DIR_NAME_TYPE fileNameType;
7279:                  int temp,count1,count2;
7280:                  BOOL supportLFN = FALSE;
7281:              	char *localFileName;
7282:              
7283:              	// go with static allocation
7284:              	#if defined(SUPPORT_LFN)
7285:                  	int count3,count4;
7286:              		BOOL	AscciIndication = TRUE;
7287:              		count1 = 256;
7288:              	#else
7289:              		count1 = 12;
7290:              	#endif
7291:              
7292:              	// Calculate the String length
7293:              	#ifdef SUPPORT_LFN
7294:              	if(utfModeFileName)
008780  8385A0     MOV utfModeFileName, W0
008782  E00000     CP0 W0
008784  32000E     BRA Z, 0x87A2
7295:              	{
7296:              		utf16Filename = (unsigned short int *)string;
008786  8A42A8     MOV W8, utf16Filename
7297:              		fileNameLength = 0;
008788  EB0000     CLR W0
00878A  370001     BRA 0x878E
7298:              		while(utf16Filename[fileNameLength])
008790  8242B1     MOV fileNameLength, W1
008792  408001     ADD W1, W1, W0
008794  400008     ADD W0, W8, W0
008796  E00010     CP0 [W0]
008798  3AFFF9     BRA NZ, 0x878C
00879A  370007     BRA 0x87AA
7299:              		{
7300:              			fileNameLength++;
00878C  E80001     INC W1, W0
00878E  8A42B0     MOV W0, fileNameLength
7301:              		}
7302:              	}
7303:              	else
7304:              	#endif
7305:              	{
7306:              		asciiFilename = string;
0087A2  8A42C8     MOV W8, asciiFilename
7307:              		fileNameLength = strlen(string);
0087A4  780008     MOV W8, W0
0087A6  07E7F1     RCALL strlen
0087A8  8A42B0     MOV W0, fileNameLength
7308:              	}
7309:              
7310:              	if(fileNameLength > count1)
0087AA  8242B1     MOV fileNameLength, W1
0087AC  201000     MOV #0x100, W0
0087AE  508F80     SUB W1, W0, [W15]
0087B0  3E00EC     BRA GTU, 0x898A
7311:              	{
7312:              		return FALSE;
7313:              	}
7314:              
7315:                  // Make sure the characters are valid
7316:                  fileNameType = ValidateChars(mode);
0087B2  78400A     MOV.B W10, W0
0087B4  07FDF7     RCALL ValidateChars
0087B6  780080     MOV W0, W1
7317:              
7318:                  // If the file name doesn't follow 8P3 or LFN format, then return FALSE
7319:                  if(NAME_ERROR == fileNameType)
0087B8  500FE7     SUB W0, #0x7, [W15]
0087BA  3200E7     BRA Z, 0x898A
7320:              	{
7321:              		return FALSE;
7322:              	}
7323:              
7324:              	temp = fileNameLength;
0087BC  8242B6     MOV fileNameLength, W6
7325:              
7326:              	#if defined(SUPPORT_LFN)
7327:              		fptr->AsciiEncodingType = TRUE;
0087BE  200010     MOV #0x1, W0
0087C0  9814C0     MOV W0, [W9+40]
7328:              		fptr->utf16LFNlength = 0;
0087C2  EB0180     CLR W3
0087C4  9814E3     MOV W3, [W9+44]
7329:              	#endif
7330:              
7331:              	// If LFN is supported and the file name is UTF16 type or Ascii mixed type,
7332:              	// go for LFN support rather than trying to adjust in 8P3 format
7333:              	if(NAME_8P3_ASCII_MIXED_TYPE == fileNameType)
0087C6  508F80     SUB W1, W0, [W15]
0087C8  32001E     BRA Z, 0x8806
7334:              	{
7335:              		#if defined(SUPPORT_LFN)
7336:              			supportLFN = TRUE;
7337:              		#endif
7338:              	}
7339:              
7340:              	#if defined(SUPPORT_LFN)
7341:              	if(NAME_8P3_UTF16_TYPE == fileNameType)
0087CC  508FE2     SUB W1, #0x2, [W15]
0087CE  3A0017     BRA NZ, 0x87FE
7342:              	{
7343:              		for (count3 = 0; count3 < temp; count3++)
0087DC  E80183     INC W3, W3
0087DE  518F86     SUB W3, W6, [W15]
0087E0  35FFFB     BRA LT, 0x87D8
0087E2  EB0200     CLR W4
0087E4  200021     MOV #0x2, W1
7344:              		{
7345:              			if(utf16Filename[count3] > 0xFF)
00879C  200014     MOV #0x1, W4
00879E  200051     MOV #0x5, W1
0087A0  370022     BRA 0x87E6
0087D0  8242A2     MOV utf16Filename, W2
0087D2  780002     MOV W2, W0
0087D4  200FF1     MOV #0xFF, W1
0087D6  370003     BRA 0x87DE
0087D8  108FB0     SUBR W1, [W0++], [W15]
0087DA  3EFFE0     BRA GTU, 0x879C
7346:              			{
7347:              				fileNameType = NAME_8P3_UTF16_NONASCII_TYPE;
7348:              				supportLFN = TRUE;
7349:              				break;
7350:              			}
7351:              		}
7352:              
7353:              		if(count3 == temp)
0087E6  518F86     SUB W3, W6, [W15]
0087E8  3A000A     BRA NZ, 0x87FE
0087EA  EB0080     CLR W1
0087EC  2FF9F5     MOV #0xFF9F, W5
0087EE  370004     BRA 0x87F8
7354:              		{
7355:              			fileNameType = NAME_8P3_UTF16_ASCII_CAPS_TYPE;
7356:              
7357:              			for (count3 = 0; count3 < temp; count3++)
0087CA  EB0200     CLR W4
0087F6  E80081     INC W1, W1
0087F8  508F83     SUB W1, W3, [W15]
0087FA  35FFFA     BRA LT, 0x87F0
0087FC  370002     BRA 0x8802
7358:              			{
7359:              				if((utf16Filename[count3] >= 0x61) && (utf16Filename[count3] <= 0x7A))
0087F0  428032     ADD W5, [W2++], W0
0087F2  500FF9     SUB W0, #0x19, [W15]
0087F4  360008     BRA LEU, 0x8806
7360:              				{
7361:              					fileNameType = NAME_8P3_UTF16_ASCII_MIXED_TYPE;
7362:              					supportLFN = TRUE;
7363:              					break;
7364:              				}
7365:              			}
7366:              		}
7367:              	}
7368:              	#endif
7369:              
7370:              	// If the file name follows LFN format
7371:                  if((NAME_LFN_TYPE == fileNameType) || (TRUE == supportLFN))
0087FE  508FE6     SUB W1, #0x6, [W15]
008800  320002     BRA Z, 0x8806
008802  520FE1     SUB W4, #0x1, [W15]
008804  3A0046     BRA NZ, 0x8892
7372:              	{
7373:              		#if !defined(SUPPORT_LFN)
7374:                      	return FALSE;
7375:              		#else
7376:              			fptr -> utf16LFNptr = (unsigned short int *)string;
008806  9814D8     MOV W8, [W9+42]
7377:              		
7378:              			if(utfModeFileName)
008808  8385A2     MOV utfModeFileName, W2
00880A  E00002     CP0 W2
00880C  320025     BRA Z, 0x8858
7379:              			{
7380:              				if(utf16Filename != (unsigned short int *)string)
00880E  8242A0     MOV utf16Filename, W0
008810  200015     MOV #0x1, W5
008812  EB0200     CLR W4
008814  500F88     SUB W0, W8, [W15]
008816  3A000F     BRA NZ, 0x8836
008818  780100     MOV W0, W2
00881A  EB0080     CLR W1
00881C  370017     BRA 0x884C
7381:              				{
7382:              					// Copy the validated/Fomated name in the UTF16 string
7383:              					for(count1 = 0; count1 < temp; count1++)
008834  E80204     INC W4, W4
008836  420084     ADD W4, W4, W1
008838  901159     MOV [W9+42], W2
00883A  520F86     SUB W4, W6, [W15]
00883C  35FFF0     BRA LT, 0x881E
7384:              					{
7385:              						fptr -> utf16LFNptr[count1] = utf16Filename[count1];
00881E  8242A0     MOV utf16Filename, W0
008820  408180     ADD W1, W0, W3
008822  78B113     MOV [W3], [W2+W1]
7386:              						if(AscciIndication)
008824  E00005     CP0 W5
008826  320006     BRA Z, 0x8834
7387:              						{
7388:              							if(utf16Filename[count1] > 0xFF)
008828  200FF0     MOV #0xFF, W0
00882A  100F93     SUBR W0, [W3], [W15]
00882C  360003     BRA LEU, 0x8834
7389:              							{
7390:              								fptr->AsciiEncodingType = FALSE;
00882E  EB0000     CLR W0
008830  9814C0     MOV W0, [W9+40]
008832  780280     MOV W0, W5
7391:              								AscciIndication = FALSE;
7392:              							}
7393:              						}
7394:              					}
7395:              					fptr -> utf16LFNptr[count1] = 0x0000;
00883E  408002     ADD W1, W2, W0
008840  EB0800     CLR [W0]
008842  370024     BRA 0x888C
7396:              				}
7397:              				else
7398:              				{
7399:              					for(count1 = 0; count1 < temp; count1++)
00884A  E80081     INC W1, W1
00884C  508F86     SUB W1, W6, [W15]
00884E  35FFFA     BRA LT, 0x8844
008850  37001D     BRA 0x888C
008858  78028F     MOV W15, W5
7400:              					{
7401:              						if(AscciIndication)
7402:              						{
7403:              							if(utf16Filename[count1] > 0xFF)
008844  200FF0     MOV #0xFF, W0
008846  100FB2     SUBR W0, [W2++], [W15]
008848  3E0004     BRA GTU, 0x8852
7404:              							{
7405:              								fptr->AsciiEncodingType = FALSE;
008852  EB0000     CLR W0
008854  9814C0     MOV W0, [W9+40]
008856  37001A     BRA 0x888C
7406:              								AscciIndication = FALSE;
7407:              								break;
7408:              							}
7409:              						}
7410:              					}
7411:              				}
7412:              			}
7413:              			else
7414:              			{
7415:              				#ifdef FS_DYNAMIC_MEM
7416:              	    			unsigned short int *tempAsciiLFN = (unsigned short int *)FS_malloc((temp + 1) * 2);
7417:              				#else
7418:              					unsigned short int	tempAsciiLFN[temp + 1];
00885A  D00006     SL W6, W0
00885C  400064     ADD W0, #0x4, W0
00885E  478780     ADD W15, W0, W15
008860  780185     MOV W5, W3
008862  780085     MOV W5, W1
008864  784202     MOV.B W2, W4
008866  370005     BRA 0x8872
7419:              				#endif
7420:              
7421:              				localFileName = (char *)tempAsciiLFN;
7422:              
7423:              				// Copy the validated/Fomated name in the Ascii string
7424:              				count2 = 0;
7425:              
7426:              				for(count1 = 0; count1 < temp; count1++)
00886E  E80102     INC W2, W2
008870  E88081     INC2 W1, W1
008872  510F86     SUB W2, W6, [W15]
008874  35FFF9     BRA LT, 0x8868
008876  EB0080     CLR W1
008878  901159     MOV [W9+42], W2
00887A  370002     BRA 0x8880
7427:              				{
7428:              					localFileName[count2++] = asciiFilename[count1];
008868  8242C0     MOV asciiFilename, W0
00886A  7948E0     MOV.B [W0+W2], [W1]
7429:              
7430:              					localFileName[count2++] = (BYTE)0x00;
00886C  984094     MOV.B W4, [W1+1]
7431:              
7432:              				}
7433:              
7434:              				// Copy the validated/Fomated name in the UTF16 string
7435:              				for(count1 = 0; count1 < temp; count1++)
00887E  E80081     INC W1, W1
008880  408001     ADD W1, W1, W0
008882  508F86     SUB W1, W6, [W15]
008884  35FFFB     BRA LT, 0x887C
7436:              				{
7437:              					fptr -> utf16LFNptr[count1] = tempAsciiLFN[count1];
00887C  793033     MOV [W3++], [W0+W2]
7438:              				}
7439:              
7440:              				#ifdef FS_DYNAMIC_MEM
7441:              	    			FS_free((unsigned char *)tempAsciiLFN);
7442:              				#endif
7443:              				fptr -> utf16LFNptr[count1] = 0x0000;
008886  400002     ADD W0, W2, W0
008888  EB0800     CLR [W0]
00888A  780785     MOV W5, W15
7444:              			}
7445:              
7446:              			fptr->utf16LFNlength = fileNameLength;
00888C  8242B0     MOV fileNameLength, W0
00888E  9814E0     MOV W0, [W9+44]
008890  37007A     BRA 0x8986
7447:              		#endif
7448:              	}
7449:              	else
7450:              	{
7451:              		#ifdef SUPPORT_LFN
7452:              		if(utfModeFileName)
008892  8385A0     MOV utfModeFileName, W0
008894  E00000     CP0 W0
008896  3A0003     BRA NZ, 0x889E
7453:              		{
7454:              			localFileName = (char *)utf16Filename;
00889E  8242A7     MOV utf16Filename, W7
0088A0  780187     MOV W7, W3
0088A2  780207     MOV W7, W4
0088A4  EB0280     CLR W5
0088A6  780085     MOV W5, W1
0088A8  370011     BRA 0x88CC
7455:              
7456:              			// Copy the name part in the temporary string
7457:              		    count4 = 0;
7458:              		    for (count3 = 0; (count3 < temp) && (utf16Filename[count3] != '.') && (utf16Filename[count3] != 0); count3++)
0088C6  E80285     INC W5, W5
0088C8  E88183     INC2 W3, W3
0088CA  E88204     INC2 W4, W4
0088CC  528F86     SUB W5, W6, [W15]
0088CE  350002     BRA LT, 0x88D4
0088D0  470101     ADD W14, W1, W2
0088D2  37000A     BRA 0x88E8
0088D4  780114     MOV [W4], W2
0088D6  2002E0     MOV #0x2E, W0
0088D8  510F80     SUB W2, W0, [W15]
0088DA  32FFFA     BRA Z, 0x88D0
0088DC  E00002     CP0 W2
0088DE  3AFFE5     BRA NZ, 0x88AA
0088E0  37FFF7     BRA 0x88D0
7459:              		    {
7460:              				count1 = count3 * 2;
7461:              				if(localFileName[count1])
0088AA  784013     MOV.B [W3], W0
0088AC  E00400     CP0.B W0
0088AE  320004     BRA Z, 0x88B8
7462:              				{
7463:              			        tempString[count4] = localFileName[count1];
0088B0  78F700     MOV.B W0, [W14+W1]
7464:              					count4++;
0088B2  E80081     INC W1, W1
7465:              					if(count4 == 8)
0088B4  508FE8     SUB W1, #0x8, [W15]
0088B6  32000C     BRA Z, 0x88D0
7466:              						break;
7467:              				}
7468:              		 
7469:              				if(localFileName[count1 + 1])
0088B8  904013     MOV.B [W3+1], W0
0088BA  E00400     CP0.B W0
0088BC  320004     BRA Z, 0x88C6
7470:              				{
7471:              			        tempString[count4] = localFileName[count1 + 1];
0088BE  78F700     MOV.B W0, [W14+W1]
7472:              					count4++;
0088C0  E80081     INC W1, W1
7473:              					if(count4 == 8)
0088C2  508FE8     SUB W1, #0x8, [W15]
0088C4  320005     BRA Z, 0x88D0
7474:              						break;
7475:              				}
7476:              		    }
7477:              
7478:              			// File the remaining name portion with spaces
7479:              		    while (count4 < 8)
0088E8  508FE7     SUB W1, #0x7, [W15]
0088EA  34FFFB     BRA LE, 0x88E2
7480:              		    {
7481:              		        tempString [count4++] = 0x20;
0088E2  B3C200     MOV #0x20, W0
0088E4  785900     MOV.B W0, [W2++]
0088E6  E80081     INC W1, W1
7482:              		    }
7483:              
7484:              			// Copy the extension part in the temporary string
7485:              		    if (utf16Filename[count3] == '.')
0088EC  428005     ADD W5, W5, W0
0088EE  400107     ADD W0, W7, W2
0088F0  2002E0     MOV #0x2E, W0
0088F2  100F92     SUBR W0, [W2], [W15]
0088F4  3A000A     BRA NZ, 0x890A
7486:              		    {
7487:              				count1 = count3 * 2 + 2;
7488:              		        while (localFileName[count1] != 0)
0088F6  E88002     INC2 W2, W0
0088F8  E00410     CP0.B [W0]
0088FA  320007     BRA Z, 0x890A
7489:              		        {
7490:              					if(localFileName[count3])
0088FC  7AC067     MOV.B [W7+W5], W0
0088FE  E00400     CP0.B W0
008900  32FFFD     BRA Z, 0x88FC
7491:              					{
7492:              				        tempString[count4] = localFileName[count3];
008902  78F700     MOV.B W0, [W14+W1]
7493:              						count4++;
008904  E80081     INC W1, W1
7494:              						if(count4 == 11)
008906  508FEB     SUB W1, #0xB, [W15]
008908  3AFFF9     BRA NZ, 0x88FC
00890A  780101     MOV W1, W2
00890C  470082     ADD W14, W2, W1
00890E  370026     BRA 0x895C
7495:              							break;
7496:              					}
7497:              		        }
7498:              		    }
7499:              
7500:              			count1 = count4;
7501:              		}
7502:              		else
7503:              		#endif
7504:              		{
7505:              			// Copy the name part in the temporary string
7506:              		    for (count1 = 0; (count1 < 8) && (*(asciiFilename + count1) != '.') && (*(asciiFilename + count1) != 0); count1++)
008898  8242C4     MOV asciiFilename, W4
00889A  780180     MOV W0, W3
00889C  37003D     BRA 0x8918
008912  E80183     INC W3, W3
008914  518FE8     SUB W3, #0x8, [W15]
008916  320006     BRA Z, 0x8924
008918  7A40E3     MOV.B [W3+W4], W1
00891A  B3C2E0     MOV #0x2E, W0
00891C  50CF80     SUB.B W1, W0, [W15]
00891E  320002     BRA Z, 0x8924
008920  E00401     CP0.B W1
008922  3AFFF6     BRA NZ, 0x8910
008924  470003     ADD W14, W3, W0
008926  780103     MOV W3, W2
008928  B3C201     MOV #0x20, W1
00892A  370002     BRA 0x8930
7507:              		    {
7508:              		        tempString[count1] = *(asciiFilename + count1);
008910  7F7181     MOV.B W1, [W3+W14]
7509:              		    }
7510:              
7511:              			count2 = count1;
7512:              
7513:              			// File the remaining name portion with spaces
7514:              		    while (count1 < 8)
008930  510FE7     SUB W2, #0x7, [W15]
008932  34FFFC     BRA LE, 0x892C
7515:              		    {
7516:              		        tempString [count1++] = 0x20;
00892C  785801     MOV.B W1, [W0++]
00892E  E80102     INC W2, W2
7517:              		    }
7518:              
7519:              			// Copy the extension part in the temporary string
7520:              		    if (*(asciiFilename + count2) == '.')
008934  79C0E4     MOV.B [W4+W3], W1
008936  B3C2E0     MOV #0x2E, W0
008938  50CF80     SUB.B W1, W0, [W15]
00893A  3AFFE8     BRA NZ, 0x890C
00893C  E80003     INC W3, W0
00893E  420000     ADD W4, W0, W0
008940  470182     ADD W14, W2, W3
008942  370002     BRA 0x8948
7521:              		    {
7522:              		        count2++;
7523:              		        while ((*(asciiFilename + count2) != 0) && (count1 < FILE_NAME_SIZE_8P3))
008948  784090     MOV.B [W0], W1
00894A  E00401     CP0.B W1
00894C  32FFDF     BRA Z, 0x890C
00894E  E80000     INC W0, W0
008950  510FEA     SUB W2, #0xA, [W15]
008952  34FFF8     BRA LE, 0x8944
008954  370005     BRA 0x8960
7524:              		        {
7525:              		            tempString[count1++] = *(asciiFilename + count2++);
008944  785981     MOV.B W1, [W3++]
008946  E80102     INC W2, W2
7526:              		        }
7527:              		    }
7528:              		}
7529:              
7530:              		// File the remaining portion with spaces
7531:              		while (count1 < FILE_NAME_SIZE_8P3)
00895C  510FEA     SUB W2, #0xA, [W15]
00895E  34FFFB     BRA LE, 0x8956
7532:              		{
7533:              		    tempString[count1++] = 0x20;
008956  B3C200     MOV #0x20, W0
008958  785880     MOV.B W0, [W1++]
00895A  E80102     INC W2, W2
7534:              		}
7535:              
7536:              		// Forbidden
7537:              		if (tempString[0] == 0x20)
008960  B3C200     MOV #0x20, W0
008962  104F9E     SUBR.B W0, [W14], [W15]
008964  3A0002     BRA NZ, 0x896A
7538:              		{
7539:              		    tempString[0] = '_';
008966  B3C5F0     MOV #0x5F, W0
008968  784F00     MOV.B W0, [W14]
7540:              		}
7541:              
7542:              		// point fN2 to short file name
7543:              		localFileName = fptr -> name;
00896A  4480FC     ADD W9, #0x1C, W1
00896C  EB0200     CLR W4
00896E  B3C9F6     MOV #0x9F, W6
008970  B3CE05     MOV #0xE0, W5
7544:              
7545:              		// Copy the formated name in string
7546:              		for (count1 = 0; count1 < FILE_NAME_SIZE_8P3; count1++)
008980  E80204     INC W4, W4
008982  520FEB     SUB W4, #0xB, [W15]
008984  3AFFF6     BRA NZ, 0x8972
008986  200010     MOV #0x1, W0
008988  370001     BRA 0x898C
00898A  EB0000     CLR W0
7547:              		{
7548:              		    localFileName[count1] = tempString[count1];
008972  7F4164     MOV.B [W4+W14], W2
008976  784982     MOV.B W2, [W3]
7549:              
7550:              			// Convert lower-case to upper-case
7551:              			if ((tempString[count1] >= 0x61) && (tempString[count1] <= 0x7A))
008978  414006     ADD.B W2, W6, W0
00897A  504FF9     SUB.B W0, #0x19, [W15]
00897C  3E0001     BRA GTU, 0x8980
7552:              			{
7553:              			    localFileName[count1] -= 0x20;
00897E  414985     ADD.B W2, W5, [W3]
7554:              			}
7555:              		}
7556:              	}
7557:              
7558:              	return TRUE;
7559:              }
008996  FA0020     LNK #0x20
008998  BE9F88     MOV.D W8, [W15++]
00899A  BE9F8A     MOV.D W10, [W15++]
00899C  BE9F8C     MOV.D W12, [W15++]
00899E  780400     MOV W0, W8
0089A0  BE0502     MOV.D W2, W10
0089A2  BE0604     MOV.D W4, W12
7560:              #endif
7561:              
7562:              
7563:              /*************************************************************
7564:                Function:
7565:                  FILE_DIR_NAME_TYPE ValidateChars(BYTE mode)
7566:                Summary:
7567:                  Validate the characters in a given file name
7568:                Conditions:
7569:                  This function should not be called by the user.
7570:                Input:
7571:                  fileName -  The name to be validated
7572:                  mode -      Determines if partial string search is allowed
7573:                Return Values:
7574:                  TRUE - Name was validated
7575:                  FALSE - File name was not valid
7576:                Side Effects:
7577:                  None
7578:                Description:
7579:                  The ValidateChars function will compare characters in a
7580:                  specified filename to determine if they're permissable
7581:                  in the FAT file system.  Lower-case characters will be
7582:                  converted to upper-case.  If the mode argument is specifed
7583:                  to be 'TRUE,' partial string search characters are allowed.
7584:                Remarks:
7585:                  None.
7586:                *************************************************************/
7587:              FILE_DIR_NAME_TYPE ValidateChars(BYTE mode)
7588:              {
0083EC  418003     ADD W3, W3, W0
0083EE  440280     ADD W8, W0, W5
0083F0  450203     ADD W10, W3, W4
0083F2  EB0000     CLR W0
0083F4  200207     MOV #0x20, W7
0083F6  2002E6     MOV #0x2E, W6
0083F8  370011     BRA 0x841C
7589:              	FILE_DIR_NAME_TYPE fileNameType;
7590:                  unsigned short int count1;
7591:              	#if defined(SUPPORT_LFN)
7592:              	unsigned short int utf16Value;
7593:                  unsigned short int count2;
7594:              	int		count3;
7595:              	#endif
7596:                  unsigned char radix = FALSE,asciiValue;
7597:              
7598:              	#if defined(SUPPORT_LFN)
7599:              
7600:              		// Remove the spaces if they are present before the file name
7601:              		for (count1 = 0; count1 < fileNameLength; count1++)
0083AE  8242B4     MOV fileNameLength, W4
0083DA  E80183     INC W3, W3
0083DC  E88102     INC2 W2, W2
0083DE  E80081     INC W1, W1
0083E0  518F84     SUB W3, W4, [W15]
0083E2  39FFED     BRA NC, 0x83BE
7602:              		{
7603:              	        if(utfModeFileName)
0083B0  8385A9     MOV utfModeFileName, W9
0083B2  8242A2     MOV utf16Filename, W2
0083B4  8242C1     MOV asciiFilename, W1
0083B6  EB0180     CLR W3
0083B8  200206     MOV #0x20, W6
0083BA  2002E5     MOV #0x2E, W5
0083BC  370011     BRA 0x83E0
0083BE  E00009     CP0 W9
0083C0  320007     BRA Z, 0x83D0
7604:              			{
7605:              				if((utf16Filename[count1] != ' ') && (utf16Filename[count1] != '.'))
0083C2  780012     MOV [W2], W0
0083C4  500F86     SUB W0, W6, [W15]
0083C6  320009     BRA Z, 0x83DA
0083C8  500F85     SUB W0, W5, [W15]
0083CA  320007     BRA Z, 0x83DA
7606:              				{
7607:              					utf16Filename = utf16Filename + count1;
0083CC  8A42A2     MOV W2, utf16Filename
0083CE  37000A     BRA 0x83E4
7608:              					break;
7609:              				}
7610:              			}
7611:              			else if((asciiFilename[count1] != ' ') && (asciiFilename[count1] != '.'))
0083D0  784011     MOV.B [W1], W0
0083D2  504F86     SUB.B W0, W6, [W15]
0083D4  320002     BRA Z, 0x83DA
0083D6  504F85     SUB.B W0, W5, [W15]
0083D8  3A0030     BRA NZ, 0x843A
7612:              			{
7613:              				asciiFilename = asciiFilename + count1;
00843A  8A42C1     MOV W1, asciiFilename
00843C  37FFD3     BRA 0x83E4
7614:              				break;
7615:              	    	}
7616:              	    }
7617:              
7618:              	    count2 = 0;
7619:              
7620:              		// Remove the spaces  & dots if they are present after the file name
7621:              	    for (count3 = fileNameLength - count1 - 1; count3 > 0; count3--)
0083E4  520083     SUB W4, W3, W1
0083E6  E90181     DEC W1, W3
008416  E90183     DEC W3, W3
008418  E98285     DEC2 W5, W5
00841A  E90204     DEC W4, W4
00841C  E00003     CP0 W3
00841E  3CFFED     BRA GT, 0x83FA
7622:              	    {
7623:              	        if(utfModeFileName)
0083FA  E00009     CP0 W9
0083FC  320006     BRA Z, 0x840A
7624:              			{
7625:              				if((utf16Filename[count3] != ' ') && (utf16Filename[count3] != '.'))
0083EA  8242A8     MOV utf16Filename, W8
0083FE  780115     MOV [W5], W2
008400  510F87     SUB W2, W7, [W15]
008402  320008     BRA Z, 0x8414
008404  510F86     SUB W2, W6, [W15]
008406  320006     BRA Z, 0x8414
008408  37000B     BRA 0x8420
7626:              				{
7627:              					break;
7628:              				}
7629:              			}
7630:              			else if((asciiFilename[count3] != ' ') && (asciiFilename[count3] != '.'))
0083E8  8242CA     MOV asciiFilename, W10
00840A  784114     MOV.B [W4], W2
00840C  514F87     SUB.B W2, W7, [W15]
00840E  320002     BRA Z, 0x8414
008410  514F86     SUB.B W2, W6, [W15]
008412  3A0006     BRA NZ, 0x8420
7631:              			{
7632:              				break;
7633:              	    	}
7634:              
7635:              	    	count2++;
008414  E80000     INC W0, W0
7636:              	    }
7637:              
7638:              		fileNameLength = fileNameLength - count1 - count2;
008420  508180     SUB W1, W0, W3
008422  8A42B3     MOV W3, fileNameLength
7639:              
7640:                  	if(( fileNameLength > MAX_FILE_NAME_LENGTH_LFN ) || (fileNameLength == 0))// 255
008424  E90083     DEC W3, W1
008426  200FF0     MOV #0xFF, W0
008428  508F80     SUB W1, W0, [W15]
00842A  3E009D     BRA GTU, 0x8566
7641:                      	return NAME_ERROR; //long file name
7642:              
7643:                  #endif
7644:              
7645:               	// If the string length is greater then 8P3 length, then assume
7646:              	// the file name as LFN type provided there are no errors in the
7647:              	// below for loop.
7648:              	#ifdef SUPPORT_LFN
7649:              	if(utfModeFileName)
00842C  E00009     CP0 W9
00842E  320007     BRA Z, 0x843E
7650:              	{
7651:              		if((fileNameLength * 2) > (TOTAL_FILE_SIZE_8P3 * 2))
008430  418003     ADD W3, W3, W0
008432  200022     MOV #0x2, W2
008434  500FF8     SUB W0, #0x18, [W15]
008436  360008     BRA LEU, 0x8448
008438  370006     BRA 0x8446
7652:              		{
7653:              			fileNameType = NAME_LFN_TYPE;
7654:              		}
7655:              		else
7656:              		{
7657:              			fileNameType = NAME_8P3_UTF16_TYPE;
7658:              		}
7659:              	}
7660:              	else
7661:              	#endif
7662:              	{
7663:              		if(fileNameLength > TOTAL_FILE_SIZE_8P3)
00843E  518FEC     SUB W3, #0xC, [W15]
008440  3E0002     BRA GTU, 0x8446
008442  780109     MOV W9, W2
008444  370001     BRA 0x8448
008446  200062     MOV #0x6, W2
008448  780208     MOV W8, W4
00844A  EB4280     CLR.B W5
00844C  EB0300     CLR W6
00844E  2003AE     MOV #0x3A, W14
008450  2003CC     MOV #0x3C, W12
008452  2003ED     MOV #0x3E, W13
008454  2005C8     MOV #0x5C, W8
008456  2007C7     MOV #0x7C, W7
008458  370083     BRA 0x8560
7664:              		{
7665:              			fileNameType = NAME_LFN_TYPE;
7666:              		}
7667:              		else
7668:              		{
7669:              			fileNameType = NAME_8P3_ASCII_CAPS_TYPE;
7670:              		}
7671:              	}
7672:              
7673:              	for( count1 = 0; count1 < fileNameLength; count1++ )
00855C  E80306     INC W6, W6
00855E  E88204     INC2 W4, W4
008560  530F83     SUB W6, W3, [W15]
008562  39FF7B     BRA NC, 0x845A
008564  370001     BRA 0x8568
008566  200072     MOV #0x7, W2
7674:              	{
7675:              		#ifdef SUPPORT_LFN
7676:              		if(utfModeFileName)
00845A  E00009     CP0 W9
00845C  32003C     BRA Z, 0x84D6
7677:              		{
7678:              			utf16Value = utf16Filename[count1];
00845E  780094     MOV [W4], W1
7679:              		    // Characters not valid for either of 8P3 & LFN format
7680:              		    if (((utf16Value < 0x20) && (utf16Value != 0x05)) || (utf16Value == 0x22) || 
008460  508FFF     SUB W1, #0x1F, [W15]
008462  3E0003     BRA GTU, 0x846A
008464  508FE5     SUB W1, #0x5, [W15]
008466  320011     BRA Z, 0x848A
008468  37007E     BRA 0x8566
00846A  200220     MOV #0x22, W0
00846C  508F80     SUB W1, W0, [W15]
00846E  32007B     BRA Z, 0x8566
008470  40006D     ADD W0, #0xD, W0
008472  508F80     SUB W1, W0, [W15]
008474  320078     BRA Z, 0x8566
008476  508F8E     SUB W1, W14, [W15]
008478  320076     BRA Z, 0x8566
00847A  508F8C     SUB W1, W12, [W15]
00847C  320074     BRA Z, 0x8566
00847E  508F8D     SUB W1, W13, [W15]
008480  320072     BRA Z, 0x8566
008482  508F88     SUB W1, W8, [W15]
008484  320070     BRA Z, 0x8566
008486  508F87     SUB W1, W7, [W15]
008488  32006E     BRA Z, 0x8566
7681:              				(utf16Value == 0x2F) || (utf16Value == 0x3A) || (utf16Value == 0x3C) || 
7682:              		        (utf16Value == 0x3E) || (utf16Value == 0x5C) || (utf16Value == 0x7C))
7683:              		    {
7684:              		        return NAME_ERROR;
7685:              		    }
7686:              
7687:              	        // Check for partial string search chars
7688:              	        if (mode == FALSE)
00848A  E0040B     CP0.B W11
00848C  3A0006     BRA NZ, 0x849A
7689:              	        {
7690:              	            if ((utf16Value == '*') || (utf16Value == '?'))
00848E  2002A0     MOV #0x2A, W0
008490  508F80     SUB W1, W0, [W15]
008492  320069     BRA Z, 0x8566
008494  400075     ADD W0, #0x15, W0
008496  508F80     SUB W1, W0, [W15]
008498  320066     BRA Z, 0x8566
7691:              	            {
7692:              	    		    return NAME_ERROR;
7693:              	        	}
7694:              	        }
7695:              
7696:              			if(fileNameType != NAME_LFN_TYPE)
00849A  510FE6     SUB W2, #0x6, [W15]
00849C  32005F     BRA Z, 0x855C
7697:              			{
7698:              				// Characters valid for LFN format only
7699:              			    if ((utf16Value == 0x20) || (utf16Value == 0x2B) || (utf16Value == 0x2C) || 
00849E  200200     MOV #0x20, W0
0084A0  508F80     SUB W1, W0, [W15]
0084A2  32005B     BRA Z, 0x855A
0084A4  40006B     ADD W0, #0xB, W0
0084A6  508F80     SUB W1, W0, [W15]
0084A8  320058     BRA Z, 0x855A
0084AA  E80000     INC W0, W0
0084AC  508F80     SUB W1, W0, [W15]
0084AE  320055     BRA Z, 0x855A
0084B0  40006F     ADD W0, #0xF, W0
0084B2  508F80     SUB W1, W0, [W15]
0084B4  320052     BRA Z, 0x855A
0084B6  E88000     INC2 W0, W0
0084B8  508F80     SUB W1, W0, [W15]
0084BA  32004F     BRA Z, 0x855A
0084BC  40007E     ADD W0, #0x1E, W0
0084BE  508F80     SUB W1, W0, [W15]
0084C0  32004C     BRA Z, 0x855A
0084C2  E88000     INC2 W0, W0
0084C4  508F80     SUB W1, W0, [W15]
0084C6  320049     BRA Z, 0x855A
0084C8  2002E0     MOV #0x2E, W0
0084CA  508F80     SUB W1, W0, [W15]
0084CC  3A0047     BRA NZ, 0x855C
0084CE  52CFE1     SUB.B W5, #0x1, [W15]
0084D0  320044     BRA Z, 0x855A
0084D2  B3C015     MOV #0x1, W5
0084D4  370043     BRA 0x855C
7700:              					(utf16Value == 0x3B) || (utf16Value == 0x3D) || (utf16Value == 0x5B) || 
7701:              					(utf16Value == 0x5D) || ((utf16Value == 0x2E) && (radix == TRUE)))
7702:              			    {
7703:              					fileNameType = NAME_LFN_TYPE;
7704:              					continue;
7705:              			    }
7706:              
7707:              	    	    // only one radix ('.') character is allowed in 8P3 format, where as 
7708:              				// multiple radices can be present in LFN format
7709:              	    	    if (utf16Filename[count1] == 0x2E)
7710:              	    	    {
7711:              	    	        radix = TRUE;
7712:              	    	    }
7713:              			}
7714:              		}
7715:              		else 
7716:              		#endif
7717:              		{
7718:              			asciiValue = asciiFilename[count1];
0084D6  7D40E6     MOV.B [W6+W10], W1
7719:              			if(((asciiValue < 0x20) && (asciiValue != 0x05)) || (asciiValue == 0x22) ||
0084D8  50CFFF     SUB.B W1, #0x1F, [W15]
0084DA  3E0002     BRA GTU, 0x84E0
0084DC  50CFE5     SUB.B W1, #0x5, [W15]
0084DE  3A0043     BRA NZ, 0x8566
0084E0  B3C220     MOV #0x22, W0
0084E2  50CF80     SUB.B W1, W0, [W15]
0084E4  320040     BRA Z, 0x8566
0084E6  40406D     ADD.B W0, #0xD, W0
0084E8  50CF80     SUB.B W1, W0, [W15]
0084EA  32003D     BRA Z, 0x8566
0084EC  50CF8E     SUB.B W1, W14, [W15]
0084EE  32003B     BRA Z, 0x8566
0084F0  50CF8C     SUB.B W1, W12, [W15]
0084F2  320039     BRA Z, 0x8566
0084F4  50CF8D     SUB.B W1, W13, [W15]
0084F6  320037     BRA Z, 0x8566
0084F8  50CF88     SUB.B W1, W8, [W15]
0084FA  320035     BRA Z, 0x8566
0084FC  50CF87     SUB.B W1, W7, [W15]
0084FE  320033     BRA Z, 0x8566
7720:              				(asciiValue == 0x2F) || (asciiValue == 0x3A) || (asciiValue == 0x3C) ||
7721:              				(asciiValue == 0x3E) || (asciiValue == 0x5C) || (asciiValue == 0x7C))
7722:              			{
7723:              				return NAME_ERROR;
7724:              			}
7725:              
7726:              	        // Check for partial string search chars
7727:              	        if (mode == FALSE)
008500  E0040B     CP0.B W11
008502  3A0006     BRA NZ, 0x8510
7728:              	        {
7729:              	            if ((asciiValue == '*') || (asciiValue == '?'))
008504  504065     SUB.B W0, #0x5, W0
008506  50CF80     SUB.B W1, W0, [W15]
008508  32002E     BRA Z, 0x8566
00850A  404075     ADD.B W0, #0x15, W0
00850C  50CF80     SUB.B W1, W0, [W15]
00850E  32002B     BRA Z, 0x8566
7730:              	            {
7731:              	    		    return NAME_ERROR;
7732:              	        	}
7733:              	        }
7734:              
7735:              			if(fileNameType != NAME_LFN_TYPE)
008510  510FE6     SUB W2, #0x6, [W15]
008512  320024     BRA Z, 0x855C
7736:              			{
7737:              				// Characters valid for LFN format only
7738:              			    if ((asciiValue == 0x20) || (asciiValue == 0x2B) || (asciiValue == 0x2C) ||
008514  B3C200     MOV #0x20, W0
008516  50CF80     SUB.B W1, W0, [W15]
008518  320020     BRA Z, 0x855A
00851A  40406B     ADD.B W0, #0xB, W0
00851C  50CF80     SUB.B W1, W0, [W15]
00851E  32001D     BRA Z, 0x855A
008520  E84000     INC.B W0, W0
008522  50CF80     SUB.B W1, W0, [W15]
008524  32001A     BRA Z, 0x855A
008526  40406F     ADD.B W0, #0xF, W0
008528  50CF80     SUB.B W1, W0, [W15]
00852A  320017     BRA Z, 0x855A
00852C  E8C000     INC2.B W0, W0
00852E  50CF80     SUB.B W1, W0, [W15]
008530  320014     BRA Z, 0x855A
008532  40407E     ADD.B W0, #0x1E, W0
008534  50CF80     SUB.B W1, W0, [W15]
008536  320011     BRA Z, 0x855A
008538  E8C000     INC2.B W0, W0
00853A  50CF80     SUB.B W1, W0, [W15]
00853C  32000E     BRA Z, 0x855A
00853E  B3C2E0     MOV #0x2E, W0
008540  50CF80     SUB.B W1, W0, [W15]
008542  3A0003     BRA NZ, 0x854A
008544  52CFE1     SUB.B W5, #0x1, [W15]
008546  320009     BRA Z, 0x855A
008548  B3C015     MOV #0x1, W5
7739:              			    	(asciiValue == 0x3B) || (asciiValue == 0x3D) || (asciiValue == 0x5B) ||
7740:              			        (asciiValue == 0x5D) || ((asciiValue == 0x2E) && (radix == TRUE)))
7741:              			    {
7742:              					fileNameType = NAME_LFN_TYPE;
7743:              					continue;
7744:              			    }
7745:              
7746:              	    	    // only one radix ('.') character is allowed in 8P3 format, where as 
7747:              				// multiple radices can be present in LFN format
7748:              	    	    if (asciiValue == 0x2E)
7749:              	    	    {
7750:              	    	        radix = TRUE;
7751:              	    	    }
7752:              
7753:              				// If the characters are mixed type & are within 8P3 length range
7754:              				// then store file type as 8P3 mixed type format
7755:              				if(fileNameType != NAME_8P3_ASCII_MIXED_TYPE)
00854A  510FE1     SUB W2, #0x1, [W15]
00854C  320007     BRA Z, 0x855C
7756:              				{
7757:              					if((asciiValue >= 0x61) && (asciiValue <= 0x7A))
00854E  B3C9F0     MOV #0x9F, W0
008550  40C000     ADD.B W1, W0, W0
008552  504FF9     SUB.B W0, #0x19, [W15]
008554  3E0003     BRA GTU, 0x855C
008556  200012     MOV #0x1, W2
008558  370001     BRA 0x855C
00855A  200062     MOV #0x6, W2
7758:              					{
7759:              						fileNameType = NAME_8P3_ASCII_MIXED_TYPE;
7760:              					}
7761:              				}
7762:              			}
7763:              		}
7764:              	}
7765:              
7766:              	return fileNameType;
7767:              }
008574  FA0200     LNK #0x200
008576  BE9F88     MOV.D W8, [W15++]
008578  BE9F8A     MOV.D W10, [W15++]
00857A  780400     MOV W0, W8
00857C  780501     MOV W1, W10
00857E  784582     MOV.B W2, W11
7768:              
7769:              
7770:              /**********************************************************************
7771:                Function:
7772:                  int FSfseek(FSFILE *stream, long offset, int whence)
7773:                Summary:
7774:                  Change the current position in a file
7775:                Conditions:
7776:                  File opened
7777:                Input:
7778:                  stream -    Pointer to file structure
7779:                  offset -    Offset from base location
7780:                  whence -
7781:                         - SEEK_SET -  Seek from start of file
7782:                         - SEEK_CUR -  Seek from current location
7783:                         - SEEK_END -  Seek from end of file (subtract offset)
7784:                Return Values:
7785:                  0 -  Operation successful
7786:                  -1 - Operation unsuccesful
7787:                Side Effects:
7788:                  The FSerrno variable will be changed.
7789:                Description:
7790:                  The FSfseek function will change the current position in the file to
7791:                  one specified by the user.  First, an absolute offset is calculated
7792:                  using the offset and base location passed in by the user.  Then, the
7793:                  position variables are updated, and the sector number that corresponds
7794:                  to the new location.  That sector is then loaded.  If the offset
7795:                  falls exactly on a cluster boundary, a new cluster will be allocated
7796:                  to the file and the position will be set to the first byte of that
7797:                  cluster.
7798:                Remarks:
7799:                  None
7800:                **********************************************************************/
7801:              
7802:              int FSfseek(FSFILE *stream, long offset, int whence)
7803:              {
7804:                  DWORD    numsector, temp;   // lba of first sector of first cluster
7805:                  DISK*   dsk;            // pointer to disk structure
7806:                  BYTE   test;
7807:                  long offset2 = offset;
7808:              
7809:                  dsk = stream->dsk;
007E0E  780010     MOV [W0], W0
007E10  9FBF80     MOV W0, [W15-16]
7810:              
7811:                  switch(whence)
007E12  508FE1     SUB W1, #0x1, [W15]
007E14  320004     BRA Z, 0x7E1E
007E16  508FE2     SUB W1, #0x2, [W15]
007E18  320007     BRA Z, 0x7E28
007E1A  BE0602     MOV.D W2, W12
007E1C  370009     BRA 0x7E30
7812:                  {
7813:                      case SEEK_CUR:
7814:                          // Apply the offset to the current position
7815:                          offset2 += stream->seek;
007E1E  90007E     MOV [W14+14], W0
007E20  90088E     MOV [W14+16], W1
007E22  400602     ADD W0, W2, W12
007E24  488683     ADDC W1, W3, W13
007E26  370004     BRA 0x7E30
7816:                          break;
7817:                      case SEEK_END:
7818:                          // Apply the offset to the end of the file
7819:                          offset2 = stream->size - offset2;
007E28  90081E     MOV [W14+18], W0
007E2A  9008AE     MOV [W14+20], W1
007E2C  500602     SUB W0, W2, W12
007E2E  588683     SUBB W1, W3, W13
7820:                          break;
7821:                      case SEEK_SET:
7822:                          // automatically there
7823:                      default:
7824:                          break;
7825:                 }
7826:              
7827:              #ifdef ALLOW_WRITES
7828:                  if (gNeedDataWrite)
007E30  270BB0     MOV #0x70BB, W0
007E32  E00410     CP0.B [W0]
007E34  320004     BRA Z, 0x7E3E
7829:                      if (flushData())
007E36  07F876     RCALL flushData
007E3A  E00400     CP0.B W0
007E3C  3A000A     BRA NZ, 0x7E52
7830:                      {
7831:                          FSerrno = CE_WRITE_ERROR;
007E38  B3C091     MOV #0x9, W1
7832:                          return EOF;
7833:                      }
7834:              #endif
7835:              
7836:                  // start from the beginning
7837:                  temp = stream->cluster;
7838:                  stream->ccls = temp;
007E3E  90001E     MOV [W14+2], W0
007E40  9000AE     MOV [W14+4], W1
007E42  980730     MOV W0, [W14+6]
007E44  980741     MOV W1, [W14+8]
7839:              
7840:                  temp = stream->size;
7841:              
7842:                  if (offset2 > temp)
007E46  90081E     MOV [W14+18], W0
007E48  9008AE     MOV [W14+20], W1
007E4A  560F80     SUB W12, W0, [W15]
007E4C  5E8F81     SUBB W13, W1, [W15]
007E4E  360005     BRA LEU, 0x7E5A
7843:                  {
7844:                      FSerrno = CE_INVALID_ARGUMENT;
007E50  B3C1F1     MOV #0x1F, W1
007E52  249380     MOV #0x4938, W0
007E54  784801     MOV.B W1, [W0]
007E56  EB8000     SETM W0
007E58  37007B     BRA 0x7F50
7845:                      return (-1);      // past the limits
7846:                  }
7847:                  else
7848:                  {
7849:                      // if we are writing we are no longer at the end
7850:                      stream->flags.FileWriteEOF = FALSE;
007E5A  90083E     MOV [W14+22], W0
007E5C  A12000     BCLR W0, #2
007E5E  980F30     MOV W0, [W14+22]
7851:              
7852:                      // set the new postion
7853:                      stream->seek = offset2;
007E60  98077C     MOV W12, [W14+14]
007E62  980F0D     MOV W13, [W14+16]
7854:              
7855:                      // figure out how many sectors
7856:                      numsector = offset2 / dsk->sectorSize;
007E64  97B90F     MOV [W15-16], W2
007E66  905882     MOV.B [W2+24], W1
007E68  FB8081     ZE W1, W1
007E6A  905812     MOV.B [W2+25], W0
007E6C  DD0048     SL W0, #8, W0
007E6E  700401     IOR W0, W1, W8
007E70  9058A2     MOV.B [W2+26], W1
007E72  FB8081     ZE W1, W1
007E74  905832     MOV.B [W2+27], W0
007E76  DD0048     SL W0, #8, W0
007E78  700481     IOR W0, W1, W9
007E7A  BE0108     MOV.D W8, W2
007E7C  BE000C     MOV.D W12, W0
007E7E  07EB11     RCALL __udivsi3
007E80  BE0500     MOV.D W0, W10
7857:              
7858:                      // figure out how many bytes off of the offset
7859:                      offset2 = offset2 - (numsector * dsk->sectorSize);
7860:                      stream->pos = offset2;
007E82  BE0108     MOV.D W8, W2
007E84  07EA9E     RCALL __mulp32eds3
007E86  560000     SUB W12, W0, W0
007E88  5E8081     SUBB W13, W1, W1
007E8A  980760     MOV W0, [W14+12]
7861:              
7862:                      // figure out how many clusters
7863:                      temp = numsector / dsk->SecPerClus;
007E8C  97BA0F     MOV [W15-16], W4
007E8E  906414     MOV.B [W4+33], W8
007E90  FB8408     ZE W8, W8
007E92  200009     MOV #0x0, W9
007E94  BE0108     MOV.D W8, W2
007E96  BE000A     MOV.D W10, W0
007E98  07EB04     RCALL __udivsi3
7864:              
7865:                      // figure out the stranded sectors
7866:                      numsector = numsector - (dsk->SecPerClus * temp);
7867:                      stream->sec = numsector;
007E9A  BE0600     MOV.D W0, W12
007E9C  BE0100     MOV.D W0, W2
007E9E  BE0008     MOV.D W8, W0
007EA0  07EA90     RCALL __mulp32eds3
007EA2  550500     SUB W10, W0, W10
007EA4  5D8581     SUBB W11, W1, W11
007EA6  98075A     MOV W10, [W14+10]
7868:              
7869:                      // if we are in the current cluster stay there
7870:                      if (temp > 0)
007EA8  560FE0     SUB W12, #0x0, [W15]
007EAA  5E8FE0     SUBB W13, #0x0, [W15]
007EAC  320035     BRA Z, 0x7F18
7871:                      {
7872:                          test = FILEget_next_cluster(stream, temp);
007EAE  BE010C     MOV.D W12, W2
007EB0  78000E     MOV W14, W0
007EB2  07FC76     RCALL FILEget_next_cluster
007EB4  784080     MOV.B W0, W1
7873:                          if (test != CE_GOOD)
007EB6  E00400     CP0.B W0
007EB8  32002F     BRA Z, 0x7F18
7874:                          {
7875:                              if (test == CE_FAT_EOF)
007EBA  B3C3C0     MOV #0x3C, W0
007EBC  50CF80     SUB.B W1, W0, [W15]
007EBE  3A002A     BRA NZ, 0x7F14
7876:                              {
7877:              #ifdef ALLOW_WRITES
7878:                                  if (stream->flags.write)
007EC0  90083E     MOV [W14+22], W0
007EC2  A30800     BTST.Z W0, #0
007EC4  320011     BRA Z, 0x7EE8
7879:                                  {
7880:                                      // load the previous cluster
7881:                                      stream->ccls = stream->cluster;
007EC6  90001E     MOV [W14+2], W0
007EC8  9000AE     MOV [W14+4], W1
007ECA  980730     MOV W0, [W14+6]
007ECC  980741     MOV W1, [W14+8]
7882:                                      // Don't perform this operation if there's only one cluster
7883:                                      if (temp != 1)
007ECE  560FE1     SUB W12, #0x1, [W15]
007ED0  5E8FE0     SUBB W13, #0x0, [W15]
007ED2  320004     BRA Z, 0x7EDC
7884:                                      test = FILEget_next_cluster(stream, temp - 1);
007ED4  560161     SUB W12, #0x1, W2
007ED6  5E81E0     SUBB W13, #0x0, W3
007ED8  78000E     MOV W14, W0
007EDA  07FC62     RCALL FILEget_next_cluster
7885:                                      if (FILEallocate_new_cluster(stream, 0) != CE_GOOD)
007EDC  EB4080     CLR.B W1
007EDE  78000E     MOV W14, W0
007EE0  07FEA0     RCALL FILEallocate_new_cluster
007EE2  E00400     CP0.B W0
007EE4  320019     BRA Z, 0x7F18
007EE6  370016     BRA 0x7F14
7886:                                      {
7887:                                          FSerrno = CE_COULD_NOT_GET_CLUSTER;
7888:                                          return -1;
7889:                                      }
7890:                                      // sec and pos should already be zero
7891:                                  }
7892:                                  else
7893:                                  {
7894:              #endif
7895:                                      stream->ccls = stream->cluster;
007EE8  90001E     MOV [W14+2], W0
007EEA  9000AE     MOV [W14+4], W1
007EEC  980730     MOV W0, [W14+6]
007EEE  980741     MOV W1, [W14+8]
7896:                                      test = FILEget_next_cluster(stream, temp - 1);
007EF0  560161     SUB W12, #0x1, W2
007EF2  5E81E0     SUBB W13, #0x0, W3
007EF4  78000E     MOV W14, W0
007EF6  07FC54     RCALL FILEget_next_cluster
7897:                                      if (test != CE_GOOD)
007EF8  E00400     CP0.B W0
007EFA  3A000C     BRA NZ, 0x7F14
7898:                                      {
7899:                                          FSerrno = CE_COULD_NOT_GET_CLUSTER;
7900:                                          return (-1);
7901:                                      }
7902:                                      stream->pos = dsk->sectorSize;
007EFC  97BA0F     MOV [W15-16], W4
007EFE  905884     MOV.B [W4+24], W1
007F00  FB8081     ZE W1, W1
007F02  905814     MOV.B [W4+25], W0
007F04  DD0048     SL W0, #8, W0
007F06  700101     IOR W0, W1, W2
007F08  980762     MOV W2, [W14+12]
7903:                                      stream->sec = dsk->SecPerClus - 1;
007F0A  906014     MOV.B [W4+33], W0
007F0C  FB8000     ZE W0, W0
007F0E  E90000     DEC W0, W0
007F10  980750     MOV W0, [W14+10]
007F12  370002     BRA 0x7F18
7904:              #ifdef ALLOW_WRITES
7905:                                  }
7906:              #endif
7907:                              }
7908:                              else
7909:                              {
7910:                                  FSerrno = CE_COULD_NOT_GET_CLUSTER;
007F14  B3C0F1     MOV #0xF, W1
007F16  37FF9D     BRA 0x7E52
007F18  24938A     MOV #0x4938, W10
7911:                                  return (-1);   // past the limits
7912:                              }
7913:                          }
7914:                      }
7915:              
7916:                      // Determine the lba of the selected sector and load
7917:                      temp = Cluster2Sector(dsk,stream->ccls);
007F1A  90013E     MOV [W14+6], W2
007F1C  9001CE     MOV [W14+8], W3
007F1E  97B80F     MOV [W15-16], W0
007F20  07F7B2     RCALL Cluster2Sector
7918:              
7919:                      // now the extra sectors
7920:                      numsector = stream->sec;
7921:                      temp += numsector;
007F22  90015E     MOV [W14+10], W2
007F24  400602     ADD W0, W2, W12
007F26  4886E0     ADDC W1, #0x0, W13
7922:              
7923:                      gBufferOwner = NULL;
007F28  EB0400     CLR W8
007F2A  8B8608     MOV W8, gBufferOwner
7924:                      gBufferZeroed = FALSE;
007F2C  270B90     MOV #0x70B9, W0
007F2E  784808     MOV.B W8, [W0]
7925:                      if( !MDD_SectorRead(temp, dsk->buffer) )
007F30  97B88F     MOV [W15-16], W1
007F32  FB8011     ZE [W1], W0
007F34  904111     MOV.B [W1+1], W2
007F36  DD1148     SL W2, #8, W2
007F38  710100     IOR W2, W0, W2
007F3A  BE000C     MOV.D W12, W0
007F3C  072AD2     RCALL MDD_SDSPI_SectorRead
007F3E  E00400     CP0.B W0
007F40  3A0003     BRA NZ, 0x7F48
7926:                      {
7927:                          FSerrno = CE_BADCACHEREAD;
007F42  B3C1B0     MOV #0x1B, W0
007F44  784D00     MOV.B W0, [W10]
007F46  37FF87     BRA 0x7E56
7928:                          return (-1);   // Bad read
7929:                      }
7930:                      gLastDataSectorRead = temp;
007F48  8B85EC     MOV W12, gLastDataSectorRead
007F4A  8B85FD     MOV W13, 0x70BE
7931:                  }
7932:              
7933:                  FSerrno = CE_GOOD;
007F4C  784D08     MOV.B W8, [W10]
007F4E  780008     MOV W8, W0
7934:              
7935:                  return (0);
7936:              }
7937:              
7938:              
7939:              // FSfopenpgm, FSremovepgm, and FSrenamepgm will only work on PIC18s
7940:              #ifdef __18CXX
7941:              #ifdef ALLOW_PGMFUNCTIONS
7942:              
7943:              #ifdef ALLOW_WRITES
7944:              
7945:              /*****************************************************************
7946:                Function:
7947:                  int FSrenamepgm(const rom char * fileName, FSFILE * fo)
7948:                Summary:
7949:                  Renames the file with the ascii ROM string(PIC18)
7950:                Conditions:
7951:                  File opened.
7952:                Input:
7953:                  fileName -  The new name of the file (in ROM)
7954:                  fo -        The file to rename
7955:                Return Values:
7956:                  0 -  File renamed successfully
7957:                  -1 - File could not be renamed
7958:                Side Effects:
7959:                  The FSerrno variable will be changed.
7960:                Description:
7961:                  Renames the file with the ascii ROM string(PIC18).The Fsrenamepgm
7962:                  function will copy the rom fileName specified by the user into a 
7963:                  RAM array and pass that array into the FSrename function.
7964:                Remarks:
7965:                  This function is for use with PIC18 when passing arguments in ROM.                       
7966:                *****************************************************************/
7967:              
7968:              int FSrenamepgm (const rom char * fileName, FSFILE * fo)
7969:              {
7970:              	#if defined(SUPPORT_LFN)
7971:              
7972:              		char tempArray[257];
7973:              		unsigned short int count;
7974:              	#else
7975:              
7976:              		char	tempArray[13];
7977:              
7978:              	    BYTE count;
7979:              	#endif
7980:              
7981:              
7982:                  *fileName;
7983:                  for(count = 0; count < sizeof(tempArray); count++)
7984:                  {
7985:                      _asm TBLRDPOSTINC _endasm
7986:                      tempArray[count] = TABLAT;
7987:                  }//end for(...)
7988:              
7989:                  return FSrename (tempArray, fo);
7990:              }
7991:              #endif
7992:              
7993:              /******************************************************************************
7994:                Function:
7995:                  FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode)
7996:                Summary:
7997:                  Opens a file on PIC18 Microcontrollers where 'fileName' ROM string is given
7998:                  in Ascii format.
7999:                Conditions:
8000:                  For read modes, file exists; FSInit performed
8001:                Input:
8002:                  fileName -  The name of the file to be opened (ROM)
8003:                  mode -      The mode the file will be opened in (ROM)
8004:                Return Values:
8005:                  FSFILE * - A pointer to the file object
8006:                  NULL -     File could not be opened
8007:                Side Effects:
8008:                  The FSerrno variable will be changed.
8009:                Description:
8010:                  This function opens a file on PIC18 Microcontrollers where 'fileName' ROM string
8011:                  is given in Ascii format.The FSfopenpgm function will copy a PIC18 ROM fileName and
8012:                  mode argument into RAM arrays, and then pass those arrays to the FSfopen function.
8013:                Remarks:
8014:                  This function is for use with PIC18 when passing arguments in ROM.
8015:                ******************************************************************************/
8016:              
8017:              FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode)
8018:              {
8019:              	#if defined(SUPPORT_LFN)
8020:                  	char tempArray[257];
8021:                  	unsigned short int count = 0;
8022:                  #else
8023:                  	char tempArray[13];
8024:                  	BYTE count = 0;
8025:              	#endif
8026:                  char M[2];
8027:              
8028:                  for(;;)
8029:              	{
8030:              		tempArray[count] = fileName[count];
8031:              		if(tempArray[count])
8032:              			count++;
8033:              		else
8034:              			break;
8035:              	}
8036:              
8037:                  for (count = 0; count < 2; count++)
8038:                  {
8039:                      M[count] = *(mode + count);
8040:                  }
8041:              
8042:                  return FSfopen(tempArray, M);
8043:              }
8044:              
8045:              /*************************************************************
8046:                Function:
8047:                  int FSremovepgm (const rom char * fileName)
8048:                Summary:
8049:                  Deletes the file on PIC18 device
8050:                Conditions:
8051:                  File not opened; file exists
8052:                Input:
8053:                  fileName -  The name of the file to be deleted (ROM)
8054:                Return Values:
8055:                  0 -  File was removed successfully
8056:                  -1 - File could not be removed
8057:                Side Effects:
8058:                  The FSerrno variable will be changed.
8059:                Description:
8060:                  Deletes the file on PIC18 device.The FSremovepgm function will copy a
8061:                  PIC18 ROM fileName argument into a RAM array, and then pass that array
8062:                  to the FSremove function.
8063:                Remarks:
8064:                  This function is for use with PIC18 when passing arguments in ROM.
8065:                *************************************************************/
8066:              #ifdef ALLOW_WRITES
8067:              int FSremovepgm (const rom char * fileName)
8068:              {
8069:              	#ifdef SUPPORT_LFN
8070:              		char tempArray[257];
8071:              		unsigned short int count;
8072:              	#else
8073:              
8074:              		char	tempArray[13];
8075:              
8076:              	    BYTE count;
8077:              	#endif
8078:              
8079:              
8080:                  *fileName;
8081:                  for(count = 0; count < sizeof(tempArray); count++)
8082:                  {
8083:                      _asm TBLRDPOSTINC _endasm
8084:                      tempArray[count] = TABLAT;
8085:                  }//end for(...)
8086:              
8087:                  return FSremove (tempArray);
8088:              }
8089:              #endif
8090:              
8091:              /**************************************************************************************
8092:                Function:
8093:                  int FindFirstpgm (const char * fileName, unsigned int attr, SearchRec * rec)
8094:                Summary:
8095:                  Find a file named with a ROM string on PIC18
8096:                Conditions:
8097:                  None
8098:                Input:
8099:                  fileName -  The name of the file to be found (ROM)
8100:                  attr -      The attributes of the file to be found
8101:                  rec -       Pointer to a search record to store the file info in
8102:                Return Values:
8103:                  0 -  File was found
8104:                  -1 - No file matching the given parameters was found
8105:                Side Effects:
8106:                  Search criteria from previous FindFirstpgm call on passed SearchRec object
8107:                  will be lost.The FSerrno variable will be changed.
8108:                Description:
8109:                  This function finds a file named with 'fileName' on PIC18. The FindFirstpgm
8110:                  function will copy a PIC18 ROM fileName argument into a RAM array, and then
8111:                  pass that array to the FindFirst function.
8112:                Remarks:
8113:                  Call FindFirstpgm or FindFirst before calling FindNext.
8114:                  This function is for use with PIC18 when passing arguments in ROM.
8115:                **************************************************************************************/
8116:              #ifdef ALLOW_FILESEARCH
8117:              int FindFirstpgm (const rom char * fileName, unsigned int attr, SearchRec * rec)
8118:              {
8119:              	#if defined(SUPPORT_LFN)
8120:              
8121:              		char tempArray[257];
8122:              		unsigned short int count;
8123:              	#else
8124:              
8125:              		char	tempArray[13];
8126:              
8127:              	    BYTE count;
8128:              	#endif
8129:              
8130:              
8131:                  *fileName;
8132:                  for(count = 0; count < sizeof(tempArray); count++)
8133:                  {
8134:                      _asm TBLRDPOSTINC _endasm
8135:                      tempArray[count] = TABLAT;
8136:                  }//end for
8137:              
8138:                  return FindFirst (tempArray,attr,rec);
8139:              }
8140:              #endif
8141:              #endif
8142:              #endif
8143:              
8144:              
8145:              /***********************************************
8146:                Function:
8147:                  DWORD ReadFAT (DISK *dsk, DWORD ccls)
8148:                Summary:
8149:                  Read the next entry from the FAT
8150:                Conditions:
8151:                  This function should not be called by the user.
8152:                Input:
8153:                  dsk -   The disk structure
8154:                  ccls -  The current cluster
8155:                Return:
8156:                  DWORD - The next cluster in a file chain
8157:                Side Effects:
8158:                  None
8159:                Description:
8160:                  The ReadFAT function will read the FAT and
8161:                  determine the next cluster value after the
8162:                  cluster specified by 'ccls.' Note that the
8163:                  FAT sector that is read is stored in the
8164:                  global FAT cache buffer.
8165:                Remarks:
8166:                  None.
8167:                ***********************************************/
8168:              
8169:              DWORD ReadFAT (DISK *dsk, DWORD ccls)
8170:              {
8171:                  BYTE q;
8172:                  DWORD p, l;  // "l" is the sector Address
8173:                  DWORD c = 0, d, ClusterFailValue,LastClusterLimit;   // ClusterEntries
8174:              
8175:                  gBufferZeroed = FALSE;
007398  270B90     MOV #0x70B9, W0
00739A  EB4800     CLR.B [W0]
8176:              
8177:                  /* Settings based on FAT type */
8178:                  switch (dsk->type)
00739C  90602E     MOV.B [W14+34], W0
00739E  9FF790     MOV.B W0, [W15-15]
0073A0  504FE1     SUB.B W0, #0x1, [W15]
0073A2  320011     BRA Z, 0x73C6
0073A4  504FE3     SUB.B W0, #0x3, [W15]
0073A6  3A001E     BRA NZ, 0x73E4
8179:                  {
8180:              #ifdef SUPPORT_FAT32 // If FAT32 supported.
8181:                      case FAT32:
8182:                          p = (DWORD)ccls * 4;
0073A8  DD1E42     SL W3, #2, W12
0073AA  DE16CE     LSR W2, #14, W13
0073AC  76068D     IOR W12, W13, W13
0073AE  DD1642     SL W2, #2, W12
0073B0  EB4080     CLR.B W1
0073B2  9FF781     MOV.B W1, [W15-16]
0073B4  2FFFF2     MOV #0xFFFF, W2
0073B6  20FFF3     MOV #0xFFF, W3
0073B8  9FB7E2     MOV W2, [W15-20]
0073BA  9FB7F3     MOV W3, [W15-18]
0073BC  2FFF80     MOV #0xFFF8, W0
0073BE  20FFF1     MOV #0xFFF, W1
0073C0  9FB7C0     MOV W0, [W15-24]
0073C2  9FB7D1     MOV W1, [W15-22]
0073C4  37001B     BRA 0x73FC
8183:                          q = 0; // "q" not used for FAT32, only initialized to remove a warning
8184:                          ClusterFailValue = CLUSTER_FAIL_FAT32;
8185:                          LastClusterLimit = LAST_CLUSTER_FAT32;
8186:                          break;
8187:              #endif
8188:                      case FAT12:
8189:                          p = (DWORD) ccls *3;  // Mulby1.5 to find cluster pos in FAT
0073C6  200032     MOV #0x3, W2
0073C8  200003     MOV #0x0, W3
0073CA  BE0004     MOV.D W4, W0
0073CC  07EFFA     RCALL __mulp32eds3
8190:                          q = p&1;
0073CE  604161     AND.B W0, #0x1, W2
0073D0  9FF782     MOV.B W2, [W15-16]
8191:                          p >>= 1;
0073D2  D10681     LSR W1, W13
0073D4  D38600     RRC W0, W12
0073D6  2FFFF0     MOV #0xFFFF, W0
0073D8  200001     MOV #0x0, W1
0073DA  9FB7E0     MOV W0, [W15-20]
0073DC  9FB7F1     MOV W1, [W15-18]
0073DE  20FF82     MOV #0xFF8, W2
0073E0  200003     MOV #0x0, W3
0073E2  37000A     BRA 0x73F8
8192:                          ClusterFailValue = CLUSTER_FAIL_FAT16;
8193:                          LastClusterLimit = LAST_CLUSTER_FAT12;
8194:                          break;
8195:                      case FAT16:
8196:                      default:
8197:                          p = (DWORD)ccls *2;     // Mulby 2 to find cluster pos in FAT
0073E4  410602     ADD W2, W2, W12
0073E6  498683     ADDC W3, W3, W13
0073E8  EB4180     CLR.B W3
0073EA  9FF783     MOV.B W3, [W15-16]
0073EC  2FFFF0     MOV #0xFFFF, W0
0073EE  200001     MOV #0x0, W1
0073F0  9FB7E0     MOV W0, [W15-20]
0073F2  9FB7F1     MOV W1, [W15-18]
0073F4  2FFF82     MOV #0xFFF8, W2
0073F6  200003     MOV #0x0, W3
0073F8  9FB7C2     MOV W2, [W15-24]
0073FA  9FB7D3     MOV W3, [W15-22]
8198:                          q = 0; // "q" not used for FAT16, only initialized to remove a warning
8199:                          ClusterFailValue = CLUSTER_FAIL_FAT16;
8200:                          LastClusterLimit = LAST_CLUSTER_FAT16;
8201:                          break;
8202:                  }
8203:              
8204:                  l = dsk->fat + (p / dsk->sectorSize);     //
0073FC  90588E     MOV.B [W14+24], W1
0073FE  FB8081     ZE W1, W1
007400  90581E     MOV.B [W14+25], W0
007402  DD0048     SL W0, #8, W0
007404  700401     IOR W0, W1, W8
007406  9058AE     MOV.B [W14+26], W1
007408  FB8081     ZE W1, W1
00740A  90583E     MOV.B [W14+27], W0
00740C  DD0048     SL W0, #8, W0
00740E  700481     IOR W0, W1, W9
007410  9040EE     MOV.B [W14+6], W1
007412  FB8081     ZE W1, W1
007414  90407E     MOV.B [W14+7], W0
007416  DD0048     SL W0, #8, W0
007418  700501     IOR W0, W1, W10
00741A  90488E     MOV.B [W14+8], W1
00741C  FB8081     ZE W1, W1
00741E  90481E     MOV.B [W14+9], W0
007420  DD0048     SL W0, #8, W0
007422  700581     IOR W0, W1, W11
007424  BE0108     MOV.D W8, W2
007426  BE000C     MOV.D W12, W0
007428  07F03C     RCALL __udivsi3
00742A  40050A     ADD W0, W10, W10
00742C  48858B     ADDC W1, W11, W11
8205:                  p &= dsk->sectorSize - 1;                 // Restrict 'p' within the FATbuffer size
00742E  540461     SUB W8, #0x1, W8
007430  5C84E0     SUBB W9, #0x0, W9
007432  780308     MOV W8, W6
007434  780209     MOV W9, W4
007436  64008C     AND W8, W12, W1
007438  64800D     AND W9, W13, W0
00743A  780180     MOV W0, W3
00743C  780101     MOV W1, W2
00743E  BE0402     MOV.D W2, W8
8206:              
8207:                  // Check if the appropriate FAT sector is already loaded
8208:                  if (gLastFATSectorRead == l)
007440  838620     MOV gLastFATSectorRead, W0
007442  838631     MOV 0x70C6, W1
007444  500F8A     SUB W0, W10, [W15]
007446  588F8B     SUBB W1, W11, [W15]
007448  3A0047     BRA NZ, 0x74D8
8209:                  {
8210:              #ifdef SUPPORT_FAT32 // If FAT32 supported.
8211:                      if (dsk->type == FAT32)
00744A  97F19F     MOV.B [W15-15], W3
00744C  51CFE3     SUB.B W3, #0x3, [W15]
00744E  32005E     BRA Z, 0x750C
8212:                          c = RAMreadD (gFATBuffer, p);
8213:                      else
8214:              #endif
8215:                          if(dsk->type == FAT16)
007450  97F01F     MOV.B [W15-15], W0
007452  504FE2     SUB.B W0, #0x2, [W15]
007454  320061     BRA Z, 0x7518
8216:                              c = RAMreadW (gFATBuffer, p);
8217:                          else if(dsk->type == FAT12)
007456  97F09F     MOV.B [W15-15], W1
007458  50CFE1     SUB.B W1, #0x1, [W15]
00745A  3A0096     BRA NZ, 0x7588
8218:                          {
8219:                              c = RAMread (gFATBuffer, p);
00745C  268982     MOV #0x6898, W2
00745E  794068     MOV.B [W8+W2], W0
007460  FB8600     ZE W0, W12
007462  20000D     MOV #0x0, W13
8220:                              if (q)
007464  97F18F     MOV.B [W15-16], W3
007466  E00403     CP0.B W3
007468  320004     BRA Z, 0x7472
8221:                              {
8222:                                  c >>= 4;
00746A  DD684C     SL W13, #12, W0
00746C  DE6644     LSR W12, #4, W12
00746E  70060C     IOR W0, W12, W12
007470  DE6EC4     LSR W13, #4, W13
8223:                              }
8224:                              // Check if the MSB is across the sector boundry
8225:                              p = (p +1) & (dsk->sectorSize-1);
007472  440061     ADD W8, #0x1, W0
007474  4C80E0     ADDC W9, #0x0, W1
007476  630100     AND W6, W0, W2
007478  620001     AND W4, W1, W0
00747A  780080     MOV W0, W1
00747C  780002     MOV W2, W0
00747E  BE0400     MOV.D W0, W8
8226:                              if (p == 0)
007480  540FE0     SUB W8, #0x0, [W15]
007482  5C8FE0     SUBB W9, #0x0, [W15]
007484  3A0014     BRA NZ, 0x74AE
8227:                              {
8228:                                  // Start by writing the sector we just worked on to the card
8229:                                  // if we need to
8230:              #ifdef ALLOW_WRITES
8231:                                  if (gNeedFATWrite)
007486  270C20     MOV #0x70C2, W0
007488  E00410     CP0.B [W0]
00748A  320008     BRA Z, 0x749C
8232:                                      if(WriteFAT (dsk, 0, 0, TRUE))
00748C  97F09F     MOV.B [W15-15], W1
00748E  BE0208     MOV.D W8, W4
007490  BE0108     MOV.D W8, W2
007492  78000E     MOV W14, W0
007494  07FE4E     RCALL WriteFAT
007496  500FE0     SUB W0, #0x0, [W15]
007498  588FE0     SUBB W1, #0x0, [W15]
00749A  3A007F     BRA NZ, 0x759A
8233:                                          return ClusterFailValue;
8234:              #endif
8235:                                  if (!MDD_SectorRead (l+1, gFATBuffer))
00749C  450561     ADD W10, #0x1, W10
00749E  4D85E0     ADDC W11, #0x0, W11
0074A0  268982     MOV #0x6898, W2
0074A2  BE000A     MOV.D W10, W0
0074A4  07301E     RCALL MDD_SDSPI_SectorRead
0074A6  E00400     CP0.B W0
0074A8  320027     BRA Z, 0x74F8
8236:                                  {
8237:                                      gLastFATSectorRead = 0xFFFF;
8238:                                      return ClusterFailValue;
8239:                                  }
8240:                                  else
8241:                                  {
8242:                                      gLastFATSectorRead = l +1;
0074AA  8B862A     MOV W10, gLastFATSectorRead
0074AC  8B863B     MOV W11, 0x70C6
8243:                                  }
8244:                              }
8245:                              d = RAMread (gFATBuffer, p);
0074AE  268980     MOV #0x6898, W0
0074B0  784068     MOV.B [W8+W0], W0
0074B2  FB8000     ZE W0, W0
0074B4  200001     MOV #0x0, W1
8246:                              if (q)
0074B6  97F10F     MOV.B [W15-16], W2
0074B8  E00402     CP0.B W2
0074BA  320005     BRA Z, 0x74C6
8247:                              {
8248:                                  c += (d <<4);
0074BC  DD09C4     SL W1, #4, W3
0074BE  DE00CC     LSR W0, #12, W1
0074C0  718081     IOR W3, W1, W1
0074C2  DD0044     SL W0, #4, W0
0074C4  370006     BRA 0x74D2
8249:                              }
8250:                              else
8251:                              {
8252:                                  c += ((d & 0x0F)<<8);
0074C6  60006F     AND W0, #0xF, W0
0074C8  200001     MOV #0x0, W1
0074CA  DD08C8     SL W1, #8, W1
0074CC  FD8000     SWAP W0
0074CE  784080     MOV.B W0, W1
0074D0  EB4000     CLR.B W0
0074D2  40000C     ADD W0, W12, W0
0074D4  48808D     ADDC W1, W13, W1
0074D6  370059     BRA 0x758A
8253:                              }
8254:                          }
8255:                      }
8256:                      else
8257:                      {
8258:                          // If there's a currently open FAT sector,
8259:                          // write it back before reading into the buffer
8260:              #ifdef ALLOW_WRITES
8261:                          if (gNeedFATWrite)
0074D8  270C20     MOV #0x70C2, W0
0074DA  E00410     CP0.B [W0]
0074DC  320008     BRA Z, 0x74EE
8262:                          {
8263:                              if(WriteFAT (dsk, 0, 0, TRUE))
0074DE  B3C011     MOV #0x1, W1
0074E0  B82260     MUL.UU W4, #0, W4
0074E2  BE0104     MOV.D W4, W2
0074E4  78000E     MOV W14, W0
0074E6  07FE25     RCALL WriteFAT
0074E8  500FE0     SUB W0, #0x0, [W15]
0074EA  588FE0     SUBB W1, #0x0, [W15]
0074EC  3A0056     BRA NZ, 0x759A
8264:                                  return ClusterFailValue;
8265:                          }
8266:              #endif
8267:                          if (!MDD_SectorRead (l, gFATBuffer))
0074EE  268982     MOV #0x6898, W2
0074F0  BE000A     MOV.D W10, W0
0074F2  072FF7     RCALL MDD_SDSPI_SectorRead
0074F4  E00400     CP0.B W0
0074F6  3A0005     BRA NZ, 0x7502
8268:                          {
8269:                              gLastFATSectorRead = 0xFFFF;  // Note: It is Sector not Cluster.
0074F8  2FFFF0     MOV #0xFFFF, W0
0074FA  200001     MOV #0x0, W1
0074FC  8B8620     MOV W0, gLastFATSectorRead
0074FE  8B8631     MOV W1, 0x70C6
007500  37004C     BRA 0x759A
8270:                              return ClusterFailValue;
8271:                          }
8272:                          else
8273:                          {
8274:                              gLastFATSectorRead = l;
007502  8B862A     MOV W10, gLastFATSectorRead
007504  8B863B     MOV W11, 0x70C6
8275:              
8276:              #ifdef SUPPORT_FAT32 // If FAT32 supported.
8277:                              if (dsk->type == FAT32)
007506  90602E     MOV.B [W14+34], W0
007508  504FE3     SUB.B W0, #0x3, [W15]
00750A  3A0004     BRA NZ, 0x7514
8278:                                  c = RAMreadD (gFATBuffer, p);
00750C  268980     MOV #0x6898, W0
00750E  440000     ADD W8, W0, W0
007510  BE0010     MOV.D [W0], W0
007512  37003B     BRA 0x758A
8279:                              else
8280:              #endif
8281:                                  if(dsk->type == FAT16)
007514  504FE2     SUB.B W0, #0x2, [W15]
007516  3A0004     BRA NZ, 0x7520
8282:                                      c = RAMreadW (gFATBuffer, p);
007518  268980     MOV #0x6898, W0
00751A  780068     MOV [W8+W0], W0
00751C  200001     MOV #0x0, W1
00751E  370035     BRA 0x758A
8283:                                  else if (dsk->type == FAT12)
007520  504FE1     SUB.B W0, #0x1, [W15]
007522  3A0032     BRA NZ, 0x7588
8284:                                  {
8285:                                      c = RAMread (gFATBuffer, p);
007524  26898A     MOV #0x6898, W10
007526  7D4068     MOV.B [W8+W10], W0
007528  FB8300     ZE W0, W6
00752A  200007     MOV #0x0, W7
8286:                                      if (q)
00752C  97F00F     MOV.B [W15-16], W0
00752E  E00400     CP0.B W0
007530  320004     BRA Z, 0x753A
8287:                                      {
8288:                                          c >>= 4;
007532  DD38CC     SL W7, #12, W1
007534  DE3344     LSR W6, #4, W6
007536  708306     IOR W1, W6, W6
007538  DE3BC4     LSR W7, #4, W7
8289:                                      }
8290:                                      p = (p +1) & (dsk->sectorSize-1);
8291:                                      d = RAMread (gFATBuffer, p);
00753A  440261     ADD W8, #0x1, W4
00753C  4C82E0     ADDC W9, #0x0, W5
00753E  90598E     MOV.B [W14+24], W3
007540  FB8183     ZE W3, W3
007542  90591E     MOV.B [W14+25], W2
007544  DD1148     SL W2, #8, W2
007546  710003     IOR W2, W3, W0
007548  9059AE     MOV.B [W14+26], W3
00754A  FB8183     ZE W3, W3
00754C  90593E     MOV.B [W14+27], W2
00754E  DD1148     SL W2, #8, W2
007550  710083     IOR W2, W3, W1
007552  500061     SUB W0, #0x1, W0
007554  5880E0     SUBB W1, #0x0, W1
007556  600104     AND W0, W4, W2
007558  608005     AND W1, W5, W0
00755A  780280     MOV W0, W5
00755C  780202     MOV W2, W4
00755E  BE0004     MOV.D W4, W0
007560  7D4060     MOV.B [W0+W10], W0
007562  FB8000     ZE W0, W0
007564  200001     MOV #0x0, W1
8292:                                      if (q)
007566  97F10F     MOV.B [W15-16], W2
007568  E00402     CP0.B W2
00756A  320005     BRA Z, 0x7576
8293:                                      {
8294:                                          c += (d <<4);
00756C  DD09C4     SL W1, #4, W3
00756E  DE00CC     LSR W0, #12, W1
007570  718081     IOR W3, W1, W1
007572  DD0044     SL W0, #4, W0
007574  370006     BRA 0x7582
8295:                                      }
8296:                                      else
8297:                                      {
8298:                                          c += ((d & 0x0F)<<8);
007576  60006F     AND W0, #0xF, W0
007578  200001     MOV #0x0, W1
00757A  DD08C8     SL W1, #8, W1
00757C  FD8000     SWAP W0
00757E  784080     MOV.B W0, W1
007580  EB4000     CLR.B W0
007582  400006     ADD W0, W6, W0
007584  488087     ADDC W1, W7, W1
007586  370001     BRA 0x758A
007588  B80060     MUL.UU W0, #0, W0
8299:                                      }
8300:                                  }
8301:                          }
8302:                  }
8303:              
8304:                  // Normalize it so 0xFFFF is an error
8305:                  if (c >= LastClusterLimit)
00758A  97B14F     MOV [W15-24], W2
00758C  97B1DF     MOV [W15-22], W3
00758E  500F82     SUB W0, W2, [W15]
007590  588F83     SUBB W1, W3, [W15]
007592  390001     BRA NC, 0x7596
007594  BE0002     MOV.D W2, W0
007596  9FB7E0     MOV W0, [W15-20]
007598  9FB7F1     MOV W1, [W15-18]
8306:                      c = LastClusterLimit;
8307:              
8308:                 return c;
8309:              }   // ReadFAT
0075AA  4787EE     ADD W15, #0xE, W15
0075AC  BE9F88     MOV.D W8, [W15++]
0075AE  BE9F8A     MOV.D W10, [W15++]
0075B0  BE9F8C     MOV.D W12, [W15++]
0075B2  781F8E     MOV W14, [W15++]
0075B4  780700     MOV W0, W14
0075B6  9FB7D1     MOV W1, [W15-22]
0075B8  9FEFC2     MOV.B W2, [W15-20]
8310:              
8311:              
8312:              
8313:              /****************************************************************************
8314:                Function:
8315:                  WORD WriteFAT (DISK *dsk, DWORD ccls, WORD value, BYTE forceWrite)
8316:                Summary:
8317:                  Write an entry to the FAT
8318:                Conditions:
8319:                  This function should not be called by the user.
8320:                Input:
8321:                  dsk -         The disk structure
8322:                  ccls -        The current cluster
8323:                  value -       The value to write in
8324:                  forceWrite -  Force the function to write the current FAT sector
8325:                Return:
8326:                  0 -    The FAT write was successful
8327:                  FAIL - The FAT could not be written
8328:                Side Effects:
8329:                  None
8330:                Description:
8331:                  The WriteFAT function writes an entry to the FAT.  If the function
8332:                  is called and the 'forceWrite' argument is TRUE, the function will
8333:                  write the existing FAT data to the device.  Otherwise, the function
8334:                  will replace a single entry in the FAT buffer (indicated by 'ccls')
8335:                  with a new value (indicated by 'value.')
8336:                Remarks:
8337:                  None.
8338:                ****************************************************************************/
8339:              
8340:              #ifdef ALLOW_WRITES
8341:              DWORD WriteFAT (DISK *dsk, DWORD ccls, DWORD value, BYTE forceWrite)
8342:              {
8343:                  BYTE i, q, c;
8344:                  DWORD p, li, l, ClusterFailValue;
8345:              
8346:              #ifdef SUPPORT_FAT32 // If FAT32 supported.
8347:                  if ((dsk->type != FAT32) && (dsk->type != FAT16) && (dsk->type != FAT12))
007144  906120     MOV.B [W0+34], W2
007146  E94002     DEC.B W2, W0
007148  2FFFF4     MOV #0xFFFF, W4
00714A  20FFF5     MOV #0xFFF, W5
00714C  9FB7C4     MOV W4, [W15-24]
00714E  9FB7D5     MOV W5, [W15-22]
007150  504FE2     SUB.B W0, #0x2, [W15]
007152  3E0113     BRA GTU, 0x737A
8348:                      return CLUSTER_FAIL_FAT32;
8349:              #else // If FAT32 support not enabled
8350:                  if ((dsk->type != FAT16) && (dsk->type != FAT12))
8351:                      return CLUSTER_FAIL_FAT16;
8352:              #endif
8353:              
8354:                  /* Settings based on FAT type */
8355:                  switch (dsk->type)
007154  514FE3     SUB.B W2, #0x3, [W15]
007156  320004     BRA Z, 0x7160
007158  2FFFF2     MOV #0xFFFF, W2
00715A  200003     MOV #0x0, W3
00715C  9FB7C2     MOV W2, [W15-24]
00715E  9FB7D3     MOV W3, [W15-22]
8356:                  {
8357:              #ifdef SUPPORT_FAT32 // If FAT32 supported.
8358:                      case FAT32:
8359:                          ClusterFailValue = CLUSTER_FAIL_FAT32;
8360:                          break;
8361:              #endif
8362:                      case FAT12:
8363:                      case FAT16:
8364:                      default:
8365:                          ClusterFailValue = CLUSTER_FAIL_FAT16;
8366:                          break;
8367:                  }
8368:              
8369:                  gBufferZeroed = FALSE;
007160  270B90     MOV #0x70B9, W0
007162  EB4800     CLR.B [W0]
8370:              
8371:                  // The only purpose for calling this function with forceWrite
8372:                  // is to write the current FAT sector to the card
8373:                  if (forceWrite)
007164  E00401     CP0.B W1
007166  320020     BRA Z, 0x71A8
8374:                  {
8375:                      for (i = 0, li = gLastFATSectorRead; i < dsk->fatcopy; i++, li += dsk->fatsize)
007168  838628     MOV gLastFATSectorRead, W8
00716A  838639     MOV 0x70C6, W9
00716C  EB0500     CLR W10
00716E  370013     BRA 0x7196
00717E  9058CE     MOV.B [W14+28], W1
007180  FB8081     ZE W1, W1
007182  90585E     MOV.B [W14+29], W0
007184  DD0048     SL W0, #8, W0
007186  700101     IOR W0, W1, W2
007188  9058EE     MOV.B [W14+30], W1
00718A  FB8081     ZE W1, W1
00718C  90587E     MOV.B [W14+31], W0
00718E  DD0048     SL W0, #8, W0
007190  700181     IOR W0, W1, W3
007192  410408     ADD W2, W8, W8
007194  498489     ADDC W3, W9, W9
007196  90600E     MOV.B [W14+32], W0
007198  504F8A     SUB.B W0, W10, [W15]
00719A  3EFFEA     BRA GTU, 0x7170
8376:                      {
8377:                          if (!MDD_SectorWrite (li, gFATBuffer, FALSE))
007170  EB4180     CLR.B W3
007172  268982     MOV #0x6898, W2
007174  BE0008     MOV.D W8, W0
007176  0732B1     RCALL MDD_SDSPI_SectorWrite
007178  E8050A     INC W10, W10
00717A  E00400     CP0.B W0
00717C  3200FE     BRA Z, 0x737A
8378:                          {
8379:                              return ClusterFailValue;
8380:                          }
8381:                      }
8382:              
8383:                      gNeedFATWrite = FALSE;
00719C  270C20     MOV #0x70C2, W0
00719E  EB4800     CLR.B [W0]
0071A0  B82260     MUL.UU W4, #0, W4
0071A2  9FB7C4     MOV W4, [W15-24]
0071A4  9FB7D5     MOV W5, [W15-22]
0071A6  3700E9     BRA 0x737A
8384:              
8385:                      return 0;
8386:                  }
8387:              
8388:                  /* Settings based on FAT type */
8389:                  switch (dsk->type)
0071A8  90602E     MOV.B [W14+34], W0
0071AA  504FE1     SUB.B W0, #0x1, [W15]
0071AC  320007     BRA Z, 0x71BC
0071AE  504FE3     SUB.B W0, #0x3, [W15]
0071B0  3A000E     BRA NZ, 0x71CE
8390:                  {
8391:              #ifdef SUPPORT_FAT32 // If FAT32 supported.
8392:                      case FAT32:
8393:                          p = (DWORD)ccls *4;   // "p" is the position in "gFATBuffer" for corresponding cluster.
0071B2  DD3E42     SL W7, #2, W12
0071B4  DE36CE     LSR W6, #14, W13
0071B6  76068D     IOR W12, W13, W13
0071B8  DD3642     SL W6, #2, W12
0071BA  37000B     BRA 0x71D2
8394:                          q = 0;      // "q" not used for FAT32, only initialized to remove a warning
8395:                          break;
8396:              #endif
8397:                      case FAT12:
8398:                          p = (DWORD) ccls * 3; // "p" is the position in "gFATBuffer" for corresponding cluster.
0071BC  200032     MOV #0x3, W2
0071BE  200003     MOV #0x0, W3
0071C0  BE0006     MOV.D W6, W0
0071C2  07F0FF     RCALL __mulp32eds3
8399:                          q = p & 1;   // Odd or even?
0071C4  6042E1     AND.B W0, #0x1, W5
0071C6  9FEFC5     MOV.B W5, [W15-20]
8400:                          p >>= 1;
0071C8  D10681     LSR W1, W13
0071CA  D38600     RRC W0, W12
0071CC  370003     BRA 0x71D4
8401:                          break;
8402:                      case FAT16:
8403:                      default:
8404:                          p = (DWORD) ccls *2;   // "p" is the position in "gFATBuffer" for corresponding cluster.
0071CE  430606     ADD W6, W6, W12
0071D0  4B8687     ADDC W7, W7, W13
0071D2  9FEFC1     MOV.B W1, [W15-20]
8405:                          q = 0;      // "q" not used for FAT16, only initialized to remove a warning
8406:                          break;
8407:                  }
8408:              
8409:                  l = dsk->fat + (p / dsk->sectorSize);     //
0071D4  90588E     MOV.B [W14+24], W1
0071D6  FB8081     ZE W1, W1
0071D8  90581E     MOV.B [W14+25], W0
0071DA  DD0048     SL W0, #8, W0
0071DC  700401     IOR W0, W1, W8
0071DE  9058AE     MOV.B [W14+26], W1
0071E0  FB8081     ZE W1, W1
0071E2  90583E     MOV.B [W14+27], W0
0071E4  DD0048     SL W0, #8, W0
0071E6  700481     IOR W0, W1, W9
0071E8  9040EE     MOV.B [W14+6], W1
0071EA  FB8081     ZE W1, W1
0071EC  90407E     MOV.B [W14+7], W0
0071EE  DD0048     SL W0, #8, W0
0071F0  700501     IOR W0, W1, W10
0071F2  90488E     MOV.B [W14+8], W1
0071F4  FB8081     ZE W1, W1
0071F6  90481E     MOV.B [W14+9], W0
0071F8  DD0048     SL W0, #8, W0
0071FA  700581     IOR W0, W1, W11
0071FC  BE0108     MOV.D W8, W2
0071FE  BE000C     MOV.D W12, W0
007200  07F150     RCALL __udivsi3
007202  40050A     ADD W0, W10, W10
007204  48858B     ADDC W1, W11, W11
8410:                  p &= dsk->sectorSize - 1;                 // Restrict 'p' within the FATbuffer size
007206  540461     SUB W8, #0x1, W8
007208  5C84E0     SUBB W9, #0x0, W9
00720A  64008C     AND W8, W12, W1
00720C  64800D     AND W9, W13, W0
00720E  780180     MOV W0, W3
007210  780101     MOV W1, W2
007212  BE0602     MOV.D W2, W12
8411:              
8412:                  if (gLastFATSectorRead != l)
007214  838628     MOV gLastFATSectorRead, W8
007216  838639     MOV 0x70C6, W9
007218  540F8A     SUB W8, W10, [W15]
00721A  5C8F8B     SUBB W9, W11, [W15]
00721C  320028     BRA Z, 0x726E
8413:                  {
8414:                      // If we are loading a new sector then write
8415:                      // the current one to the card if we need to
8416:                      if (gNeedFATWrite)
00721E  EB0000     CLR W0
007220  9FB7B0     MOV W0, [W15-26]
007222  270C20     MOV #0x70C2, W0
007224  E00410     CP0.B [W0]
007226  3A0016     BRA NZ, 0x7254
007228  37001B     BRA 0x7260
8417:                      {
8418:                          for (i = 0, li = gLastFATSectorRead; i < dsk->fatcopy; i++, li += dsk->fatsize)
00723C  9058CE     MOV.B [W14+28], W1
00723E  FB8081     ZE W1, W1
007240  90585E     MOV.B [W14+29], W0
007242  DD0048     SL W0, #8, W0
007244  700101     IOR W0, W1, W2
007246  9058EE     MOV.B [W14+30], W1
007248  FB8081     ZE W1, W1
00724A  90587E     MOV.B [W14+31], W0
00724C  DD0048     SL W0, #8, W0
00724E  700181     IOR W0, W1, W3
007250  410408     ADD W2, W8, W8
007252  498489     ADDC W3, W9, W9
007254  90600E     MOV.B [W14+32], W0
007256  97E16F     MOV.B [W15-26], W2
007258  504F82     SUB.B W0, W2, [W15]
00725A  3EFFE7     BRA GTU, 0x722A
8419:                          {
8420:                              if (!MDD_SectorWrite (li, gFATBuffer, FALSE))
00722A  EB4180     CLR.B W3
00722C  268982     MOV #0x6898, W2
00722E  BE0008     MOV.D W8, W0
007230  073254     RCALL MDD_SDSPI_SectorWrite
007232  97B0BF     MOV [W15-26], W1
007234  E80081     INC W1, W1
007236  9FB7B1     MOV W1, [W15-26]
007238  E00400     CP0.B W0
00723A  32009F     BRA Z, 0x737A
8421:                              {
8422:                                  return ClusterFailValue;
8423:                              }
8424:                          }
8425:              
8426:                          gNeedFATWrite = FALSE;
00725C  270C20     MOV #0x70C2, W0
00725E  EB4800     CLR.B [W0]
8427:                      }
8428:              
8429:                      // Load the new sector
8430:                      if (!MDD_SectorRead (l, gFATBuffer))
007260  268982     MOV #0x6898, W2
007262  BE000A     MOV.D W10, W0
007264  07313E     RCALL MDD_SDSPI_SectorRead
007266  E00400     CP0.B W0
007268  320063     BRA Z, 0x7330
8431:                      {
8432:                          gLastFATSectorRead = 0xFFFF;
8433:                          return ClusterFailValue;
8434:                      }
8435:                      else
8436:                      {
8437:                          gLastFATSectorRead = l;
00726A  8B862A     MOV W10, gLastFATSectorRead
00726C  8B863B     MOV W11, 0x70C6
8438:                      }
8439:                  }
8440:              
8441:              #ifdef SUPPORT_FAT32 // If FAT32 supported.
8442:                  if (dsk->type == FAT32)  // Refer page 16 of FAT requirement.
00726E  90602E     MOV.B [W14+34], W0
007270  504FE3     SUB.B W0, #0x3, [W15]
007272  3A001A     BRA NZ, 0x72A8
8443:                  {
8444:                      RAMwrite (gFATBuffer, p,   ((value & 0x000000ff)));         // lsb,1st byte of cluster value
007274  268980     MOV #0x6898, W0
007276  97E9EF     MOV.B [W15-18], W3
007278  787603     MOV.B W3, [W12+W0]
8445:                      RAMwrite (gFATBuffer, p+1, ((value & 0x0000ff00) >> 8));
00727A  97B90F     MOV [W15-16], W2
00727C  2FF000     MOV #0xFF00, W0
00727E  97B27F     MOV [W15-18], W4
007280  600004     AND W0, W4, W0
007282  200001     MOV #0x0, W1
007284  DD09C8     SL W1, #8, W3
007286  DE0048     LSR W0, #8, W0
007288  718000     IOR W3, W0, W0
00728A  DE08C8     LSR W1, #8, W1
00728C  268994     MOV #0x6899, W4
00728E  7A7600     MOV.B W0, [W12+W4]
8446:                      RAMwrite (gFATBuffer, p+2, ((value & 0x00ff0000) >> 16));
007290  2689A0     MOV #0x689A, W0
007292  787602     MOV.B W2, [W12+W0]
8447:                      RAMwrite (gFATBuffer, p+3, ((value & 0x0f000000) >> 24));   // the MSB nibble is supposed to be "0" in FAT32. So mask it.
007294  20F000     MOV #0xF00, W0
007296  610100     AND W2, W0, W2
007298  200003     MOV #0x0, W3
00729A  DD1A48     SL W3, #8, W4
00729C  DE1148     LSR W2, #8, W2
00729E  720102     IOR W4, W2, W2
0072A0  DE19C8     LSR W3, #8, W3
0072A2  2689B0     MOV #0x689B, W0
0072A4  787602     MOV.B W2, [W12+W0]
0072A6  370063     BRA 0x736E
8448:                  }
8449:                  else
8450:                  
8451:              #endif
8452:                  {
8453:                      if (dsk->type == FAT16)
0072A8  504FE2     SUB.B W0, #0x2, [W15]
0072AA  3A000E     BRA NZ, 0x72C8
8454:                      {
8455:                          RAMwrite (gFATBuffer, p, value);            //lsB
0072AC  268980     MOV #0x6898, W0
0072AE  97EAEF     MOV.B [W15-18], W5
0072B0  787605     MOV.B W5, [W12+W0]
8456:                          RAMwrite (gFATBuffer, p+1, ((value&0x0000ff00) >> 8));    // msB
0072B2  2FF000     MOV #0xFF00, W0
0072B4  97B0FF     MOV [W15-18], W1
0072B6  600001     AND W0, W1, W0
0072B8  200001     MOV #0x0, W1
0072BA  DD0948     SL W1, #8, W2
0072BC  DE0048     LSR W0, #8, W0
0072BE  710000     IOR W2, W0, W0
0072C0  DE08C8     LSR W1, #8, W1
0072C2  268992     MOV #0x6899, W2
0072C4  797600     MOV.B W0, [W12+W2]
0072C6  370053     BRA 0x736E
8457:                      }
8458:                      else if (dsk->type == FAT12)
0072C8  504FE1     SUB.B W0, #0x1, [W15]
0072CA  3A0051     BRA NZ, 0x736E
8459:                      {
8460:                          // Get the current byte from the FAT
8461:                          c = RAMread (gFATBuffer, p);
0072CC  268980     MOV #0x6898, W0
0072CE  460100     ADD W12, W0, W2
0072D0  784012     MOV.B [W2], W0
8462:                          if (q)
0072D2  97E9CF     MOV.B [W15-20], W3
0072D4  E00403     CP0.B W3
0072D6  320005     BRA Z, 0x72E2
8463:                          {
8464:                              c = ((value & 0x0F) << 4) | ( c & 0x0F);
0072D8  97EA6F     MOV.B [W15-18], W4
0072DA  DD20C4     SL W4, #4, W1
0072DC  60406F     AND.B W0, #0xF, W0
0072DE  70C000     IOR.B W1, W0, W0
0072E0  370001     BRA 0x72E4
8465:                          }
8466:                          else
8467:                          {
8468:                              c = (value & 0xFF);
0072E2  97E86F     MOV.B [W15-18], W0
8469:                          }
8470:                          // Write in those bits
8471:                          RAMwrite (gFATBuffer, p, c);
0072E4  784900     MOV.B W0, [W2]
8472:              
8473:                          // FAT12 entries can cross sector boundaries
8474:                          // Check if we need to load a new sector
8475:                          p = (p +1) & (dsk->sectorSize-1);
0072E6  460261     ADD W12, #0x1, W4
0072E8  4E82E0     ADDC W13, #0x0, W5
0072EA  90598E     MOV.B [W14+24], W3
0072EC  FB8183     ZE W3, W3
0072EE  90591E     MOV.B [W14+25], W2
0072F0  DD1148     SL W2, #8, W2
0072F2  710003     IOR W2, W3, W0
0072F4  9059AE     MOV.B [W14+26], W3
0072F6  FB8183     ZE W3, W3
0072F8  90593E     MOV.B [W14+27], W2
0072FA  DD1148     SL W2, #8, W2
0072FC  710083     IOR W2, W3, W1
0072FE  500061     SUB W0, #0x1, W0
007300  5880E0     SUBB W1, #0x0, W1
007302  600104     AND W0, W4, W2
007304  608005     AND W1, W5, W0
007306  780080     MOV W0, W1
007308  780002     MOV W2, W0
00730A  BE0400     MOV.D W0, W8
8476:                          if (p == 0)
00730C  540FE0     SUB W8, #0x0, [W15]
00730E  5C8FE0     SUBB W9, #0x0, [W15]
007310  3A0016     BRA NZ, 0x733E
8477:                          {
8478:                              // call this function to update the FAT on the card
8479:                              if (WriteFAT (dsk, 0,0,TRUE))
007312  B3C011     MOV #0x1, W1
007314  BE0208     MOV.D W8, W4
007316  BE0108     MOV.D W8, W2
007318  78000E     MOV W14, W0
00731A  07FF0B     RCALL WriteFAT
00731C  500FE0     SUB W0, #0x0, [W15]
00731E  588FE0     SUBB W1, #0x0, [W15]
007320  3A002C     BRA NZ, 0x737A
8480:                                  return ClusterFailValue;
8481:              
8482:                              // Load the next sector
8483:                              if (!MDD_SectorRead (l +1, gFATBuffer))
007322  450561     ADD W10, #0x1, W10
007324  4D85E0     ADDC W11, #0x0, W11
007326  268982     MOV #0x6898, W2
007328  BE000A     MOV.D W10, W0
00732A  0730DB     RCALL MDD_SDSPI_SectorRead
00732C  E00400     CP0.B W0
00732E  3A0005     BRA NZ, 0x733A
8484:                              {
8485:                                  gLastFATSectorRead = 0xFFFF;
007330  2FFFF0     MOV #0xFFFF, W0
007332  200001     MOV #0x0, W1
007334  8B8620     MOV W0, gLastFATSectorRead
007336  8B8631     MOV W1, 0x70C6
007338  370020     BRA 0x737A
8486:                                  return ClusterFailValue;
8487:                              }
8488:                              else
8489:                              {
8490:                                  gLastFATSectorRead = l + 1;
00733A  8B862A     MOV W10, gLastFATSectorRead
00733C  8B863B     MOV W11, 0x70C6
8491:                              }
8492:                          }
8493:              
8494:                          // Get the second byte of the table entry
8495:                          c = RAMread (gFATBuffer, p);
00733E  268980     MOV #0x6898, W0
007340  440200     ADD W8, W0, W4
007342  784314     MOV.B [W4], W6
8496:                          if (q)
007344  97EACF     MOV.B [W15-20], W5
007346  E00405     CP0.B W5
007348  320007     BRA Z, 0x7358
8497:                          {
8498:                              c = (value >> 4);
00734A  97B17F     MOV [W15-18], W2
00734C  97B98F     MOV [W15-16], W3
00734E  DD1ACC     SL W3, #12, W5
007350  DE1044     LSR W2, #4, W0
007352  728000     IOR W5, W0, W0
007354  DE18C4     LSR W3, #4, W1
007356  37000A     BRA 0x736C
8499:                          }
8500:                          else
8501:                          {
8502:                              c = ((value >> 8) & 0x0F) | (c & 0xF0);
007358  97B17F     MOV [W15-18], W2
00735A  97B98F     MOV [W15-16], W3
00735C  DD1AC8     SL W3, #8, W5
00735E  DE1048     LSR W2, #8, W0
007360  728000     IOR W5, W0, W0
007362  DE18C8     LSR W3, #8, W1
007364  60406F     AND.B W0, #0xF, W0
007366  B3CF02     MOV #0xF0, W2
007368  634102     AND.B W6, W2, W2
00736A  704002     IOR.B W0, W2, W0
8503:                          }
8504:                          RAMwrite (gFATBuffer, p, c);
00736C  784A00     MOV.B W0, [W4]
8505:                      }
8506:                  }
8507:                  gNeedFATWrite = TRUE;
00736E  B3C011     MOV #0x1, W1
007370  270C20     MOV #0x70C2, W0
007372  784801     MOV.B W1, [W0]
007374  B80060     MUL.UU W0, #0, W0
007376  9FB7C0     MOV W0, [W15-24]
007378  9FB7D1     MOV W1, [W15-22]
8508:              
8509:                  return 0;
8510:              }
00738A  4787EC     ADD W15, #0xC, W15
00738C  BE9F88     MOV.D W8, [W15++]
00738E  BE9F8A     MOV.D W10, [W15++]
007390  BE9F8C     MOV.D W12, [W15++]
007392  781F8E     MOV W14, [W15++]
007394  780700     MOV W0, W14
007396  BE0202     MOV.D W2, W4
8511:              #endif
8512:              
8513:              
8514:              #ifdef ALLOW_DIRS
8515:              
8516:              // This string is used by dir functions to hold dir names temporarily
8517:              #if defined(SUPPORT_LFN)
8518:              	char tempDirectoryString [522];
8519:              #else
8520:              	char tempDirectoryString [14];
8521:              #endif
8522:              /**************************************************************************
8523:                Function:
8524:                  int FSchdir (char * path)
8525:                Summary:
8526:                  Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC)
8527:                Conditions:
8528:                  None
8529:                Input:
8530:                  path - The path of the directory to change to.
8531:                Return Values:
8532:                  0 -   The current working directory was changed successfully
8533:                  EOF - The current working directory could not be changed
8534:                Side Effects:
8535:                  The current working directory may be changed. The FSerrno variable will
8536:                  be changed.
8537:                Description:
8538:                  Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC).
8539:                  The FSchdir function passes a RAM pointer to the path to the chdirhelper function.
8540:                Remarks:
8541:                  None                                            
8542:                **************************************************************************/
8543:              
8544:              int FSchdir (char * path)
8545:              {
8546:                  return chdirhelper (0, path, NULL);
00AFFE  EB0100     CLR W2
00B000  EB4000     CLR.B W0
00B002  37FEB3     BRA chdirhelper
8547:              }
00B004  FA0040     LNK #0x40
00B006  BE9F88     MOV.D W8, [W15++]
00B008  BE9F8A     MOV.D W10, [W15++]
00B00A  BE9F8C     MOV.D W12, [W15++]
00B00C  780500     MOV W0, W10
8548:              
8549:              /**************************************************************************
8550:                Function:
8551:                  int wFSchdir (unsigned short int * path)
8552:                Summary:
8553:                  Change the current working directory as per the path specified in
8554:                  UTF16 format (PIC24/PIC32/dsPIC)
8555:                Conditions:
8556:                  None
8557:                Input:
8558:                  path - The path of the directory to change to.
8559:                Return Values:
8560:                  0 -   The current working directory was changed successfully
8561:                  EOF - The current working directory could not be changed
8562:                Side Effects:
8563:                  The current working directory may be changed. The FSerrno variable will
8564:                  be changed.
8565:                Description:
8566:                  Change the current working directory as per the path specified in
8567:                  UTF16 format (PIC24/PIC32/dsPIC).The FSchdir function passes a RAM
8568:                  pointer to the path to the chdirhelper function.
8569:                Remarks:
8570:                  None                                            
8571:                **************************************************************************/
8572:              #ifdef SUPPORT_LFN
8573:              int wFSchdir (unsigned short int * path)
8574:              {
8575:              	int result;
8576:              	utfModeFileName = TRUE;
00AFEC  200010     MOV #0x1, W0
00AFEE  8B85A0     MOV W0, utfModeFileName
8577:                  result = chdirhelper (0, (char *)path, NULL);
00AFF0  EB0100     CLR W2
00AFF2  EB4000     CLR.B W0
00AFF4  07FEBA     RCALL chdirhelper
8578:              	utfModeFileName = FALSE;
00AFF6  EB0080     CLR W1
00AFF8  8B85A1     MOV W1, utfModeFileName
8579:                  return result;
8580:              }
00AFFC  780080     MOV W0, W1
8581:              #endif
8582:              
8583:              /**************************************************************************
8584:                Function:
8585:                  int FSchdirpgm (const rom char * path)
8586:                Summary:
8587:                  Changes the CWD to the input path on PIC18
8588:                Conditions:
8589:                  None
8590:                Input:
8591:                  path - The path of the directory to change to (ROM)
8592:                Return Values:
8593:                  0 -   The current working directory was changed successfully
8594:                  EOF - The current working directory could not be changed
8595:                Side Effects:
8596:                  The current working directory may be changed. The FSerrno variable will
8597:                  be changed.
8598:                Description:
8599:                  Changes the CWD to the input path on PIC18.The FSchdirpgm function
8600:                  passes a PIC18 ROM path pointer to the chdirhelper function.
8601:                Remarks:
8602:                  This function is for use with PIC18 when passing arguments in ROM
8603:                **************************************************************************/
8604:              
8605:              #ifdef ALLOW_PGMFUNCTIONS
8606:              int FSchdirpgm (const rom char * path)
8607:              {
8608:                  return chdirhelper (1, NULL, path);
8609:              }
8610:              
8611:              /**************************************************************************
8612:                Function:
8613:                  int wFSchdirpgm (const rom unsigned short int * path)
8614:                Summary:
8615:                  Changed the CWD with a path in ROM on PIC18
8616:                Conditions:
8617:                  None
8618:                Input:
8619:                  path - The path of the directory to change to (ROM)
8620:                Return Values:
8621:                  0 -   The current working directory was changed successfully
8622:                  EOF - The current working directory could not be changed
8623:                Side Effects:
8624:                  The current working directory may be changed. The FSerrno variable will
8625:                  be changed.
8626:                Description:
8627:                  The FSchdirpgm function passes a PIC18 ROM path pointer to the
8628:                  chdirhelper function.
8629:                Remarks:
8630:                  This function is for use with PIC18 when passing arguments in ROM
8631:                **************************************************************************/
8632:              #ifdef SUPPORT_LFN
8633:              int wFSchdirpgm (const rom unsigned short int * path)
8634:              {
8635:              	int result;
8636:              	utfModeFileName = TRUE;
8637:                  result = chdirhelper (1, NULL, (const char *)path);
8638:              	utfModeFileName = FALSE;
8639:              	return result;
8640:              }
8641:              #endif
8642:              
8643:              #endif
8644:              
8645:              /*************************************************************************
8646:                Function:
8647:                  // PIC24/30/33/32
8648:                  int chdirhelper (BYTE mode, char * ramptr, char * romptr);
8649:                  // PIC18
8650:                  int chdirhelper (BYTE mode, char * ramptr, const rom char * romptr);
8651:                Summary:
8652:                  Helper function for FSchdir
8653:                Conditions:
8654:                  None
8655:                Input:
8656:                  mode -    Indicates which path pointer to use
8657:                  ramptr -  Pointer to the path specified in RAM
8658:                  romptr -  Pointer to the path specified in ROM
8659:                Return Values:
8660:                  0 -   Directory was changed successfully.
8661:                  EOF - Directory could not be changed.
8662:                Side Effects:
8663:                  The current working directory will be changed. The FSerrno variable
8664:                  will be changed. Any unwritten data in the data buffer will be written
8665:                  to the device.
8666:                Description:
8667:                  This helper function is used by the FSchdir function. If the path
8668:                  argument is specified in ROM for PIC18 this function will be able to
8669:                  parse it correctly.  The function will loop through a switch statement
8670:                  to process the tokens in the path string.  Dot or dotdot entries are
8671:                  handled in the first case statement.  A backslash character is handled
8672:                  in the second case statement (note that this case statement will only
8673:                  be used if backslash is the first character in the path; backslash
8674:                  token delimiters will automatically be skipped after each token in the
8675:                  path is processed).  The third case statement will handle actual
8676:                  directory name strings.
8677:                Remarks:
8678:                  None.
8679:                *************************************************************************/
8680:              
8681:              #ifdef ALLOW_PGMFUNCTIONS
8682:              int chdirhelper (BYTE mode, char * ramptr, const rom char * romptr)
8683:              #else
8684:              int chdirhelper (BYTE mode, char * ramptr, char * romptr)
8685:              #endif
8686:              {
8687:                  unsigned short int i,j,k = 0;
8688:                  WORD curent = 1;
00AD72  2FFBA0     MOV #0xFFBA, W0
00AD74  40000F     ADD W0, W15, W0
00AD76  200011     MOV #0x1, W1
00AD78  781801     MOV W1, [W0++]
8689:                  DIRENTRY entry;
8690:                  char * temppath = ramptr;
8691:              #ifdef ALLOW_PGMFUNCTIONS
8692:                  rom char * temppath2 = romptr;
8693:                  rom unsigned short int * utf16path2 = (rom unsigned short int *)romptr;
8694:              #endif
8695:              	#ifdef SUPPORT_LFN
8696:              		unsigned short int *utf16path = (unsigned short int *)ramptr;
00AD7A  78048A     MOV W10, W9
8697:              	#endif
8698:              
8699:                  FSFILE tempCWDobj2;
8700:                  FILEOBJ tempCWD = &tempCWDobj2;
8701:              
8702:                  FileObjectCopy (tempCWD, cwdptr);
00AD7C  8385B1     MOV cwdptr, W1
00AD7E  07E66A     RCALL FileObjectCopy
8703:              
8704:                  FSerrno = CE_GOOD;
00AD80  249380     MOV #0x4938, W0
00AD82  EB4800     CLR.B [W0]
8705:              
8706:                 // Check the first char of the path
8707:              #ifdef ALLOW_PGMFUNCTIONS
8708:                  if (mode)
8709:              	{
8710:              		#ifdef SUPPORT_LFN
8711:              		if(utfModeFileName)
8712:              
8713:              		{
8714:              
8715:              			i = *utf16path2;
8716:              		}
8717:              		else
8718:              		#endif
8719:              		{
8720:              			i = *temppath2;
8721:              		}
8722:                  }
8723:                  else
8724:              #endif
8725:              	{
8726:              		#ifdef SUPPORT_LFN
8727:              		if(utfModeFileName)
00AD84  8385A0     MOV utfModeFileName, W0
00AD86  E00000     CP0 W0
00AD88  320002     BRA Z, 0xAD8E
8728:              
8729:              		{
8730:              
8731:              			i = *utf16path;
00AD8A  78041A     MOV [W10], W8
00AD8C  370001     BRA 0xAD90
8732:              		}
8733:              		else
8734:              		#endif
8735:              		{
8736:              			i = *temppath;
00AD8E  FB041A     SE [W10], W8
8737:              		}
8738:                  }
8739:              
8740:              	// if NULL character return error
8741:                  if (i == 0)
00AD90  E00008     CP0 W8
00AD92  32007F     BRA Z, 0xAE92
00AD94  78058A     MOV W10, W11
00AD96  370007     BRA 0xADA6
8742:                  {
8743:                      FSerrno = CE_INVALID_ARGUMENT;
8744:                      return -1;
8745:                  }
8746:              
8747:                  while(1)
8748:                  {
8749:                      switch (i)
00ADA6  2002E0     MOV #0x2E, W0
00ADA8  540F80     SUB W8, W0, [W15]
00ADAA  320004     BRA Z, 0xADB4
00ADAC  2005C0     MOV #0x5C, W0
00ADAE  540F80     SUB W8, W0, [W15]
00ADB0  3A009F     BRA NZ, 0xAEF0
00ADB2  370071     BRA 0xAE96
8750:                      {
8751:                          // First case: dot or dotdot entry
8752:                          case '.':
8753:                              // Move past the dot
8754:              #ifdef ALLOW_PGMFUNCTIONS
8755:                              if (mode)
8756:                              {
8757:              					#ifdef SUPPORT_LFN
8758:              					if(utfModeFileName)
8759:              
8760:              					{
8761:              
8762:                              	    utf16path2++;
8763:                              	    i = *utf16path2;
8764:              					}
8765:              					else
8766:              					#endif
8767:              					{
8768:                              	    temppath2++;
8769:                              	    i = *temppath2;
8770:              					}
8771:                              }
8772:                              else
8773:                              {
8774:              #endif
8775:              					#ifdef SUPPORT_LFN
8776:              					if(utfModeFileName)
00ADB4  8385A1     MOV utfModeFileName, W1
00ADB6  E00001     CP0 W1
00ADB8  320002     BRA Z, 0xADBE
8777:              
8778:              					{
8779:              
8780:                              	    utf16path++;
8781:                              	    i = *utf16path;
00ADBA  780459     MOV [++W9], W8
00ADBC  370001     BRA 0xADC0
8782:              					}
8783:              					else
8784:              					#endif
8785:              					{
8786:                              	    temppath++;
8787:                              	    i = *temppath;
00ADBE  FB045B     SE [++W11], W8
8788:              					}
8789:              #ifdef ALLOW_PGMFUNCTIONS
8790:                              }
8791:              #endif
8792:                              // Check if it's a dotdot entry
8793:                              if (i == '.')
00ADC0  2002E0     MOV #0x2E, W0
00ADC2  540F80     SUB W8, W0, [W15]
00ADC4  3A0056     BRA NZ, 0xAE72
8794:                              {
8795:                                  // Increment the path variable
8796:              #ifdef ALLOW_PGMFUNCTIONS
8797:                                  if (mode)
8798:                                  {
8799:              						#ifdef SUPPORT_LFN
8800:              						if(utfModeFileName)
8801:              
8802:              						{
8803:              
8804:                              		    utf16path2++;
8805:                              		    i = *utf16path2;
8806:              						}
8807:              						else
8808:              						#endif
8809:              						{
8810:                              		    temppath2++;
8811:                              		    i = *temppath2;
8812:              						}
8813:                                  }
8814:                                  else
8815:                                  {
8816:              #endif
8817:              						#ifdef SUPPORT_LFN
8818:              						if(utfModeFileName)
00ADC6  E00001     CP0 W1
00ADC8  320002     BRA Z, 0xADCE
8819:              
8820:              						{
8821:              
8822:                              		    utf16path++;
8823:                              		    i = *utf16path;
00ADCA  780459     MOV [++W9], W8
00ADCC  370001     BRA 0xADD0
8824:              						}
8825:              						else
8826:              						#endif
8827:              						{
8828:                              		    temppath++;
8829:                              		    i = *temppath;
00ADCE  FB045B     SE [++W11], W8
8830:              						}
8831:              #ifdef ALLOW_PGMFUNCTIONS
8832:                                  }
8833:              #endif
8834:                                  // Check if we're in the root
8835:                                  if (tempCWD->dirclus == FatRootDirClusterValue)
00ADD0  2FFBA4     MOV #0xFFBA, W4
00ADD2  42020F     ADD W4, W15, W4
00ADD4  E88504     INC2 W4, W10
00ADD6  97B90F     MOV [W15-16], W2
00ADD8  97B99F     MOV [W15-14], W3
00ADDA  8249D0     MOV FatRootDirClusterValue, W0
00ADDC  8249E1     MOV 0x493C, W1
00ADDE  510F80     SUB W2, W0, [W15]
00ADE0  598F81     SUBB W3, W1, [W15]
00ADE2  320057     BRA Z, 0xAE92
8836:                                  {
8837:                                      // Fails if there's a dotdot chdir from the root
8838:                                      FSerrno = CE_INVALID_ARGUMENT;
8839:                                      return -1;
8840:                                  }
8841:                                  else
8842:                                  {
8843:                                      // Cache the dotdot entry
8844:                                      tempCWD->dirccls = tempCWD->dirclus;
00ADE4  9FBFA2     MOV W2, [W15-12]
00ADE6  9FBFB3     MOV W3, [W15-10]
8845:                                      curent = 1;
00ADE8  200012     MOV #0x1, W2
00ADEA  9F9FD2     MOV W2, [W15-70]
8846:                                      entry = Cache_File_Entry (tempCWD, &curent, TRUE);
00ADEC  780084     MOV W4, W1
00ADEE  78000A     MOV W10, W0
00ADF0  07E3DC     RCALL Cache_File_Entry
8847:                                      if (entry == NULL)
00ADF2  E00000     CP0 W0
00ADF4  32FFD1     BRA Z, 0xAD98
8848:                                      {
8849:                                          FSerrno = CE_BADCACHEREAD;
00AD98  B3C1B1     MOV #0x1B, W1
00AD9A  249380     MOV #0x4938, W0
00AD9C  784801     MOV.B W1, [W0]
00AD9E  EB8000     SETM W0
00ADA0  370120     BRA 0xAFE2
8850:                                          return -1;
8851:                                      }
8852:              
8853:                                      // Get the cluster
8854:                                      tempCWD->dirclus = GetFullClusterNumber(entry); // Get Complete Cluster number.
00AE06  9FBF82     MOV W2, [W15-16]
00AE08  9FBF93     MOV W3, [W15-14]
8855:                                      tempCWD->dirccls = tempCWD->dirclus;
00AE0A  9FBFA2     MOV W2, [W15-12]
00AE0C  9FBFB3     MOV W3, [W15-10]
8856:              
8857:                                      // If we changed to root, record the name
8858:                                      if (tempCWD->dirclus == VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT) // "0" is the value of Dotdot entry for Root in both FAT types.
00AE0E  510FE0     SUB W2, #0x0, [W15]
00AE10  598FE0     SUBB W3, #0x0, [W15]
00AE12  3A0010     BRA NZ, 0xAE34
8859:                                      {
8860:                                          j = 0;
8861:                                          tempCWD->name[j++] = '\\';
00AE14  B3C5C0     MOV #0x5C, W0
00AE16  9FDF80     MOV.B W0, [W15-40]
00AE18  2FFD95     MOV #0xFFD9, W5
00AE1A  478005     ADD W15, W5, W0
00AE1C  B3C202     MOV #0x20, W2
00AE1E  4000EA     ADD W0, #0xA, W1
8862:              //                            if(utfModeFileName)
8863:              //							{
8864:              //                            	tempCWD->name[j++] = 0x00;
8865:              //							}
8866:                                          for (;j < 11;)
00AE22  500F81     SUB W0, W1, [W15]
00AE24  3AFFFD     BRA NZ, 0xAE20
8867:                                          {
8868:                                              tempCWD->name[j] = 0x20;
00AE20  785802     MOV.B W2, [W0++]
8869:                                          	++j;
8870:                                          }
8871:              
8872:                                          /* While moving to Root, get the Root cluster value */
8873:                                          tempCWD->dirccls = FatRootDirClusterValue;
00AE26  8249D0     MOV FatRootDirClusterValue, W0
00AE28  8249E1     MOV 0x493C, W1
00AE2A  9FBFA0     MOV W0, [W15-12]
00AE2C  9FBFB1     MOV W1, [W15-10]
8874:                                          tempCWD->dirclus = FatRootDirClusterValue;
00AE2E  9FBF80     MOV W0, [W15-16]
00AE30  9FBF91     MOV W1, [W15-14]
00AE32  370009     BRA 0xAE46
8875:                                      }
8876:                                      else
8877:                                      {
8878:                                          // Otherwise set the name to ..
8879:                                          j = 0;
8880:                                          tempCWD->name[j++] = '.';
00AE34  B3C2E0     MOV #0x2E, W0
00AE36  9FDF80     MOV.B W0, [W15-40]
8881:              //                            if(utfModeFileName)
8882:              //							{
8883:              //                            	tempCWD->name[j++] = 0x00;
8884:              //                            	tempCWD->name[j++] = '.';
8885:              //                            	tempCWD->name[j++] = 0x00;
8886:              //							}
8887:              //							else
8888:              							{
8889:                                          	tempCWD->name[j++] = '.';
00AE38  9FDF90     MOV.B W0, [W15-39]
00AE3A  45007E     ADD W10, #0x1E, W0
00AE3C  B3C202     MOV #0x20, W2
00AE3E  4000E9     ADD W0, #0x9, W1
8890:                                          }
8891:                                          for (; j < 11;)
00AE42  500F81     SUB W0, W1, [W15]
00AE44  3AFFFD     BRA NZ, 0xAE40
8892:                                          {
8893:                                              tempCWD->name[j] = 0x20;
00AE40  785802     MOV.B W2, [W0++]
8894:                                          	++j;
8895:                                          }
8896:                                      }
8897:                                      // Cache the dot entry
8898:                                      curent = 0;
00AE46  2FFBA0     MOV #0xFFBA, W0
00AE48  40000F     ADD W0, W15, W0
00AE4A  EB1800     CLR [W0++]
8899:                                      if (Cache_File_Entry(tempCWD, &curent, TRUE) == NULL)
00AE4C  B3C012     MOV #0x1, W2
00AE4E  2FFBA1     MOV #0xFFBA, W1
00AE50  40808F     ADD W1, W15, W1
00AE52  07E3AB     RCALL Cache_File_Entry
00AE54  E00000     CP0 W0
00AE56  32FFA0     BRA Z, 0xAD98
8900:                                      {
8901:                                          FSerrno = CE_BADCACHEREAD;
8902:                                          return -1;
8903:                                      }
8904:                                      // Move past the next backslash, if necessary
8905:                                      while (i == '\\')
00AE66  2005C0     MOV #0x5C, W0
00AE68  540F80     SUB W8, W0, [W15]
00AE6A  32FFF8     BRA Z, 0xAE5C
8906:                                      {
8907:              #ifdef ALLOW_PGMFUNCTIONS
8908:                                          if (mode)
8909:                                          {
8910:              								#ifdef SUPPORT_LFN
8911:              								if(utfModeFileName)
8912:              
8913:              								{
8914:              
8915:                              				    utf16path2++;
8916:                              				    i = *utf16path2;
8917:              								}
8918:              								else
8919:              								#endif
8920:              								{
8921:                              				    temppath2++;
8922:                              				    i = *temppath2;
8923:              								}
8924:                                          }
8925:                                          else
8926:                                          {
8927:              #endif
8928:              								#ifdef SUPPORT_LFN
8929:              								if(utfModeFileName)
00AE58  8385A1     MOV utfModeFileName, W1
00AE5A  370005     BRA 0xAE66
00AE5C  E00001     CP0 W1
00AE5E  320002     BRA Z, 0xAE64
8930:              
8931:              								{
8932:              
8933:                              				    utf16path++;
8934:                              				    i = *utf16path;
00AE60  780459     MOV [++W9], W8
00AE62  370001     BRA 0xAE66
8935:              								}
8936:              								else
8937:              								#endif
8938:              								{
8939:                              				    temppath++;
8940:                              				    i = *temppath;
00AE64  FB045B     SE [++W11], W8
8941:              								}
8942:              #ifdef ALLOW_PGMFUNCTIONS
8943:                                          }
8944:              #endif
8945:                                      }
8946:                                      // Copy and return, if we're at the end
8947:                                      if (i == 0)
00AE6C  E00008     CP0 W8
00AE6E  3AFF9B     BRA NZ, 0xADA6
00AE70  3700A1     BRA 0xAFB4
8948:                                      {
8949:                                          FileObjectCopy (cwdptr, tempCWD);
8950:                                          return 0;
8951:                                      }
8952:                                  }
8953:                              }
8954:                              else
8955:                              {
8956:                                  // If we ended with a . entry,
8957:                                  // just return what we have
8958:                                  if (i == 0)
00AE72  E00008     CP0 W8
00AE74  32009F     BRA Z, 0xAFB4
8959:                                  {
8960:                                      FileObjectCopy (cwdptr, tempCWD);
8961:                                      return 0;
8962:                                  }
8963:                                  else
8964:                                  {
8965:                                      if (i == '\\')
00AE76  2005C0     MOV #0x5C, W0
00AE78  540F80     SUB W8, W0, [W15]
00AE7A  3A000B     BRA NZ, 0xAE92
00AE7C  780008     MOV W8, W0
8966:                                      {
8967:                                          while (i == '\\')
00AE88  540F80     SUB W8, W0, [W15]
00AE8A  32FFF9     BRA Z, 0xAE7E
8968:                                          {
8969:              #ifdef ALLOW_PGMFUNCTIONS
8970:                                              if (mode)
8971:                                              {
8972:              									#ifdef SUPPORT_LFN
8973:              									if(utfModeFileName)
8974:              
8975:              									{
8976:              
8977:                              					    utf16path2++;
8978:                              					    i = *utf16path2;
8979:              									}
8980:              									else
8981:              									#endif
8982:              									{
8983:                              					    temppath2++;
8984:                              					    i = *temppath2;
8985:              									}
8986:                                              }
8987:                                              else
8988:                                              {
8989:              #endif
8990:              									#ifdef SUPPORT_LFN
8991:              									if(utfModeFileName)
00AE7E  E00001     CP0 W1
00AE80  320002     BRA Z, 0xAE86
8992:              
8993:              									{
8994:              
8995:                              					    utf16path++;
8996:                              					    i = *utf16path;
00AE82  780459     MOV [++W9], W8
00AE84  370001     BRA 0xAE88
8997:              									}
8998:              									else
8999:              									#endif
9000:              									{
9001:                              					    temppath++;
9002:                              					    i = *temppath;
00AE86  FB045B     SE [++W11], W8
9003:              									}
9004:              #ifdef ALLOW_PGMFUNCTIONS
9005:                                              }
9006:              #endif
9007:                                          }
9008:                                          if (i == 0)
00AE8C  E00008     CP0 W8
00AE8E  3AFF8B     BRA NZ, 0xADA6
00AE90  37009C     BRA 0xAFCA
9009:                                          {
9010:                                              FileObjectCopy (cwdptr, tempCWD);
9011:                                              return 0;
9012:                                          }
9013:                                      }
9014:                                      else
9015:                                      {
9016:                                          // Anything else after a dot doesn't make sense
9017:                                          FSerrno = CE_INVALID_ARGUMENT;
00AE92  B3C1F1     MOV #0x1F, W1
00AE94  37FF82     BRA 0xAD9A
9018:                                          return -1;
9019:                                      }
9020:                                  }
9021:                              }
9022:              
9023:                              break;
9024:              
9025:                          // Second case: the first char is the root backslash
9026:                          // We will ONLY switch to this case if the first char
9027:                          // of the path is a backslash
9028:                          case '\\':
9029:                          // Increment pointer to second char
9030:              #ifdef ALLOW_PGMFUNCTIONS
9031:                          if (mode)
9032:                          {
9033:              				#ifdef SUPPORT_LFN
9034:              				if(utfModeFileName)
9035:              
9036:              				{
9037:              
9038:                                  utf16path2++;
9039:                                  i = *utf16path2;
9040:              				}
9041:              				else
9042:              				#endif
9043:              				{
9044:                                  temppath2++;
9045:                                  i = *temppath2;
9046:              				}
9047:                          }
9048:                          else
9049:                          {
9050:              #endif
9051:              				#ifdef SUPPORT_LFN
9052:              				if(utfModeFileName)
00AE96  8385A0     MOV utfModeFileName, W0
00AE98  E00000     CP0 W0
00AE9A  320002     BRA Z, 0xAEA0
9053:              
9054:              				{
9055:              
9056:                                  utf16path++;
9057:                                  i = *utf16path;
00AE9C  780459     MOV [++W9], W8
00AE9E  370001     BRA 0xAEA2
9058:              				}
9059:              				else
9060:              				#endif
9061:              				{
9062:                                  temppath++;
9063:                                  i = *temppath;
00AEA0  FB045B     SE [++W11], W8
9064:              				}
9065:              #ifdef ALLOW_PGMFUNCTIONS
9066:                          }
9067:              #endif
9068:                          // Can't start the path with multiple backslashes
9069:                          if (i == '\\')
00AEA2  2005C2     MOV #0x5C, W2
00AEA4  540F82     SUB W8, W2, [W15]
00AEA6  32FFF5     BRA Z, 0xAE92
9070:                          {
9071:                              FSerrno = CE_INVALID_ARGUMENT;
9072:                              return -1;
9073:                          }
9074:              
9075:                          if (i == 0)
00AEA8  E00008     CP0 W8
00AEAA  3A0013     BRA NZ, 0xAED2
9076:                          {
9077:                              // The user is changing directory to
9078:                              // the root
9079:                              cwdptr->dirclus = FatRootDirClusterValue;
00AEAC  8385B0     MOV cwdptr, W0
00AEAE  8249D4     MOV FatRootDirClusterValue, W4
00AEB0  8249E5     MOV 0x493C, W5
00AEB2  981824     MOV W4, [W0+52]
00AEB4  981835     MOV W5, [W0+54]
9080:                              cwdptr->dirccls = FatRootDirClusterValue;
00AEB6  8249D4     MOV FatRootDirClusterValue, W4
00AEB8  8249E5     MOV 0x493C, W5
00AEBA  981844     MOV W4, [W0+56]
00AEBC  981855     MOV W5, [W0+58]
9081:                              j = 0;
9082:                              cwdptr->name[j++] = '\\';
00AEBE  985842     MOV.B W2, [W0+28]
00AEC0  200012     MOV #0x1, W2
00AEC2  B3C203     MOV #0x20, W3
9083:              //                if(utfModeFileName)
9084:              //				{
9085:              //                	cwdptr->name[j++] = 0x00;
9086:              //				}
9087:                              for (; j < 11;)
00AECC  510FEB     SUB W2, #0xB, [W15]
00AECE  320088     BRA Z, 0xAFE0
00AED0  37FFF9     BRA 0xAEC4
9088:                              {
9089:                                  cwdptr->name[j] = 0x20;
00AEC4  4100FC     ADD W2, #0x1C, W1
00AEC6  8385B0     MOV cwdptr, W0
00AEC8  78F003     MOV.B W3, [W0+W1]
9090:                              	++j;
00AECA  E80102     INC W2, W2
9091:                              }
9092:                              return 0;
9093:                          }
9094:                          else
9095:                          {
9096:                              // Our first char is the root dir switch
9097:                              tempCWD->dirclus = FatRootDirClusterValue;
00AED2  8249D0     MOV FatRootDirClusterValue, W0
00AED4  8249E1     MOV 0x493C, W1
00AED6  9FBF80     MOV W0, [W15-16]
00AED8  9FBF91     MOV W1, [W15-14]
9098:                              tempCWD->dirccls = FatRootDirClusterValue;
00AEDA  9FBFA0     MOV W0, [W15-12]
00AEDC  9FBFB1     MOV W1, [W15-10]
9099:                              j = 0;
9100:                              tempCWD->name[j++] = '\\';
00AEDE  9FDF82     MOV.B W2, [W15-40]
00AEE0  2FFD95     MOV #0xFFD9, W5
00AEE2  478005     ADD W15, W5, W0
00AEE4  B3C202     MOV #0x20, W2
00AEE6  4000EA     ADD W0, #0xA, W1
9101:              //                if(utfModeFileName)
9102:              //				{
9103:              //                	tempCWD->name[j++] = 0x00;
9104:              //				}
9105:                              for (; j < 11;)
00AEEA  500F81     SUB W0, W1, [W15]
00AEEC  32FF5C     BRA Z, 0xADA6
00AEEE  37FFFC     BRA 0xAEE8
9106:                              {
9107:                                  tempCWD->name[j] = 0x20;
00AEE8  785802     MOV.B W2, [W0++]
9108:                              	++j;
9109:                              }
9110:                          }
9111:                          break;
9112:              
9113:                      default:
9114:                          // We should be at the beginning of a string of letters/numbers
9115:                          j = 0;
9116:              #ifdef ALLOW_PGMFUNCTIONS
9117:                          if (mode)
9118:                          {
9119:              				#ifdef SUPPORT_LFN
9120:              				if(utfModeFileName)
9121:              
9122:              				{
9123:              
9124:                          	    // Change directories as specified
9125:              					k = 512;
9126:              
9127:              
9128:              
9129:                          	    // Parse the next token
9130:                          	    while ((i != 0) && (i != '\\') && (j < k))
9131:                          	    {
9132:                          	        tempDirectoryString[j++] = i;
9133:                          	        tempDirectoryString[j++] = i >> 8;
9134:                          	        i = *(++utf16path2);
9135:                          	    }
9136:              
9137:              					tempDirectoryString[j++] = 0;
9138:              				}
9139:              
9140:              				else
9141:              
9142:              				#endif
9143:                      		{
9144:              
9145:              					#if defined(SUPPORT_LFN)
9146:              
9147:              						k = 256;
9148:              
9149:              					#else
9150:              
9151:              						k = 12;
9152:              
9153:              					#endif
9154:              
9155:              
9156:              
9157:                          	    // Parse the next token
9158:                          	    while ((i != 0) && (i != '\\') && (j < k))
9159:                          	    {
9160:                          	        tempDirectoryString[j++] = i;
9161:                          	        i = *(++temppath2);
9162:                          	    }
9163:              				}
9164:              
9165:                          }
9166:                          else
9167:                          {
9168:              #endif
9169:              				#ifdef SUPPORT_LFN
9170:              				if(utfModeFileName)
00AEF0  8385A4     MOV utfModeFileName, W4
00AEF2  E00004     CP0 W4
00AEF4  3A0002     BRA NZ, 0xAEFA
00AEF6  780104     MOV W4, W2
00AEF8  37001B     BRA 0xAF30
00AEFA  EB0100     CLR W2
00AEFC  2464A1     MOV #0x464A, W1
00AEFE  780280     MOV W0, W5
00AF00  202003     MOV #0x200, W3
00AF02  370006     BRA 0xAF10
9171:              
9172:              				{
9173:              
9174:                          	    // Change directories as specified
9175:              					k = 512;
9176:              
9177:              
9178:              
9179:                          	    // Parse the next token
9180:                          	    while ((i != 0) && (i != '\\') && (j < k))
00AF10  E00008     CP0 W8
00AF12  320004     BRA Z, 0xAF1C
00AF14  540F85     SUB W8, W5, [W15]
00AF16  320002     BRA Z, 0xAF1C
00AF18  510F83     SUB W2, W3, [W15]
00AF1A  3AFFF4     BRA NZ, 0xAF04
9181:                          	    {
9182:                          	        tempDirectoryString[j++] = i;
00AF04  784888     MOV.B W8, [W1]
9183:                          	        tempDirectoryString[j++] = i >> 8;
00AF06  DE4048     LSR W8, #8, W0
00AF08  984090     MOV.B W0, [W1+1]
00AF0A  E88102     INC2 W2, W2
9184:                          	        i = *(++utf16path);
00AF0C  780459     MOV [++W9], W8
00AF0E  E88081     INC2 W1, W1
9185:                          	    }
9186:              
9187:              					tempDirectoryString[j++] = 0;
00AF1C  EB4080     CLR.B W1
00AF1E  2464A0     MOV #0x464A, W0
00AF20  797001     MOV.B W1, [W0+W2]
00AF22  E80102     INC W2, W2
00AF24  202003     MOV #0x200, W3
00AF26  37000D     BRA 0xAF42
9188:              				}
9189:              
9190:              				else
9191:              
9192:              				#endif
9193:                      		{
9194:              
9195:              					#if defined(SUPPORT_LFN)
9196:              
9197:              						k = 256;
9198:              
9199:              					#else
9200:              
9201:              						k = 12;
9202:              
9203:              					#endif
9204:              
9205:              
9206:              
9207:                          	    // Parse the next token
9208:                          	    while ((i != 0) && (i != '\\') && (j < k))
00AF30  E00008     CP0 W8
00AF32  320006     BRA Z, 0xAF40
00AF34  2005C0     MOV #0x5C, W0
00AF36  540F80     SUB W8, W0, [W15]
00AF38  320003     BRA Z, 0xAF40
00AF3A  201000     MOV #0x100, W0
00AF3C  510F80     SUB W2, W0, [W15]
00AF3E  3AFFF4     BRA NZ, 0xAF28
00AF40  201003     MOV #0x100, W3
9209:                          	    {
9210:                          	        tempDirectoryString[j++] = i;
00AF28  2464A0     MOV #0x464A, W0
00AF2A  787108     MOV.B W8, [W2+W0]
00AF2C  E80102     INC W2, W2
9211:                          	        i = *(++temppath);
00AF2E  FB045B     SE [++W11], W8
9212:                          	    }
9213:              				}
9214:              
9215:              #ifdef ALLOW_PGMFUNCTIONS
9216:                          }
9217:              #endif
9218:               
9219:                          tempDirectoryString[j++] = 0;
00AF42  EB4000     CLR.B W0
00AF44  2464A1     MOV #0x464A, W1
00AF46  797080     MOV.B W0, [W1+W2]
9220:              
9221:                          // We got a whole 12 chars
9222:                          // There could be more- truncate it
9223:                          if (j > k)
00AF48  E80002     INC W2, W0
00AF4A  500F83     SUB W0, W3, [W15]
00AF4C  3E0006     BRA GTU, 0xAF5A
00AF4E  37000A     BRA 0xAF64
9224:                          {
9225:                              while ((i != 0) && (i != '\\'))
00AF5A  E00008     CP0 W8
00AF5C  320003     BRA Z, 0xAF64
00AF5E  2005C0     MOV #0x5C, W0
00AF60  540F80     SUB W8, W0, [W15]
00AF62  3AFFF6     BRA NZ, 0xAF50
9226:                              {
9227:              #ifdef ALLOW_PGMFUNCTIONS
9228:                                  if (mode)
9229:                                  {
9230:              						#ifdef SUPPORT_LFN
9231:              						if(utfModeFileName)
9232:              
9233:              						{
9234:              
9235:                                      	i = *(++utf16path2);
9236:                                  	}
9237:              						else
9238:              						#endif
9239:              						{
9240:              
9241:                                      	i = *(++temppath2);
9242:                                  	}
9243:                                  }
9244:                                  else
9245:                                  {
9246:              #endif
9247:              						#ifdef SUPPORT_LFN
9248:              						if(utfModeFileName)
00AF50  E00004     CP0 W4
00AF52  320002     BRA Z, 0xAF58
9249:              
9250:              						{
9251:              
9252:                                      	i = *(++utf16path);
00AF54  780459     MOV [++W9], W8
00AF56  370001     BRA 0xAF5A
9253:                                  	}
9254:              						else
9255:              						#endif
9256:              						{
9257:              
9258:                                      	i = *(++temppath);
00AF58  FB045B     SE [++W11], W8
9259:                                  	}
9260:              #ifdef ALLOW_PGMFUNCTIONS
9261:                                  }
9262:              #endif
9263:                              }
9264:                          }
9265:              
9266:                          if (FormatDirName (tempDirectoryString, tempCWD,0) == FALSE)
00AF64  2FFBC0     MOV #0xFFBC, W0
00AF66  478500     ADD W15, W0, W10
00AF68  EB4100     CLR.B W2
00AF6A  78008A     MOV W10, W1
00AF6C  2464A0     MOV #0x464A, W0
00AF6E  07EC02     RCALL FormatDirName
00AF70  E00400     CP0.B W0
00AF72  32FF15     BRA Z, 0xAD9E
9267:                              return -1;
9268:              
9269:                          // copy file object over
9270:                          FileObjectCopy(&gFileTemp, tempCWD);
00AF74  78008A     MOV W10, W1
00AF76  248BA0     MOV #0x48BA, W0
00AF78  07E56D     RCALL FileObjectCopy
9271:              
9272:                          // See if the directory is there
9273:                          if(FILEfind (&gFileTemp, tempCWD, LOOK_FOR_MATCHING_ENTRY, 0) != CE_GOOD)
00AF7A  EB4180     CLR.B W3
00AF7C  B3C012     MOV #0x1, W2
00AF7E  78008A     MOV W10, W1
00AF80  248BA0     MOV #0x48BA, W0
00AF82  07F4CC     RCALL FILEfind
00AF84  E00000     CP0 W0
00AF86  3AFF0D     BRA NZ, 0xADA2
9274:                          {
9275:                              // Couldn't find the DIR
9276:                              FSerrno = CE_DIR_NOT_FOUND;
00ADA2  B3C0C1     MOV #0xC, W1
00ADA4  37FFFA     BRA 0xAD9A
9277:                              return -1;
9278:                          }
9279:                          else
9280:                          {
9281:                              // Found the file
9282:                              // Check to make sure it's actually a directory
9283:                              if ((gFileTemp.attributes & ATTR_DIRECTORY) == 0 )
00AF88  248EC0     MOV #0x48EC, W0
00AF8A  780010     MOV [W0], W0
00AF8C  600070     AND W0, #0x10, W0
00AF8E  32FF81     BRA Z, 0xAE92
9284:                              {
9285:                                  FSerrno = CE_INVALID_ARGUMENT;
9286:                                  return -1;
9287:                              }
9288:              
9289:                              // Get the new name
9290:              				#if defined(SUPPORT_LFN)
9291:              					if(!tempCWD->utf16LFNlength)
00AF90  97B04F     MOV [W15-24], W0
00AF92  E00000     CP0 W0
00AF94  3A0007     BRA NZ, 0xAFA4
00AF96  248D60     MOV #0x48D6, W0
00AF98  2FFD81     MOV #0xFFD8, W1
00AF9A  478101     ADD W15, W1, W2
00AF9C  248E11     MOV #0x48E1, W1
9292:              				#endif
9293:                              		for (j = 0; j < 11; j++)
00AFA0  500F81     SUB W0, W1, [W15]
00AFA2  3AFFFD     BRA NZ, 0xAF9E
9294:                              		{
9295:                                  		tempCWD->name[j] = gFileTemp.name[j];
00AF9E  785930     MOV.B [W0++], [W2++]
9296:                              		}
9297:              
9298:                              tempCWD->dirclus = gFileTemp.cluster;
00AFA4  8245E0     MOV 0x48BC, W0
00AFA6  8245F1     MOV 0x48BE, W1
00AFA8  9FBF80     MOV W0, [W15-16]
00AFAA  9FBF91     MOV W1, [W15-14]
9299:                              tempCWD->dirccls = tempCWD->dirclus;
00AFAC  9FBFA0     MOV W0, [W15-12]
00AFAE  9FBFB1     MOV W1, [W15-10]
9300:                          }
9301:              
9302:                          if (i == 0)
00AFB0  E00008     CP0 W8
00AFB2  3A0011     BRA NZ, 0xAFD6
9303:                          {
9304:                              // If we're at the end of the string, we're done
9305:                              FileObjectCopy (cwdptr, tempCWD);
00AFB4  8385B0     MOV cwdptr, W0
00AFB6  2FFBC2     MOV #0xFFBC, W2
00AFB8  478082     ADD W15, W2, W1
00AFBA  37000A     BRA 0xAFD0
9306:                              return 0;
9307:                          }
9308:                          else
9309:                          {
9310:                              while (i == '\\')
00AFD8  2005C0     MOV #0x5C, W0
00AFDA  540F80     SUB W8, W0, [W15]
00AFDC  32FFEF     BRA Z, 0xAFBC
00AFDE  37FEE3     BRA 0xADA6
00AFE0  EB0000     CLR W0
9311:                              {
9312:                                  // If we get to another backslash, increment past it
9313:              #ifdef ALLOW_PGMFUNCTIONS
9314:                                  if (mode)
9315:                                  {
9316:              						#ifdef SUPPORT_LFN
9317:              						if(utfModeFileName)
9318:              
9319:              						{
9320:              
9321:                              		    utf16path2++;
9322:                              		    i = *utf16path2;
9323:              						}
9324:              						else
9325:              						#endif
9326:              						{
9327:                              		    temppath2++;
9328:                              		    i = *temppath2;
9329:              						}
9330:                                  }
9331:                                  else
9332:                                  {
9333:              #endif
9334:              						#ifdef SUPPORT_LFN
9335:              						if(utfModeFileName)
00AFBC  E00001     CP0 W1
00AFBE  320002     BRA Z, 0xAFC4
00AFD6  8385A1     MOV utfModeFileName, W1
9336:              
9337:              						{
9338:              
9339:                              		    utf16path++;
9340:                              		    i = *utf16path;
00AFC0  780459     MOV [++W9], W8
00AFC2  370001     BRA 0xAFC6
9341:              						}
9342:              						else
9343:              						#endif
9344:              						{
9345:                              		    temppath++;
9346:                              		    i = *temppath;
00AFC4  FB045B     SE [++W11], W8
9347:              						}
9348:              #ifdef ALLOW_PGMFUNCTIONS
9349:                                  }
9350:              #endif
9351:                                  if (i == 0)
00AFC6  E00008     CP0 W8
00AFC8  3A0007     BRA NZ, 0xAFD8
9352:                                  {
9353:                                      FileObjectCopy (cwdptr, tempCWD);
00AFCA  8385B0     MOV cwdptr, W0
00AFCC  2FFBC4     MOV #0xFFBC, W4
00AFCE  478084     ADD W15, W4, W1
00AFD0  07E541     RCALL FileObjectCopy
00AFD2  780008     MOV W8, W0
00AFD4  370006     BRA 0xAFE2
9354:                                      return 0;
9355:                                  }
9356:                              }
9357:                          }
9358:                          break;
9359:                      }
9360:                  } // loop
9361:              }
00AFEA  780080     MOV W0, W1
9362:              
9363:              
9364:              
9365:              // This string is used by FSgetcwd to return the cwd name if the path
9366:              // passed into the function is NULL
9367:              char defaultArray [10];
9368:              
9369:              
9370:              /**************************************************************
9371:                Function:
9372:                  char * FSgetcwd (char * path, int numchars)
9373:                Summary:
9374:                  Get the current working directory path in Ascii format
9375:                Conditions:
9376:                  None
9377:                Input:
9378:                  path -      Pointer to the array to return the cwd name in
9379:                  numchars -  Number of chars in the path
9380:                Return Values:
9381:                  char * - The cwd name string pointer (path or defaultArray)
9382:                  NULL -   The current working directory name could not be loaded.
9383:                Side Effects:
9384:                  The FSerrno variable will be changed
9385:                Description:
9386:                  Get the current working directory path in Ascii format.
9387:                  The FSgetcwd function will get the name of the current
9388:                  working directory and return it to the user.  The name
9389:                  will be copied into the buffer pointed to by 'path,'
9390:                  starting at the root directory and copying as many chars
9391:                  as possible before the end of the buffer.  The buffer
9392:                  size is indicated by the 'numchars' argument.  The first
9393:                  thing this function will do is load the name of the current
9394:                  working directory, if it isn't already present.  This could
9395:                  occur if the user switched to the dotdot entry of a
9396:                  subdirectory immediately before calling this function.  The
9397:                  function will then copy the current working directory name 
9398:                  into the buffer backwards, and insert a backslash character.  
9399:                  Next, the function will continuously switch to the previous 
9400:                  directories and copy their names backwards into the buffer
9401:                  until it reaches the root.  If the buffer overflows, it
9402:                  will be treated as a circular buffer, and data will be
9403:                  copied over existing characters, starting at the beginning.
9404:                  Once the root directory is reached, the text in the buffer
9405:                  will be swapped, so that the buffer contains as much of the
9406:                  current working directory name as possible, starting at the 
9407:                  root.
9408:                Remarks:
9409:                  None                                                       
9410:                **************************************************************/
9411:              char * FSgetcwd (char * path, int numchars)
9412:              {
9413:                  // If path is passed in as null, set up a default
9414:                  // array with 10 characters
9415:                  unsigned short int totalchars = (path == NULL) ? 10 : numchars;
00B21E  2000AD     MOV #0xA, W13
00B220  E00000     CP0 W0
00B222  320001     BRA Z, 0xB226
00B224  780681     MOV W1, W13
9416:                  char * returnPointer;
9417:                  char * bufferEnd;
9418:                  FILEOBJ tempCWD = &gFileTemp;
9419:                  BYTE bufferOverflow = FALSE;
9420:                  signed char j;
9421:                  DWORD curclus;
9422:                  WORD fHandle, tempindex;
9423:                  short int i = 0, index = 0;
9424:                  char aChar;
9425:                  DIRENTRY entry;
9426:              
9427:              	#if defined(SUPPORT_LFN)
9428:              	WORD prevHandle;
9429:              	UINT16_VAL tempShift;
9430:              	FSFILE cwdTemp;
9431:              	LFN_ENTRY *lfno;
9432:              	unsigned short int *tempLFN = (unsigned short int *)&tempDirectoryString[0];
9433:              	#endif
9434:              
9435:                  FSerrno = CE_GOOD;
00B226  249381     MOV #0x4938, W1
00B228  EB4880     CLR.B [W1]
9436:              
9437:                  // Set up the return value
9438:                  if (path == NULL)
00B22A  E00000     CP0 W0
00B22C  320008     BRA Z, 0xB23E
9439:                      returnPointer = defaultArray;
9440:                  else
9441:                  {
9442:                      returnPointer = path;
9443:                      if (numchars == 0)
00B22E  E0000E     CP0 W14
00B230  320002     BRA Z, 0xB236
00B232  780580     MOV W0, W11
00B234  370005     BRA 0xB240
9444:                      {
9445:                          FSerrno = CE_INVALID_ARGUMENT;
00B236  B3C1F0     MOV #0x1F, W0
00B238  784880     MOV.B W0, [W1]
00B23A  78058E     MOV W14, W11
00B23C  3701D3     BRA 0xB5E4
9446:                          return NULL;
00B23E  24640B     MOV #0x4640, W11
9447:                      }
9448:                  }
9449:              
9450:                  bufferEnd = returnPointer + totalchars - 1;
00B240  45800D     ADD W11, W13, W0
00B242  E90000     DEC W0, W0
00B244  9FBF80     MOV W0, [W15-16]
9451:              
9452:                  FileObjectCopy (tempCWD, cwdptr);
00B246  8385B1     MOV cwdptr, W1
00B248  248BA0     MOV #0x48BA, W0
00B24A  07E404     RCALL FileObjectCopy
9453:              
9454:                  if (((tempCWD->name[0] == '.') && (tempCWD->name[1] == '.'))
00B24C  248D61     MOV #0x48D6, W1
00B24E  22E2E0     MOV #0x2E2E, W0
00B250  100F91     SUBR W0, [W1], [W15]
00B252  320003     BRA Z, 0xB25A
00B254  248E60     MOV #0x48E6, W0
00B256  E00010     CP0 [W0]
00B258  3200E5     BRA Z, 0xB424
9455:              		#if defined(SUPPORT_LFN)	
9456:              	 	|| tempCWD->utf16LFNlength
9457:              		#endif
9458:              		)
9459:                  {
9460:                      // We last changed directory into a dotdot entry
9461:                      // Save the value of the current directory
9462:                      curclus = tempCWD->dirclus;
00B25A  824770     MOV 0x48EE, W0
00B25C  824781     MOV 0x48F0, W1
00B25E  9FB7E0     MOV W0, [W15-20]
00B260  9FB7F1     MOV W1, [W15-18]
9463:                      // Put this dir's dotdot entry into the dirclus
9464:                      // Our cwd absolutely is not the root
9465:                      fHandle = 1;
00B262  200012     MOV #0x1, W2
00B264  9F97E2     MOV W2, [W15-84]
9466:                      tempCWD->dirccls = tempCWD->dirclus;
00B266  8A4790     MOV W0, 0x48F2
00B268  8A47A1     MOV W1, 0x48F4
9467:                      entry = Cache_File_Entry (tempCWD,&fHandle, TRUE);
00B26A  2FFAC1     MOV #0xFFAC, W1
00B26C  40808F     ADD W1, W15, W1
00B26E  248BA0     MOV #0x48BA, W0
00B270  07E19C     RCALL Cache_File_Entry
00B272  780200     MOV W0, W4
9468:                      if (entry == NULL)
00B274  E00000     CP0 W0
00B276  3A0005     BRA NZ, 0xB282
9469:                      {
9470:                          FSerrno = CE_BADCACHEREAD;
00B278  B3C1B1     MOV #0x1B, W1
00B27A  249380     MOV #0x4938, W0
00B27C  784801     MOV.B W1, [W0]
00B27E  780584     MOV W4, W11
00B280  3701B1     BRA 0xB5E4
9471:                          return NULL;
9472:                      }
9473:              
9474:                     // Get the cluster
9475:                     TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number.
00B292  8A49A0     MOV W0, TempClusterCalc
00B294  8A49B1     MOV W1, 0x4936
9476:              
9477:                      // For FAT32, if the .. entry is 0, the cluster won't be 0
9478:              #ifdef SUPPORT_FAT32
9479:                      if (TempClusterCalc == VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT)
00B296  500FE0     SUB W0, #0x0, [W15]
00B298  588FE0     SUBB W1, #0x0, [W15]
00B29A  3A0005     BRA NZ, 0xB2A6
9480:                      {
9481:                          tempCWD->dirclus = FatRootDirClusterValue;
00B29C  8249D2     MOV FatRootDirClusterValue, W2
00B29E  8249E3     MOV 0x493C, W3
00B2A0  8A4772     MOV W2, 0x48EE
00B2A2  8A4783     MOV W3, 0x48F0
00B2A4  370002     BRA 0xB2AA
9482:                      }
9483:                      else
9484:              #endif
9485:                          tempCWD->dirclus = TempClusterCalc;
00B2A6  8A4770     MOV W0, 0x48EE
00B2A8  8A4781     MOV W1, 0x48F0
9486:              
9487:                      tempCWD->dirccls = tempCWD->dirclus;
00B2AA  824770     MOV 0x48EE, W0
00B2AC  824781     MOV 0x48F0, W1
00B2AE  8A4790     MOV W0, 0x48F2
00B2B0  8A47A1     MOV W1, 0x48F4
9488:              
9489:                      // Find the direntry for the entry we were just in
9490:                      fHandle = 0;
00B2B2  EB0080     CLR W1
00B2B4  9F97E1     MOV W1, [W15-84]
9491:                      entry = Cache_File_Entry (tempCWD, &fHandle, TRUE);
00B2B6  B3C012     MOV #0x1, W2
00B2B8  370004     BRA 0xB2C2
9492:                      if (entry == NULL)
9493:                      {
9494:                          FSerrno = CE_BADCACHEREAD;
9495:                          return NULL;
9496:                      }
9497:              
9498:                      // Get the cluster
9499:                      TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number.
9500:              
9501:                      while ((TempClusterCalc != curclus) ||
00B2E4  8249A0     MOV TempClusterCalc, W0
00B2E6  8249B1     MOV 0x4936, W1
00B2E8  97B16F     MOV [W15-20], W2
00B2EA  97B1FF     MOV [W15-18], W3
00B2EC  500F82     SUB W0, W2, [W15]
00B2EE  588F83     SUBB W1, W3, [W15]
00B2F0  3AFFE4     BRA NZ, 0xB2BA
00B2F2  B3CE53     MOV #0xE5, W3
00B2F4  11CF9A     SUBR.B W3, [W10], [W15]
00B2F6  32FFE1     BRA Z, 0xB2BA
00B2F8  90483A     MOV.B [W10+11], W0
00B2FA  504FE8     SUB.B W0, #0x8, [W15]
00B2FC  32FFDE     BRA Z, 0xB2BA
00B2FE  504FEF     SUB.B W0, #0xF, [W15]
00B300  32FFDC     BRA Z, 0xB2BA
9502:                          ((TempClusterCalc == curclus) &&
9503:                          (((unsigned char)entry->DIR_Name[0] == 0xE5) || (entry->DIR_Attr == ATTR_VOLUME) || (entry->DIR_Attr == ATTR_LONG_NAME))))
9504:                      {
9505:                          fHandle++;
00B2BA  97916F     MOV [W15-84], W2
00B2BC  E80102     INC W2, W2
00B2BE  9F97E2     MOV W2, [W15-84]
9506:                          entry = Cache_File_Entry (tempCWD, &fHandle, FALSE);
00B2C0  EB4100     CLR.B W2
00B2C2  2FFAC1     MOV #0xFFAC, W1
00B2C4  40808F     ADD W1, W15, W1
00B2C6  248BA0     MOV #0x48BA, W0
00B2C8  07E170     RCALL Cache_File_Entry
00B2CA  780500     MOV W0, W10
9507:                          if (entry == NULL)
00B2CC  E00000     CP0 W0
00B2CE  320178     BRA Z, 0xB5C0
9508:                          {
9509:                              FSerrno = CE_BADCACHEREAD;
00B5C0  B3C1B1     MOV #0x1B, W1
00B5C2  249380     MOV #0x4938, W0
00B5C4  784801     MOV.B W1, [W0]
00B5C6  78058A     MOV W10, W11
00B5C8  37000D     BRA 0xB5E4
9510:                              return NULL;
9511:                          }
9512:              
9513:                          // Get the cluster
9514:                          TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number in a loop.
00B2D8  90095A     MOV [W10+26], W2
00B2DA  200003     MOV #0x0, W3
00B2DC  700002     IOR W0, W2, W0
00B2DE  708083     IOR W1, W3, W1
00B2E0  8A49A0     MOV W0, TempClusterCalc
00B2E2  8A49B1     MOV W1, 0x4936
9515:                      }
9516:              
9517:              		#if defined(SUPPORT_LFN)
9518:                     	FileObjectCopy (&cwdTemp, tempCWD);
00B302  248BA1     MOV #0x48BA, W1
00B304  2FFB02     MOV #0xFFB0, W2
00B306  478002     ADD W15, W2, W0
00B308  07E3A5     RCALL FileObjectCopy
9519:              	   	prevHandle = fHandle - 1;
00B30A  2FFAC1     MOV #0xFFAC, W1
00B30C  40808F     ADD W1, W15, W1
00B30E  9791EF     MOV [W15-84], W3
00B310  E92883     DEC W3, [++W1]
9520:              
9521:              	   	lfno = (LFN_ENTRY *)Cache_File_Entry (tempCWD, &prevHandle, FALSE);
00B312  EB4100     CLR.B W2
00B314  248BA0     MOV #0x48BA, W0
00B316  07E149     RCALL Cache_File_Entry
00B318  780100     MOV W0, W2
00B31A  2464A9     MOV #0x464A, W9
00B31C  EB0600     CLR W12
00B31E  370048     BRA 0xB3B0
9522:              
9523:              
9524:              	   	while((lfno->LFN_Attribute == ATTR_LONG_NAME) && (lfno->LFN_SequenceNo != DIR_DEL)
00B3B0  904832     MOV.B [W2+11], W0
00B3B2  504FEF     SUB.B W0, #0xF, [W15]
00B3B4  3A0005     BRA NZ, 0xB3C0
00B3B6  784012     MOV.B [W2], W0
00B3B8  404FFB     ADD.B W0, #0x1B, [W15]
00B3BA  320002     BRA Z, 0xB3C0
00B3BC  E00400     CP0.B W0
00B3BE  3AFFB0     BRA NZ, 0xB320
9525:              
9526:              	   			&& (lfno->LFN_SequenceNo != DIR_EMPTY))
9527:              
9528:              	   	{
9529:              
9530:              	   		tempShift.byte.LB = lfno->LFN_Part1[0];
00B320  904012     MOV.B [W2+1], W0
00B322  FB8000     ZE W0, W0
00B324  2FF001     MOV #0xFF00, W1
00B326  640401     AND W8, W1, W8
00B328  740400     IOR W8, W0, W8
9531:              
9532:              	   		tempShift.byte.HB = lfno->LFN_Part1[1];
00B32A  904022     MOV.B [W2+2], W0
00B32C  DD0048     SL W0, #8, W0
00B32E  B20FF8     AND #0xFF, W8
00B330  740400     IOR W8, W0, W8
9533:              
9534:              	   		tempLFN[i++] = tempShift.Val;
00B332  780C88     MOV W8, [W9]
9535:              
9536:              	   		tempShift.byte.LB = lfno->LFN_Part1[2];
00B334  904032     MOV.B [W2+3], W0
00B336  FB8000     ZE W0, W0
00B338  640401     AND W8, W1, W8
00B33A  740400     IOR W8, W0, W8
9537:              
9538:              	   		tempShift.byte.HB = lfno->LFN_Part1[3];
00B33C  904042     MOV.B [W2+4], W0
00B33E  DD0048     SL W0, #8, W0
00B340  B20FF8     AND #0xFF, W8
00B342  740400     IOR W8, W0, W8
9539:              
9540:              	   		tempLFN[i++] = tempShift.Val;
00B344  980498     MOV W8, [W9+2]
9541:              
9542:              	   		tempShift.byte.LB = lfno->LFN_Part1[4];
00B346  904052     MOV.B [W2+5], W0
00B348  FB8000     ZE W0, W0
00B34A  640401     AND W8, W1, W8
00B34C  740400     IOR W8, W0, W8
9543:              
9544:              	   		tempShift.byte.HB = lfno->LFN_Part1[5];
00B34E  904062     MOV.B [W2+6], W0
00B350  DD0048     SL W0, #8, W0
00B352  B20FF8     AND #0xFF, W8
00B354  740400     IOR W8, W0, W8
9545:              
9546:              	   		tempLFN[i++] = tempShift.Val;
00B356  9804A8     MOV W8, [W9+4]
9547:              
9548:              	   		tempShift.byte.LB = lfno->LFN_Part1[6];
00B358  904072     MOV.B [W2+7], W0
00B35A  FB8000     ZE W0, W0
00B35C  640401     AND W8, W1, W8
00B35E  740400     IOR W8, W0, W8
9549:              
9550:              	   		tempShift.byte.HB = lfno->LFN_Part1[7];
00B360  904802     MOV.B [W2+8], W0
00B362  DD0048     SL W0, #8, W0
00B364  B20FF8     AND #0xFF, W8
00B366  740400     IOR W8, W0, W8
9551:              
9552:              	   		tempLFN[i++] = tempShift.Val;
00B368  9804B8     MOV W8, [W9+6]
9553:              
9554:              	   		tempShift.byte.LB = lfno->LFN_Part1[8];
00B36A  904812     MOV.B [W2+9], W0
00B36C  FB8000     ZE W0, W0
00B36E  640401     AND W8, W1, W8
00B370  740400     IOR W8, W0, W8
9555:              
9556:              	   		tempShift.byte.HB = lfno->LFN_Part1[9];
00B372  904822     MOV.B [W2+10], W0
00B374  DD0048     SL W0, #8, W0
00B376  B20FF8     AND #0xFF, W8
00B378  740400     IOR W8, W0, W8
9557:              
9558:              	   		tempLFN[i++] = tempShift.Val;
00B37A  9804C8     MOV W8, [W9+8]
9559:              
9560:              
9561:              
9562:              	   		tempLFN[i++] = lfno->LFN_Part2[0];
00B37C  900072     MOV [W2+14], W0
00B37E  9804D0     MOV W0, [W9+10]
9563:              
9564:              	   		tempLFN[i++] = lfno->LFN_Part2[1];
00B380  900882     MOV [W2+16], W1
00B382  9804E1     MOV W1, [W9+12]
9565:              
9566:              	   		tempLFN[i++] = lfno->LFN_Part2[2];
00B384  900992     MOV [W2+18], W3
00B386  9804F3     MOV W3, [W9+14]
9567:              
9568:              	   		tempLFN[i++] = lfno->LFN_Part2[3];
00B388  900822     MOV [W2+20], W0
00B38A  980C80     MOV W0, [W9+16]
9569:              
9570:              	   		tempLFN[i++] = lfno->LFN_Part2[4];
00B38C  9008B2     MOV [W2+22], W1
00B38E  980C91     MOV W1, [W9+18]
9571:              
9572:              	   		tempLFN[i++] = lfno->LFN_Part2[5];
00B390  9009C2     MOV [W2+24], W3
00B392  980CA3     MOV W3, [W9+20]
9573:              
9574:              
9575:              
9576:              	   		tempLFN[i++] = lfno->LFN_Part3[0];
00B394  900862     MOV [W2+28], W0
00B396  980CB0     MOV W0, [W9+22]
9577:              
9578:              	   		tempLFN[i++] = lfno->LFN_Part3[1];
00B398  900972     MOV [W2+30], W2
00B39A  980CC2     MOV W2, [W9+24]
00B39C  46066D     ADD W12, #0xD, W12
9579:              
9580:              	   
9581:              
9582:              	   		prevHandle = prevHandle - 1;
00B39E  2FFAC1     MOV #0xFFAC, W1
00B3A0  40808F     ADD W1, W15, W1
00B3A2  97907F     MOV [W15-82], W0
00B3A4  E92880     DEC W0, [++W1]
9583:              
9584:              	   		lfno = (LFN_ENTRY *)Cache_File_Entry (tempCWD, &prevHandle, FALSE);
00B3A6  EB4100     CLR.B W2
00B3A8  248BA0     MOV #0x48BA, W0
00B3AA  07E0FF     RCALL Cache_File_Entry
00B3AC  780100     MOV W0, W2
00B3AE  4484FA     ADD W9, #0x1A, W9
9585:              
9586:              	   	}
9587:              
9588:              	   	FileObjectCopy (tempCWD, &cwdTemp);
00B3C0  2FFB02     MOV #0xFFB0, W2
00B3C2  478082     ADD W15, W2, W1
00B3C4  248BA0     MOV #0x48BA, W0
00B3C6  07E346     RCALL FileObjectCopy
9589:              		#endif
9590:              
9591:              	   	if(i == 0)
00B3C8  E0000C     CP0 W12
00B3CA  3A0012     BRA NZ, 0xB3F0
00B3CC  78010A     MOV W10, W2
00B3CE  78018C     MOV W12, W3
00B3D0  248D64     MOV #0x48D6, W4
9592:              	   	{
9593:              	   	    for (j = 0; j < 11; j++)
00B3DC  518FEB     SUB W3, #0xB, [W15]
00B3DE  3AFFF9     BRA NZ, 0xB3D2
9594:                     	    {
9595:                      	    tempCWD->name[j] = entry->DIR_Name[j];
00B3D2  7A7192     MOV.B [W2], [W3+W4]
9596:                      	    cwdptr->name[j] = entry->DIR_Name[j];
00B3D4  4180FC     ADD W3, #0x1C, W1
00B3D6  8385B0     MOV cwdptr, W0
00B3D8  78F032     MOV.B [W2++], [W0+W1]
00B3DA  E80183     INC W3, W3
9597:                     	    }
9598:              			#if defined(SUPPORT_LFN)
9599:              	   		cwdptr->utf16LFNlength = 0;
00B3E0  EB0080     CLR W1
00B3E2  8385B0     MOV cwdptr, W0
00B3E4  981061     MOV W1, [W0+44]
9600:              
9601:              	   		tempCWD->utf16LFNlength = 0;
00B3E6  8A4731     MOV W1, 0x48E6
00B3E8  370017     BRA 0xB418
9602:              
9603:              			#endif
9604:              	   	}
9605:              
9606:              		#if defined(SUPPORT_LFN)
9607:              	   	else
9608:              	   	{
9609:              
9610:              	   		tempCWD->utf16LFNlength = i;
00B3F0  8A473C     MOV W12, 0x48E6
00B3F2  5600EC     SUB W12, #0xC, W1
00B3F4  46000C     ADD W12, W12, W0
00B3F6  2464A3     MOV #0x464A, W3
00B3F8  418000     ADD W3, W0, W0
00B3FA  50007A     SUB W0, #0x1A, W0
00B3FC  B3C0D2     MOV #0xD, W2
9611:              
9612:              			for(j = 12;j >= 0;j--)
00B408  E00402     CP0.B W2
00B40A  3AFFF9     BRA NZ, 0xB3FE
9613:              			{
9614:              				if((tempLFN[i - j - 1]) == 0x0000)
00B3FE  E00010     CP0 [W0]
00B400  32FFF4     BRA Z, 0xB3EA
9615:              				{
9616:              					tempCWD->utf16LFNlength = i - j - 1;
00B3EA  E90001     DEC W1, W0
00B3EC  8A4730     MOV W0, 0x48E6
00B3EE  37000E     BRA 0xB40C
9617:              					break;
00B402  E94102     DEC.B W2, W2
00B404  E80081     INC W1, W1
00B406  E88000     INC2 W0, W0
9618:              				}
9619:              			}
9620:              			cwdptr->utf16LFNlength = tempCWD->utf16LFNlength;
00B40C  8385B0     MOV cwdptr, W0
00B40E  824731     MOV 0x48E6, W1
00B410  981061     MOV W1, [W0+44]
9621:              
9622:              	   		tempCWD->utf16LFNptr = (unsigned short int *)&tempDirectoryString[0];
00B412  2464A2     MOV #0x464A, W2
00B414  8A4722     MOV W2, 0x48E4
9623:              
9624:              	   		cwdptr->utf16LFNptr = (unsigned short int *)&tempDirectoryString[0];
00B416  981052     MOV W2, [W0+42]
9625:              
9626:              	   	}
9627:              
9628:              		#endif
9629:                      // Reset our temp dir back to that cluster
9630:                      tempCWD->dirclus = curclus;
00B418  97B06F     MOV [W15-20], W0
00B41A  97B0FF     MOV [W15-18], W1
00B41C  8A4770     MOV W0, 0x48EE
00B41E  8A4781     MOV W1, 0x48F0
9631:                      tempCWD->dirccls = curclus;
00B420  8A4790     MOV W0, 0x48F2
00B422  8A47A1     MOV W1, 0x48F4
00B424  248E62     MOV #0x48E6, W2
9632:                      // This will set us at the cwd, but it will actually
9633:                      // have the name in the name field this time
9634:                  }
9635:              
9636:                  // There's actually some kind of name value in the cwd
9637:              	#if defined(SUPPORT_LFN)
9638:                  if (((tempCWD->name[0] == '\\') && (tempCWD->utf16LFNlength == 0x0000)) || 
00B426  248D61     MOV #0x48D6, W1
00B428  B3C5C0     MOV #0x5C, W0
00B42A  104F91     SUBR.B W0, [W1], [W15]
00B42C  3A0003     BRA NZ, 0xB434
00B42E  E00012     CP0 [W2]
00B430  32000B     BRA Z, 0xB448
00B432  370002     BRA 0xB438
00B434  E00012     CP0 [W2]
00B436  320004     BRA Z, 0xB440
00B438  824721     MOV 0x48E4, W1
00B43A  2005C0     MOV #0x5C, W0
00B43C  100F91     SUBR W0, [W1], [W15]
00B43E  320004     BRA Z, 0xB448
00B444  570FE2     SUB W14, #0x2, [W15]
00B446  3A0098     BRA NZ, 0xB578
9639:              		((tempCWD->utf16LFNlength != 0x0000) && (tempCWD->utf16LFNptr[0] == (unsigned short int)'\\')) || (numchars == 0x02)) 
9640:              	#else
9641:                  if ((tempCWD->name[0] == '\\') || (numchars == 0x02))
9642:              	#endif
9643:                  {
9644:                      // Easy, our CWD is the root
9645:                      *returnPointer = '\\';
00B448  B3C5C0     MOV #0x5C, W0
00B44A  784D80     MOV.B W0, [W11]
9646:                      *(returnPointer + 1) = 0;
00B44C  EB4000     CLR.B W0
00B44E  984590     MOV.B W0, [W11+1]
00B450  3700C9     BRA 0xB5E4
9647:                      return returnPointer;
9648:                  }
9649:                  else
9650:                  {
9651:                      index = 0;
9652:                      // Loop until we get back to the root
9653:                      while (tempCWD->dirclus != FatRootDirClusterValue)
00B578  248EE2     MOV #0x48EE, W2
00B57A  8249D0     MOV FatRootDirClusterValue, W0
00B57C  8249E1     MOV 0x493C, W1
00B57E  100FB2     SUBR W0, [W2++], [W15]
00B580  188FA2     SUBBR W1, [W2--], [W15]
00B582  3AFF67     BRA NZ, 0xB452
9654:                      {
9655:              			#if defined(SUPPORT_LFN)
9656:                          if(tempCWD->utf16LFNlength)
00B452  824730     MOV 0x48E6, W0
00B454  B3C0A2     MOV #0xA, W2
00B456  E00000     CP0 W0
00B458  32001D     BRA Z, 0xB494
9657:                          {
9658:              			    i = tempCWD->utf16LFNlength * 2 - 1;
00B45A  400000     ADD W0, W0, W0
00B45C  370016     BRA 0xB48A
00B45E  2464A1     MOV #0x464A, W1
9659:              			    while(i >= 0)
00B48C  E00000     CP0 W0
00B48E  3DFFE7     BRA GE, 0xB45E
00B490  370055     BRA 0xB53C
9660:              				{
9661:              					#ifdef SUPPORT_LFN
9662:              					if(twoByteMode)
00B460  838592     MOV twoByteMode, W2
00B462  E00002     CP0 W2
00B464  320009     BRA Z, 0xB478
9663:              					{
9664:              						returnPointer[index++] = tempDirectoryString[i--];
00B466  7840E1     MOV.B [W1+W0], W1
00B468  7C7581     MOV.B W1, [W11+W8]
00B46A  E80408     INC W8, W8
00B46C  E90000     DEC W0, W0
9665:              	            	    if (index == totalchars)
00B46E  540F8D     SUB W8, W13, [W15]
00B470  3A000D     BRA NZ, 0xB48C
00B472  B3C019     MOV #0x1, W9
00B474  EB0400     CLR W8
00B476  37000A     BRA 0xB48C
9666:              	            	    {
9667:              	            	        index = 0;
9668:              	            	        bufferOverflow = TRUE;
9669:              	            	    }
9670:              					}
9671:              					else
9672:              					#endif
9673:              					{
9674:              						if(tempDirectoryString[i])
00B478  7840E1     MOV.B [W1+W0], W1
00B47A  E00401     CP0.B W1
00B47C  320006     BRA Z, 0xB48A
9675:              						{
9676:              							returnPointer[index++] = tempDirectoryString[i];
00B47E  7C7581     MOV.B W1, [W11+W8]
00B480  E80408     INC W8, W8
9677:              	           		  	  	if (index == totalchars)
00B482  540F8D     SUB W8, W13, [W15]
00B484  3A0002     BRA NZ, 0xB48A
00B486  B3C019     MOV #0x1, W9
00B488  780402     MOV W2, W8
9678:              	           		  	  	{
9679:              	           		  	  	    index = 0;
9680:              	           		  	  	    bufferOverflow = TRUE;
9681:              	           		  	  	}
9682:              							
9683:              						}
9684:              						i--;
00B48A  E90000     DEC W0, W0
9685:              					}
9686:              				}
9687:              			}
9688:              			else
9689:              			#endif
9690:              			{
9691:              	            j = 10;
9692:              	            while (tempCWD->name[j] == 0x20)
00B494  FB0002     SE W2, W0
00B496  40007C     ADD W0, #0x1C, W0
00B498  248BA3     MOV #0x48BA, W3
00B49A  400003     ADD W0, W3, W0
00B49C  B3C201     MOV #0x20, W1
00B49E  10CF90     SUBR.B W1, [W0], [W15]
00B4A0  32FFF8     BRA Z, 0xB492
9693:              	                j--;
00B492  E94102     DEC.B W2, W2
9694:              	            if (j >= 8)
00B4A2  514FE7     SUB.B W2, #0x7, [W15]
00B4A4  340049     BRA LE, 0xB538
00B4A6  784082     MOV.B W2, W1
00B4A8  780203     MOV W3, W4
00B4AA  EB4180     CLR.B W3
00B4AC  B3C072     MOV #0x7, W2
9695:              	            {
9696:              	                while (j >= 8)
00B4D4  50CF82     SUB.B W1, W2, [W15]
00B4D6  3AFFEB     BRA NZ, 0xB4AE
9697:              	                {
9698:              	                    *(returnPointer + index++) = tempCWD->name[j--];
00B4AE  FB0001     SE W1, W0
00B4B0  40007C     ADD W0, #0x1C, W0
00B4B2  7A4060     MOV.B [W0+W4], W0
00B4B4  7C7580     MOV.B W0, [W11+W8]
00B4B6  E80408     INC W8, W8
00B4B8  E94081     DEC.B W1, W1
9699:              	                    // This is a circular buffer
9700:              	                    // Any unnecessary values will be overwritten
9701:              	                    if (index == totalchars)
00B4BA  540F8D     SUB W8, W13, [W15]
00B4BC  3A0002     BRA NZ, 0xB4C2
00B4BE  B3C019     MOV #0x1, W9
00B4C0  EB0400     CLR W8
9702:              	                    {
9703:              	                        index = 0;
9704:              	                        bufferOverflow = TRUE;
9705:              	                    }
9706:              
9707:              						#ifdef SUPPORT_LFN
9708:              						if(twoByteMode)
00B4C2  838590     MOV twoByteMode, W0
00B4C4  E00000     CP0 W0
00B4C6  320006     BRA Z, 0xB4D4
9709:              						{
9710:              							returnPointer[index++] = 0x00;
00B4C8  7C7583     MOV.B W3, [W11+W8]
00B4CA  E80408     INC W8, W8
9711:              	   	    		  	   if (index == totalchars)
00B4CC  540F8D     SUB W8, W13, [W15]
00B4CE  3A0002     BRA NZ, 0xB4D4
00B4D0  B3C019     MOV #0x1, W9
00B4D2  EB0400     CLR W8
9712:              	   	    		  	   {
9713:              	   	    		  	       index = 0;
9714:              	   	    		  	       bufferOverflow = TRUE;
9715:              	   	    		  	   }
9716:              						}
9717:              						#endif
9718:              	                }
9719:              
9720:              	                *(returnPointer + index++) = '.';
00B4D8  B3C2E0     MOV #0x2E, W0
00B4DA  7C7580     MOV.B W0, [W11+W8]
00B4DC  E80408     INC W8, W8
9721:              	                if (index == totalchars)
00B4DE  540F8D     SUB W8, W13, [W15]
00B4E0  3A0002     BRA NZ, 0xB4E6
00B4E2  B3C019     MOV #0x1, W9
00B4E4  EB0400     CLR W8
9722:              	                {
9723:              	                    index = 0;
9724:              	                    bufferOverflow = TRUE;
9725:              	                }
9726:              
9727:              					#ifdef SUPPORT_LFN
9728:              					if(twoByteMode)
00B4E6  838590     MOV twoByteMode, W0
00B4E8  E00000     CP0 W0
00B4EA  320007     BRA Z, 0xB4FA
9729:              					{
9730:              						returnPointer[index++] = 0x00;
00B4EC  EB4000     CLR.B W0
00B4EE  7C7580     MOV.B W0, [W11+W8]
00B4F0  E80408     INC W8, W8
9731:              	   	    		    if (index == totalchars)
00B4F2  540F8D     SUB W8, W13, [W15]
00B4F4  3A0002     BRA NZ, 0xB4FA
00B4F6  B3C019     MOV #0x1, W9
00B4F8  EB0400     CLR W8
00B4FA  784101     MOV.B W1, W2
00B4FC  248BA3     MOV #0x48BA, W3
00B4FE  B3C201     MOV #0x20, W1
00B500  370001     BRA 0xB504
9732:              	   	    		    {
9733:              	   	    		        index = 0;
9734:              	   	    		        bufferOverflow = TRUE;
9735:              	   	    		    }
9736:              					}
9737:              					#endif
9738:              	            }
9739:              
9740:              	            while (tempCWD->name[j] == 0x20)
00B504  FB0002     SE W2, W0
00B506  40007C     ADD W0, #0x1C, W0
00B508  400003     ADD W0, W3, W0
00B50A  10CF90     SUBR.B W1, [W0], [W15]
00B50C  32FFFA     BRA Z, 0xB502
00B50E  370014     BRA 0xB538
9741:              	                j--;
00B502  E94102     DEC.B W2, W2
9742:              
9743:              	            while (j >= 0)
00B538  E00402     CP0.B W2
00B53A  3DFFEA     BRA GE, 0xB510
9744:              	            {
9745:              	                *(returnPointer + index++) = tempCWD->name[j--];
00B510  FB0082     SE W2, W1
00B512  248D60     MOV #0x48D6, W0
00B514  784061     MOV.B [W1+W0], W0
00B516  7C7580     MOV.B W0, [W11+W8]
00B518  E80408     INC W8, W8
00B51A  E94102     DEC.B W2, W2
9746:              	                // This is a circular buffer
9747:              	                // Any unnecessary values will be overwritten
9748:              	                if (index == totalchars)
00B51C  540F8D     SUB W8, W13, [W15]
00B51E  3A0002     BRA NZ, 0xB524
00B520  B3C019     MOV #0x1, W9
00B522  EB0400     CLR W8
9749:              	                {
9750:              	                    index = 0;
9751:              	                    bufferOverflow = TRUE;
9752:              	                }
9753:              
9754:              					#ifdef SUPPORT_LFN
9755:              					if(twoByteMode)
00B524  838590     MOV twoByteMode, W0
00B526  E00000     CP0 W0
00B528  320007     BRA Z, 0xB538
9756:              					{
9757:              						returnPointer[index++] = 0x00;
00B52A  EB4000     CLR.B W0
00B52C  7C7580     MOV.B W0, [W11+W8]
00B52E  E80408     INC W8, W8
9758:              	   	    		    if (index == totalchars)
00B530  540F8D     SUB W8, W13, [W15]
00B532  3A0002     BRA NZ, 0xB538
00B534  B3C019     MOV #0x1, W9
00B536  EB0400     CLR W8
9759:              	   	    		    {
9760:              	   	    		        index = 0;
9761:              	   	    		        bufferOverflow = TRUE;
9762:              	   	    		    }
9763:              					}
9764:              					#endif
9765:              	            }
9766:              			}
9767:              
9768:              			#ifdef SUPPORT_LFN
9769:              			if(twoByteMode)
00B53C  838590     MOV twoByteMode, W0
00B53E  E00000     CP0 W0
00B540  320007     BRA Z, 0xB550
9770:              			{
9771:              				returnPointer[index++] = 0x00;
00B542  EB4000     CLR.B W0
00B544  7C7580     MOV.B W0, [W11+W8]
00B546  E80408     INC W8, W8
9772:              	            if (index == totalchars)
00B548  540F8D     SUB W8, W13, [W15]
00B54A  3A0002     BRA NZ, 0xB550
00B54C  B3C019     MOV #0x1, W9
00B54E  EB0400     CLR W8
9773:              	            {
9774:              	                index = 0;
9775:              	                bufferOverflow = TRUE;
9776:              	            }
9777:              			}
9778:              			#endif
9779:              
9780:                          // Put a backslash delimiter in front of the dir name
9781:                          *(returnPointer + index++) = '\\';
00B550  B3C5C0     MOV #0x5C, W0
00B552  7C7580     MOV.B W0, [W11+W8]
00B554  E80408     INC W8, W8
9782:                          if (index == totalchars)
00B556  540F8D     SUB W8, W13, [W15]
00B558  3A0002     BRA NZ, 0xB55E
00B55A  B3C019     MOV #0x1, W9
00B55C  EB0400     CLR W8
9783:                          {
9784:                              index = 0;
9785:                              bufferOverflow = TRUE;
9786:                          }
9787:              
9788:                          // Load the previous entry
9789:                          tempCWD->dirccls = tempCWD->dirclus;
00B55E  824772     MOV 0x48EE, W2
00B560  824783     MOV 0x48F0, W3
00B562  8A4792     MOV W2, 0x48F2
00B564  8A47A3     MOV W3, 0x48F4
9790:                          if (GetPreviousEntry (tempCWD))
00B566  248BA0     MOV #0x48BA, W0
00B568  07FD4D     RCALL GetPreviousEntry
00B56A  E00400     CP0.B W0
00B56C  320005     BRA Z, 0xB578
9791:                          {
9792:                              FSerrno = CE_BAD_SECTOR_READ;
00B56E  B3C081     MOV #0x8, W1
00B570  249380     MOV #0x4938, W0
00B572  784801     MOV.B W1, [W0]
00B574  EB0580     CLR W11
00B576  370036     BRA 0xB5E4
9793:                              return NULL;
00B440  EB4480     CLR.B W9
00B442  EB0400     CLR W8
9794:                          }
9795:                      }
9796:                  }
9797:              
9798:                  // Point the index back at the last char in the string
9799:                  index--;
00B584  E90208     DEC W8, W4
00B586  458004     ADD W11, W4, W0
9800:              
9801:                  i = 0;
9802:                  // Swap the chars in the buffer so they are in the right places
9803:                  if (bufferOverflow)
00B588  E00409     CP0.B W9
00B58A  32001F     BRA Z, 0xB5CA
9804:                  {
9805:                      tempindex = index;
00B58C  780184     MOV W4, W3
00B58E  78010B     MOV W11, W2
00B590  780080     MOV W0, W1
00B592  370004     BRA 0xB59C
9806:                      // Swap the overflowed values in the buffer
9807:                      while ((index - i) > 0)
00B59C  E00003     CP0 W3
00B59E  3CFFFA     BRA GT, 0xB594
9808:                      {
9809:                           aChar = *(returnPointer + i);
00B594  784012     MOV.B [W2], W0
9810:                           *(returnPointer + i) = * (returnPointer + index);
00B596  785911     MOV.B [W1], [W2++]
9811:                           *(returnPointer + index) = aChar;
00B598  785080     MOV.B W0, [W1--]
00B59A  E98183     DEC2 W3, W3
9812:                           index--;
9813:                           i++;
9814:                      }
9815:              
9816:                      // Point at the non-overflowed values
9817:                      i = tempindex + 1;
00B5A0  E80004     INC W4, W0
9818:                      index = bufferEnd - returnPointer;
00B5A2  97B98F     MOV [W15-16], W3
00B5A4  51808B     SUB W3, W11, W1
00B5A6  508180     SUB W1, W0, W3
00B5A8  458100     ADD W11, W0, W2
00B5AA  458081     ADD W11, W1, W1
00B5AC  370004     BRA 0xB5B6
9819:              
9820:                      // Swap the non-overflowed values into the right places
9821:                      while ((index - i) > 0)
00B5B6  E00003     CP0 W3
00B5B8  3CFFFA     BRA GT, 0xB5AE
9822:                      {
9823:                           aChar = *(returnPointer + i);
00B5AE  784012     MOV.B [W2], W0
9824:                           *(returnPointer + i) = * (returnPointer + index);
00B5B0  785911     MOV.B [W1], [W2++]
9825:                           *(returnPointer + index) = aChar;
00B5B2  785080     MOV.B W0, [W1--]
00B5B4  E98183     DEC2 W3, W3
9826:                           index--;
9827:                           i++;
9828:                      }
9829:                      // All the values should be in the right place now
9830:                      // Null-terminate the string
9831:                      *(bufferEnd) = 0;
00B5BA  97B80F     MOV [W15-16], W0
00B5BC  EB4800     CLR.B [W0]
00B5BE  370012     BRA 0xB5E4
9832:                  }
9833:                  else
9834:                  {
9835:                      // There was no overflow, just do one set of swaps
9836:                      tempindex = index;
00B5CA  780184     MOV W4, W3
00B5CC  78010B     MOV W11, W2
00B5CE  780080     MOV W0, W1
00B5D0  370004     BRA 0xB5DA
9837:                      while ((index - i) > 0)
00B5DA  E00003     CP0 W3
00B5DC  3CFFFA     BRA GT, 0xB5D2
9838:                      {
9839:                          aChar = *(returnPointer + i);
00B5D2  784012     MOV.B [W2], W0
9840:                          *(returnPointer + i) = * (returnPointer + index);
00B5D4  785911     MOV.B [W1], [W2++]
9841:                          *(returnPointer + index) = aChar;
00B5D6  785080     MOV.B W0, [W1--]
00B5D8  E98183     DEC2 W3, W3
9842:                          index--;
9843:                          i++;
9844:                      }
9845:                      *(returnPointer + tempindex + 1) = 0;
00B5DE  458084     ADD W11, W4, W1
00B5E0  EB4000     CLR.B W0
00B5E2  984090     MOV.B W0, [W1+1]
9846:                  }
9847:              
9848:                  return returnPointer;
9849:              }
9850:              
9851:              #ifdef SUPPORT_LFN
9852:              
9853:              /**************************************************************
9854:                Function:
9855:                  char * wFSgetcwd (unsigned short int * path, int numchars)
9856:                Summary:
9857:                  Get the current working directory path in UTF16 format
9858:                Conditions:
9859:                  None
9860:                Input:
9861:                  path -      Pointer to the array to return the cwd name in
9862:                  numchars -  Number of chars in the path
9863:                Return Values:
9864:                  char * - The cwd name string pointer (path or defaultArray)
9865:                  NULL -   The current working directory name could not be loaded.
9866:                Side Effects:
9867:                  The FSerrno variable will be changed
9868:                Description:
9869:                  Get the current working directory path in UTF16 format.
9870:                  The FSgetcwd function will get the name of the current
9871:                  working directory and return it to the user.  The name
9872:                  will be copied into the buffer pointed to by 'path,'
9873:                  starting at the root directory and copying as many chars
9874:                  as possible before the end of the buffer.  The buffer
9875:                  size is indicated by the 'numchars' argument.  The first
9876:                  thing this function will do is load the name of the current
9877:                  working directory, if it isn't already present.  This could
9878:                  occur if the user switched to the dotdot entry of a
9879:                  subdirectory immediately before calling this function.  The
9880:                  function will then copy the current working directory name 
9881:                  into the buffer backwards, and insert a backslash character.  
9882:                  Next, the function will continuously switch to the previous 
9883:                  directories and copy their names backwards into the buffer
9884:                  until it reaches the root.  If the buffer overflows, it
9885:                  will be treated as a circular buffer, and data will be
9886:                  copied over existing characters, starting at the beginning.
9887:                  Once the root directory is reached, the text in the buffer
9888:                  will be swapped, so that the buffer contains as much of the
9889:                  current working directory name as possible, starting at the 
9890:                  root.
9891:                Remarks:
9892:                  None                                                       
9893:                **************************************************************/
9894:              char * wFSgetcwd (unsigned short int * path, int numchars)
9895:              {
9896:              	char *result;
9897:              	twoByteMode = TRUE;
00B5F2  200012     MOV #0x1, W2
00B5F4  8B8592     MOV W2, twoByteMode
9898:                  result = FSgetcwd ((char *)path,numchars);
00B5F6  07FE0D     RCALL FSgetcwd
9899:              	twoByteMode = FALSE;
00B5F8  EB0080     CLR W1
00B5FA  8B8591     MOV W1, twoByteMode
9900:              	return result;
9901:              }
00B5FE  FA0002     LNK #0x2
00B600  BE9F88     MOV.D W8, [W15++]
9902:              #endif
9903:              
9904:              /**************************************************************************
9905:                Function:
9906:                  void GetPreviousEntry (FSFILE * fo)
9907:                Summary:
9908:                  Get the file entry info for the parent dir of the specified dir
9909:                Conditions:
9910:                  Should not be called by the user.
9911:                Input:
9912:                  fo -  The file to get the previous entry of
9913:                Return Values:
9914:                  0 -  The previous entry was successfully retrieved
9915:                  -1 - The previous entry could not be retrieved
9916:                Side Effects:
9917:                  None
9918:                Description:
9919:                  The GetPreviousEntry function is used by the FSgetcwd function to
9920:                  load the previous (parent) directory.  This function will load the
9921:                  parent directory and then search through the file entries in that
9922:                  directory for one that matches the cluster number of the original
9923:                  directory.  When the matching entry is found, the name of the
9924:                  original directory is copied into the 'fo' FSFILE object.
9925:                Remarks:
9926:                  None.
9927:                **************************************************************************/
9928:              
9929:              BYTE GetPreviousEntry (FSFILE * fo)
9930:              {
9931:                  int i,j;
9932:                  WORD fHandle = 1;
00B00E  20001C     MOV #0x1, W12
00B010  9F9FAC     MOV W12, [W15-76]
9933:                  DWORD dirclus;
9934:                  DIRENTRY dirptr;
9935:              
9936:              	#ifdef SUPPORT_LFN
9937:              		unsigned short int *tempLFN = (unsigned short int *)&tempDirectoryString[0];
00B012  2464AD     MOV #0x464A, W13
9938:              		FSFILE cwdTemp;
9939:              		LFN_ENTRY *lfno;
9940:              
9941:              		WORD prevHandle;
9942:              		UINT16_VAL tempShift;
9943:              
9944:              	#endif
9945:              
9946:                  // Load the previous entry
9947:                  dirptr = Cache_File_Entry (fo, &fHandle, TRUE);
00B014  78410C     MOV.B W12, W2
00B016  2FFB41     MOV #0xFFB4, W1
00B018  40808F     ADD W1, W15, W1
00B01A  07E2C7     RCALL Cache_File_Entry
00B01C  780580     MOV W0, W11
9948:                  if (dirptr == NULL)
00B01E  E00000     CP0 W0
00B020  3200F2     BRA Z, 0xB206
9949:                      return -1;
9950:              
9951:                  // Get the cluster
9952:                  TempClusterCalc = GetFullClusterNumber(dirptr); // Get complete cluster number.
00B032  8A49A8     MOV W8, TempClusterCalc
00B034  8A49B9     MOV W9, 0x4936
9953:              
9954:                  if (TempClusterCalc == VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT)
00B036  540FE0     SUB W8, #0x0, [W15]
00B038  5C8FE0     SUBB W9, #0x0, [W15]
00B03A  3A0012     BRA NZ, 0xB060
9955:                  {
9956:                      // The previous directory is the root
9957:                      fo->name[0] = '\\';
00B03C  B3C5C0     MOV #0x5C, W0
00B03E  985D40     MOV.B W0, [W10+28]
00B040  4500FC     ADD W10, #0x1C, W1
00B042  EB0000     CLR W0
00B044  B3C202     MOV #0x20, W2
9958:                      for (i = 0; i < 11; i++)
00B048  E80000     INC W0, W0
00B04A  500FEB     SUB W0, #0xB, [W15]
00B04C  3AFFFC     BRA NZ, 0xB046
9959:                      {
9960:                          fo->name[i] = 0x20;
00B046  785882     MOV.B W2, [W1++]
9961:                      }
9962:                      fo->dirclus = FatRootDirClusterValue;
00B04E  8249D0     MOV FatRootDirClusterValue, W0
00B050  8249E1     MOV 0x493C, W1
00B052  981D20     MOV W0, [W10+52]
00B054  981D31     MOV W1, [W10+54]
9963:                      fo->dirccls = FatRootDirClusterValue;
00B056  8249D0     MOV FatRootDirClusterValue, W0
00B058  8249E1     MOV 0x493C, W1
00B05A  981D40     MOV W0, [W10+56]
00B05C  981D51     MOV W1, [W10+58]
00B05E  370051     BRA 0xB102
9964:                  }
9965:                  else
9966:                  {
9967:                      // Get the directory name
9968:                      // Save the previous cluster value
9969:                     // Get the cluster
9970:              
9971:                      dirclus = TempClusterCalc;
9972:                      fo->dirclus = TempClusterCalc;
00B060  981D28     MOV W8, [W10+52]
00B062  981D39     MOV W9, [W10+54]
9973:                      fo->dirccls = TempClusterCalc;
00B064  981D48     MOV W8, [W10+56]
00B066  981D59     MOV W9, [W10+58]
9974:              
9975:              
9976:                      // Load the previous previous cluster
9977:                      dirptr = Cache_File_Entry (fo, &fHandle, TRUE);
00B068  78410C     MOV.B W12, W2
00B06A  2FFB41     MOV #0xFFB4, W1
00B06C  40808F     ADD W1, W15, W1
00B06E  78000A     MOV W10, W0
00B070  07E29C     RCALL Cache_File_Entry
9978:                      if (dirptr == NULL)
00B072  E00000     CP0 W0
00B074  3200C8     BRA Z, 0xB206
9979:                          return -1;
9980:              
9981:                     // Get the cluster
9982:                      TempClusterCalc = GetFullClusterNumber(dirptr); // Get complete cluster number.
00B086  8A49A0     MOV W0, TempClusterCalc
00B088  8A49B1     MOV W1, 0x4936
9983:              #ifdef SUPPORT_FAT32
9984:                      // If we're using FAT32 and the previous previous cluster is the root, the
9985:                      // value in the dotdot entry will be 0, but the actual cluster won't
9986:                      if (TempClusterCalc == VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT)
00B08A  500FE0     SUB W0, #0x0, [W15]
00B08C  588FE0     SUBB W1, #0x0, [W15]
00B08E  3A0002     BRA NZ, 0xB094
9987:                      {
9988:                          fo->dirclus = FatRootDirClusterValue;
00B090  8249D0     MOV FatRootDirClusterValue, W0
00B092  8249E1     MOV 0x493C, W1
9989:                      }
9990:                      else
9991:              #endif
9992:                          fo->dirclus = TempClusterCalc;
00B094  981D20     MOV W0, [W10+52]
00B096  981D31     MOV W1, [W10+54]
9993:              
9994:                      fo->dirccls = fo->dirclus;
00B098  90182A     MOV [W10+52], W0
00B09A  9018BA     MOV [W10+54], W1
00B09C  981D40     MOV W0, [W10+56]
00B09E  981D51     MOV W1, [W10+58]
9995:              
9996:                      fHandle = 0;
00B0A0  EB0080     CLR W1
00B0A2  9F9FA1     MOV W1, [W15-76]
9997:                      dirptr = Cache_File_Entry (fo, &fHandle, TRUE);
00B0A4  B3C012     MOV #0x1, W2
00B0A6  2FFB41     MOV #0xFFB4, W1
00B0A8  40808F     ADD W1, W15, W1
00B0AA  78000A     MOV W10, W0
00B0AC  07E27E     RCALL Cache_File_Entry
00B0AE  780580     MOV W0, W11
9998:                      if (dirptr == NULL)
00B0B0  E00000     CP0 W0
00B0B2  3200A9     BRA Z, 0xB206
00B0B4  37000B     BRA 0xB0CC
9999:                          return -1;
10000:                     // Look through it until we get the name
10001:                     // of the previous cluster
10002:                     // Get the cluster
10003:                     TempClusterCalc = GetFullClusterNumber(dirptr); // Get complete cluster number.
10004:                     while ((TempClusterCalc != dirclus) ||
00B0E0  8249A0     MOV TempClusterCalc, W0
00B0E2  8249B1     MOV 0x4936, W1
00B0E4  500F88     SUB W0, W8, [W15]
00B0E6  588F89     SUBB W1, W9, [W15]
00B0E8  3AFFE6     BRA NZ, 0xB0B6
00B0EA  B3CE50     MOV #0xE5, W0
00B0EC  104F9B     SUBR.B W0, [W11], [W15]
00B0EE  32FFE3     BRA Z, 0xB0B6
00B0F0  90483B     MOV.B [W11+11], W0
00B0F2  504FE8     SUB.B W0, #0x8, [W15]
00B0F4  32FFE0     BRA Z, 0xB0B6
00B0F6  504FEF     SUB.B W0, #0xF, [W15]
00B0F8  32FFDE     BRA Z, 0xB0B6
10005:                         ((TempClusterCalc == dirclus) &&
10006:                         (((unsigned char)dirptr->DIR_Name[0] == 0xE5) || (dirptr->DIR_Attr == ATTR_VOLUME) || (dirptr->DIR_Attr == ATTR_LONG_NAME))))
10007:                     {
10008:                         // Look through the entries until we get the
10009:                         // right one
10010:                         dirptr = Cache_File_Entry (fo, &fHandle, FALSE);
00B0B6  EB4100     CLR.B W2
00B0B8  2FFB41     MOV #0xFFB4, W1
00B0BA  40808F     ADD W1, W15, W1
00B0BC  78000A     MOV W10, W0
00B0BE  07E275     RCALL Cache_File_Entry
00B0C0  780580     MOV W0, W11
10011:                         if (dirptr == NULL)
00B0C2  E00000     CP0 W0
00B0C4  3200A0     BRA Z, 0xB206
10012:                             return -1;
10013:                         fHandle++;
00B0C6  97992F     MOV [W15-76], W2
00B0C8  E80102     INC W2, W2
00B0CA  9F9FA2     MOV W2, [W15-76]
10014:             
10015:                        TempClusterCalc = GetFullClusterNumber(dirptr); // Get complete cluster number in a loop.
00B0D4  90095B     MOV [W11+26], W2
00B0D6  200003     MOV #0x0, W3
00B0D8  700002     IOR W0, W2, W0
00B0DA  708083     IOR W1, W3, W1
00B0DC  8A49A0     MOV W0, TempClusterCalc
00B0DE  8A49B1     MOV W1, 0x4936
10016:                     }
10017:             
10018:                     // The name should be in the entry now
10019:                     // Copy the actual directory location back
10020:                     fo->dirclus = dirclus;
00B0FA  981D28     MOV W8, [W10+52]
00B0FC  981D39     MOV W9, [W10+54]
10021:                     fo->dirccls = dirclus;
00B0FE  981D48     MOV W8, [W10+56]
00B100  981D59     MOV W9, [W10+58]
10022:             	}
10023:             
10024:                	i = 0;
10025:             	#ifdef SUPPORT_LFN
10026:                    	FileObjectCopy (&cwdTemp, fo);
00B102  78008A     MOV W10, W1
00B104  2FFB82     MOV #0xFFB8, W2
00B106  478002     ADD W15, W2, W0
00B108  07E4A5     RCALL FileObjectCopy
10027:             	   	prevHandle = fHandle - 2;
00B10A  2FFB41     MOV #0xFFB4, W1
00B10C  40808F     ADD W1, W15, W1
00B10E  97982F     MOV [W15-76], W0
00B110  E9A880     DEC2 W0, [++W1]
10028:             
10029:             	   	lfno = (LFN_ENTRY *)Cache_File_Entry (fo, &prevHandle, FALSE);
00B112  EB4100     CLR.B W2
00B114  78000A     MOV W10, W0
00B116  07E249     RCALL Cache_File_Entry
00B118  780100     MOV W0, W2
00B11A  2464A9     MOV #0x464A, W9
00B11C  EB0600     CLR W12
00B11E  370048     BRA 0xB1B0
10030:             
10031:             		// Get the long file name of the short file name(if present)
10032:             	   	while((lfno->LFN_Attribute == ATTR_LONG_NAME) && (lfno->LFN_SequenceNo != DIR_DEL)
00B1B0  904832     MOV.B [W2+11], W0
00B1B2  504FEF     SUB.B W0, #0xF, [W15]
00B1B4  3A0005     BRA NZ, 0xB1C0
00B1B6  784012     MOV.B [W2], W0
00B1B8  404FFB     ADD.B W0, #0x1B, [W15]
00B1BA  320002     BRA Z, 0xB1C0
00B1BC  E00400     CP0.B W0
00B1BE  3AFFB0     BRA NZ, 0xB120
10033:             
10034:             	   			&& (lfno->LFN_SequenceNo != DIR_EMPTY))
10035:             
10036:             	   	{
10037:             
10038:             	   		tempShift.byte.LB = lfno->LFN_Part1[0];
00B120  904012     MOV.B [W2+1], W0
00B122  FB8000     ZE W0, W0
00B124  2FF001     MOV #0xFF00, W1
00B126  640401     AND W8, W1, W8
00B128  740400     IOR W8, W0, W8
10039:             
10040:             	   		tempShift.byte.HB = lfno->LFN_Part1[1];
00B12A  904022     MOV.B [W2+2], W0
00B12C  DD0048     SL W0, #8, W0
00B12E  B20FF8     AND #0xFF, W8
00B130  740400     IOR W8, W0, W8
10041:             
10042:             	   		tempLFN[i++] = tempShift.Val;
00B132  780C88     MOV W8, [W9]
10043:             
10044:             	   		tempShift.byte.LB = lfno->LFN_Part1[2];
00B134  904032     MOV.B [W2+3], W0
00B136  FB8000     ZE W0, W0
00B138  640401     AND W8, W1, W8
00B13A  740400     IOR W8, W0, W8
10045:             
10046:             	   		tempShift.byte.HB = lfno->LFN_Part1[3];
00B13C  904042     MOV.B [W2+4], W0
00B13E  DD0048     SL W0, #8, W0
00B140  B20FF8     AND #0xFF, W8
00B142  740400     IOR W8, W0, W8
10047:             
10048:             	   		tempLFN[i++] = tempShift.Val;
00B144  980498     MOV W8, [W9+2]
10049:             
10050:             	   		tempShift.byte.LB = lfno->LFN_Part1[4];
00B146  904052     MOV.B [W2+5], W0
00B148  FB8000     ZE W0, W0
00B14A  640401     AND W8, W1, W8
00B14C  740400     IOR W8, W0, W8
10051:             
10052:             	   		tempShift.byte.HB = lfno->LFN_Part1[5];
00B14E  904062     MOV.B [W2+6], W0
00B150  DD0048     SL W0, #8, W0
00B152  B20FF8     AND #0xFF, W8
00B154  740400     IOR W8, W0, W8
10053:             
10054:             	   		tempLFN[i++] = tempShift.Val;
00B156  9804A8     MOV W8, [W9+4]
10055:             
10056:             	   		tempShift.byte.LB = lfno->LFN_Part1[6];
00B158  904072     MOV.B [W2+7], W0
00B15A  FB8000     ZE W0, W0
00B15C  640401     AND W8, W1, W8
00B15E  740400     IOR W8, W0, W8
10057:             
10058:             	   		tempShift.byte.HB = lfno->LFN_Part1[7];
00B160  904802     MOV.B [W2+8], W0
00B162  DD0048     SL W0, #8, W0
00B164  B20FF8     AND #0xFF, W8
00B166  740400     IOR W8, W0, W8
10059:             
10060:             	   		tempLFN[i++] = tempShift.Val;
00B168  9804B8     MOV W8, [W9+6]
10061:             
10062:             	   		tempShift.byte.LB = lfno->LFN_Part1[8];
00B16A  904812     MOV.B [W2+9], W0
00B16C  FB8000     ZE W0, W0
00B16E  640401     AND W8, W1, W8
00B170  740400     IOR W8, W0, W8
10063:             
10064:             	   		tempShift.byte.HB = lfno->LFN_Part1[9];
00B172  904822     MOV.B [W2+10], W0
00B174  DD0048     SL W0, #8, W0
00B176  B20FF8     AND #0xFF, W8
00B178  740400     IOR W8, W0, W8
10065:             
10066:             	   		tempLFN[i++] = tempShift.Val;
00B17A  9804C8     MOV W8, [W9+8]
10067:             
10068:             
10069:             	   		tempLFN[i++] = lfno->LFN_Part2[0];
00B17C  9000F2     MOV [W2+14], W1
00B17E  9804D1     MOV W1, [W9+10]
10070:             
10071:             	   		tempLFN[i++] = lfno->LFN_Part2[1];
00B180  900802     MOV [W2+16], W0
00B182  9804E0     MOV W0, [W9+12]
10072:             
10073:             	   		tempLFN[i++] = lfno->LFN_Part2[2];
00B184  900892     MOV [W2+18], W1
00B186  9804F1     MOV W1, [W9+14]
10074:             
10075:             	   		tempLFN[i++] = lfno->LFN_Part2[3];
00B188  900822     MOV [W2+20], W0
00B18A  980C80     MOV W0, [W9+16]
10076:             
10077:             	   		tempLFN[i++] = lfno->LFN_Part2[4];
00B18C  9008B2     MOV [W2+22], W1
00B18E  980C91     MOV W1, [W9+18]
10078:             
10079:             	   		tempLFN[i++] = lfno->LFN_Part2[5];
00B190  900842     MOV [W2+24], W0
00B192  980CA0     MOV W0, [W9+20]
10080:             
10081:             
10082:             	   		tempLFN[i++] = lfno->LFN_Part3[0];
00B194  9008E2     MOV [W2+28], W1
00B196  980CB1     MOV W1, [W9+22]
10083:             
10084:             	   		tempLFN[i++] = lfno->LFN_Part3[1];
00B198  900972     MOV [W2+30], W2
00B19A  980CC2     MOV W2, [W9+24]
00B19C  46066D     ADD W12, #0xD, W12
10085:             
10086:             	   
10087:             
10088:             	   		prevHandle = prevHandle - 1;
00B19E  2FFB41     MOV #0xFFB4, W1
00B1A0  40808F     ADD W1, W15, W1
00B1A2  97983F     MOV [W15-74], W0
00B1A4  E92880     DEC W0, [++W1]
10089:             
10090:             	   		lfno = (LFN_ENTRY *)Cache_File_Entry (fo, &prevHandle, FALSE);
00B1A6  EB4100     CLR.B W2
00B1A8  78000A     MOV W10, W0
00B1AA  07E1FF     RCALL Cache_File_Entry
00B1AC  780100     MOV W0, W2
00B1AE  4484FA     ADD W9, #0x1A, W9
10091:             
10092:             	   	}
10093:             
10094:             
10095:             	   	FileObjectCopy (fo, &cwdTemp);
00B1C0  2FFB82     MOV #0xFFB8, W2
00B1C2  478082     ADD W15, W2, W1
00B1C4  78000A     MOV W10, W0
00B1C6  07E446     RCALL FileObjectCopy
10096:             	#endif
10097:             
10098:                	if(i == 0)
00B1C8  E0000C     CP0 W12
00B1CA  3A000D     BRA NZ, 0xB1E6
00B1CC  78010B     MOV W11, W2
00B1CE  4500FC     ADD W10, #0x1C, W1
00B1D0  78000C     MOV W12, W0
10099:             
10100:             	{
10101:                	    for (j = 0; j < 11; j++)
00B1D4  E80000     INC W0, W0
00B1D6  500FEB     SUB W0, #0xB, [W15]
00B1D8  3AFFFC     BRA NZ, 0xB1D2
10102:                     	fo->name[j] = dirptr->DIR_Name[j];
00B1D2  7858B2     MOV.B [W2++], [W1++]
10103:             		#ifdef SUPPORT_LFN
10104:                			fo->utf16LFNlength = 0;
00B1DA  EB0000     CLR W0
00B1DC  981560     MOV W0, [W10+44]
00B1DE  370014     BRA 0xB208
10105:             
10106:                		#endif
10107:                	}
10108:             	#ifdef SUPPORT_LFN
10109:                	else
10110:             
10111:                	{
10112:             
10113:             		fo->utf16LFNlength = i;
00B1E6  98156C     MOV W12, [W10+44]
00B1E8  5600EC     SUB W12, #0xC, W1
00B1EA  46000C     ADD W12, W12, W0
00B1EC  468000     ADD W13, W0, W0
00B1EE  50007A     SUB W0, #0x1A, W0
00B1F0  2000C2     MOV #0xC, W2
10114:             
10115:             		
10116:             
10117:             		for(j = 12;j >= 0;j--)
00B1F6  E90102     DEC W2, W2
00B1F8  E80081     INC W1, W1
00B1FA  E88000     INC2 W0, W0
00B1FC  410FE1     ADD W2, #0x1, [W15]
00B1FE  3AFFF9     BRA NZ, 0xB1F2
10118:             
10119:             		{
10120:             
10121:             			if((tempLFN[i - j - 1]) == 0x0000)
00B1F2  E00010     CP0 [W0]
00B1F4  32FFF5     BRA Z, 0xB1E0
10122:             
10123:             			{
10124:             
10125:             				fo->utf16LFNlength = i - j - 1;
00B1E0  E90001     DEC W1, W0
00B1E2  981560     MOV W0, [W10+44]
00B1E4  37000D     BRA 0xB200
10126:             
10127:             				break;
10128:             
10129:             			}
10130:             
10131:             		}
10132:             
10133:             		
10134:                		fo->utf16LFNptr = (unsigned short int *)&tempDirectoryString[0];
00B200  98155D     MOV W13, [W10+42]
00B202  EB0000     CLR W0
00B204  370001     BRA 0xB208
00B206  200FF0     MOV #0xFF, W0
10135:             
10136:                	}
10137:             
10138:             	#endif
10139:             
10140:                 return 0;
10141:             }
00B212  B0048F     ADD #0x48, W15
00B214  BE9F88     MOV.D W8, [W15++]
00B216  BE9F8A     MOV.D W10, [W15++]
00B218  BE9F8C     MOV.D W12, [W15++]
00B21A  781F8E     MOV W14, [W15++]
00B21C  780701     MOV W1, W14
10142:             
10143:             
10144:             /**************************************************************************
10145:               Function:
10146:                 int FSmkdir (char * path)
10147:               Summary:
10148:                 Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC)
10149:               Conditions:
10150:                 None
10151:               Input:
10152:                 path - The path of directories to create.
10153:               Return Values:
10154:                 0 -   The specified directory was created successfully
10155:                 EOF - The specified directory could not be created
10156:               Side Effects:
10157:                 Will create all non-existent directories in the path. The FSerrno 
10158:                 variable will be changed.
10159:               Description:
10160:                 Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC).
10161:                 This function doesn't move the current working directory setting.
10162:               Remarks:
10163:                 None                                            
10164:               **************************************************************************/
10165:             
10166:             #ifdef ALLOW_WRITES
10167:             int FSmkdir (char * path)
10168:             {
10169:                 return mkdirhelper (0, path, NULL);
00B9B4  EB0100     CLR W2
00B9B6  EB4000     CLR.B W0
00B9B8  37FE82     BRA mkdirhelper
10170:             }
00B9BA  B0246F     ADD #0x246, W15
00B9BC  BE9F88     MOV.D W8, [W15++]
00B9BE  BE9F8A     MOV.D W10, [W15++]
00B9C0  BE9F8C     MOV.D W12, [W15++]
00B9C2  781F8E     MOV W14, [W15++]
00B9C4  780401     MOV W1, W8
00B9C6  784503     MOV.B W3, W10
10171:             
10172:             /**************************************************************************
10173:               Function:
10174:                 int wFSmkdir (unsigned short int * path)
10175:               Summary:
10176:                 Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC)
10177:               Conditions:
10178:                 None
10179:               Input:
10180:                 path - The path of directories to create.
10181:               Return Values:
10182:                 0 -   The specified directory was created successfully
10183:                 EOF - The specified directory could not be created
10184:               Side Effects:
10185:                 Will create all non-existent directories in the path. The FSerrno 
10186:                 variable will be changed.
10187:               Description:
10188:                 Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC).
10189:                 This function doesn't move the current working directory setting.
10190:               Remarks:
10191:                 None                                            
10192:               **************************************************************************/
10193:             #ifdef SUPPORT_LFN
10194:             int wFSmkdir (unsigned short int * path)
10195:             {
10196:             	int	result;
10197:             	utfModeFileName = TRUE;
00B9A2  200010     MOV #0x1, W0
00B9A4  8B85A0     MOV W0, utfModeFileName
10198:                 result = mkdirhelper (0, (char *)path, NULL);
00B9A6  EB0100     CLR W2
00B9A8  EB4000     CLR.B W0
00B9AA  07FE89     RCALL mkdirhelper
10199:             	utfModeFileName = FALSE;
00B9AC  EB0080     CLR W1
00B9AE  8B85A1     MOV W1, utfModeFileName
10200:                 return result;
10201:             }
00B9B2  780080     MOV W0, W1
10202:             #endif
10203:             
10204:             /**************************************************************************
10205:               Function:
10206:                 int FSmkdirpgm (const rom char * path)
10207:               Summary:
10208:                 Creates a directory as per the path mentioned in the input string on 
10209:                 PIC18 devices.
10210:               Conditions:
10211:                 None
10212:               Input:
10213:                 path - The path of directories to create (ROM)
10214:               Return Values:
10215:                 0 -   The specified directory was created successfully
10216:                 EOF - The specified directory could not be created
10217:               Side Effects:
10218:                 Will create all non-existent directories in the path. The FSerrno 
10219:                 variable will be changed.
10220:               Description:
10221:                 Creates a directory as per the path mentioned in the input string on 
10222:                 PIC18 devices.'FSmkdirpgm' creates the directories as per the input
10223:                 string path.This function doesn't move the current working
10224:                 directory setting.
10225:               Remarks:
10226:                 This function is for use with PIC18 when passing arugments in ROM
10227:               **************************************************************************/
10228:             
10229:             #ifdef ALLOW_PGMFUNCTIONS
10230:             int FSmkdirpgm (const rom char * path)
10231:             {
10232:                 return mkdirhelper (1, NULL, path);
10233:             }
10234:             
10235:             /**************************************************************************
10236:               Function:
10237:                 int wFSmkdirpgm (const rom unsigned short int * path)
10238:               Summary:
10239:                 Create a directory with a path in ROM on PIC18
10240:               Conditions:
10241:                 None
10242:               Input:
10243:                 path - The path of directories to create (ROM)
10244:               Return Values:
10245:                 0 -   The specified directory was created successfully
10246:                 EOF - The specified directory could not be created
10247:               Side Effects:
10248:                 Will create all non-existent directories in the path. The FSerrno
10249:                 variable will be changed.
10250:               Description:
10251:                 The FSmkdirpgm function passes a PIC18 ROM path pointer to the
10252:                 mkdirhelper function.
10253:               Remarks:
10254:                 This function is for use with PIC18 when passing arugments in ROM
10255:               **************************************************************************/
10256:             #ifdef SUPPORT_LFN
10257:             int wFSmkdirpgm (const rom unsigned short int * path)
10258:             {
10259:             	int result;
10260:             	utfModeFileName = TRUE;
10261:                 result = mkdirhelper (1, NULL, (const char *)path);
10262:             	utfModeFileName = FALSE;
10263:                 return result;
10264:             }
10265:             #endif
10266:             
10267:             #endif
10268:             
10269:             /*************************************************************************
10270:               Function:
10271:                 // PIC24/30/33/32
10272:                 int mkdirhelper (BYTE mode, char * ramptr, char * romptr)
10273:                 // PIC18
10274:                 int mkdirhelper (BYTE mode, char * ramptr, const rom char * romptr)
10275:               Summary:
10276:                 Helper function for FSmkdir
10277:               Conditions:
10278:                 None
10279:               Input:
10280:                 mode -   Indicates which path pointer to use
10281:                 ramptr - Pointer to the path specified in RAM
10282:                 romptr - Pointer to the path specified in ROM
10283:               Return Values:
10284:                 0 -  Directory was created
10285:                 -1 - Directory could not be created
10286:               Side Effects:
10287:                 Will create all non-existant directories in the path.
10288:                 The FSerrno variable will be changed.
10289:               Description:
10290:                 This helper function is used by the FSchdir function. If the path
10291:                 argument is specified in ROM for PIC18 this function will be able
10292:                 to parse it correctly.  This function will first scan through the path
10293:                 to ensure that any DIR names don't exceed 11 characters.  It will then
10294:                 backup the current working directory and begin changing directories
10295:                 through the path until it reaches a directory than can't be changed to.
10296:                 It will then create the specified directory and change directories to
10297:                 the new directory. The function will continue creating and changing to
10298:                 directories until the end of the path is reached.  The function will
10299:                 then restore the original current working directory.
10300:               Remarks:
10301:                 None
10302:               **************************************************************************/
10303:             
10304:             #ifdef ALLOW_PGMFUNCTIONS
10305:             int mkdirhelper (BYTE mode, char * ramptr, const rom char * romptr)
10306:             #else
10307:             int mkdirhelper (BYTE mode, char * ramptr, char * romptr)
10308:             #endif
10309:             {
10310:                 unsigned short int i,j = 0,k = 0;
10311:                 char * temppath = ramptr;
10312:             #ifdef ALLOW_PGMFUNCTIONS
10313:                 rom char * temppath2 = romptr;
10314:                 rom unsigned short int * utf16path2 = (rom unsigned short int *)romptr;
10315:             #endif
10316:             	unsigned short int *utf16path = (unsigned short int *)ramptr;
10317:                 FILEOBJ tempCWD = &tempCWDobj;
10318:             
10319:             #ifdef __18CXX
10320:                 char dotdotPath[] = "..";
10321:                 char dotdotPath1[5] = {'.','\0','.','\0','\0'};
10322:             #endif
10323:             
10324:             // Do Dynamic allocation if the macro is defined or
10325:             // go with static allocation
10326:             #if defined(SUPPORT_LFN)
10327:             	char tempArray[514];
10328:             #else
10329:             	char tempArray[14];
10330:             #endif
10331:             
10332:                 FSerrno = CE_GOOD;
00B6C6  249388     MOV #0x4938, W8
00B6C8  EB4C00     CLR.B [W8]
10333:             
10334:                 if (MDD_WriteProtectState())
00B6CA  071021     RCALL MDD_SDSPI_WriteProtectState
00B6CC  E00400     CP0.B W0
00B6CE  320002     BRA Z, 0xB6D4
10335:                 {
10336:                     FSerrno = CE_WRITE_PROTECTED;
00B6D0  B3C180     MOV #0x18, W0
00B6D2  370025     BRA 0xB71E
10337:                     return (-1);
10338:                 }
10339:             
10340:             #ifdef ALLOW_PGMFUNCTIONS
10341:                 if (mode == 1)
10342:                 {
10343:             		#ifdef SUPPORT_LFN
10344:             		if(utfModeFileName)
10345:             		{
10346:             	        // Scan for too-long file names
10347:             	        while (1)
10348:             	        {
10349:             	            i = 0;
10350:             	            while((*utf16path2 != 0) && (*utf16path2 != '.')&& (*utf16path2 != '\\'))
10351:             	            {
10352:             	                utf16path2++;
10353:             	                i++;
10354:             	            }
10355:             
10356:             		        if (i > 256)
10357:             		        {
10358:             		            FSerrno = CE_INVALID_ARGUMENT;
10359:             		            return -1;
10360:             		        }
10361:             
10362:             	            j = 0;
10363:             	            if (*utf16path2 == '.')
10364:             	            {
10365:             	                utf16path2++;
10366:             	                while ((*utf16path2 != 0) && (*utf16path2 != '\\'))
10367:             	                {
10368:             	                    utf16path2++;
10369:             	                    j++;
10370:             	                }
10371:             		    	    if ((i + j) > 256)
10372:             		    	    {
10373:             		    	        FSerrno = CE_INVALID_ARGUMENT;
10374:             		    	        return -1;
10375:             		    	    }
10376:             	            }
10377:             
10378:             				if((i + j) > k)
10379:             				{
10380:             					k = (i + j);
10381:             				}
10382:             
10383:             	            while (*utf16path2 == '\\')
10384:             	                utf16path2++;
10385:             	            if (*utf16path2 == 0)
10386:             	                break;
10387:             	        }
10388:                 	}
10389:             		else
10390:             		#endif
10391:             		{
10392:             	        // Scan for too-long file names
10393:             	        while (1)
10394:             	        {
10395:             	            i = 0;
10396:             	            while((*temppath2 != 0) && (*temppath2 != '.')&& (*temppath2 != '\\'))
10397:             	            {
10398:             	                temppath2++;
10399:             	                i++;
10400:             	            }
10401:             
10402:             				#if defined(SUPPORT_LFN)
10403:             		            if (i > 256)
10404:             		            {
10405:             		                FSerrno = CE_INVALID_ARGUMENT;
10406:             		                return -1;
10407:             		            }
10408:             				#else
10409:             		            if (i > 8)
10410:             		            {
10411:             		                FSerrno = CE_INVALID_ARGUMENT;
10412:             		                return -1;
10413:             		            }
10414:             				#endif
10415:             
10416:             	            j = 0;
10417:             	            if (*temppath2 == '.')
10418:             	            {
10419:             	                temppath2++;
10420:             	                while ((*temppath2 != 0) && (*temppath2 != '\\'))
10421:             	                {
10422:             	                    temppath2++;
10423:             	                    j++;
10424:             	                }
10425:             					#if defined(SUPPORT_LFN)
10426:             		    	        if ((i + j) > 256)
10427:             		    	        {
10428:             		    	            FSerrno = CE_INVALID_ARGUMENT;
10429:             		    	            return -1;
10430:             		    	        }
10431:             					#else
10432:             		    	        if (j > 3)
10433:             		    	        {
10434:             		    	            FSerrno = CE_INVALID_ARGUMENT;
10435:             		    	            return -1;
10436:             		    	        }
10437:             					#endif
10438:             	            }
10439:             
10440:             				if((i + j) > k)
10441:             				{
10442:             					k = (i + j);
10443:             				}
10444:             
10445:             	            while (*temppath2 == '\\')
10446:             	                temppath2++;
10447:             	            if (*temppath2 == 0)
10448:             	                break;
10449:             	        }
10450:                 	}
10451:                 }
10452:                 else
10453:             #endif
10454:             	{
10455:             		#ifdef SUPPORT_LFN
10456:             		if(utfModeFileName)
00B6D4  8385A0     MOV utfModeFileName, W0
00B6D6  E00000     CP0 W0
00B6D8  32002C     BRA Z, 0xB732
10457:             		{
10458:             			utf16path = (unsigned short int *)ramptr;
00B6DA  780109     MOV W9, W2
00B6DC  2002E7     MOV #0x2E, W7
00B6DE  2005C6     MOV #0x5C, W6
00B6E0  201005     MOV #0x100, W5
00B6E2  EB0180     CLR W3
00B6E4  370002     BRA 0xB6EA
10459:             	        // Scan for too-long file names
10460:             	        while (1)
10461:             	        {
10462:             	            i = 0;
10463:             	            while((*utf16path != 0) && (*utf16path != '.')&& (*utf16path != '\\'))
00B6EA  780092     MOV [W2], W1
00B6EC  E00001     CP0 W1
00B6EE  320004     BRA Z, 0xB6F8
00B6F0  508F87     SUB W1, W7, [W15]
00B6F2  320002     BRA Z, 0xB6F8
00B6F4  508F86     SUB W1, W6, [W15]
00B6F6  3AFFF7     BRA NZ, 0xB6E6
10464:             	            {
10465:             	                utf16path++;
00B6E6  E88102     INC2 W2, W2
10466:             	                i++;
00B6E8  E80183     INC W3, W3
10467:             	            }
10468:             		        if (i > 256)
00B6F8  518F85     SUB W3, W5, [W15]
00B6FA  3E00FA     BRA GTU, 0xB8F0
10469:             		        {
10470:             		            FSerrno = CE_INVALID_ARGUMENT;
10471:             		            return -1;
10472:             		        }
10473:             
10474:             	            j = 0;
10475:             	            if (*utf16path == '.')
00B6FC  508F87     SUB W1, W7, [W15]
00B6FE  3A0013     BRA NZ, 0xB726
10476:             	            {
10477:             	                utf16path++;
00B700  E88102     INC2 W2, W2
00B702  EB0000     CLR W0
00B704  2005C4     MOV #0x5C, W4
00B706  370002     BRA 0xB70C
10478:             	                while ((*utf16path != 0) && (*utf16path != '\\'))
00B70C  780092     MOV [W2], W1
00B70E  E00001     CP0 W1
00B710  320002     BRA Z, 0xB716
00B712  508F84     SUB W1, W4, [W15]
00B714  3AFFF9     BRA NZ, 0xB708
10479:             	                {
10480:             	                    utf16path++;
00B708  E88102     INC2 W2, W2
10481:             	                    j++;
00B70A  E80000     INC W0, W0
10482:             	                }
10483:             		    	    if ((i + j) > 256)
00B716  418000     ADD W3, W0, W0
00B718  500F85     SUB W0, W5, [W15]
00B71A  360005     BRA LEU, 0xB726
10484:             		    	    {
10485:             		    	        FSerrno = CE_INVALID_ARGUMENT;
00B71C  B3C1F0     MOV #0x1F, W0
00B71E  784C00     MOV.B W0, [W8]
00B720  EB8000     SETM W0
00B722  37013A     BRA 0xB998
10486:             		    	        return -1;
10487:             		    	    }
10488:             	            }
10489:             
10490:             				if((i + j) > k)
10491:             				{
10492:             					k = (i + j);
10493:             				}
10494:             
10495:             	            while (*utf16path == '\\')
00B726  780012     MOV [W2], W0
00B728  500F86     SUB W0, W6, [W15]
00B72A  32FFFC     BRA Z, 0xB724
10496:             	                utf16path++;
00B724  E88102     INC2 W2, W2
10497:             	            if (*utf16path == 0)
00B72C  E00000     CP0 W0
00B72E  320029     BRA Z, 0xB782
00B730  37FFD8     BRA 0xB6E2
00B732  780109     MOV W9, W2
00B734  B3C2E7     MOV #0x2E, W7
00B736  B3C5C6     MOV #0x5C, W6
00B738  201005     MOV #0x100, W5
00B73A  EB0180     CLR W3
00B73C  370002     BRA 0xB742
10498:             	                break;
10499:             	        }
10500:             		}
10501:             		else
10502:             		#endif
10503:             		{
10504:             	        // Scan for too-long file names
10505:             	        while (1)
10506:             	        {
10507:             	            i = 0;
10508:             	            while((*temppath != 0) && (*temppath != '.')&& (*temppath != '\\'))
00B742  784092     MOV.B [W2], W1
00B744  E00401     CP0.B W1
00B746  320004     BRA Z, 0xB750
00B748  50CF87     SUB.B W1, W7, [W15]
00B74A  320002     BRA Z, 0xB750
00B74C  50CF86     SUB.B W1, W6, [W15]
00B74E  3AFFF7     BRA NZ, 0xB73E
10509:             	            {
10510:             	                temppath++;
00B73E  E80102     INC W2, W2
10511:             	                i++;
00B740  E80183     INC W3, W3
10512:             	            }
10513:             				#if defined(SUPPORT_LFN)
10514:             		            if (i > 256)
00B750  518F85     SUB W3, W5, [W15]
00B752  3E00CE     BRA GTU, 0xB8F0
10515:             		            {
10516:             		                FSerrno = CE_INVALID_ARGUMENT;
10517:             		                return -1;
10518:             		            }
10519:             				#else
10520:             		            if (i > 8)
10521:             		            {
10522:             		                FSerrno = CE_INVALID_ARGUMENT;
10523:             		                return -1;
10524:             		            }
10525:             				#endif
10526:             
10527:             	            j = 0;
10528:             	            if (*temppath == '.')
00B754  50CF87     SUB.B W1, W7, [W15]
00B756  3A0010     BRA NZ, 0xB778
10529:             	            {
10530:             	                temppath++;
00B758  E80102     INC W2, W2
00B75A  EB0000     CLR W0
00B75C  B3C5C4     MOV #0x5C, W4
00B75E  370002     BRA 0xB764
10531:             	                while ((*temppath != 0) && (*temppath != '\\'))
00B764  784092     MOV.B [W2], W1
00B766  E00401     CP0.B W1
00B768  320002     BRA Z, 0xB76E
00B76A  50CF84     SUB.B W1, W4, [W15]
00B76C  3AFFF9     BRA NZ, 0xB760
10532:             	                {
10533:             	                    temppath++;
00B760  E80102     INC W2, W2
10534:             	                    j++;
00B762  E80000     INC W0, W0
10535:             	                }
10536:             					#if defined(SUPPORT_LFN)
10537:             		    	        if ((i + j) > 256)
00B76E  418000     ADD W3, W0, W0
00B770  500F85     SUB W0, W5, [W15]
00B772  360002     BRA LEU, 0xB778
00B774  3700BD     BRA 0xB8F0
10538:             		    	        {
10539:             		    	            FSerrno = CE_INVALID_ARGUMENT;
10540:             		    	            return -1;
10541:             		    	        }
10542:             					#else
10543:             		    	        if (j > 3)
10544:             		    	        {
10545:             		    	            FSerrno = CE_INVALID_ARGUMENT;
10546:             		    	            return -1;
10547:             		    	        }
10548:             					#endif
10549:             	            }
10550:             
10551:             				if((i + j) > k)
10552:             				{
10553:             					k = (i + j);
10554:             				}
10555:             
10556:             	            while (*temppath == '\\')
00B778  784012     MOV.B [W2], W0
00B77A  504F86     SUB.B W0, W6, [W15]
00B77C  32FFFC     BRA Z, 0xB776
10557:             	                temppath++;
00B776  E80102     INC W2, W2
10558:             	            if (*temppath == 0)
00B77E  E00400     CP0.B W0
00B780  3AFFDC     BRA NZ, 0xB73A
10559:             	                break;
10560:             	        }
10561:             		}
10562:             	}
10563:             
10564:             	utf16path = (unsigned short int *)ramptr;
10565:                 temppath = ramptr;
10566:             #ifdef ALLOW_PGMFUNCTIONS
10567:             	utf16path2 = (rom unsigned short int *)romptr;
10568:                 temppath2 = romptr;
10569:             #endif
10570:             
10571:                 // We're going to be moving the CWD
10572:                 // Back up the CWD
10573:                 FileObjectCopy (tempCWD, cwdptr);
00B782  8385B1     MOV cwdptr, W1
00B784  248F60     MOV #0x48F6, W0
00B786  07E166     RCALL FileObjectCopy
00B788  780509     MOV W9, W10
10574:             
10575:                 // get to the target directory
10576:                 while (1)
10577:                 {
10578:             #ifdef ALLOW_PGMFUNCTIONS
10579:                     if (mode == 1)
10580:                     {
10581:             			#ifdef SUPPORT_LFN
10582:             			if(utfModeFileName)
10583:                         	i = *utf16path2;
10584:             			else
10585:             			#endif
10586:                         	i = *temppath2;
10587:             		}
10588:                     else
10589:             #endif
10590:             		{
10591:             			#ifdef SUPPORT_LFN
10592:             			if(utfModeFileName)
00B78A  8385A4     MOV utfModeFileName, W4
00B78C  E00004     CP0 W4
00B78E  320002     BRA Z, 0xB794
10593:                         	i = *utf16path;
00B790  780099     MOV [W9], W1
00B792  370001     BRA 0xB796
10594:             			else
10595:             			#endif
10596:                         	i = *temppath;
00B794  FB009A     SE [W10], W1
10597:             		}
10598:             
10599:                     if (i == '.')
00B796  2002E0     MOV #0x2E, W0
00B798  508F80     SUB W1, W0, [W15]
00B79A  3A0032     BRA NZ, 0xB800
10600:                     {
10601:             #ifdef ALLOW_PGMFUNCTIONS
10602:                         if (mode == 1)
10603:                         {
10604:             				#ifdef SUPPORT_LFN
10605:             				if(utfModeFileName)
10606:             				{
10607:                         	    utf16path2++;
10608:                         	    i = *utf16path2;
10609:             				}
10610:             				else
10611:             				#endif
10612:                     	    {
10613:                         	    temppath2++;
10614:                         	    i = *temppath2;
10615:             				}
10616:                         }
10617:                         else
10618:                         {
10619:             #endif
10620:             				#ifdef SUPPORT_LFN
10621:             				if(utfModeFileName)
00B79C  E00004     CP0 W4
00B79E  320002     BRA Z, 0xB7A4
10622:             				{
10623:                         	    utf16path++;
10624:                         	    i = *utf16path;
00B7A0  780459     MOV [++W9], W8
00B7A2  370001     BRA 0xB7A6
10625:             				}
10626:             				else
10627:             				#endif
10628:                     	    {
10629:                         	    temppath++;
10630:                         	    i = *temppath;
00B7A4  FB045A     SE [++W10], W8
10631:             				}
10632:             #ifdef ALLOW_PGMFUNCTIONS
10633:                         }
10634:             #endif
10635:             
10636:                         if ((i != '.') && (i != 0) && (i != '\\'))
00B7A6  2002E0     MOV #0x2E, W0
00B7A8  540F80     SUB W8, W0, [W15]
00B7AA  320006     BRA Z, 0xB7B8
00B7AC  E00008     CP0 W8
00B7AE  320022     BRA Z, 0xB7F4
00B7B0  2005C0     MOV #0x5C, W0
00B7B2  540F80     SUB W8, W0, [W15]
00B7B4  320019     BRA Z, 0xB7E8
00B7B6  37009C     BRA 0xB8F0
10637:                         {
10638:                             FSerrno = CE_INVALID_ARGUMENT;
10639:                             return -1;
10640:                         }
10641:             
10642:                         if (i == '.')
10643:                         {
10644:                             if (cwdptr->dirclus ==  FatRootDirClusterValue)
00B7B8  8385B0     MOV cwdptr, W0
00B7BA  901920     MOV [W0+52], W2
00B7BC  9019B0     MOV [W0+54], W3
00B7BE  8249D0     MOV FatRootDirClusterValue, W0
00B7C0  8249E1     MOV 0x493C, W1
00B7C2  510F80     SUB W2, W0, [W15]
00B7C4  598F81     SUBB W3, W1, [W15]
00B7C6  320094     BRA Z, 0xB8F0
10645:                             {
10646:                                 // If we try to change to the .. from the
10647:                                 // root, operation fails
10648:                                 FSerrno = CE_INVALID_ARGUMENT;
10649:                                 return -1;
10650:                             }
10651:             #ifdef ALLOW_PGMFUNCTIONS
10652:                             if (mode == 1)
10653:                             {
10654:             					#ifdef SUPPORT_LFN
10655:             					if(utfModeFileName)
10656:             					{
10657:                         		    utf16path2++;
10658:                         		    i = *utf16path2;
10659:             					}
10660:             					else
10661:             					#endif
10662:                     		    {
10663:                         		    temppath2++;
10664:                         		    i = *temppath2;
10665:             					}
10666:                             }
10667:                             else
10668:             #endif
10669:                             {
10670:             					#ifdef SUPPORT_LFN
10671:             					if(utfModeFileName)
00B7C8  E00004     CP0 W4
00B7CA  320002     BRA Z, 0xB7D0
10672:             					{
10673:                         		    utf16path++;
10674:                         		    i = *utf16path;
00B7CC  780459     MOV [++W9], W8
00B7CE  370001     BRA 0xB7D2
10675:             					}
10676:             					else
10677:             					#endif
10678:                     		    {
10679:                         		    temppath++;
10680:                         		    i = *temppath;
00B7D0  FB045A     SE [++W10], W8
10681:             					}
10682:             				}
10683:             
10684:                             if ((i != '\\') && (i != 0))
00B7D2  2005C0     MOV #0x5C, W0
00B7D4  540F80     SUB W8, W0, [W15]
00B7D6  320002     BRA Z, 0xB7DC
00B7D8  E00008     CP0 W8
00B7DA  3A008A     BRA NZ, 0xB8F0
10685:                             {
10686:                                 FSerrno = CE_INVALID_ARGUMENT;
10687:                                 return -1;
10688:                             }
10689:             // dotdot entry
10690:             #ifndef __18CXX
10691:             			#ifdef SUPPORT_LFN
10692:             			if(utfModeFileName)
00B7DE  E00004     CP0 W4
00B7E0  3A0001     BRA NZ, 0xB7E4
10693:                             FSchdir (".\0.\0\0");
00B7DC  2EE6A0     MOV #0xEE6A, W0
10694:             			#endif
10695:             			else
10696:                             FSchdir ("..");
00B7E2  2EE700     MOV #0xEE70, W0
00B7E4  07FC0B     RCALL FSchdir
00B7E6  370006     BRA 0xB7F4
10697:             #else
10698:             			#ifdef SUPPORT_LFN
10699:             			if(utfModeFileName)
10700:                             FSchdir (dotdotPath1);
10701:             			else
10702:             			#endif
10703:                             FSchdir (dotdotPath);
10704:             #endif
10705:                         }
10706:                         // Skip past any backslashes
10707:                         while (i == '\\')
00B7F4  2005C0     MOV #0x5C, W0
00B7F6  540F80     SUB W8, W0, [W15]
00B7F8  32FFF7     BRA Z, 0xB7E8
10708:                         {
10709:             #ifdef ALLOW_PGMFUNCTIONS
10710:                             if (mode == 1)
10711:                             {
10712:             					#ifdef SUPPORT_LFN
10713:             					if(utfModeFileName)
10714:             					{
10715:                         		    utf16path2++;
10716:                         		    i = *utf16path2;
10717:             					}
10718:             					else
10719:             					#endif
10720:                     		    {
10721:                         		    temppath2++;
10722:                         		    i = *temppath2;
10723:             					}
10724:                             }
10725:                             else
10726:                             {
10727:             #endif
10728:             					#ifdef SUPPORT_LFN
10729:             					if(utfModeFileName)
00B7E8  8385A0     MOV utfModeFileName, W0
00B7EA  E00000     CP0 W0
00B7EC  320002     BRA Z, 0xB7F2
10730:             					{
10731:                         		    utf16path++;
10732:                         		    i = *utf16path;
00B7EE  780459     MOV [++W9], W8
00B7F0  370001     BRA 0xB7F4
10733:             					}
10734:             					else
10735:             					#endif
10736:                     		    {
10737:                         		    temppath++;
10738:                         		    i = *temppath;
00B7F2  FB045A     SE [++W10], W8
10739:             					}
10740:             #ifdef ALLOW_PGMFUNCTIONS
10741:                             }
10742:             #endif
10743:                         }
10744:                         if (i == 0)
00B7FA  E00008     CP0 W8
00B7FC  3AFFC6     BRA NZ, 0xB78A
00B7FE  370075     BRA 0xB8EA
10745:                         {
10746:                             // No point in creating a dot or dotdot entry directly
10747:                             FileObjectCopy (cwdptr, tempCWD);
10748:                             FSerrno = CE_INVALID_ARGUMENT;
10749:                             return -1;
10750:                         }
10751:                     }
10752:                     else
10753:                     {
10754:                         if (i == '\\')
00B800  2005C0     MOV #0x5C, W0
00B802  508F80     SUB W1, W0, [W15]
00B804  3A0027     BRA NZ, 0xB854
10755:                         {
10756:                             // Start at the root
10757:                             cwdptr->dirclus = FatRootDirClusterValue;
00B806  8385B0     MOV cwdptr, W0
00B808  8249D2     MOV FatRootDirClusterValue, W2
00B80A  8249E3     MOV 0x493C, W3
00B80C  981822     MOV W2, [W0+52]
00B80E  981833     MOV W3, [W0+54]
10758:                             cwdptr->dirccls = FatRootDirClusterValue;
00B810  8249D4     MOV FatRootDirClusterValue, W4
00B812  8249E5     MOV 0x493C, W5
00B814  981844     MOV W4, [W0+56]
00B816  981855     MOV W5, [W0+58]
10759:                             i = 0;
10760:                             cwdptr->name[i++] = '\\';
00B818  985841     MOV.B W1, [W0+28]
00B81A  200012     MOV #0x1, W2
00B81C  B3C203     MOV #0x20, W3
10761:             //                if(utfModeFileName)
10762:             //				{
10763:             //                	cwdptr->name[i++] = 0x00;
10764:             //				}
10765:                             for (; i < 11; i++)
00B824  E80102     INC W2, W2
00B826  510FEB     SUB W2, #0xB, [W15]
00B828  3AFFFA     BRA NZ, 0xB81E
10766:                             {
10767:                                 cwdptr->name[i] = 0x20;
00B81E  4100FC     ADD W2, #0x1C, W1
00B820  8385B0     MOV cwdptr, W0
00B822  78F003     MOV.B W3, [W0+W1]
10768:                             }
10769:             
10770:             #ifdef ALLOW_PGMFUNCTIONS
10771:                             if (mode == 1)
10772:                             {
10773:             					#ifdef SUPPORT_LFN
10774:             					if(utfModeFileName)
10775:             					{
10776:                         		    utf16path2++;
10777:                         		    i = *utf16path2;
10778:             					}
10779:             					else
10780:             					#endif
10781:                     		    {
10782:                         		    temppath2++;
10783:                         		    i = *temppath2;
10784:             					}
10785:                             }
10786:                             else
10787:                             {
10788:             #endif
10789:             					#ifdef SUPPORT_LFN
10790:             					if(utfModeFileName)
00B82A  8385A0     MOV utfModeFileName, W0
00B82C  E00000     CP0 W0
00B82E  320002     BRA Z, 0xB834
10791:             					{
10792:                         		    utf16path++;
10793:                         		    i = *utf16path;
00B830  7800D9     MOV [++W9], W1
00B832  370001     BRA 0xB836
10794:             					}
10795:             					else
10796:             					#endif
10797:                     		    {
10798:                         		    temppath++;
10799:                         		    i = *temppath;
00B834  FB00DA     SE [++W10], W1
10800:             					}
10801:             #ifdef ALLOW_PGMFUNCTIONS
10802:                             }
10803:             #endif
10804:                             // If we just got two backslashes in a row at the
10805:                             // beginning of the path, the function fails
10806:                             if ((i == '\\') || (i == 0))
00B836  2005C0     MOV #0x5C, W0
00B838  508F80     SUB W1, W0, [W15]
00B83A  320057     BRA Z, 0xB8EA
00B83C  E00001     CP0 W1
00B83E  3AFFA5     BRA NZ, 0xB78A
00B840  370054     BRA 0xB8EA
10807:                             {
10808:                                 FileObjectCopy (cwdptr, tempCWD);
10809:                                 FSerrno = CE_INVALID_ARGUMENT;
10810:                                 return -1;
10811:                             }
10812:                         }
10813:                         else
10814:                         {
10815:                             break;
10816:                         }
10817:                     }
10818:                 }
10819:             
10820:                 while (1)
10821:                 {
10822:                     while(1)
10823:                     {
10824:             #ifdef ALLOW_PGMFUNCTIONS
10825:                         if (mode == 1)
10826:                         {
10827:             				#ifdef SUPPORT_LFN
10828:             				if(utfModeFileName)
10829:             				{
10830:                         	    // Change directories as specified
10831:                         	    i = *utf16path2;
10832:                         	    j = 0;
10833:             
10834:             					k = 512;
10835:             
10836:                         	    // Parse the next token
10837:                         	    while ((i != 0) && (i != '\\') && (j < k))
10838:                         	    {
10839:                         	        tempArray[j++] = i;
10840:                         	        tempArray[j++] = i >> 8;
10841:                         	        utf16path2++;
10842:                         	        i = *utf16path2;
10843:                         	    }
10844:             				}
10845:             				else
10846:             				#endif
10847:                     		{
10848:                         	    // Change directories as specified
10849:                         	    i = *temppath2;
10850:                         	    j = 0;
10851:             
10852:             					#if defined(SUPPORT_LFN)
10853:             						k = 256;
10854:             					#else
10855:             						k = 12;
10856:             					#endif
10857:             
10858:                         	    // Parse the next token
10859:                         	    while ((i != 0) && (i != '\\') && (j < k))
10860:                         	    {
10861:                         	        tempArray[j++] = i;
10862:                         	        temppath2++;
10863:                         	        i = *temppath2;
10864:                         	    }
10865:             				}
10866:                         }
10867:                         else
10868:                         {
10869:             #endif
10870:             				#ifdef SUPPORT_LFN
10871:             				if(utfModeFileName)
00B854  8385A0     MOV utfModeFileName, W0
00B856  E00000     CP0 W0
00B858  320016     BRA Z, 0xB886
10872:             				{
10873:                         	    // Change directories as specified
10874:                         	    i = *utf16path;
00B85A  780419     MOV [W9], W8
00B85C  EB0080     CLR W1
00B85E  2FDF95     MOV #0xFDF9, W5
00B860  478105     ADD W15, W5, W2
00B862  2005C4     MOV #0x5C, W4
00B864  202003     MOV #0x200, W3
00B866  370008     BRA 0xB878
10875:                         	    j = 0;
10876:             
10877:             					k = 512;
10878:             
10879:                         	    // Parse the next token
10880:                         	    while ((i != 0) && (i != '\\') && (j < k))
00B878  E00008     CP0 W8
00B87A  320015     BRA Z, 0xB8A6
00B87C  540F84     SUB W8, W4, [W15]
00B87E  320013     BRA Z, 0xB8A6
00B880  508F83     SUB W1, W3, [W15]
00B882  3AFFF2     BRA NZ, 0xB868
00B884  370010     BRA 0xB8A6
10881:                         	    {
10882:                         	        tempArray[j++] = i;
00B868  2FDF80     MOV #0xFDF8, W0
00B86A  400001     ADD W0, W1, W0
00B86C  7FF008     MOV.B W8, [W0+W15]
10883:                         	        tempArray[j++] = i >> 8;
00B86E  DE4048     LSR W8, #8, W0
00B870  784900     MOV.B W0, [W2]
00B872  E88081     INC2 W1, W1
10884:                         	        utf16path++;
10885:                         	        i = *utf16path;
00B874  780459     MOV [++W9], W8
00B876  E88102     INC2 W2, W2
10886:                         	    }
10887:             				}
10888:             				else
10889:             				#endif
10890:                     		{
10891:                         	    // Change directories as specified
10892:                         	    i = *temppath;
00B886  FB041A     SE [W10], W8
00B888  2005C2     MOV #0x5C, W2
00B88A  201001     MOV #0x100, W1
00B88C  370005     BRA 0xB898
10893:                         	    j = 0;
10894:             
10895:             					#if defined(SUPPORT_LFN)
10896:             						k = 256;
10897:             					#else
10898:             						k = 12;
10899:             					#endif
10900:             
10901:                         	    // Parse the next token
10902:                         	    while ((i != 0) && (i != '\\') && (j < k))
00B898  E00008     CP0 W8
00B89A  320075     BRA Z, 0xB986
00B89C  540F82     SUB W8, W2, [W15]
00B89E  320073     BRA Z, 0xB986
00B8A0  500F81     SUB W0, W1, [W15]
00B8A2  3AFFF5     BRA NZ, 0xB88E
00B8A4  370070     BRA 0xB986
10903:                         	    {
10904:                         	        tempArray[j++] = i;
00B88E  2FDF83     MOV #0xFDF8, W3
00B890  418180     ADD W3, W0, W3
00B892  7FF188     MOV.B W8, [W3+W15]
00B894  E80000     INC W0, W0
10905:                         	        temppath++;
10906:                         	        i = *temppath;
00B896  FB045A     SE [++W10], W8
10907:                         	    }
10908:             				}
10909:             #ifdef ALLOW_PGMFUNCTIONS
10910:                         }
10911:             #endif
10912:             			#ifdef SUPPORT_LFN
10913:             			if(utfModeFileName)
10914:             			{
10915:                         	tempArray[j++] = 0;
00B8A6  2FDF85     MOV #0xFDF8, W5
00B8A8  42828F     ADD W5, W15, W5
00B8AA  428001     ADD W5, W1, W0
00B8AC  EB4800     CLR.B [W0]
10916:                         	tempArray[j] = 0;
00B8AE  E80001     INC W1, W0
00B8B0  428000     ADD W5, W0, W0
00B8B2  EB4800     CLR.B [W0]
10917:             
10918:                     	    if ((tempArray[0] == '.') && (tempArray[1] == 0))
00B8B4  B3C2E2     MOV #0x2E, W2
00B8B6  784015     MOV.B [W5], W0
00B8B8  504F82     SUB.B W0, W2, [W15]
00B8BA  3A0028     BRA NZ, 0xB90C
00B8BC  2FDF91     MOV #0xFDF9, W1
00B8BE  78C06F     MOV.B [W15+W1], W0
00B8C0  E00400     CP0.B W0
00B8C2  3A0024     BRA NZ, 0xB90C
10919:                     	    {
10920:                     	        if (((tempArray[2] != 0) || (tempArray[3] != 0)) && ((tempArray[2] != '.') || (tempArray[3] != 0)))
00B8C4  2FDFA3     MOV #0xFDFA, W3
00B8C6  79C0EF     MOV.B [W15+W3], W1
00B8C8  E00401     CP0.B W1
00B8CA  320002     BRA Z, 0xB8D0
00B8CC  50CF82     SUB.B W1, W2, [W15]
00B8CE  3A000D     BRA NZ, 0xB8EA
00B8D0  2FDFB4     MOV #0xFDFB, W4
00B8D2  7A406F     MOV.B [W15+W4], W0
00B8D4  E00400     CP0.B W0
00B8D6  3A0009     BRA NZ, 0xB8EA
10921:                     	        {
10922:                     	            FileObjectCopy (cwdptr, tempCWD);
10923:                     	            FSerrno = CE_INVALID_ARGUMENT;
10924:                     	            return -1;
10925:                     	        }
10926:                     	        if (((tempArray[2] == '.') && (tempArray[3] == 0)) && ((tempArray[4] != 0) || (tempArray[5] != 0)))
00B8D8  50CF82     SUB.B W1, W2, [W15]
00B8DA  3A0018     BRA NZ, 0xB90C
00B8DC  2FDFC5     MOV #0xFDFC, W5
00B8DE  7AC06F     MOV.B [W15+W5], W0
00B8E0  E00400     CP0.B W0
00B8E2  3A0003     BRA NZ, 0xB8EA
00B8E4  2FDFD1     MOV #0xFDFD, W1
00B8E6  78C06F     MOV.B [W15+W1], W0
00B8E8  37000F     BRA 0xB908
10927:                     	        {
10928:                     	            FileObjectCopy (cwdptr, tempCWD);
00B8EA  8385B0     MOV cwdptr, W0
00B8EC  248F61     MOV #0x48F6, W1
00B8EE  07E0B2     RCALL FileObjectCopy
10929:                     	            FSerrno = CE_INVALID_ARGUMENT;
00B8F0  B3C1F1     MOV #0x1F, W1
00B8F2  249380     MOV #0x4938, W0
00B8F4  784801     MOV.B W1, [W0]
00B8F6  37FF14     BRA 0xB720
10930:                     	            return -1;
10931:                     	        }
10932:                     	    }
10933:             			}
10934:             			else
10935:             			#endif
10936:             			{
10937:                         	tempArray[j] = 0;
00B986  2FDF84     MOV #0xFDF8, W4
00B988  42020F     ADD W4, W15, W4
00B98A  420000     ADD W4, W0, W0
00B98C  EB4800     CLR.B [W0]
10938:             
10939:                     	    if (tempArray[0] == '.')
00B98E  B3C2E1     MOV #0x2E, W1
00B990  784294     MOV.B [W4], W5
00B992  52CF81     SUB.B W5, W1, [W15]
00B994  3AFFBB     BRA NZ, 0xB90C
00B996  37FFB0     BRA 0xB8F8
10940:                     	    {
10941:                     	        if ((tempArray[1] != 0) && (tempArray[1] != '.'))
00B8F8  2FDF92     MOV #0xFDF9, W2
00B8FA  79406F     MOV.B [W15+W2], W0
00B8FC  E00400     CP0.B W0
00B8FE  320006     BRA Z, 0xB90C
00B900  504F81     SUB.B W0, W1, [W15]
00B902  3AFFF3     BRA NZ, 0xB8EA
10942:                     	        {
10943:                     	            FileObjectCopy (cwdptr, tempCWD);
10944:                     	            FSerrno = CE_INVALID_ARGUMENT;
10945:                     	            return -1;
10946:                     	        }
10947:                     	        if ((tempArray[1] == '.') && (tempArray[2] != 0))
00B904  2FDFA3     MOV #0xFDFA, W3
00B906  79C06F     MOV.B [W15+W3], W0
00B908  E00400     CP0.B W0
00B90A  3AFFEF     BRA NZ, 0xB8EA
10948:                     	        {
10949:                     	            FileObjectCopy (cwdptr, tempCWD);
10950:                     	            FSerrno = CE_INVALID_ARGUMENT;
10951:                     	            return -1;
10952:                     	        }
10953:                     	    }
10954:             			}
10955:             
10956:                         // Try to change to it
10957:                         // If you can't we need to create it
10958:                         if (FSchdir (tempArray))
00B90C  2FDF80     MOV #0xFDF8, W0
00B90E  40000F     ADD W0, W15, W0
00B910  07FB75     RCALL FSchdir
00B912  8385A1     MOV utfModeFileName, W1
00B914  2005C2     MOV #0x5C, W2
00B916  E00000     CP0 W0
00B918  320006     BRA Z, 0xB926
00B91A  370008     BRA 0xB92C
10959:             				break;
10960:                         else
10961:                         {
10962:                             // We changed into the directory
10963:                             while (i == '\\')
00B926  540F82     SUB W8, W2, [W15]
00B928  32FFF9     BRA Z, 0xB91C
00B92A  370026     BRA 0xB978
10964:                             {
10965:                                 // Next char is a backslash
10966:                                 // Move past it
10967:             #ifdef ALLOW_PGMFUNCTIONS
10968:                                 if (mode == 1)
10969:                                 {
10970:             						#ifdef SUPPORT_LFN
10971:             						if(utfModeFileName)
10972:             						{
10973:                         			    utf16path2++;
10974:                         			    i = *utf16path2;
10975:             						}
10976:             						else
10977:             						#endif
10978:                     			    {
10979:                         			    temppath2++;
10980:                         			    i = *temppath2;
10981:             						}
10982:                                 }
10983:                                 else
10984:                                 {
10985:             #endif
10986:             						#ifdef SUPPORT_LFN
10987:             						if(utfModeFileName)
00B91C  E00001     CP0 W1
00B91E  320002     BRA Z, 0xB924
10988:             						{
10989:                         			    utf16path++;
10990:                         			    i = *utf16path;
00B920  780459     MOV [++W9], W8
00B922  370001     BRA 0xB926
10991:             						}
10992:             						else
10993:             						#endif
10994:                     			    {
10995:                         			    temppath++;
10996:                         			    i = *temppath;
00B924  FB045A     SE [++W10], W8
10997:             						}
10998:             #ifdef ALLOW_PGMFUNCTIONS
10999:                                 }
11000:             #endif
11001:                             }
11002:                             // If it's the last one, return success
11003:                             if (i == 0)
11004:                             {
11005:                                 FileObjectCopy (cwdptr, tempCWD);
11006:                                 return 0;
11007:                             }
11008:                         }
11009:                     }
11010:             
11011:             		#ifdef SUPPORT_LFN
11012:             		if(utfModeFileName)
00B92C  E00001     CP0 W1
00B92E  32000A     BRA Z, 0xB944
11013:             		{
11014:             			unsigned short int *tempPtr1;
11015:             			unsigned short int *tempPtr2;
11016:             			k = 0;
11017:             			tempPtr1 = (unsigned short int *)&tempArray[0];
00B930  2FDF83     MOV #0xFDF8, W3
00B932  41818F     ADD W3, W15, W3
11018:             			tempPtr2 = (unsigned short int *)&tempDirectoryString[0];
00B934  2464A2     MOV #0x464A, W2
00B936  EB0080     CLR W1
11019:             
11020:             			for(;;)
11021:             			{
11022:             				tempPtr2[k] = tempPtr1[k];
00B938  798061     MOV [W1+W3], W0
00B93A  793080     MOV W0, [W1+W2]
00B93C  E88081     INC2 W1, W1
11023:             				if(tempPtr2[k])
00B93E  E00000     CP0 W0
00B940  320005     BRA Z, 0xB94C
00B942  37FFFA     BRA 0xB938
11024:             					k++;
11025:             				else
11026:             					break;
11027:             			}
11028:             		}
11029:             		else
11030:             		#endif
11031:             		{
11032:             			strcpy(&tempDirectoryString[0],&tempArray[0]);
00B944  2FDF81     MOV #0xFDF8, W1
00B946  40808F     ADD W1, W15, W1
00B948  2464A0     MOV #0x464A, W0
00B94A  07CF25     RCALL strcpy
11033:             		}
11034:             
11035:                     // Create a dir here
11036:                     if (!CreateDIR (tempDirectoryString))
00B94C  2464A0     MOV #0x464A, W0
00B94E  07FE57     RCALL CreateDIR
00B950  E00000     CP0 W0
00B952  32FF77     BRA Z, 0xB842
11037:                     {
11038:                         FileObjectCopy (cwdptr, tempCWD);
00B842  8385B0     MOV cwdptr, W0
00B844  248F61     MOV #0x48F6, W1
00B846  07E106     RCALL FileObjectCopy
00B848  37FF6B     BRA 0xB720
11039:                     	return -1;
11040:                     }
11041:             
11042:                     // Try to change to that directory
11043:                     if (FSchdir (tempArray))
00B954  2FDF80     MOV #0xFDF8, W0
00B956  40000F     ADD W0, W15, W0
00B958  07FB51     RCALL FSchdir
00B95A  E00000     CP0 W0
00B95C  3AFF76     BRA NZ, 0xB84A
11044:                     {
11045:                         FileObjectCopy (cwdptr, tempCWD);
00B84A  8385B0     MOV cwdptr, W0
00B84C  248F61     MOV #0x48F6, W1
00B84E  07E102     RCALL FileObjectCopy
11046:                         FSerrno = CE_BADCACHEREAD;
00B850  B3C1B1     MOV #0x1B, W1
00B852  37004F     BRA 0xB8F2
11047:                     	return -1;
11048:                     }
11049:             
11050:             #ifdef ALLOW_PGMFUNCTIONS
11051:                     if (mode == 1)
11052:                     {
11053:             			#ifdef SUPPORT_LFN
11054:             			if(utfModeFileName)
11055:             			{
11056:             	            while (*utf16path2 == '\\')
11057:             	            {
11058:             	                utf16path2++;
11059:             	                i = *utf16path2;
11060:             	            }
11061:             			}
11062:             			else
11063:             			#endif
11064:                     	{
11065:                     	    // Check for another backslash
11066:                     	    while (*temppath2 == '\\')
11067:                     	    {
11068:                     	        temppath2++;
11069:                     	        i = *temppath2;
11070:                     	    }
11071:             			}
11072:                     }
11073:                     else
11074:                     {
11075:             #endif
11076:             			#ifdef SUPPORT_LFN
11077:             			if(utfModeFileName)
00B95E  8385A0     MOV utfModeFileName, W0
00B960  E00000     CP0 W0
00B962  3A0002     BRA NZ, 0xB968
00B964  370006     BRA 0xB972
11078:             			{
11079:                     	    while (*utf16path == '\\')
00B968  2005C0     MOV #0x5C, W0
00B96A  100F99     SUBR W0, [W9], [W15]
00B96C  32FFFC     BRA Z, 0xB966
00B96E  370004     BRA 0xB978
11080:                     	    {
11081:                     	        utf16path++;
11082:                     	        i = *utf16path;
00B966  780459     MOV [++W9], W8
11083:                     	    }
11084:             			}
11085:             			else
11086:             			#endif
11087:                     	{
11088:                     	    while (*temppath == '\\')
00B972  B3C5C0     MOV #0x5C, W0
00B974  104F9A     SUBR.B W0, [W10], [W15]
00B976  32FFFC     BRA Z, 0xB970
11089:                     	    {
11090:                     	        temppath++;
11091:                     	        i = *temppath;
00B970  FB045A     SE [++W10], W8
11092:                     	    }
11093:             			}
11094:             #ifdef ALLOW_PGMFUNCTIONS
11095:                     }
11096:             #endif
11097:             
11098:                     // Check to see if we're at the end of the path string
11099:                     if (i == 0)
00B978  E00008     CP0 W8
00B97A  3AFF6C     BRA NZ, 0xB854
11100:                     {
11101:                         // We already have one
11102:                         FileObjectCopy (cwdptr, tempCWD);
00B97C  8385B0     MOV cwdptr, W0
00B97E  248F61     MOV #0x48F6, W1
00B980  07E069     RCALL FileObjectCopy
00B982  780008     MOV W8, W0
00B984  370009     BRA 0xB998
11103:                     	return 0;
11104:                     }
11105:                 }
11106:             }
00B9A0  780080     MOV W0, W1
11107:             
11108:             
11109:             /**************************************************************************
11110:               Function:
11111:                 int CreateDIR (char * path)
11112:               Summary:
11113:                 FSmkdir helper function to create a directory
11114:               Conditions:
11115:                 This function should not be called by the user.
11116:               Input:
11117:                 path -  The name of the dir to create
11118:               Return Values:
11119:                 TRUE -  Directory was created successfully
11120:                 FALSE - Directory could not be created.
11121:               Side Effects:
11122:                 Any unwritten data in the data buffer or the FAT buffer will be written
11123:                 to the device.
11124:               Description:
11125:                 The CreateDIR function is a helper function for the mkdirhelper
11126:                 function.  The CreateDIR function will create a new file entry for
11127:                 a directory and assign a cluster to it.  It will erase the cluster
11128:                 and write a dot and dotdot entry to it.
11129:               Remarks:
11130:                 None.
11131:               **************************************************************************/
11132:             
11133:             int CreateDIR (char * path)
11134:             {
11135:                 FSFILE * dirEntryPtr = &gFileTemp;
11136:                 DIRENTRY dir;
11137:                 WORD handle = 0;
00B602  EB0080     CLR W1
00B604  9FBFD1     MOV W1, [W15-6]
11138:                 DWORD dot, dotdot;
11139:             
11140:                 if (FormatDirName(path, dirEntryPtr,0) == FALSE)
00B606  EB4100     CLR.B W2
00B608  248BA1     MOV #0x48BA, W1
00B60A  07E8B4     RCALL FormatDirName
00B60C  E00400     CP0.B W0
00B60E  3A0004     BRA NZ, 0xB618
11141:                 {
11142:                     FSerrno = CE_INVALID_FILENAME;
00B610  B3C121     MOV #0x12, W1
00B612  249380     MOV #0x4938, W0
00B614  784801     MOV.B W1, [W0]
00B616  37004E     BRA 0xB6B4
11143:                     return FALSE;
11144:                 }
11145:             
11146:                 dirEntryPtr->dirclus = cwdptr->dirclus;
00B618  8385B0     MOV cwdptr, W0
00B61A  901920     MOV [W0+52], W2
00B61C  9019B0     MOV [W0+54], W3
00B61E  8A4772     MOV W2, 0x48EE
00B620  8A4783     MOV W3, 0x48F0
11147:                 dirEntryPtr->dirccls = cwdptr->dirccls;
00B622  901940     MOV [W0+56], W2
00B624  9019D0     MOV [W0+58], W3
00B626  8A4792     MOV W2, 0x48F2
00B628  8A47A3     MOV W3, 0x48F4
11148:                 dirEntryPtr->cluster = 0;
00B62A  248BC1     MOV #0x48BC, W1
00B62C  EB0880     CLR [W1]
00B62E  7810B1     MOV [W1++], [W1--]
11149:                 dirEntryPtr->ccls = 0;
00B630  248C01     MOV #0x48C0, W1
00B632  EB0880     CLR [W1]
00B634  7810B1     MOV [W1++], [W1--]
11150:                 dirEntryPtr->dsk = cwdptr->dsk;
00B636  780010     MOV [W0], W0
00B638  8A45D0     MOV W0, gFileTemp
11151:             
11152:                 // Create a directory entry
11153:                 if(CreateFileEntry(dirEntryPtr, &handle, DIRECTORY, TRUE) != CE_GOOD)
00B63A  200013     MOV #0x1, W3
00B63C  B3C122     MOV #0x12, W2
00B63E  5780E6     SUB W15, #0x6, W1
00B640  248BA0     MOV #0x48BA, W0
00B642  07F7FB     RCALL CreateFileEntry
00B644  780400     MOV W0, W8
00B646  E00000     CP0 W0
00B648  3A0035     BRA NZ, 0xB6B4
11154:                 {
11155:                     return FALSE;
11156:                 }
11157:                 else
11158:                 {
11159:                     if (gNeedFATWrite)
00B64A  270C20     MOV #0x70C2, W0
00B64C  E00410     CP0.B [W0]
00B64E  32000D     BRA Z, 0xB66A
11160:                         if(WriteFAT (dirEntryPtr->dsk, 0, 0, TRUE))
00B650  B3C011     MOV #0x1, W1
00B652  B82260     MUL.UU W4, #0, W4
00B654  BE0104     MOV.D W4, W2
00B656  8245D0     MOV gFileTemp, W0
00B658  07DD6C     RCALL WriteFAT
00B65A  500FE0     SUB W0, #0x0, [W15]
00B65C  588FE0     SUBB W1, #0x0, [W15]
00B65E  320005     BRA Z, 0xB66A
11161:                         {
11162:                             FSerrno = CE_WRITE_ERROR;
00B660  B3C091     MOV #0x9, W1
00B662  249380     MOV #0x4938, W0
00B664  784801     MOV.B W1, [W0]
00B666  780088     MOV W8, W1
00B668  370026     BRA 0xB6B6
11163:                             return FALSE;
11164:                         }
11165:                     // Zero that cluster
11166:                     if (dirEntryPtr->dirclus == FatRootDirClusterValue)
00B66A  824772     MOV 0x48EE, W2
00B66C  824783     MOV 0x48F0, W3
00B66E  B84460     MUL.UU W8, #0, W8
00B670  8249D0     MOV FatRootDirClusterValue, W0
00B672  8249E1     MOV 0x493C, W1
00B674  510F80     SUB W2, W0, [W15]
00B676  598F81     SUBB W3, W1, [W15]
00B678  320001     BRA Z, 0xB67C
00B67A  BE0402     MOV.D W2, W8
11167:                         dotdot = 0;
11168:                     else
11169:                         dotdot = dirEntryPtr->dirclus;
11170:                     dirEntryPtr->dirccls = dirEntryPtr->dirclus;
00B67C  8A4792     MOV W2, 0x48F2
00B67E  8A47A3     MOV W3, 0x48F4
11171:                     dir = Cache_File_Entry(dirEntryPtr, &handle, TRUE);
00B680  B3C012     MOV #0x1, W2
00B682  5780E6     SUB W15, #0x6, W1
00B684  248BA0     MOV #0x48BA, W0
00B686  07DF91     RCALL Cache_File_Entry
00B688  780200     MOV W0, W4
11172:                     if (dir == NULL)
00B68A  E00000     CP0 W0
00B68C  3A0005     BRA NZ, 0xB698
11173:                     {
11174:                         FSerrno = CE_BADCACHEREAD;
00B68E  B3C1B1     MOV #0x1B, W1
00B690  249380     MOV #0x4938, W0
00B692  784801     MOV.B W1, [W0]
00B694  780084     MOV W4, W1
00B696  37000F     BRA 0xB6B6
11175:                         return FALSE;
11176:                     }
11177:             
11178:                     // Get the cluster
11179:                     dot = GetFullClusterNumber(dir); // Get complete cluster number.
11180:             
11181:                     if (writeDotEntries (dirEntryPtr->dsk, dot, dotdot))
00B69C  DD11C0     SL W2, #0, W3
00B69E  200002     MOV #0x0, W2
00B6A0  900850     MOV [W0+26], W0
00B6A2  200001     MOV #0x0, W1
00B6A4  710100     IOR W2, W0, W2
00B6A6  718181     IOR W3, W1, W3
00B6A8  BE0208     MOV.D W8, W4
00B6AA  8245D0     MOV gFileTemp, W0
00B6AC  07E974     RCALL writeDotEntries
00B6AE  200011     MOV #0x1, W1
00B6B0  E00400     CP0.B W0
00B6B2  3A0001     BRA NZ, 0xB6B6
00B6B4  EB0080     CLR W1
11182:                         return TRUE;
11183:                     else
11184:                         return FALSE;
11185:             
11186:                 }
11187:             }
00B6BE  FA0202     LNK #0x202
00B6C0  BE9F88     MOV.D W8, [W15++]
00B6C2  781F8A     MOV W10, [W15++]
00B6C4  780481     MOV W1, W9
11188:             
11189:             
11190:             /***********************************************************************************
11191:               Function:
11192:                 BYTE writeDotEntries (DISK * disk, DWORD dotAddress, DWORD dotdotAddress)
11193:               Summary:
11194:                 Create dot and dotdot entries in a non-root directory
11195:               Conditions:
11196:                 This function should not be called by the user.
11197:               Input:
11198:                 disk -           The global disk structure
11199:                 dotAddress -     The cluster the current dir is in
11200:                 dotdotAddress -  The cluster the previous directory was in
11201:               Return Values:
11202:                 TRUE -  The dot and dotdot entries were created
11203:                 FALSE - The dot and dotdot entries could not be created in the new directory
11204:               Side Effects:
11205:                 None
11206:               Description:
11207:                 The writeDotEntries function will create and write dot and dotdot entries
11208:                 to a newly created directory.
11209:               Remarks:
11210:                 None.
11211:               ***********************************************************************************/
11212:             
11213:             BYTE writeDotEntries (DISK * disk, DWORD dotAddress, DWORD dotdotAddress)
11214:             {
11215:                 WORD i;
11216:                 WORD size;
11217:                 volatile _DIRENTRY entry;
11218:                 DIRENTRY entryptr = (DIRENTRY)&entry;
0089A4  2FFD49     MOV #0xFFD4, W9
0089A6  44848F     ADD W9, W15, W9
11219:                 DWORD sector;
11220:             
11221:                 gBufferOwner = NULL;
0089A8  EB0080     CLR W1
0089AA  8B8601     MOV W1, gBufferOwner
11222:             
11223:                 size = sizeof (_DIRENTRY);
11224:             
11225:             	memset(disk->buffer, 0x00, disk->sectorSize);
0089AC  905A00     MOV.B [W0+24], W4
0089AE  FB8204     ZE W4, W4
0089B0  905810     MOV.B [W0+25], W0
0089B2  DD0048     SL W0, #8, W0
0089B4  700104     IOR W0, W4, W2
0089B6  FB8218     ZE [W8], W4
0089B8  904018     MOV.B [W8+1], W0
0089BA  DD0048     SL W0, #8, W0
0089BC  700004     IOR W0, W4, W0
0089BE  07E6B0     RCALL memset
11226:             
11227:                 entry.DIR_Name[0] = '.';
0089C0  B3C2E0     MOV #0x2E, W0
0089C2  9FD7C0     MOV.B W0, [W15-44]
0089C4  200010     MOV #0x1, W0
0089C6  B3C201     MOV #0x20, W1
11228:             
11229:                 for (i = 1; i < 8; i++)
0089CE  E80000     INC W0, W0
0089D0  500FE8     SUB W0, #0x8, [W15]
0089D2  3AFFFA     BRA NZ, 0x89C8
0089D4  EB0000     CLR W0
0089D6  B3C202     MOV #0x20, W2
0089D8  2FFDC3     MOV #0xFFDC, W3
0089DA  478083     ADD W15, W3, W1
11230:                 {
11231:                     entry.DIR_Name[i] = 0x20;
0089C8  2FFD42     MOV #0xFFD4, W2
0089CA  41010F     ADD W2, W15, W2
0089CC  787101     MOV.B W1, [W2+W0]
11232:                 }
11233:                 for (i = 0; i < 3; i++)
0089DE  E80000     INC W0, W0
0089E0  500FE3     SUB W0, #0x3, [W15]
0089E2  3AFFFC     BRA NZ, 0x89DC
11234:                 {
11235:                     entry.DIR_Extension[i] = 0x20;
0089DC  785882     MOV.B W2, [W1++]
11236:                 }
11237:             
11238:                 entry.DIR_Attr = ATTR_DIRECTORY;
0089E4  B3C100     MOV #0x10, W0
0089E6  9FDFF0     MOV.B W0, [W15-33]
11239:                 entry.DIR_NTRes = 0x00;
0089E8  EB4000     CLR.B W0
0089EA  9FE780     MOV.B W0, [W15-32]
11240:             
11241:                 entry.DIR_FstClusLO = (WORD)(dotAddress & 0x0000FFFF); // Lower 16 bit address
0089EC  9FB7FA     MOV W10, [W15-18]
11242:             
11243:             #ifdef SUPPORT_FAT32 // If FAT32 supported.
11244:                 entry.DIR_FstClusHI = (WORD)((dotAddress & 0x0FFF0000)>> 16); // Higher 16 bit address. FAT32 uses only 28 bits. Mask even higher nibble also.
0089EE  200002     MOV #0x0, W2
0089F0  20FFF3     MOV #0xFFF, W3
0089F2  61800B     AND W3, W11, W0
0089F4  B80261     MUL.UU W0, #1, W4
0089F6  DD20C0     SL W4, #0, W1
0089F8  200000     MOV #0x0, W0
0089FA  B82260     MUL.UU W4, #0, W4
0089FC  9FB7C1     MOV W1, [W15-24]
11245:             #else // If FAT32 support not enabled
11246:                 entry.DIR_FstClusHI = 0;
11247:             #endif
11248:             
11249:                 entry.DIR_FileSize = 0x00;
0089FE  9FBF84     MOV W4, [W15-16]
008A00  9FBF95     MOV W5, [W15-14]
11250:             
11251:             // Times need to be the same as the times in the directory entry
11252:             
11253:             // Set dir date for uncontrolled clock source
11254:             #ifdef INCREMENTTIMESTAMP
11255:                 entry.DIR_CrtTimeTenth = 0xB2;
11256:                 entry.DIR_CrtTime = 0x7278;
11257:                 entry.DIR_CrtDate = 0x32B0;
11258:                 entry.DIR_LstAccDate = 0x0000;
11259:                 entry.DIR_WrtTime = 0x0000;
11260:                 entry.DIR_WrtDate = 0x0000;
11261:             #endif
11262:             
11263:             #ifdef USEREALTIMECLOCK
11264:                 entry.DIR_CrtTimeTenth = gTimeCrtMS;         // millisecond stamp
008A02  249480     MOV #0x4948, W0
008A04  784010     MOV.B [W0], W0
008A06  9FE790     MOV.B W0, [W15-31]
11265:                 entry.DIR_CrtTime =      gTimeCrtTime;      // time created //
008A08  824A30     MOV gTimeCrtTime, W0
008A0A  9FB790     MOV W0, [W15-30]
11266:                 entry.DIR_CrtDate =      gTimeCrtDate;      // date created (1/1/2004)
008A0C  824A21     MOV gTimeCrtDate, W1
008A0E  9FB7A1     MOV W1, [W15-28]
11267:                 entry.DIR_LstAccDate =   0x0000;         // Last Access date
008A10  9FB7B2     MOV W2, [W15-26]
11268:                 entry.DIR_WrtTime =      0x0000;         // last update time
008A12  9FB7D2     MOV W2, [W15-22]
11269:                 entry.DIR_WrtDate =      0x0000;         // last update date
008A14  9FB7E2     MOV W2, [W15-20]
008A16  200203     MOV #0x20, W3
11270:             #endif
11271:             
11272:             #ifdef USERDEFINEDCLOCK
11273:                 entry.DIR_CrtTimeTenth  =   gTimeCrtMS;         // millisecond stamp
11274:                 entry.DIR_CrtTime       =   gTimeCrtTime;       // time created //
11275:                 entry.DIR_CrtDate       =   gTimeCrtDate;       // date created (1/1/2004)
11276:                 entry.DIR_LstAccDate    =   0x0000;             // Last Access date
11277:                 entry.DIR_WrtTime       =   0x0000;             // last update time
11278:                 entry.DIR_WrtDate       =   0x0000;             // last update date
11279:             #endif
11280:             
11281:                 for (i = 0; i < size; i++)
008A22  E80102     INC W2, W2
008A24  510F83     SUB W2, W3, [W15]
008A26  3AFFF8     BRA NZ, 0x8A18
11282:                 {
11283:                     *(disk->buffer + i) = *((char *)entryptr + i);
008A18  FB8098     ZE [W8], W1
008A1A  904018     MOV.B [W8+1], W0
008A1C  DD0048     SL W0, #8, W0
008A1E  700001     IOR W0, W1, W0
008A20  797069     MOV.B [W9+W2], [W0+W2]
11284:                 }
11285:                 entry.DIR_Name[1] = '.';
008A28  B3C2E0     MOV #0x2E, W0
008A2A  9FD7D0     MOV.B W0, [W15-43]
11286:             
11287:                 entry.DIR_FstClusLO = (WORD)(dotdotAddress & 0x0000FFFF); // Lower 16 bit address
008A2C  9FB7FC     MOV W12, [W15-18]
11288:             
11289:             #ifdef SUPPORT_FAT32 // If FAT32 supported.
11290:                 entry.DIR_FstClusHI = (WORD)((dotdotAddress & 0x0FFF0000)>> 16); // Higher 16 bit address. FAT32 uses only 28 bits. Mask even higher nibble also.
008A2E  200000     MOV #0x0, W0
008A30  20FFF1     MOV #0xFFF, W1
008A32  60810D     AND W1, W13, W2
008A34  9FB7C2     MOV W2, [W15-24]
008A36  780100     MOV W0, W2
008A38  200203     MOV #0x20, W3
11291:             #else // If FAT32 support not enabled
11292:                 entry.DIR_FstClusHI = 0;
11293:             #endif
11294:             
11295:             
11296:                 for (i = 0; i < size; i++)
008A48  E80102     INC W2, W2
008A4A  510F83     SUB W2, W3, [W15]
008A4C  3AFFF6     BRA NZ, 0x8A3A
11297:                 {
11298:                     *(disk->buffer + i + size) = *((char *)entryptr + i);
008A3A  FB8098     ZE [W8], W1
008A3C  904018     MOV.B [W8+1], W0
008A3E  DD0048     SL W0, #8, W0
008A40  700001     IOR W0, W1, W0
008A42  400002     ADD W0, W2, W0
008A44  7CC0E2     MOV.B [W2+W9], W1
008A46  986001     MOV.B W1, [W0+32]
11299:                 }
11300:             
11301:                 sector = Cluster2Sector (disk, dotAddress);
008A56  BE010A     MOV.D W10, W2
008A58  780008     MOV W8, W0
008A5A  07F215     RCALL Cluster2Sector
008A5C  EB4180     CLR.B W3
008A5E  780109     MOV W9, W2
008A60  07263C     RCALL MDD_SDSPI_SectorWrite
11302:             
11303:                 if (MDD_SectorWrite(sector, disk->buffer, FALSE) == FALSE)
008A4E  FB8018     ZE [W8], W0
008A50  904098     MOV.B [W8+1], W1
008A52  DD08C8     SL W1, #8, W1
008A54  708480     IOR W1, W0, W9
008A62  200011     MOV #0x1, W1
008A64  E00400     CP0.B W0
008A66  3A0004     BRA NZ, 0x8A70
11304:                 {
11305:                     FSerrno = CE_WRITE_ERROR;
008A68  B3C091     MOV #0x9, W1
008A6A  249380     MOV #0x4938, W0
008A6C  784801     MOV.B W1, [W0]
008A6E  EB0080     CLR W1
11306:                     return FALSE;
11307:                 }
11308:             
11309:                 return TRUE;
11310:             }
008A7C  781F88     MOV W8, [W15++]
008A7E  780400     MOV W0, W8
11311:             
11312:             // This array is used to prevent a stack frame error
11313:             #ifdef __18CXX
11314:                 char tempArray[13] = "           ";
11315:             #endif
11316:             
11317:             
11318:             /**************************************************************************
11319:               Function:
11320:                 int FSrmdir (char * path)
11321:               Summary:
11322:                 Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC).
11323:               Conditions:
11324:                 None
11325:               Input:
11326:                 path -      The path of the directory to remove
11327:                 rmsubdirs - 
11328:                           - TRUE -  All sub-dirs and files in the target dir will be removed
11329:                           - FALSE - FSrmdir will not remove non-empty directories
11330:               Return Values:
11331:                 0 -   The specified directory was deleted successfully
11332:                 EOF - The specified directory could not be deleted
11333:               Side Effects:
11334:                 The FSerrno variable will be changed.
11335:               Description:
11336:                 Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC).
11337:                 This function wont delete the current working directory.
11338:               Remarks:
11339:                 None.
11340:               **************************************************************************/
11341:             
11342:             int FSrmdir (char * path, unsigned char rmsubdirs)
11343:             {
11344:                 return rmdirhelper (0, path, NULL, rmsubdirs);
00BF7A  784181     MOV.B W1, W3
00BF7C  EB0100     CLR W2
00BF7E  780080     MOV W0, W1
00BF80  EB4000     CLR.B W0
00BF82  37FD1B     BRA rmdirhelper
11345:             }
11346:             
11347:             
11348:             /**************************************************************************
11349:               Function:
11350:                 int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs)
11351:               Summary:
11352:                 Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC).
11353:               Conditions:
11354:                 None
11355:               Input:
11356:                 path -      The path of the directory to remove
11357:                 rmsubdirs - 
11358:                           - TRUE -  All sub-dirs and files in the target dir will be removed
11359:                           - FALSE - FSrmdir will not remove non-empty directories
11360:               Return Values:
11361:                 0 -   The specified directory was deleted successfully
11362:                 EOF - The specified directory could not be deleted
11363:               Side Effects:
11364:                 The FSerrno variable will be changed.
11365:               Description:
11366:                 Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC).
11367:                 This function wont delete the current working directory.
11368:               Remarks:
11369:                 None.
11370:               **************************************************************************/
11371:             #ifdef SUPPORT_LFN
11372:             int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs)
11373:             {
11374:             	int result;
11375:             	utfModeFileName = TRUE;
00BF66  200010     MOV #0x1, W0
00BF68  8B85A0     MOV W0, utfModeFileName
11376:                 result = rmdirhelper (0, (char *)path, NULL, rmsubdirs);
00BF6A  784181     MOV.B W1, W3
00BF6C  EB0100     CLR W2
00BF6E  780084     MOV W4, W1
00BF70  EB4000     CLR.B W0
00BF72  07FD23     RCALL rmdirhelper
11377:             	utfModeFileName = FALSE;
00BF74  EB0080     CLR W1
00BF76  8B85A1     MOV W1, utfModeFileName
11378:                 return result;
11379:             }
11380:             #endif
11381:             
11382:             /**************************************************************************
11383:               Function:
11384:                 int FSrmdirpgm (const rom char * path)
11385:               Summary:
11386:                 Deletes the directory as per the ascii input path (PIC18).
11387:               Conditions:
11388:                 None.
11389:               Input:
11390:                 path -      The path of the directory to remove (ROM)
11391:                 rmsubdirs - 
11392:                           - TRUE -  All sub-dirs and files in the target dir will be removed
11393:                           - FALSE - FSrmdir will not remove non-empty directories
11394:               Return Values:
11395:                 0 -   The specified directory was deleted successfully
11396:                 EOF - The specified directory could not be deleted
11397:               Side Effects:
11398:                 The FSerrno variable will be changed.
11399:               Description:
11400:                 Deletes the directory as per the ascii input path (PIC18).
11401:                 This function deletes the directory as specified in the path.
11402:                 This function wont delete the current working directory.
11403:               Remarks:
11404:                 This function is for use with PIC18 when passing arguments in ROM.
11405:               **************************************************************************/
11406:             
11407:             #ifdef ALLOW_PGMFUNCTIONS
11408:             int FSrmdirpgm (const rom char * path, unsigned char rmsubdirs)
11409:             {
11410:                 return rmdirhelper (1, NULL, path, rmsubdirs);
11411:             }
11412:             #endif
11413:             
11414:             /**************************************************************************
11415:               Function:
11416:                     int wFSrmdirpgm (const rom unsigned short int * path, unsigned char rmsubdirs)
11417:               Summary:
11418:                 Delete a directory with a path in ROM on PIC18
11419:               Conditions:
11420:                 None.
11421:               Input:
11422:                 path -      The path of the directory to remove (ROM)
11423:                 rmsubdirs -
11424:                           - TRUE -  All sub-dirs and files in the target dir will be removed
11425:                           - FALSE - FSrmdir will not remove non-empty directories
11426:               Return Values:
11427:                 0 -   The specified directory was deleted successfully
11428:                 EOF - The specified directory could not be deleted
11429:               Side Effects:
11430:                 The FSerrno variable will be changed.
11431:               Description:
11432:                 The FSrmdirpgm function passes a PIC18 ROM path pointer to the
11433:                 rmdirhelper function.
11434:               Remarks:
11435:                 This function is for use with PIC18 when passing arguments in ROM.
11436:               **************************************************************************/
11437:             
11438:             #ifdef ALLOW_PGMFUNCTIONS
11439:             
11440:             #ifdef SUPPORT_LFN
11441:             int wFSrmdirpgm (const rom unsigned short int * path, unsigned char rmsubdirs)
11442:             {
11443:             	int result;
11444:             	utfModeFileName = TRUE;
11445:                 result = rmdirhelper (1, NULL, (const char *)path, rmsubdirs);
11446:             	utfModeFileName = FALSE;
11447:                 return result;
11448:             }
11449:             #endif
11450:             
11451:             #endif
11452:             
11453:             /************************************************************************************************
11454:               Function:
11455:                 // PIC24/30/33/32
11456:                 int rmdirhelper (BYTE mode, char * ramptr, char * romptr, unsigned char rmsubdirs)
11457:                 // PIC18
11458:                 int rmdirhelper (BYTE mode, char * ramptr, const rom char * romptr, unsigned char rmsubdirs)
11459:               Summary:
11460:                 Helper function for FSrmdir
11461:               Conditions:
11462:                 This function should not be called by the user.
11463:               Input:
11464:                 path -      The path of the dir to delete
11465:                 rmsubdirs -
11466:                           - TRUE -  Remove all sub-directories and files in the directory
11467:                           - FALSE - Non-empty directories can not be removed
11468:               Return Values:
11469:                 0 -   The specified directory was successfully removed.
11470:                 EOF - The specified directory could not be removed.
11471:               Side Effects:
11472:                 The FSerrno variable will be changed.
11473:               Description:
11474:                 This helper function is used by the FSmkdir function.  If the path
11475:                 argument is specified in ROM for PIC18 this function will be able
11476:                 to parse it correctly.  This function will first change to the
11477:                 specified directory.  If the rmsubdirs argument is FALSE the function
11478:                 will search through the directory to ensure that it is empty and then
11479:                 remove it.  If the rmsubdirs argument is TRUE the function will also
11480:                 search through the directory for subdirectories or files.  When the
11481:                 function finds a file, the file will be erased.  When the function
11482:                 finds a subdirectory, it will switch to the subdirectory and begin
11483:                 removing all of the files in that subdirectory.  Once the subdirectory
11484:                 is empty, the function will switch back to the original directory.
11485:                 return to the original position in that directory, and continue removing
11486:                 files.  Once the specified directory is empty, the function will
11487:                 change to the parent directory, search through it for the directory
11488:                 to remove, and then erase that directory.
11489:               Remarks:
11490:                 None.
11491:               ************************************************************************************************/
11492:             
11493:             #ifdef ALLOW_PGMFUNCTIONS
11494:             int rmdirhelper (BYTE mode, char * ramptr, const rom char * romptr, unsigned char rmsubdirs)
11495:             #else
11496:             int rmdirhelper (BYTE mode, char * ramptr, char * romptr, unsigned char rmsubdirs)
11497:             #endif
11498:             {
00BBC2  784205     MOV.B W5, W4
11499:                 FILEOBJ tempCWD = &tempCWDobj;
11500:                 FILEOBJ fo = &gFileTemp;
11501:                 DIRENTRY entry;
11502:                 WORD handle = 0;
00B9C8  EB0000     CLR W0
00B9CA  9D97F0     MOV W0, [W15-594]
11503:                 WORD handle2;
11504:                 WORD subDirDepth;
11505:                 short int Index3 = 0;
11506:                 char Index, Index2;
11507:             
11508:             	#if defined(SUPPORT_LFN)
11509:             
11510:             		BOOL prevUtfModeFileName = utfModeFileName;
00B9CC  8385AE     MOV utfModeFileName, W14
11511:             		char tempArray[514];
11512:                 	WORD prevHandle;
11513:                 	LFN_ENTRY *lfno;
11514:                 	FSFILE cwdTemp;
11515:             		UINT16_VAL tempShift;
11516:             		unsigned short int *tempLFN = (unsigned short int *)&tempArray[0];
00B9CE  2FDF0C     MOV #0xFDF0, W12
00B9D0  47860C     ADD W15, W12, W12
11517:             		BOOL	forFirstTime;
11518:             	#else
11519:             
11520:             		char	tempArray[13];
11521:             
11522:             	#endif
11523:             
11524:             #ifndef __18CXX
11525:             
11526:             #else
11527:                 char dotdotname[] = "..";
11528:                 char dotdotname1[5] = {'.','\0','.','\0','\0'};
11529:             #endif
11530:             
11531:                 FSerrno = CE_GOOD;
00B9D2  249389     MOV #0x4938, W9
00B9D4  EB4C80     CLR.B [W9]
11532:             
11533:                 // Back up the current working directory
11534:                 FileObjectCopy (tempCWD, cwdptr);
00B9D6  8385B1     MOV cwdptr, W1
00B9D8  248F60     MOV #0x48F6, W0
00B9DA  07E03C     RCALL FileObjectCopy
11535:             
11536:             #ifdef ALLOW_PGMFUNCTIONS
11537:                 if (mode)
11538:                 {
11539:                     if (chdirhelper (1, NULL, romptr))
11540:                     {
11541:                         FSerrno = CE_DIR_NOT_FOUND;
11542:                         return -1;
11543:                     }
11544:                 }
11545:                 else
11546:                 {
11547:             #endif
11548:                     if (FSchdir (ramptr))
00B9DC  780008     MOV W8, W0
00B9DE  07FB0E     RCALL FSchdir
00B9E0  780400     MOV W0, W8
00B9E4  E00008     CP0 W8
00B9E6  3A0010     BRA NZ, 0xBA08
11549:                     {
11550:                         FSerrno = CE_DIR_NOT_FOUND;
00B9E2  B3C0C0     MOV #0xC, W0
11551:                         return -1;
11552:                     }
11553:             #ifdef ALLOW_PGMFUNCTIONS
11554:                 }
11555:             #endif
11556:             
11557:                 // Make sure we aren't trying to remove the root dir or the CWD
11558:                 if ((cwdptr->dirclus == FatRootDirClusterValue) || (cwdptr->dirclus == tempCWD->dirclus))
00B9E8  8385B4     MOV cwdptr, W4
00B9EA  901924     MOV [W4+52], W2
00B9EC  9019B4     MOV [W4+54], W3
00B9EE  8249D0     MOV FatRootDirClusterValue, W0
00B9F0  8249E1     MOV 0x493C, W1
00B9F2  510F80     SUB W2, W0, [W15]
00B9F4  598F81     SUBB W3, W1, [W15]
00B9F6  320004     BRA Z, 0xBA00
00B9F8  2492A0     MOV #0x492A, W0
00B9FA  510FB0     SUB W2, [W0++], [W15]
00B9FC  598FA0     SUBB W3, [W0--], [W15]
00B9FE  3A0007     BRA NZ, 0xBA0E
11559:                 {
11560:                     FileObjectCopy (cwdptr, tempCWD);
00BA00  248F61     MOV #0x48F6, W1
00BA02  780004     MOV W4, W0
00BA04  07E027     RCALL FileObjectCopy
11561:                     FSerrno = CE_INVALID_ARGUMENT;
00BA06  B3C1F0     MOV #0x1F, W0
00BA08  784C80     MOV.B W0, [W9]
00BA0A  EB8000     SETM W0
00BA0C  3702A4     BRA 0xBF56
11562:                     return -1;
11563:                 }
11564:             
11565:                 handle++;
00BA0E  9590FF     MOV [W15-594], W1
00BA10  E80081     INC W1, W1
00BA12  9D97F1     MOV W1, [W15-594]
11566:                 entry = Cache_File_Entry (cwdptr, &handle, TRUE);
00BA14  B3C012     MOV #0x1, W2
00BA16  2FDAE1     MOV #0xFDAE, W1
00BA18  40808F     ADD W1, W15, W1
00BA1A  780004     MOV W4, W0
00BA1C  07DDC6     RCALL Cache_File_Entry
00BA1E  8385B3     MOV cwdptr, W3
11567:             
11568:                 if (entry == NULL)
00BA20  E00000     CP0 W0
00BA22  3A0003     BRA NZ, 0xBA2A
11569:                 {
11570:                     FileObjectCopy (cwdptr, tempCWD);
00BA24  248F61     MOV #0x48F6, W1
00BA26  780003     MOV W3, W0
00BA28  37000D     BRA 0xBA44
11571:                     FSerrno = CE_BADCACHEREAD;
11572:                     return -1;
11573:                 }
11574:             
11575:                 handle++;
00BA2A  95917F     MOV [W15-594], W2
00BA2C  E80102     INC W2, W2
00BA2E  9D97F2     MOV W2, [W15-594]
11576:                 entry = Cache_File_Entry (cwdptr, &handle, FALSE);
00BA30  784108     MOV.B W8, W2
00BA32  2FDAE1     MOV #0xFDAE, W1
00BA34  40808F     ADD W1, W15, W1
00BA36  780003     MOV W3, W0
00BA38  07DDB8     RCALL Cache_File_Entry
00BA3A  780180     MOV W0, W3
11577:                 if (entry == NULL)
00BA3C  E00000     CP0 W0
00BA3E  3A0005     BRA NZ, 0xBA4A
11578:                 {
11579:                     FileObjectCopy (cwdptr, tempCWD);
00BA40  8385B0     MOV cwdptr, W0
00BA42  248F61     MOV #0x48F6, W1
00BA44  07E007     RCALL FileObjectCopy
11580:                     FSerrno = CE_BADCACHEREAD;
00BA46  B3C1B0     MOV #0x1B, W0
00BA48  37FFDF     BRA 0xBA08
11581:                     return -1;
11582:                 }
11583:                 // Don't remove subdirectories and sub-files
11584:                 if (!rmsubdirs)
00BA4A  E0040A     CP0.B W10
00BA4C  32000F     BRA Z, 0xBA6C
00BA4E  370012     BRA 0xBA74
00BA50  8385B3     MOV cwdptr, W3
11585:                 {
11586:                     while (entry->DIR_Name[0] != 0)
00BA6C  784013     MOV.B [W3], W0
00BA6E  E00400     CP0.B W0
00BA70  3AFFEF     BRA NZ, 0xBA50
00BA72  37021A     BRA 0xBEA8
11587:                     {
11588:                         if ((unsigned char)entry->DIR_Name[0] != 0xE5)
00BA52  404FFB     ADD.B W0, #0x1B, [W15]
00BA54  3A025B     BRA NZ, 0xBF0C
11589:                         {
11590:                             FileObjectCopy (cwdptr, tempCWD);
00BF0C  248F61     MOV #0x48F6, W1
00BF0E  780003     MOV W3, W0
00BF10  07DDA1     RCALL FileObjectCopy
11591:                             FSerrno = CE_DIR_NOT_EMPTY;
00BF12  B3C161     MOV #0x16, W1
00BF14  370019     BRA 0xBF48
11592:                             return -1;
11593:                         }
11594:                         handle++;
00BA56  95907F     MOV [W15-594], W0
00BA58  E80000     INC W0, W0
00BA5A  9D97F0     MOV W0, [W15-594]
11595:                         entry = Cache_File_Entry (cwdptr, &handle, FALSE);
00BA5C  EB4100     CLR.B W2
00BA5E  2FDAE1     MOV #0xFDAE, W1
00BA60  40808F     ADD W1, W15, W1
00BA62  780003     MOV W3, W0
00BA64  07DDA2     RCALL Cache_File_Entry
00BA66  780180     MOV W0, W3
11596:                         if ((entry == NULL))
00BA68  E00000     CP0 W0
00BA6A  32026A     BRA Z, 0xBF40
11597:                         {
11598:                             FileObjectCopy (cwdptr, tempCWD);
11599:                             FSerrno = CE_BADCACHEREAD;
11600:                             return -1;
11601:                         }
11602:                     }
11603:                 }
11604:                 else
11605:                 {
11606:                     // Do remove subdirectories and sub-files
11607:                     dirCleared = FALSE;
00BA74  249320     MOV #0x4932, W0
00BA76  EB4800     CLR.B [W0]
11608:                     subDirDepth = 0;
11609:             		#if defined(SUPPORT_LFN)
11610:             		tempCWD-> utf16LFNptr = (unsigned short int *)&tempArray[0];
00BA78  8A490C     MOV W12, 0x4920
11611:             		fo-> utf16LFNptr = (unsigned short int *)&tempArray[0];
00BA7A  8A472C     MOV W12, 0x48E4
00BA7C  EB0680     CLR W13
00BA7E  370211     BRA 0xBEA2
11612:             		#endif
11613:             
11614:                     while (!dirCleared)
00BEA2  249321     MOV #0x4932, W1
00BEA4  E00411     CP0.B [W1]
00BEA6  32FDEC     BRA Z, 0xBA80
11615:                     {
11616:                         if (entry->DIR_Name[0] != 0)
00BA80  784013     MOV.B [W3], W0
00BA82  E00400     CP0.B W0
00BA84  320119     BRA Z, 0xBCB8
11617:                         {
11618:                             if (((unsigned char)entry->DIR_Name[0] != 0xE5) && (entry->DIR_Attr == ATTR_LONG_NAME))
00BA86  404FFB     ADD.B W0, #0x1B, [W15]
00BA88  3200FF     BRA Z, 0xBC88
00BA8A  9048B3     MOV.B [W3+11], W1
00BA8C  50CFEF     SUB.B W1, #0xF, [W15]
00BA8E  3A007B     BRA NZ, 0xBB86
11619:             				{
11620:             					#if defined(SUPPORT_LFN)
11621:             					lfno = (LFN_ENTRY *)entry;
11622:             
11623:             					if(lfno->LFN_SequenceNo & 0x40)
00BA90  FB8000     ZE W0, W0
00BA92  B9026D     MUL.SU W0, #13, W4
00BA94  B20400     AND #0x40, W0
00BA96  32000B     BRA Z, 0xBAAE
11624:             					{
11625:             						Index3 = (lfno->LFN_SequenceNo - 0x41) * 13;
00BA98  2FCB30     MOV #0xFCB3, W0
00BA9A  400104     ADD W0, W4, W2
11626:             						tempLFN[Index3 + 13] = 0x0000;
00BA9C  410002     ADD W2, W2, W0
00BA9E  40000C     ADD W0, W12, W0
00BAA0  40007A     ADD W0, #0x1A, W0
00BAA2  EB0800     CLR [W0]
00BAA4  200014     MOV #0x1, W4
00BAA6  370005     BRA 0xBAB2
11627:             						forFirstTime = TRUE;
11628:             					}
11629:             					else
11630:             					{
11631:             						Index3 = (lfno->LFN_SequenceNo - 1) * 13;
00BAAE  52016D     SUB W4, #0xD, W2
00BAB0  780200     MOV W0, W4
11632:             						forFirstTime = FALSE;
11633:             					}
11634:             
11635:             					tempShift.byte.LB = lfno->LFN_Part1[0];
00BAB2  904013     MOV.B [W3+1], W0
00BAB4  FB8000     ZE W0, W0
00BAB6  2FF001     MOV #0xFF00, W1
00BAB8  648481     AND W9, W1, W9
00BABA  748480     IOR W9, W0, W9
11636:             					tempShift.byte.HB = lfno->LFN_Part1[1];
00BABC  904023     MOV.B [W3+2], W0
00BABE  DD0048     SL W0, #8, W0
00BAC0  B20FF9     AND #0xFF, W9
00BAC2  748480     IOR W9, W0, W9
11637:             					tempLFN[Index3++] = tempShift.Val;
00BAC4  410002     ADD W2, W2, W0
00BAC6  7E3009     MOV W9, [W0+W12]
11638:             					tempShift.byte.LB = lfno->LFN_Part1[2];
00BAC8  904033     MOV.B [W3+3], W0
00BACA  FB8000     ZE W0, W0
00BACC  648481     AND W9, W1, W9
00BACE  748480     IOR W9, W0, W9
11639:             					tempShift.byte.HB = lfno->LFN_Part1[3];
00BAD0  904043     MOV.B [W3+4], W0
00BAD2  DD0048     SL W0, #8, W0
00BAD4  B20FF9     AND #0xFF, W9
00BAD6  748480     IOR W9, W0, W9
11640:             					tempLFN[Index3++] = tempShift.Val;
00BAD8  E80002     INC W2, W0
00BADA  400000     ADD W0, W0, W0
00BADC  7E3009     MOV W9, [W0+W12]
11641:             					tempShift.byte.LB = lfno->LFN_Part1[4];
00BADE  904053     MOV.B [W3+5], W0
00BAE0  FB8000     ZE W0, W0
00BAE2  648481     AND W9, W1, W9
00BAE4  748480     IOR W9, W0, W9
11642:             					tempShift.byte.HB = lfno->LFN_Part1[5];
00BAE6  904063     MOV.B [W3+6], W0
00BAE8  DD0048     SL W0, #8, W0
00BAEA  B20FF9     AND #0xFF, W9
00BAEC  748480     IOR W9, W0, W9
11643:             					tempLFN[Index3++] = tempShift.Val;
00BAEE  E88002     INC2 W2, W0
00BAF0  400000     ADD W0, W0, W0
00BAF2  7E3009     MOV W9, [W0+W12]
11644:             					tempShift.byte.LB = lfno->LFN_Part1[6];
00BAF4  904073     MOV.B [W3+7], W0
00BAF6  FB8000     ZE W0, W0
00BAF8  648481     AND W9, W1, W9
00BAFA  748480     IOR W9, W0, W9
11645:             					tempShift.byte.HB = lfno->LFN_Part1[7];
00BAFC  904803     MOV.B [W3+8], W0
00BAFE  DD0048     SL W0, #8, W0
00BB00  B20FF9     AND #0xFF, W9
00BB02  748480     IOR W9, W0, W9
11646:             					tempLFN[Index3++] = tempShift.Val;
00BB04  410063     ADD W2, #0x3, W0
00BB06  400000     ADD W0, W0, W0
00BB08  7E3009     MOV W9, [W0+W12]
11647:             					tempShift.byte.LB = lfno->LFN_Part1[8];
00BB0A  904813     MOV.B [W3+9], W0
00BB0C  FB8000     ZE W0, W0
00BB0E  648481     AND W9, W1, W9
00BB10  748480     IOR W9, W0, W9
11648:             					tempShift.byte.HB = lfno->LFN_Part1[9];
00BB12  904823     MOV.B [W3+10], W0
00BB14  DD0048     SL W0, #8, W0
00BB16  B20FF9     AND #0xFF, W9
00BB18  748480     IOR W9, W0, W9
11649:             					tempLFN[Index3++] = tempShift.Val;
00BB1A  410064     ADD W2, #0x4, W0
00BB1C  400000     ADD W0, W0, W0
00BB1E  7E3009     MOV W9, [W0+W12]
11650:             
11651:             					tempLFN[Index3++] = lfno->LFN_Part2[0];
00BB20  410065     ADD W2, #0x5, W0
00BB22  400000     ADD W0, W0, W0
00BB24  9000F3     MOV [W3+14], W1
00BB26  7E3001     MOV W1, [W0+W12]
11652:             					tempLFN[Index3++] = lfno->LFN_Part2[1];
00BB28  410066     ADD W2, #0x6, W0
00BB2A  400000     ADD W0, W0, W0
00BB2C  900883     MOV [W3+16], W1
00BB2E  7E3001     MOV W1, [W0+W12]
11653:             					tempLFN[Index3++] = lfno->LFN_Part2[2];
00BB30  410067     ADD W2, #0x7, W0
00BB32  400000     ADD W0, W0, W0
00BB34  900893     MOV [W3+18], W1
00BB36  7E3001     MOV W1, [W0+W12]
11654:             					tempLFN[Index3++] = lfno->LFN_Part2[3];
00BB38  410068     ADD W2, #0x8, W0
00BB3A  400000     ADD W0, W0, W0
00BB3C  9008A3     MOV [W3+20], W1
00BB3E  7E3001     MOV W1, [W0+W12]
11655:             					tempLFN[Index3++] = lfno->LFN_Part2[4];
00BB40  410069     ADD W2, #0x9, W0
00BB42  400000     ADD W0, W0, W0
00BB44  9008B3     MOV [W3+22], W1
00BB46  7E3001     MOV W1, [W0+W12]
11656:             					tempLFN[Index3++] = lfno->LFN_Part2[5];
00BB48  41006A     ADD W2, #0xA, W0
00BB4A  400000     ADD W0, W0, W0
00BB4C  9008C3     MOV [W3+24], W1
00BB4E  7E3001     MOV W1, [W0+W12]
11657:             
11658:             					tempLFN[Index3++] = lfno->LFN_Part3[0];
00BB50  41006B     ADD W2, #0xB, W0
00BB52  400000     ADD W0, W0, W0
00BB54  9008E3     MOV [W3+28], W1
00BB56  7E3001     MOV W1, [W0+W12]
00BB58  4100EC     ADD W2, #0xC, W1
11659:             					tempLFN[Index3] = lfno->LFN_Part3[1];
00BB5A  408001     ADD W1, W1, W0
00BB5C  40000C     ADD W0, W12, W0
00BB5E  9009F3     MOV [W3+30], W3
00BB60  780803     MOV W3, [W0]
11660:             
11661:             					if(forFirstTime)
00BB62  E00004     CP0 W4
00BB64  32000C     BRA Z, 0xBB7E
11662:             					{
11663:             						tempCWD->utf16LFNlength = Index3;
00BB66  8A4911     MOV W1, 0x4922
00BB68  50007A     SUB W0, #0x1A, W0
00BB6A  B3C0D1     MOV #0xD, W1
11664:             						
11665:             						for(Index = 12;Index >= 0;Index--)
00BB76  E00401     CP0.B W1
00BB78  3AFFF9     BRA NZ, 0xBB6C
11666:             						{
11667:             							if((tempLFN[Index3 - Index - 1]) == 0x0000)
00BB6C  E00010     CP0 [W0]
00BB6E  32FF9C     BRA Z, 0xBAA8
11668:             							{
11669:             								tempCWD->utf16LFNlength = Index3 - Index - 1;
00BAA8  E90002     DEC W2, W0
00BAAA  8A4910     MOV W0, 0x4922
00BAAC  370066     BRA 0xBB7A
11670:             								break;
00BB70  E94081     DEC.B W1, W1
00BB72  E80102     INC W2, W2
00BB74  E88000     INC2 W0, W0
11671:             							}
11672:             						}
11673:             					
11674:             						fo->utf16LFNlength = tempCWD->utf16LFNlength;
00BB7A  824912     MOV 0x4922, W2
00BB7C  8A4732     MOV W2, 0x48E6
11675:             					}
11676:                             	handle++;
00BB7E  9591FF     MOV [W15-594], W3
00BB80  E80183     INC W3, W3
00BB82  9D97F3     MOV W3, [W15-594]
00BB84  370084     BRA 0xBC8E
11677:             					#endif
11678:             				}
11679:                             else if (((unsigned char)entry->DIR_Name[0] != 0xE5) && (entry->DIR_Attr != ATTR_VOLUME) && (entry->DIR_Attr != ATTR_LONG_NAME))
00BB86  50CFE8     SUB.B W1, #0x8, [W15]
00BB88  32007F     BRA Z, 0xBC88
00BB8A  249228     MOV #0x4922, W8
11680:                             {
11681:                                 if ((entry->DIR_Attr & ATTR_DIRECTORY) == ATTR_DIRECTORY)
00BB8C  A34801     BTST.Z W1, #4
00BB8E  32004E     BRA Z, 0xBC2C
11682:                                 {
11683:                                     // We have a directory
11684:                                     subDirDepth++;
00BB90  E8068D     INC W13, W13
11685:             						#if defined(SUPPORT_LFN)
11686:             						if(tempCWD-> utf16LFNlength)
00BB92  E00018     CP0 [W8]
00BB94  3A0003     BRA NZ, 0xBB9C
00BB96  780103     MOV W3, W2
00BB98  EB0280     CLR W5
00BB9A  370013     BRA 0xBBC2
11687:             						{
11688:             							utfModeFileName = 1;
00BB9C  200010     MOV #0x1, W0
00BB9E  8B85A0     MOV W0, utfModeFileName
11689:             							Index = FSchdir(&tempArray[0]);
00BBA0  2FDF00     MOV #0xFDF0, W0
00BBA2  478000     ADD W15, W0, W0
00BBA4  07FA2B     RCALL FSchdir
00BBA6  784080     MOV.B W0, W1
11690:             							utfModeFileName = prevUtfModeFileName;
00BBA8  8B85AE     MOV W14, utfModeFileName
11691:             							tempCWD-> utf16LFNlength = 0;
00BBAA  EB0C00     CLR [W8]
11692:             							fo-> utf16LFNlength = 0;
00BBAC  248E60     MOV #0x48E6, W0
00BBAE  EB0800     CLR [W0]
00BBB0  37002E     BRA 0xBC0E
11693:             						}
11694:             						else
11695:             						#endif
11696:             						{
11697:                                 	    for (Index = 0; (Index < DIR_NAMESIZE) && (entry->DIR_Name[(BYTE)Index] != 0x20); Index++)
00BBBE  528FE8     SUB W5, #0x8, [W15]
00BBC0  320005     BRA Z, 0xBBCC
00BBC4  784092     MOV.B [W2], W1
00BBC6  B3C200     MOV #0x20, W0
00BBC8  50CF80     SUB.B W1, W0, [W15]
00BBCA  3AFFF3     BRA NZ, 0xBBB2
11698:                                 	    {
11699:                                 	        tempArray[(BYTE)Index] = entry->DIR_Name[(BYTE)Index];
00BBB2  2FDF00     MOV #0xFDF0, W0
00BBB4  478000     ADD W15, W0, W0
00BBB6  787281     MOV.B W1, [W5+W0]
00BBB8  E84204     INC.B W4, W4
00BBBA  E80285     INC W5, W5
00BBBC  E80102     INC W2, W2
11700:                                 	    }
11701:                                 	    if (entry->DIR_Extension[0] != 0x20)
00BBCC  904803     MOV.B [W3+8], W0
00BBCE  B3C206     MOV #0x20, W6
00BBD0  504F86     SUB.B W0, W6, [W15]
00BBD2  320013     BRA Z, 0xBBFA
11702:                                 	    {
11703:                                 	        tempArray[(BYTE)Index++] = '.';
00BBD4  2FDF02     MOV #0xFDF0, W2
00BBD6  478102     ADD W15, W2, W2
00BBD8  FB8084     ZE W4, W1
00BBDA  B3C2E0     MOV #0x2E, W0
00BBDC  78F100     MOV.B W0, [W2+W1]
00BBDE  E84204     INC.B W4, W4
00BBE0  4181E8     ADD W3, #0x8, W3
00BBE2  B3C035     MOV #0x3, W5
00BBE4  370007     BRA 0xBBF4
11704:                                 	        for (Index2 = 0; (Index2 < DIR_EXTENSION) && (entry->DIR_Extension[(BYTE)Index2] != 0x20); Index2++)
00BBF0  E00405     CP0.B W5
00BBF2  320003     BRA Z, 0xBBFA
00BBF4  784093     MOV.B [W3], W1
00BBF6  50CF86     SUB.B W1, W6, [W15]
00BBF8  3AFFF6     BRA NZ, 0xBBE6
11705:                                 	        {
11706:                                 	            tempArray[(BYTE)Index++] = entry->DIR_Extension[(BYTE)Index2];
00BBE6  FB8004     ZE W4, W0
00BBE8  787101     MOV.B W1, [W2+W0]
00BBEA  E84204     INC.B W4, W4
00BBEC  E94285     DEC.B W5, W5
00BBEE  E80183     INC W3, W3
11707:                                 	        }
11708:                                 	    }
11709:                                 	    tempArray[(BYTE)Index] = 0;
00BBFA  2FDF00     MOV #0xFDF0, W0
00BBFC  478000     ADD W15, W0, W0
00BBFE  FB8084     ZE W4, W1
00BC00  400081     ADD W0, W1, W1
00BC02  EB4880     CLR.B [W1]
11710:             							#ifdef SUPPORT_LFN
11711:             							utfModeFileName = 0;
00BC04  EB0080     CLR W1
00BC06  8B85A1     MOV W1, utfModeFileName
11712:             							#endif
11713:             							Index = FSchdir(&tempArray[0]);
00BC08  07F9F9     RCALL FSchdir
00BC0A  784080     MOV.B W0, W1
11714:             							#ifdef SUPPORT_LFN
11715:             							utfModeFileName = prevUtfModeFileName;
00BC0C  8B85AE     MOV W14, utfModeFileName
00BC0E  8385B3     MOV cwdptr, W3
11716:             							#endif
11717:             						}
11718:             
11719:                                     // Change to the subdirectory
11720:                                     if (Index)
00BC10  E00401     CP0.B W1
00BC12  3A018C     BRA NZ, 0xBF2C
11721:                                     {
11722:                                         FileObjectCopy (cwdptr, tempCWD);
11723:                                         FSerrno = CE_DIR_NOT_FOUND;
11724:                                         return -1;
11725:                                     }
11726:                                     else
11727:                                     {
11728:                                         // Make sure we're not trying to delete the CWD
11729:                                         if (cwdptr->dirclus == tempCWD->dirclus)
00BC14  901823     MOV [W3+52], W0
00BC16  9018B3     MOV [W3+54], W1
00BC18  2492A2     MOV #0x492A, W2
00BC1A  500FB2     SUB W0, [W2++], [W15]
00BC1C  588FA2     SUBB W1, [W2--], [W15]
00BC1E  32017B     BRA Z, 0xBF16
11730:                                         {
11731:                                             FileObjectCopy (cwdptr, tempCWD);
00BF16  248F61     MOV #0x48F6, W1
00BF18  780003     MOV W3, W0
00BF1A  07DD9C     RCALL FileObjectCopy
11732:                                             FSerrno = CE_INVALID_ARGUMENT;
00BF1C  B3C1F1     MOV #0x1F, W1
00BF1E  370014     BRA 0xBF48
11733:                                             return -1;
11734:                                         }
11735:                                     }
11736:                                     handle = 2;
00BC20  200020     MOV #0x2, W0
00BC22  9D97F0     MOV W0, [W15-594]
11737:                                     recache = TRUE;
00BC24  B3C011     MOV #0x1, W1
00BC26  270B80     MOV #0x70B8, W0
00BC28  784801     MOV.B W1, [W0]
00BC2A  370031     BRA 0xBC8E
11738:                                 }
11739:                                 else
11740:                                 {
11741:             						#if defined(SUPPORT_LFN)
11742:             						if(!tempCWD-> utf16LFNlength)
00BC2C  E00018     CP0 [W8]
00BC2E  3A000B     BRA NZ, 0xBC46
00BC30  780003     MOV W3, W0
00BC32  248D61     MOV #0x48D6, W1
00BC34  248DE2     MOV #0x48DE, W2
11743:             						#endif
11744:             						{
11745:                                 	    for (Index = 0; Index < 8; Index++)
00BC38  508F82     SUB W1, W2, [W15]
00BC3A  3AFFFD     BRA NZ, 0xBC36
00BC3C  418068     ADD W3, #0x8, W0
00BC3E  248E12     MOV #0x48E1, W2
11746:                                 	    {
11747:                                 	        fo->name[(BYTE)Index] = entry->DIR_Name[(BYTE)Index];
00BC36  7858B0     MOV.B [W0++], [W1++]
11748:                                 	    }
11749:             
11750:                                 	    for (Index = 0; Index < 3; Index++)
00BC42  508F82     SUB W1, W2, [W15]
00BC44  3AFFFD     BRA NZ, 0xBC40
00BC46  249228     MOV #0x4922, W8
11751:                                 	    {
11752:                                 	        fo->name[(BYTE)Index + 8] = entry->DIR_Extension[(BYTE)Index];
00BC40  7858B0     MOV.B [W0++], [W1++]
11753:                                 	    }
11754:             						}
11755:             
11756:                                     fo->dsk = &gDiskData;
00BC48  2485A0     MOV #0x485A, W0
00BC4A  8A45D0     MOV W0, gFileTemp
11757:             
11758:                                     fo->entry = handle;
00BC4C  95907F     MOV [W15-594], W0
00BC4E  8A4740     MOV W0, 0x48E8
11759:                                     fo->dirclus = cwdptr->dirclus;
00BC50  8385B0     MOV cwdptr, W0
00BC52  901920     MOV [W0+52], W2
00BC54  9019B0     MOV [W0+54], W3
00BC56  8A4772     MOV W2, 0x48EE
00BC58  8A4783     MOV W3, 0x48F0
11760:                                     fo->dirccls = cwdptr->dirccls;
00BC5A  901940     MOV [W0+56], W2
00BC5C  9019D0     MOV [W0+58], W3
00BC5E  8A4792     MOV W2, 0x48F2
00BC60  8A47A3     MOV W3, 0x48F4
11761:                                     fo->cluster = 0;
00BC62  248BC0     MOV #0x48BC, W0
00BC64  EB0800     CLR [W0]
00BC66  781030     MOV [W0++], [W0--]
11762:                                     fo->ccls    = 0;
00BC68  248C00     MOV #0x48C0, W0
00BC6A  EB0800     CLR [W0]
00BC6C  781030     MOV [W0++], [W0--]
11763:             
11764:                                     if (FILEerase(fo, &handle, TRUE))
00BC6E  B3C012     MOV #0x1, W2
00BC70  2FDAE1     MOV #0xFDAE, W1
00BC72  40808F     ADD W1, W15, W1
00BC74  248BA0     MOV #0x48BA, W0
00BC76  07F5C0     RCALL FILEerase
00BC78  E00000     CP0 W0
00BC7A  3A0152     BRA NZ, 0xBF20
11765:                                     {
11766:             							#if defined(SUPPORT_LFN)
11767:             							tempCWD-> utf16LFNlength = 0;
00BF20  EB0C00     CLR [W8]
11768:             							fo-> utf16LFNlength = 0;
00BF22  248E60     MOV #0x48E6, W0
00BF24  EB0800     CLR [W0]
11769:             							#endif
11770:                                         FileObjectCopy (cwdptr, tempCWD);
00BF26  8385B0     MOV cwdptr, W0
00BF28  248F61     MOV #0x48F6, W1
00BF2A  370007     BRA 0xBF3A
11771:                                         FSerrno = CE_ERASE_FAIL;
11772:                                         return -1;
11773:                                     }
11774:                                     else
11775:                                     {
11776:                                         handle++;
00BC7C  9591FF     MOV [W15-594], W3
00BC7E  E80183     INC W3, W3
00BC80  9D97F3     MOV W3, [W15-594]
11777:                                     }
11778:             						#if defined(SUPPORT_LFN)
11779:             						tempCWD-> utf16LFNlength = 0;
00BC82  8A4910     MOV W0, 0x4922
11780:             						fo-> utf16LFNlength = 0;
00BC84  8A4730     MOV W0, 0x48E6
00BC86  370003     BRA 0xBC8E
11781:             						#endif
11782:                                 } // Check to see if it's a DIR entry
11783:                             }// Check non-dir entry to see if its a valid file
11784:                             else
11785:                             {
11786:                                 handle++;
00BC88  95907F     MOV [W15-594], W0
00BC8A  E80000     INC W0, W0
00BC8C  9D97F0     MOV W0, [W15-594]
11787:                             }
11788:             
11789:                             if (recache)
00BC8E  270B80     MOV #0x70B8, W0
00BC90  8385B3     MOV cwdptr, W3
00BC94  E00410     CP0.B [W0]
00BC96  320006     BRA Z, 0xBCA4
11790:                             {
11791:                                 recache = FALSE;
00BC98  EB4800     CLR.B [W0]
11792:                                 cwdptr->dirccls = cwdptr->dirclus;
00BC9A  901823     MOV [W3+52], W0
00BC9C  9018B3     MOV [W3+54], W1
00BC9E  9819C0     MOV W0, [W3+56]
00BCA0  9819D1     MOV W1, [W3+58]
11793:                                 entry = Cache_File_Entry (cwdptr, &handle, TRUE);
00BCA2  B3C012     MOV #0x1, W2
11794:                             }
11795:                             else
11796:                             {
11797:                                 entry = Cache_File_Entry (cwdptr, &handle, FALSE);
00BC92  EB4100     CLR.B W2
00BCA4  2FDAE1     MOV #0xFDAE, W1
00BCA6  40808F     ADD W1, W15, W1
00BCA8  780003     MOV W3, W0
00BCAA  07DC7F     RCALL Cache_File_Entry
00BCAC  780180     MOV W0, W3
11798:                             }
11799:                             
11800:             				if (entry == NULL)
00BCAE  E00000     CP0 W0
00BCB0  3A00F8     BRA NZ, 0xBEA2
11801:                             {
11802:             					#if defined(SUPPORT_LFN)
11803:             					tempCWD-> utf16LFNlength = 0;
00BCB2  8A4910     MOV W0, 0x4922
11804:             					fo-> utf16LFNlength = 0;
00BCB4  8A4730     MOV W0, 0x48E6
00BCB6  370144     BRA 0xBF40
11805:             					#endif
11806:                                 FileObjectCopy (cwdptr, tempCWD);
11807:                                 FSerrno = CE_BADCACHEREAD;
11808:                                 return -1;
11809:                             }
11810:                         }
11811:                         else
11812:                         {
11813:             				#if defined(SUPPORT_LFN)
11814:             				tempCWD-> utf16LFNlength = 0;
00BCB8  EB0000     CLR W0
00BCBA  8A4910     MOV W0, 0x4922
11815:             				fo-> utf16LFNlength = 0;
00BCBC  8A4730     MOV W0, 0x48E6
11816:             				#endif
11817:             
11818:                             // We have reached the end of the directory
11819:                             if (subDirDepth != 0)
00BCBE  E0000D     CP0 W13
00BCC0  3200EE     BRA Z, 0xBE9E
11820:                             {
11821:                                 handle2 = 0;
00BCC2  2FDAE1     MOV #0xFDAE, W1
00BCC4  40808F     ADD W1, W15, W1
00BCC6  782880     MOV W0, [++W1]
11822:             
11823:                                 cwdptr->dirccls = cwdptr->dirclus;
00BCC8  8385B0     MOV cwdptr, W0
00BCCA  901920     MOV [W0+52], W2
00BCCC  9019B0     MOV [W0+54], W3
00BCCE  981842     MOV W2, [W0+56]
00BCD0  981853     MOV W3, [W0+58]
11824:                                 entry = Cache_File_Entry (cwdptr, &handle2, TRUE);
00BCD2  B3C012     MOV #0x1, W2
00BCD4  07DC6A     RCALL Cache_File_Entry
11825:                                 if (entry == NULL)
00BCD6  E00000     CP0 W0
00BCD8  320133     BRA Z, 0xBF40
11826:                                 {
11827:                                     FileObjectCopy (cwdptr, tempCWD);
11828:                                     FSerrno = CE_BADCACHEREAD;
11829:                                     return -1;
11830:                                 }
11831:             
11832:                                 // Get the cluster
11833:                                 handle2 = GetFullClusterNumber(entry); // Get complete cluster number.
00BCDA  900850     MOV [W0+26], W0
00BCDC  9D9F80     MOV W0, [W15-592]
11834:             
11835:             #ifndef __18CXX
11836:             	#ifdef SUPPORT_LFN
11837:             	if(utfModeFileName)
00BCDE  8385A0     MOV utfModeFileName, W0
00BCE0  E00000     CP0 W0
00BCE2  320002     BRA Z, 0xBCE8
11838:             
11839:                     Index3 = FSchdir (".\0.\0\0");
00BCE4  2EE6A0     MOV #0xEE6A, W0
00BCE6  370001     BRA 0xBCEA
11840:             
11841:             	else
11842:             
11843:             	#endif
11844:                     Index3 = FSchdir ("..");
00BCE8  2EE700     MOV #0xEE70, W0
00BCEA  07F988     RCALL FSchdir
00BCEC  8385B3     MOV cwdptr, W3
11845:             
11846:             #else
11847:             	#ifdef SUPPORT_LFN
11848:             	if(utfModeFileName)
11849:             
11850:                     Index3 = FSchdir (dotdotname1);
11851:             
11852:             	else
11853:             
11854:             	#endif
11855:                     Index3 = FSchdir (dotdotname);
11856:             
11857:             #endif
11858:                                 if(Index3)
00BCEE  E00000     CP0 W0
00BCF0  3A011D     BRA NZ, 0xBF2C
11859:                                 {
11860:                                     FileObjectCopy (cwdptr, tempCWD);
00BF2C  248F61     MOV #0x48F6, W1
00BF2E  780003     MOV W3, W0
00BF30  07DD91     RCALL FileObjectCopy
11861:                                     FSerrno = CE_DIR_NOT_FOUND;
00BF32  B3C0C1     MOV #0xC, W1
00BF34  370009     BRA 0xBF48
11862:                                     return -1;
11863:                                 }
11864:                                 // Return to our previous position in this directory
11865:                                 handle = 2;
00BCF2  200020     MOV #0x2, W0
00BCF4  9D97F0     MOV W0, [W15-594]
11866:                                 cwdptr->dirccls = cwdptr->dirclus;
00BCF6  901823     MOV [W3+52], W0
00BCF8  9018B3     MOV [W3+54], W1
00BCFA  9819C0     MOV W0, [W3+56]
00BCFC  9819D1     MOV W1, [W3+58]
11867:                                 entry = Cache_File_Entry (cwdptr, &handle, TRUE);
00BCFE  B3C012     MOV #0x1, W2
00BD00  2FDAE1     MOV #0xFDAE, W1
00BD02  40808F     ADD W1, W15, W1
00BD04  780003     MOV W3, W0
00BD06  370007     BRA 0xBD16
11868:                                 if (entry == NULL)
11869:                                 {
11870:                                     FileObjectCopy (cwdptr, tempCWD);
11871:                                     FSerrno = CE_BADCACHEREAD;
11872:                                     return -1;
11873:                                 }
11874:             
11875:                                 // Get the cluster
11876:                                 TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number.
11877:             
11878:                                 while ((TempClusterCalc != handle2) ||
00BD32  95980F     MOV [W15-592], W0
00BD34  200001     MOV #0x0, W1
00BD36  8249A2     MOV TempClusterCalc, W2
00BD38  8249B3     MOV 0x4936, W3
00BD3A  510F80     SUB W2, W0, [W15]
00BD3C  598F81     SUBB W3, W1, [W15]
00BD3E  3AFFE4     BRA NZ, 0xBD08
00BD40  B3CE52     MOV #0xE5, W2
00BD42  114F9A     SUBR.B W2, [W10], [W15]
00BD44  32FFE1     BRA Z, 0xBD08
00BD46  90483A     MOV.B [W10+11], W0
00BD48  504FE8     SUB.B W0, #0x8, [W15]
00BD4A  32FFDE     BRA Z, 0xBD08
11879:                                 ((TempClusterCalc == handle2) &&
11880:                                 (((unsigned char)entry->DIR_Name[0] == 0xE5) || (entry->DIR_Attr == ATTR_VOLUME))))
11881:                                 {
11882:                                     handle++;
00BD08  9590FF     MOV [W15-594], W1
00BD0A  E80081     INC W1, W1
00BD0C  9D97F1     MOV W1, [W15-594]
11883:                                     entry = Cache_File_Entry (cwdptr, &handle, FALSE);
00BD0E  8385B0     MOV cwdptr, W0
00BD10  EB4100     CLR.B W2
00BD12  2FDAE1     MOV #0xFDAE, W1
00BD14  40808F     ADD W1, W15, W1
00BD16  07DC49     RCALL Cache_File_Entry
00BD18  780500     MOV W0, W10
11884:                                     if (entry == NULL)
00BD1A  E00000     CP0 W0
00BD1C  320111     BRA Z, 0xBF40
11885:                                     {
11886:                                         FileObjectCopy (cwdptr, tempCWD);
11887:                                         FSerrno = CE_BADCACHEREAD;
11888:                                         return -1;
11889:                                     }
11890:                                     // Get the cluster
11891:                                     TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number in a loop.
00BD26  90095A     MOV [W10+26], W2
00BD28  200003     MOV #0x0, W3
00BD2A  700002     IOR W0, W2, W0
00BD2C  708083     IOR W1, W3, W1
00BD2E  8A49A0     MOV W0, TempClusterCalc
00BD30  8A49B1     MOV W1, 0x4936
11892:                                 }
11893:             
11894:             					Index3 = 0;
11895:             					#if defined(SUPPORT_LFN)
11896:                     			FileObjectCopy (&cwdTemp, cwdptr);
00BD4C  8385B1     MOV cwdptr, W1
00BD4E  2FDB43     MOV #0xFDB4, W3
00BD50  478003     ADD W15, W3, W0
00BD52  07DE80     RCALL FileObjectCopy
11897:             					prevHandle = handle - 1;
00BD54  9590FF     MOV [W15-594], W1
00BD56  E90001     DEC W1, W0
00BD58  9D9F90     MOV W0, [W15-590]
11898:             					lfno = (LFN_ENTRY *)Cache_File_Entry (cwdptr, &prevHandle, FALSE);
00BD5A  8385B0     MOV cwdptr, W0
00BD5C  EB4100     CLR.B W2
00BD5E  2FDB23     MOV #0xFDB2, W3
00BD60  478083     ADD W15, W3, W1
00BD62  07DC23     RCALL Cache_File_Entry
00BD64  780100     MOV W0, W2
00BD66  78040C     MOV W12, W8
00BD68  EB0580     CLR W11
00BD6A  370049     BRA 0xBDFE
11899:             
11900:             
11901:             					while((lfno->LFN_Attribute == ATTR_LONG_NAME) && (lfno->LFN_SequenceNo != DIR_DEL)
00BDFE  904832     MOV.B [W2+11], W0
00BE00  504FEF     SUB.B W0, #0xF, [W15]
00BE02  3A0005     BRA NZ, 0xBE0E
00BE04  784012     MOV.B [W2], W0
00BE06  404FFB     ADD.B W0, #0x1B, [W15]
00BE08  320002     BRA Z, 0xBE0E
00BE0A  E00400     CP0.B W0
00BE0C  3AFFAF     BRA NZ, 0xBD6C
11902:             							&& (lfno->LFN_SequenceNo != DIR_EMPTY))
11903:             					{
11904:             						tempShift.byte.LB = lfno->LFN_Part1[0];
00BD6C  904012     MOV.B [W2+1], W0
00BD6E  FB8000     ZE W0, W0
00BD70  2FF001     MOV #0xFF00, W1
00BD72  648481     AND W9, W1, W9
00BD74  748480     IOR W9, W0, W9
11905:             						tempShift.byte.HB = lfno->LFN_Part1[1];
00BD76  904022     MOV.B [W2+2], W0
00BD78  DD0048     SL W0, #8, W0
00BD7A  B20FF9     AND #0xFF, W9
00BD7C  748480     IOR W9, W0, W9
11906:             						tempLFN[Index3++] = tempShift.Val;
00BD7E  780C09     MOV W9, [W8]
11907:             						tempShift.byte.LB = lfno->LFN_Part1[2];
00BD80  904032     MOV.B [W2+3], W0
00BD82  FB8000     ZE W0, W0
00BD84  648481     AND W9, W1, W9
00BD86  748480     IOR W9, W0, W9
11908:             						tempShift.byte.HB = lfno->LFN_Part1[3];
00BD88  904042     MOV.B [W2+4], W0
00BD8A  DD0048     SL W0, #8, W0
00BD8C  B20FF9     AND #0xFF, W9
00BD8E  748480     IOR W9, W0, W9
11909:             						tempLFN[Index3++] = tempShift.Val;
00BD90  980419     MOV W9, [W8+2]
11910:             						tempShift.byte.LB = lfno->LFN_Part1[4];
00BD92  904052     MOV.B [W2+5], W0
00BD94  FB8000     ZE W0, W0
00BD96  648481     AND W9, W1, W9
00BD98  748480     IOR W9, W0, W9
11911:             						tempShift.byte.HB = lfno->LFN_Part1[5];
00BD9A  904062     MOV.B [W2+6], W0
00BD9C  DD0048     SL W0, #8, W0
00BD9E  B20FF9     AND #0xFF, W9
00BDA0  748480     IOR W9, W0, W9
11912:             						tempLFN[Index3++] = tempShift.Val;
00BDA2  980429     MOV W9, [W8+4]
11913:             						tempShift.byte.LB = lfno->LFN_Part1[6];
00BDA4  904072     MOV.B [W2+7], W0
00BDA6  FB8000     ZE W0, W0
00BDA8  648481     AND W9, W1, W9
00BDAA  748480     IOR W9, W0, W9
11914:             						tempShift.byte.HB = lfno->LFN_Part1[7];
00BDAC  904802     MOV.B [W2+8], W0
00BDAE  DD0048     SL W0, #8, W0
00BDB0  B20FF9     AND #0xFF, W9
00BDB2  748480     IOR W9, W0, W9
11915:             						tempLFN[Index3++] = tempShift.Val;
00BDB4  980439     MOV W9, [W8+6]
11916:             						tempShift.byte.LB = lfno->LFN_Part1[8];
00BDB6  904812     MOV.B [W2+9], W0
00BDB8  FB8000     ZE W0, W0
00BDBA  648481     AND W9, W1, W9
00BDBC  748480     IOR W9, W0, W9
11917:             						tempShift.byte.HB = lfno->LFN_Part1[9];
00BDBE  904822     MOV.B [W2+10], W0
00BDC0  DD0048     SL W0, #8, W0
00BDC2  B20FF9     AND #0xFF, W9
00BDC4  748480     IOR W9, W0, W9
11918:             						tempLFN[Index3++] = tempShift.Val;
00BDC6  980449     MOV W9, [W8+8]
11919:             
11920:             						tempLFN[Index3++] = lfno->LFN_Part2[0];
00BDC8  900072     MOV [W2+14], W0
00BDCA  980450     MOV W0, [W8+10]
11921:             						tempLFN[Index3++] = lfno->LFN_Part2[1];
00BDCC  900882     MOV [W2+16], W1
00BDCE  980461     MOV W1, [W8+12]
11922:             						tempLFN[Index3++] = lfno->LFN_Part2[2];
00BDD0  900992     MOV [W2+18], W3
00BDD2  980473     MOV W3, [W8+14]
11923:             						tempLFN[Index3++] = lfno->LFN_Part2[3];
00BDD4  900822     MOV [W2+20], W0
00BDD6  980C00     MOV W0, [W8+16]
11924:             						tempLFN[Index3++] = lfno->LFN_Part2[4];
00BDD8  9008B2     MOV [W2+22], W1
00BDDA  980C11     MOV W1, [W8+18]
11925:             						tempLFN[Index3++] = lfno->LFN_Part2[5];
00BDDC  9009C2     MOV [W2+24], W3
00BDDE  980C23     MOV W3, [W8+20]
11926:             
11927:             						tempLFN[Index3++] = lfno->LFN_Part3[0];
00BDE0  900862     MOV [W2+28], W0
00BDE2  980C30     MOV W0, [W8+22]
11928:             						tempLFN[Index3++] = lfno->LFN_Part3[1];
00BDE4  900972     MOV [W2+30], W2
00BDE6  980C42     MOV W2, [W8+24]
00BDE8  4585ED     ADD W11, #0xD, W11
11929:             				
11930:             						prevHandle = prevHandle - 1;
00BDEA  95981F     MOV [W15-590], W0
00BDEC  E90000     DEC W0, W0
00BDEE  9D9F90     MOV W0, [W15-590]
11931:             						lfno = (LFN_ENTRY *)Cache_File_Entry (cwdptr, &prevHandle, FALSE);
00BDF0  8385B0     MOV cwdptr, W0
00BDF2  EB4100     CLR.B W2
00BDF4  2FDB23     MOV #0xFDB2, W3
00BDF6  478083     ADD W15, W3, W1
00BDF8  07DBD8     RCALL Cache_File_Entry
00BDFA  780100     MOV W0, W2
00BDFC  44047A     ADD W8, #0x1A, W8
11932:             					}
11933:             
11934:             					FileObjectCopy (cwdptr, &cwdTemp);
00BE0E  8385B0     MOV cwdptr, W0
00BE10  2FDB42     MOV #0xFDB4, W2
00BE12  478082     ADD W15, W2, W1
00BE14  07DE1F     RCALL FileObjectCopy
11935:             
11936:             					#endif
11937:             
11938:             					if(Index3 == 0)
00BE16  E0000B     CP0 W11
00BE18  3A001B     BRA NZ, 0xBE50
11939:             					{
11940:                             	    memset (tempArray, 0x00, 12);
00BE1A  2FDF08     MOV #0xFDF0, W8
00BE1C  478408     ADD W15, W8, W8
00BE1E  2000C2     MOV #0xC, W2
00BE20  78008B     MOV W11, W1
00BE22  780008     MOV W8, W0
00BE24  07CC7D     RCALL memset
00BE26  78000A     MOV W10, W0
00BE28  780088     MOV W8, W1
00BE2A  2FDF82     MOV #0xFDF8, W2
00BE2C  478102     ADD W15, W2, W2
11941:                             	    for (Index = 0; Index < 8; Index++)
00BE30  508F82     SUB W1, W2, [W15]
00BE32  3AFFFD     BRA NZ, 0xBE2E
00BE34  450068     ADD W10, #0x8, W0
00BE36  2FDFB2     MOV #0xFDFB, W2
00BE38  478102     ADD W15, W2, W2
11942:                             	    {
11943:                             	        tempArray[(BYTE)Index] = entry->DIR_Name[(BYTE)Index];
00BE2E  7858B0     MOV.B [W0++], [W1++]
11944:                             	    }
11945:                             	    for (Index = 0; Index < 3; Index++)
00BE3C  508F82     SUB W1, W2, [W15]
00BE3E  3AFFFD     BRA NZ, 0xBE3A
11946:                             	    {
11947:                             	        tempArray[(BYTE)Index + 8] = entry->DIR_Extension[(BYTE)Index];
00BE3A  7858B0     MOV.B [W0++], [W1++]
11948:                             	    }
11949:             						#if defined(SUPPORT_LFN)
11950:             						cwdptr->utf16LFNlength = 0;
00BE40  EB0080     CLR W1
00BE42  8385B0     MOV cwdptr, W0
00BE44  981061     MOV W1, [W0+44]
00BE46  370014     BRA 0xBE70
11951:             						#endif
11952:             					}
11953:             					#if defined(SUPPORT_LFN)
11954:             					else
11955:             					{
11956:             						cwdptr->utf16LFNlength = Index3;
00BE50  8385B0     MOV cwdptr, W0
00BE52  98106B     MOV W11, [W0+44]
00BE54  5580EC     SUB W11, #0xC, W1
00BE56  45800B     ADD W11, W11, W0
00BE58  460000     ADD W12, W0, W0
00BE5A  50007A     SUB W0, #0x1A, W0
00BE5C  B3C0C2     MOV #0xC, W2
11957:             						
11958:             						for(Index = 12;Index >= 0;Index--)
00BE62  E94102     DEC.B W2, W2
00BE64  E80081     INC W1, W1
00BE66  E88000     INC2 W0, W0
00BE68  414FE1     ADD.B W2, #0x1, [W15]
00BE6A  3AFFF9     BRA NZ, 0xBE5E
11959:             						{
11960:             							if((tempLFN[Index3 - Index - 1]) == 0x0000)
00BE5E  E00010     CP0 [W0]
00BE60  32FFF3     BRA Z, 0xBE48
11961:             							{
11962:             								cwdptr->utf16LFNlength = Index3 - Index - 1;
00BE48  E90081     DEC W1, W1
00BE4A  8385B0     MOV cwdptr, W0
00BE4C  981061     MOV W1, [W0+44]
00BE4E  37000E     BRA 0xBE6C
11963:             								break;
11964:             							}
11965:             						}
11966:             
11967:             						cwdptr->utf16LFNptr = (unsigned short int *)&tempArray[0];
00BE6C  8385B0     MOV cwdptr, W0
00BE6E  98105C     MOV W12, [W0+42]
11968:             					}
11969:             					#endif
11970:                                 // Erase the directory that we just cleared the subdirectories out of
11971:             
11972:                                 if (eraseDir (&tempArray[0]))
00BE70  2FDF00     MOV #0xFDF0, W0
00BE72  478000     ADD W15, W0, W0
00BE74  07F530     RCALL eraseDir
00BE76  8385B3     MOV cwdptr, W3
00BE78  E00000     CP0 W0
00BE7A  3A005D     BRA NZ, 0xBF36
11973:                                 {
11974:                                     FileObjectCopy (cwdptr, tempCWD);
00BF36  248F61     MOV #0x48F6, W1
00BF38  780003     MOV W3, W0
00BF3A  07DD8C     RCALL FileObjectCopy
11975:                                     FSerrno = CE_ERASE_FAIL;
00BF3C  B3C011     MOV #0x1, W1
00BF3E  370004     BRA 0xBF48
11976:                                     return -1;
11977:                                 }
11978:                                 else
11979:                                 {
11980:                                     handle++;
00BE7C  95907F     MOV [W15-594], W0
00BE7E  E80000     INC W0, W0
00BE80  9D97F0     MOV W0, [W15-594]
11981:                                     cwdptr->dirccls = cwdptr->dirclus;
00BE82  901823     MOV [W3+52], W0
00BE84  9018B3     MOV [W3+54], W1
00BE86  9819C0     MOV W0, [W3+56]
00BE88  9819D1     MOV W1, [W3+58]
11982:                                     entry = Cache_File_Entry (cwdptr, &handle, TRUE);
00BE8A  B3C012     MOV #0x1, W2
00BE8C  2FDAE1     MOV #0xFDAE, W1
00BE8E  40808F     ADD W1, W15, W1
00BE90  780003     MOV W3, W0
00BE92  07DB8B     RCALL Cache_File_Entry
00BE94  780180     MOV W0, W3
11983:                                     if (entry == NULL)
00BE96  E00000     CP0 W0
00BE98  320053     BRA Z, 0xBF40
11984:                                     {
11985:                                         FileObjectCopy (cwdptr, tempCWD);
00BF40  8385B0     MOV cwdptr, W0
00BF42  248F61     MOV #0x48F6, W1
00BF44  07DD87     RCALL FileObjectCopy
11986:                                         FSerrno = CE_BADCACHEREAD;
00BF46  B3C1B1     MOV #0x1B, W1
00BF48  249380     MOV #0x4938, W0
00BF4A  784801     MOV.B W1, [W0]
00BF4C  37FD5E     BRA 0xBA0A
11987:                                         return -1;
11988:                                     }
11989:                                 }
11990:             
11991:                                 // Decrease the subdirectory depth
11992:                                 subDirDepth--;
00BE9A  E9068D     DEC W13, W13
00BE9C  370002     BRA 0xBEA2
11993:                             }
11994:                             else
11995:                             {
11996:                                 dirCleared = TRUE;
00BE9E  B3C010     MOV #0x1, W0
00BEA0  784880     MOV.B W0, [W1]
11997:                             } // Check subdirectory depth
11998:                         } // Check until we get an empty entry
11999:                     } // Loop until the whole dir is cleared
12000:                 }
12001:             
12002:                 // Cache the current directory name
12003:                 // tempArray is used so we don't disturb the
12004:                 // global getcwd buffer
12005:                 if (FSgetcwd (&tempArray[0], 2) == NULL)
00BEA8  2FDF09     MOV #0xFDF0, W9
00BEAA  478489     ADD W15, W9, W9
00BEAC  200021     MOV #0x2, W1
00BEAE  780009     MOV W9, W0
00BEB0  07F9B0     RCALL FSgetcwd
00BEB2  8385B3     MOV cwdptr, W3
00BEB4  E00000     CP0 W0
00BEB6  3A0004     BRA NZ, 0xBEC0
12006:                 {
12007:                     FileObjectCopy (cwdptr, tempCWD);
00BEB8  248F61     MOV #0x48F6, W1
00BEBA  780003     MOV W3, W0
00BEBC  07DDCB     RCALL FileObjectCopy
00BEBE  37FDA5     BRA 0xBA0A
12008:                     return -1;
12009:                 }
12010:             	else
12011:             	{
12012:             		#if defined(SUPPORT_LFN)
12013:             			if(!cwdptr->utf16LFNlength)
00BEC0  901463     MOV [W3+44], W8
00BEC2  E00008     CP0 W8
00BEC4  3A000C     BRA NZ, 0xBEDE
12014:             		#endif
12015:             			{
12016:                     		memset (tempArray, 0x00, 12);
00BEC6  2000C2     MOV #0xC, W2
00BEC8  780088     MOV W8, W1
00BECA  780009     MOV W9, W0
00BECC  07CC29     RCALL memset
00BECE  780088     MOV W8, W1
00BED0  780109     MOV W9, W2
00BED2  8385B0     MOV cwdptr, W0
00BED4  40007C     ADD W0, #0x1C, W0
12017:                     		for (Index = 0; Index < 11; Index++)
00BEDA  508FEB     SUB W1, #0xB, [W15]
00BEDC  3AFFFC     BRA NZ, 0xBED6
12018:                     		{
12019:                         		tempArray[(BYTE)Index] = cwdptr->name[(BYTE)Index];
00BED6  7970B0     MOV.B [W0++], [W1+W2]
00BED8  E80081     INC W1, W1
12020:                     		}			
12021:             			}
12022:             	}
12023:             
12024:                 // If we're here, this directory is empty
12025:             #ifndef __18CXX
12026:             	#ifdef SUPPORT_LFN
12027:             	if(utfModeFileName)
00BEDE  8385A0     MOV utfModeFileName, W0
00BEE0  E00000     CP0 W0
00BEE2  320002     BRA Z, 0xBEE8
12028:             
12029:                     Index3 = FSchdir (".\0.\0\0");
00BEE4  2EE6A0     MOV #0xEE6A, W0
00BEE6  370001     BRA 0xBEEA
12030:             
12031:             	else
12032:             
12033:             	#endif
12034:                     Index3 = FSchdir ("..");
00BEE8  2EE700     MOV #0xEE70, W0
00BEEA  07F888     RCALL FSchdir
00BEEC  8385B3     MOV cwdptr, W3
12035:             
12036:             #else
12037:             	#ifdef SUPPORT_LFN
12038:             	if(utfModeFileName)
12039:             
12040:                     Index3 = FSchdir (dotdotname1);
12041:             
12042:             	else
12043:             
12044:             	#endif
12045:                     Index3 = FSchdir (dotdotname);
12046:             
12047:             #endif
12048:                 if(Index3)
00BEEE  E00000     CP0 W0
00BEF0  3A001D     BRA NZ, 0xBF2C
12049:                 {
12050:                     FileObjectCopy (cwdptr, tempCWD);
12051:                     FSerrno = CE_DIR_NOT_FOUND;
12052:                     return -1;
12053:                 }
12054:             
12055:             	#if defined(SUPPORT_LFN)
12056:             	if(cwdptr->utf16LFNlength)
00BEF2  901063     MOV [W3+44], W0
00BEF4  E00000     CP0 W0
00BEF6  320002     BRA Z, 0xBEFC
12057:             	{
12058:             		Index3 = eraseDir((char *)cwdptr->utf16LFNptr);
00BEF8  901053     MOV [W3+42], W0
00BEFA  370002     BRA 0xBF00
12059:             	}
12060:             	else
12061:             	#endif
12062:             	{
12063:             		Index3 = eraseDir(tempArray);
00BEFC  2FDF00     MOV #0xFDF0, W0
00BEFE  478000     ADD W15, W0, W0
00BF00  07F4EA     RCALL eraseDir
00BF02  780400     MOV W0, W8
00BF04  8385B3     MOV cwdptr, W3
12064:             	}
12065:             
12066:                 if (Index3)
00BF06  E00000     CP0 W0
00BF08  320022     BRA Z, 0xBF4E
00BF0A  370015     BRA 0xBF36
12067:                 {
12068:                     FileObjectCopy (cwdptr, tempCWD);
12069:                     FSerrno = CE_ERASE_FAIL;
12070:                     return -1;
12071:                 }
12072:                 else
12073:                 {
12074:                     FileObjectCopy (cwdptr, tempCWD);
00BF4E  248F61     MOV #0x48F6, W1
00BF50  780003     MOV W3, W0
00BF52  07DD80     RCALL FileObjectCopy
00BF54  780008     MOV W8, W0
12075:                     return 0;
12076:                 }
12077:             }
00BF64  780200     MOV W0, W4
12078:             
12079:             
12080:             /****************************************************************
12081:               Function:
12082:                 int eraseDir (char * path)
12083:               Summary:
12084:                 FSrmdir helper function to erase dirs
12085:               Conditions:
12086:                 This function should not be called by the user.
12087:               Input:
12088:                 path -  The name of the directory to delete
12089:               Return Values:
12090:                 0 -  Dir was deleted successfully
12091:                 -1 - Dir could not be deleted.
12092:               Side Effects:
12093:                 None
12094:               Description:
12095:                 The eraseDir function is a helper function for the rmdirhelper
12096:                 function.  The eraseDir function will search for the
12097:                 directory that matches the specified path name and then erase
12098:                 it with the FILEerase function.
12099:               Remarks:
12100:                 None.
12101:               *****************************************************************/
12102:             
12103:             int eraseDir (char * path)
12104:             {
12105:                 int result;
12106:                 BYTE Index;
12107:                 FSFILE tempCWDobj2;
12108:             
12109:                 if (MDD_WriteProtectState())
00A8DC  071718     RCALL MDD_SDSPI_WriteProtectState
00A8DE  EB8400     SETM W8
00A8E0  E00400     CP0.B W0
00A8E2  3A0028     BRA NZ, 0xA934
12110:                 {
12111:                     return (-1);
12112:                 }
12113:             
12114:                 // preserve CWD
12115:                 FileObjectCopy(&tempCWDobj2, cwdptr);
00A8E4  8385B1     MOV cwdptr, W1
00A8E6  2FFC00     MOV #0xFFC0, W0
00A8E8  40000F     ADD W0, W15, W0
00A8EA  07E8B4     RCALL FileObjectCopy
12116:             
12117:             	// If long file name not present, copy the 8.3 name in cwdptr
12118:             	#if defined(SUPPORT_LFN)
12119:                 if(!cwdptr->utf16LFNlength)
00A8EC  8385B0     MOV cwdptr, W0
00A8EE  901060     MOV [W0+44], W0
00A8F0  E00000     CP0 W0
00A8F2  3A0008     BRA NZ, 0xA904
00A8F4  780100     MOV W0, W2
12120:             	#endif
12121:                 {
12122:                 	for (Index = 0; Index <11; Index++)
00A900  510FEB     SUB W2, #0xB, [W15]
00A902  3AFFF9     BRA NZ, 0xA8F6
12123:                 	{
12124:                     	cwdptr->name[Index] = *(path + Index);
00A8F6  4100FC     ADD W2, #0x1C, W1
00A8F8  8385B0     MOV cwdptr, W0
00A8FA  7CC1E2     MOV.B [W2+W9], W3
00A8FC  78F003     MOV.B W3, [W0+W1]
00A8FE  E80102     INC W2, W2
12125:                 	}
12126:             	}
12127:             
12128:                 // copy file object over
12129:                 FileObjectCopy(&gFileTemp, cwdptr);
00A904  8385B1     MOV cwdptr, W1
00A906  248BA0     MOV #0x48BA, W0
00A908  07E8A5     RCALL FileObjectCopy
12130:             
12131:                 // See if the file is found
12132:             	if(FILEfind (cwdptr, &gFileTemp, LOOK_FOR_MATCHING_ENTRY, 0) == CE_GOOD)
00A90A  8385B0     MOV cwdptr, W0
00A90C  EB4180     CLR.B W3
00A90E  B3C012     MOV #0x1, W2
00A910  248BA1     MOV #0x48BA, W1
00A912  07F804     RCALL FILEfind
00A914  E00000     CP0 W0
00A916  3A0009     BRA NZ, 0xA92A
12133:             	{
12134:             		if(FILEerase(cwdptr, &cwdptr->entry, TRUE) == CE_GOOD)
00A918  8385B0     MOV cwdptr, W0
00A91A  2002E1     MOV #0x2E, W1
00A91C  408080     ADD W1, W0, W1
00A91E  B3C012     MOV #0x1, W2
00A920  07FF6B     RCALL FILEerase
00A922  E00000     CP0 W0
00A924  3A0002     BRA NZ, 0xA92A
00A926  780400     MOV W0, W8
00A928  370001     BRA 0xA92C
00A92A  EB8400     SETM W8
12135:             			result = 0;
12136:             		else
12137:             			result = -1;
12138:             	}
12139:             	else
12140:             		result = -1;
12141:             
12142:             	FileObjectCopy(cwdptr, &tempCWDobj2);
00A92C  8385B0     MOV cwdptr, W0
00A92E  2FFC01     MOV #0xFFC0, W1
00A930  40808F     ADD W1, W15, W1
00A932  07E890     RCALL FileObjectCopy
12143:             	return(result);
12144:             }
00A93C  FA0240     LNK #0x240
00A93E  BE9F88     MOV.D W8, [W15++]
00A940  781F8A     MOV W10, [W15++]
00A942  780480     MOV W0, W9
12145:             #endif
12146:             
12147:             
12148:             #endif
12149:             
12150:             
12151:             #ifdef ALLOW_FILESEARCH
12152:             
12153:             
12154:             /***********************************************************************************
12155:               Function:
12156:                 int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec)
12157:               Summary:
12158:                 Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices.
12159:               Conditions:
12160:                 None
12161:               Input:
12162:                 fileName - The name to search for
12163:                          - Parital string search characters
12164:                          - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*)
12165:                          - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T)
12166:                 attr -            The attributes that a found file may have
12167:                      - ATTR_READ_ONLY -  File may be read only
12168:                      - ATTR_HIDDEN -     File may be a hidden file
12169:                      - ATTR_SYSTEM -     File may be a system file
12170:                      - ATTR_VOLUME -     Entry may be a volume label
12171:                      - ATTR_DIRECTORY -  File may be a directory
12172:                      - ATTR_ARCHIVE -    File may have archive attribute
12173:                      - ATTR_MASK -       All attributes
12174:                 rec -             pointer to a structure to put the file information in
12175:               Return Values:
12176:                 0 -  File was found
12177:                 -1 - No file matching the specified criteria was found
12178:               Side Effects:
12179:                 Search criteria from previous FindFirst call on passed SearchRec object
12180:                 will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext
12181:                 operations.It is the responsibility of the application to read the "utf16LFNfound"
12182:                 before it is lost.The FSerrno variable will be changed.
12183:               Description:
12184:                 Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices.
12185:                 The FindFirst function will search for a file based on parameters passed in
12186:                 by the user.  This function will use the FILEfind function to parse through
12187:                 the current working directory searching for entries that match the specified
12188:                 parameters.  If a file is found, its parameters are copied into the SearchRec
12189:                 structure, as are the initial parameters passed in by the user and the position
12190:                 of the file entry in the current working directory.If the return value of the 
12191:                 function is 0 then "utf16LFNfoundLength" indicates whether the file found was 
12192:                 long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero
12193:                 for long file name and is zero for 8P3 format."utf16LFNfound" points to the
12194:                 address of long file name if found during the operation.
12195:               Remarks:
12196:                 Call FindFirst or FindFirstpgm before calling FindNext
12197:               ***********************************************************************************/
12198:             
12199:             int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec)
12200:             {
00A2C0  E90003     DEC W3, W0
00A2C2  400000     ADD W0, W0, W0
00A2C4  2494A1     MOV #0x494A, W1
00A2C6  400281     ADD W0, W1, W5
00A2C8  400082     ADD W0, W2, W1
00A2CA  780004     MOV W4, W0
00A2CC  370002     BRA 0xA2D2
12201:                 FSFILE f;
12202:                 FILEOBJ fo = &f;
12203:                 WORD fHandle;
12204:                 BYTE j;
12205:                 BYTE Index;
12206:             	#ifdef SUPPORT_LFN
12207:             		short int indexLFN;
12208:             	#endif
12209:             
12210:                 FSerrno = CE_GOOD;
00A1FC  24938A     MOV #0x4938, W10
00A1FE  EB4480     CLR.B W9
00A200  784D09     MOV.B W9, [W10]
12211:             
12212:             	#ifdef SUPPORT_LFN
12213:             		fo->utf16LFNptr = &recordSearchName[0];
00A202  24D580     MOV #0x4D58, W0
00A204  9FB7A0     MOV W0, [W15-28]
12214:             		rec->utf16LFNfound = &recordFoundName[0];
00A206  24B560     MOV #0x4B56, W0
00A208  980940     MOV W0, [W2+24]
12215:             	#endif
12216:             
12217:             	// Format the file name as per 8.3 format or LFN format
12218:                 if( !FormatFileName(fileName, fo, 1) )
00A20A  B3C012     MOV #0x1, W2
00A20C  2FFBA0     MOV #0xFFBA, W0
00A20E  478080     ADD W15, W0, W1
00A210  78000B     MOV W11, W0
00A212  07F1B0     RCALL FormatFileName
00A214  E00400     CP0.B W0
00A216  3A0003     BRA NZ, 0xA21E
12219:                 {
12220:                     FSerrno = CE_INVALID_FILENAME;
00A218  B3C120     MOV #0x12, W0
00A21A  784D00     MOV.B W0, [W10]
00A21C  3700A8     BRA 0xA36E
12221:                     return -1;
12222:                 }
12223:             
12224:                 rec->initialized = FALSE;
00A21E  987409     MOV.B W9, [W8+48]
12225:             
12226:             	#if defined(SUPPORT_LFN)
12227:             	rec->AsciiEncodingType = fo->AsciiEncodingType;
00A220  97B09F     MOV [W15-30], W1
00A222  980C31     MOV W1, [W8+22]
12228:             	recordSearchLength = fo->utf16LFNlength;
00A224  97B03F     MOV [W15-26], W0
00A226  8A5AA0     MOV W0, recordSearchLength
12229:             
12230:             	// If file name is 8.3 format copy it in 'searchname' string
12231:                 if(!recordSearchLength)
00A228  E00000     CP0 W0
00A22A  3A0013     BRA NZ, 0xA252
00A22C  4401FE     ADD W8, #0x1E, W3
00A22E  780100     MOV W0, W2
00A230  370005     BRA 0xA23C
12232:             	#endif
12233:                 {
12234:                 	for (Index = 0; (Index < 12) && (fileName[Index] != 0); Index++)
00A238  510FEC     SUB W2, #0xC, [W15]
00A23A  320009     BRA Z, 0xA24E
00A23C  784082     MOV.B W2, W1
00A23E  7DC062     MOV.B [W2+W11], W0
00A240  E00400     CP0.B W0
00A242  3AFFF7     BRA NZ, 0xA232
12235:                 	{
12236:                     	rec->searchname[Index] = fileName[Index];
00A232  785980     MOV.B W0, [W3++]
00A234  E84081     INC.B W1, W1
00A236  E80102     INC W2, W2
12237:                 	}
12238:             
12239:                 	for (;Index < FILE_NAME_SIZE_8P3 + 2; Index++)
00A24C  E84081     INC.B W1, W1
00A24E  50CFEC     SUB.B W1, #0xC, [W15]
00A250  36FFF9     BRA LEU, 0xA244
12240:                 	{
12241:                     	rec->searchname[Index] = 0;
00A244  FB8001     ZE W1, W0
00A246  40007E     ADD W0, #0x1E, W0
00A248  440000     ADD W8, W0, W0
00A24A  EB4800     CLR.B [W0]
12242:                 	}
12243:             	}
12244:             
12245:                 rec->searchattr = attr;
00A252  986C3C     MOV.B W12, [W8+43]
12246:             #ifdef ALLOW_DIRS
12247:                 rec->cwdclus = cwdptr->dirclus;
00A254  8385B2     MOV cwdptr, W2
00A256  901822     MOV [W2+52], W0
00A258  9018B2     MOV [W2+54], W1
00A25A  981460     MOV W0, [W8+44]
00A25C  981471     MOV W1, [W8+46]
12248:             #else
12249:                 rec->cwdclus = FatRootDirClusterValue;
12250:             #endif
12251:             
12252:                 fo->dsk = &gDiskData;
00A25E  2FFBA1     MOV #0xFFBA, W1
00A260  478481     ADD W15, W1, W9
00A262  2485A0     MOV #0x485A, W0
00A264  780C80     MOV W0, [W9]
12253:                 fo->cluster = 0;
00A266  B80060     MUL.UU W0, #0, W0
00A268  980490     MOV W0, [W9+2]
00A26A  9804A1     MOV W1, [W9+4]
12254:                 fo->ccls    = 0;
00A26C  9FA780     MOV W0, [W15-64]
00A26E  9FA791     MOV W1, [W15-62]
12255:                 fo->entry = 0;
00A270  EB0000     CLR W0
00A272  9FB7C0     MOV W0, [W15-24]
12256:                 fo->attributes = attr;
00A274  9FB7EC     MOV W12, [W15-20]
12257:             
12258:             #ifndef ALLOW_DIRS
12259:                 // start at the root directory
12260:                 fo->dirclus    = FatRootDirClusterValue;
12261:                 fo->dirccls    = FatRootDirClusterValue;
12262:             #else
12263:                 fo->dirclus = cwdptr->dirclus;
00A276  901822     MOV [W2+52], W0
00A278  9018B2     MOV [W2+54], W1
00A27A  9FB7F0     MOV W0, [W15-18]
00A27C  9FBF81     MOV W1, [W15-16]
12264:                 fo->dirccls = cwdptr->dirccls;
00A27E  901842     MOV [W2+56], W0
00A280  9018D2     MOV [W2+58], W1
00A282  9FBF90     MOV W0, [W15-14]
00A284  9FBFA1     MOV W1, [W15-12]
12265:             #endif
12266:             
12267:                 // copy file object over
12268:                 FileObjectCopy(&gFileTemp, fo);
00A286  780089     MOV W9, W1
00A288  248BA0     MOV #0x48BA, W0
00A28A  07EBE4     RCALL FileObjectCopy
12269:             
12270:                 // See if the file is found
12271:                 if (FILEfind (fo, &gFileTemp,LOOK_FOR_MATCHING_ENTRY, 1) != CE_GOOD)
00A28C  B3C013     MOV #0x1, W3
00A28E  784103     MOV.B W3, W2
00A290  248BA1     MOV #0x48BA, W1
00A292  780009     MOV W9, W0
00A294  07FB43     RCALL FILEfind
00A298  E00000     CP0 W0
00A29A  3A0067     BRA NZ, 0xA36A
12272:                 {
12273:                     FSerrno = CE_FILE_NOT_FOUND;
00A296  B3C0B1     MOV #0xB, W1
12274:                     return -1;
12275:                 }
12276:             
12277:                 fHandle = fo->entry;
00A29C  97B0CF     MOV [W15-24], W1
00A29E  9F9FC1     MOV W1, [W15-72]
12278:             
12279:                 if (FILEopen (fo, &fHandle, 'r') == CE_GOOD)
00A2A0  B3C722     MOV #0x72, W2
00A2A2  2FFB81     MOV #0xFFB8, W1
00A2A4  40808F     ADD W1, W15, W1
00A2A6  780009     MOV W9, W0
00A2A8  07FAD8     RCALL FILEopen
00A2AA  780200     MOV W0, W4
00A2AC  E00000     CP0 W0
00A2AE  3A005C     BRA NZ, 0xA368
12280:                 {
12281:             		#if defined(SUPPORT_LFN)
12282:             		rec->utf16LFNfoundLength = fo->utf16LFNlength;
00A2B0  97B03F     MOV [W15-26], W0
00A2B2  980C50     MOV W0, [W8+26]
12283:             		if(fo->utf16LFNlength)
00A2B4  780180     MOV W0, W3
00A2B6  E00000     CP0 W0
00A2B8  32000E     BRA Z, 0xA2D6
12284:             		{
12285:             			indexLFN = fo->utf16LFNlength;
12286:             			recordFoundName[indexLFN] = 0x0000;
00A2BA  400000     ADD W0, W0, W0
00A2BC  24B562     MOV #0x4B56, W2
00A2BE  783104     MOV W4, [W2+W0]
12287:             			while(indexLFN--)
00A2D2  500F83     SUB W0, W3, [W15]
00A2D4  3AFFFC     BRA NZ, 0xA2CE
00A2D6  780088     MOV W8, W1
00A2D8  EB4000     CLR.B W0
12288:             				recordFoundName[indexLFN] = fileFoundString[indexLFN];
00A2CE  7810A5     MOV [W5--], [W1--]
00A2D0  E80000     INC W0, W0
12289:             		}
12290:             		#endif
12291:             
12292:             		for(j = 0; j < FILE_NAME_SIZE_8P3 + 2 ; j++)
00A2DC  E84000     INC.B W0, W0
00A2DE  504FED     SUB.B W0, #0xD, [W15]
00A2E0  3AFFFC     BRA NZ, 0xA2DA
00A2E2  2FFD60     MOV #0xFFD6, W0
00A2E4  478080     ADD W15, W0, W1
12293:             		{
12294:                         rec->filename[j] = 0;
00A2DA  EB5880     CLR.B [W1++]
12295:             		}
12296:             
12297:                     // Copy as much name as there is
12298:                     if (fo->attributes != ATTR_VOLUME)
00A2E6  97B06F     MOV [W15-20], W0
00A2E8  500FE8     SUB W0, #0x8, [W15]
00A2EA  320023     BRA Z, 0xA332
00A2EC  780188     MOV W8, W3
00A2EE  EB4100     CLR.B W2
00A2F0  B3C204     MOV #0x20, W4
00A2F2  370005     BRA 0xA2FE
12299:                     {
12300:                         for (Index = 0, j = 0; (j < 8) && (fo->name[j] != 0x20); Index++, j++)
00A2F6  E84102     INC.B W2, W2
00A2F8  E80081     INC W1, W1
00A2FA  514FE8     SUB.B W2, #0x8, [W15]
00A2FC  320003     BRA Z, 0xA304
00A2FE  784011     MOV.B [W1], W0
00A300  504F84     SUB.B W0, W4, [W15]
00A302  3AFFF8     BRA NZ, 0xA2F4
12301:                         {
12302:                            rec->filename[Index] = fo->name[j];
00A2F4  785980     MOV.B W0, [W3++]
12303:                         }
12304:             
12305:             			if(fo->name[8] != 0x20)
00A304  B3C204     MOV #0x20, W4
00A306  97D86F     MOV.B [W15-34], W0
00A308  504F84     SUB.B W0, W4, [W15]
00A30A  320019     BRA Z, 0xA33E
12306:             			{
12307:                         	rec->filename[Index++] = '.';
00A30C  FB8082     ZE W2, W1
00A30E  B3C2E0     MOV #0x2E, W0
00A310  78F400     MOV.B W0, [W8+W1]
00A312  E84082     INC.B W2, W1
00A314  2FFDE3     MOV #0xFFDE, W3
00A316  478183     ADD W15, W3, W3
00A318  784284     MOV.B W4, W5
00A31A  418263     ADD W3, #0x3, W4
00A31C  370006     BRA 0xA32A
12308:             
12309:             	            // Move to the extension, even if there are more space chars
12310:             	            for (j = 8; (j < 11) && (fo->name[j] != 0x20); Index++, j++)
00A322  E84081     INC.B W1, W1
00A324  E80183     INC W3, W3
00A326  518F84     SUB W3, W4, [W15]
00A328  32000A     BRA Z, 0xA33E
00A32A  784113     MOV.B [W3], W2
00A32C  514F85     SUB.B W2, W5, [W15]
00A32E  3AFFF7     BRA NZ, 0xA31E
00A330  370006     BRA 0xA33E
00A332  780108     MOV W8, W2
00A334  780001     MOV W1, W0
00A336  4080EB     ADD W1, #0xB, W1
12311:             	            {
12312:             	               rec->filename[Index] = fo->name[j];
00A31E  FB8001     ZE W1, W0
00A320  787402     MOV.B W2, [W8+W0]
12313:             	            }
12314:             			}
12315:                     }
12316:                     else
12317:                     {
12318:                         for (Index = 0; Index < DIR_NAMECOMP; Index++)
00A33A  500F81     SUB W0, W1, [W15]
00A33C  3AFFFD     BRA NZ, 0xA338
12319:                         {
12320:                             rec->filename[Index] = fo->name[Index];
00A338  785930     MOV.B [W0++], [W2++]
12321:                         }
12322:                     }
12323:             
12324:                     rec->attributes = fo->attributes;
00A33E  97E8CF     MOV.B [W15-20], W1
00A340  984C51     MOV.B W1, [W8+13]
12325:                     rec->filesize = fo->size;
00A342  97A06F     MOV [W15-52], W0
00A344  97A0FF     MOV [W15-50], W1
00A346  980470     MOV W0, [W8+14]
00A348  980C01     MOV W1, [W8+16]
12326:                     rec->timestamp = (DWORD)((DWORD)fo->date << 16) + fo->time;
00A34A  97A82F     MOV [W15-44], W0
00A34C  200001     MOV #0x0, W1
00A34E  DD00C0     SL W0, #0, W1
00A350  200000     MOV #0x0, W0
00A352  97A91F     MOV [W15-46], W2
00A354  400102     ADD W0, W2, W2
00A356  4881E0     ADDC W1, #0x0, W3
00A358  980C12     MOV W2, [W8+18]
00A35A  980C23     MOV W3, [W8+20]
12327:                     rec->entry = fo->entry;
00A35C  97B0CF     MOV [W15-24], W1
00A35E  980C61     MOV W1, [W8+28]
12328:                     rec->initialized = TRUE;
00A360  B3C010     MOV #0x1, W0
00A362  987400     MOV.B W0, [W8+48]
00A364  EB0000     CLR W0
00A366  370004     BRA 0xA370
12329:                     return 0;
12330:                 }
12331:                 else
12332:                 {
12333:                     FSerrno = CE_BADCACHEREAD;
00A368  B3C1B1     MOV #0x1B, W1
00A36A  249380     MOV #0x4938, W0
00A36C  784801     MOV.B W1, [W0]
00A36E  EB8000     SETM W0
12334:                     return -1;
12335:                 }
12336:             }
12337:             
12338:             
12339:             /**********************************************************************
12340:               Function:
12341:                 int FindNext (SearchRec * rec)
12342:               Summary:
12343:                 Sequential search function
12344:               Conditions:
12345:                 None
12346:               Input:
12347:                 rec -  The structure to store the file information in
12348:               Return Values:
12349:                 0 -  File was found
12350:                 -1 - No additional files matching the specified criteria were found
12351:               Side Effects:
12352:                 Search criteria from previous FindNext call on passed SearchRec object
12353:                 will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext
12354:                 operations.It is the responsibility of the application to read the "utf16LFNfound"
12355:                 before it is lost.The FSerrno variable will be changed.
12356:               Description:
12357:                 The FindNext function performs the same function as the FindFirst
12358:                 funciton, except it does not copy any search parameters into the
12359:                 SearchRec structure (only info about found files) and it begins
12360:                 searching at the last directory entry offset at which a file was
12361:                 found, rather than at the beginning of the current working
12362:                 directory.If the return value of the function is 0 then "utf16LFNfoundLength"
12363:                 indicates whether the file found was long file name or short file
12364:                 name(8P3 format). The "utf16LFNfoundLength" is non-zero for long file name
12365:                 and is zero for 8P3 format."utf16LFNfound" points to the address of long 
12366:                 file name if found during the operation.
12367:               Remarks:
12368:                 Call FindFirst or FindFirstpgm before calling this function
12369:               **********************************************************************/
12370:             
12371:             int FindNext (SearchRec * rec)
12372:             {
00A148  E90003     DEC W3, W0
00A14A  400000     ADD W0, W0, W0
00A14C  2494A1     MOV #0x494A, W1
00A14E  400281     ADD W0, W1, W5
00A150  400082     ADD W0, W2, W1
00A152  780004     MOV W4, W0
00A154  370002     BRA 0xA15A
12373:                 FSFILE f;
12374:                 FILEOBJ fo = &f;
12375:                 BYTE i, j;
12376:             	#ifdef SUPPORT_LFN
12377:             		short int indexLFN;
12378:             	#endif
12379:             
12380:                 FSerrno = CE_GOOD;
00A0A2  249389     MOV #0x4938, W9
00A0A4  EB4C80     CLR.B [W9]
12381:             
12382:                 // Make sure we called FindFirst on this object
12383:                 if (rec->initialized == FALSE)
00A0A6  907000     MOV.B [W0+48], W0
00A0A8  E00400     CP0.B W0
00A0AA  3A0002     BRA NZ, 0xA0B0
12384:                 {
12385:                     FSerrno = CE_NOT_INIT;
00A0AC  B3C070     MOV #0x7, W0
00A0AE  370009     BRA 0xA0C2
12386:                     return -1;
12387:                 }
12388:             
12389:                 // Make sure we called FindFirst in the cwd
12390:             #ifdef ALLOW_DIRS
12391:                 if (rec->cwdclus != cwdptr->dirclus)
00A0B0  901168     MOV [W8+44], W2
00A0B2  9011F8     MOV [W8+46], W3
00A0B4  8385B0     MOV cwdptr, W0
00A0B6  9018B0     MOV [W0+54], W1
00A0B8  901820     MOV [W0+52], W0
00A0BA  510F80     SUB W2, W0, [W15]
00A0BC  598F81     SUBB W3, W1, [W15]
00A0BE  320004     BRA Z, 0xA0C8
12392:                 {
12393:                     FSerrno = CE_INVALID_ARGUMENT;
00A0C0  B3C1F0     MOV #0x1F, W0
00A0C2  784C80     MOV.B W0, [W9]
00A0C4  EB8000     SETM W0
00A0C6  370090     BRA 0xA1E8
12394:                     return -1;
12395:                 }
12396:             #endif
12397:                 
12398:             	#if defined(SUPPORT_LFN)
12399:                 fo->AsciiEncodingType = rec->AsciiEncodingType;
00A0C8  900838     MOV [W8+22], W0
00A0CA  9FB7C0     MOV W0, [W15-24]
12400:                 fo->utf16LFNlength = recordSearchLength;
00A0CC  825AA0     MOV recordSearchLength, W0
00A0CE  9FB7E0     MOV W0, [W15-20]
12401:             	if(fo->utf16LFNlength)
00A0D0  E00000     CP0 W0
00A0D2  320003     BRA Z, 0xA0DA
12402:             	{
12403:             	    fo->utf16LFNptr = &recordSearchName[0];
00A0D4  24D580     MOV #0x4D58, W0
00A0D6  9FB7D0     MOV W0, [W15-22]
00A0D8  370009     BRA 0xA0EC
12404:                 }
12405:             	else
12406:             	#endif
12407:             	{
12408:             		// Format the file name
12409:             	    if( !FormatFileName(rec->searchname, fo, 1) )
00A0DA  44007E     ADD W8, #0x1E, W0
00A0DC  B3C012     MOV #0x1, W2
00A0DE  2FFC01     MOV #0xFFC0, W1
00A0E0  40808F     ADD W1, W15, W1
00A0E2  07F248     RCALL FormatFileName
00A0E4  E00400     CP0.B W0
00A0E6  3A0002     BRA NZ, 0xA0EC
12410:             	    {
12411:             	        FSerrno = CE_INVALID_FILENAME;
00A0E8  B3C120     MOV #0x12, W0
00A0EA  37FFEB     BRA 0xA0C2
12412:             	        return -1;
12413:             	    }
12414:                 }
12415:             
12416:                 /* Brn: Copy the formatted name to "fo" which is necesary before calling "FILEfind" function */
12417:                 //strcpy(fo->name,rec->searchname);
12418:             
12419:                 fo->dsk = &gDiskData;
00A0EC  2485A0     MOV #0x485A, W0
00A0EE  9FA780     MOV W0, [W15-64]
12420:                 fo->cluster = 0;
00A0F0  B80060     MUL.UU W0, #0, W0
00A0F2  9FA790     MOV W0, [W15-62]
00A0F4  9FA7A1     MOV W1, [W15-60]
12421:                 fo->ccls    = 0;
00A0F6  9FA7B0     MOV W0, [W15-58]
00A0F8  9FA7C1     MOV W1, [W15-56]
12422:                 fo->entry = rec->entry + 1;
00A0FA  900868     MOV [W8+28], W0
00A0FC  E80000     INC W0, W0
00A0FE  9FB7F0     MOV W0, [W15-18]
12423:                 fo->attributes = rec->searchattr;
00A100  906838     MOV.B [W8+43], W0
00A102  FB8000     ZE W0, W0
00A104  9FBF90     MOV W0, [W15-14]
12424:             
12425:             #ifndef ALLOW_DIRS
12426:                 // start at the root directory
12427:                 fo->dirclus    = FatRootDirClusterValue;
12428:                 fo->dirccls    = FatRootDirClusterValue;
12429:             #else
12430:                 fo->dirclus = cwdptr->dirclus;
00A106  8385B0     MOV cwdptr, W0
00A108  901920     MOV [W0+52], W2
00A10A  9019B0     MOV [W0+54], W3
00A10C  9FBFA2     MOV W2, [W15-12]
00A10E  9FBFB3     MOV W3, [W15-10]
12431:                 fo->dirccls = cwdptr->dirccls;
00A110  901940     MOV [W0+56], W2
00A112  9019D0     MOV [W0+58], W3
00A114  9FBFC2     MOV W2, [W15-8]
00A116  9FBFD3     MOV W3, [W15-6]
12432:             #endif
12433:             
12434:                 // copy file object over
12435:                 FileObjectCopy(&gFileTemp, fo);
00A118  2FFC01     MOV #0xFFC0, W1
00A11A  40808F     ADD W1, W15, W1
00A11C  248BA0     MOV #0x48BA, W0
00A11E  07EC9A     RCALL FileObjectCopy
12436:             
12437:                 // See if the file is found
12438:                 if (CE_GOOD != FILEfind (fo, &gFileTemp,LOOK_FOR_MATCHING_ENTRY, 1))
00A120  B3C013     MOV #0x1, W3
00A122  784103     MOV.B W3, W2
00A124  248BA1     MOV #0x48BA, W1
00A126  2FFC00     MOV #0xFFC0, W0
00A128  40000F     ADD W0, W15, W0
00A12A  07FBF8     RCALL FILEfind
00A12C  780200     MOV W0, W4
00A12E  E00000     CP0 W0
00A130  320004     BRA Z, 0xA13A
12439:                 {
12440:                     FSerrno = CE_FILE_NOT_FOUND;
00A132  B3C0B1     MOV #0xB, W1
00A134  249380     MOV #0x4938, W0
00A136  784801     MOV.B W1, [W0]
00A138  37FFC5     BRA 0xA0C4
12441:                     return -1;
12442:                 }
12443:                 else
12444:                 {
12445:             		#if defined(SUPPORT_LFN)
12446:             		rec->utf16LFNfoundLength = fo->utf16LFNlength;
00A13A  97B1EF     MOV [W15-20], W3
00A13C  980C53     MOV W3, [W8+26]
12447:             		if(fo->utf16LFNlength)
00A13E  E00003     CP0 W3
00A140  32000E     BRA Z, 0xA15E
12448:             		{
12449:             			indexLFN = fo->utf16LFNlength;
12450:             			recordFoundName[indexLFN] = 0x0000;
00A142  418003     ADD W3, W3, W0
00A144  24B562     MOV #0x4B56, W2
00A146  783104     MOV W4, [W2+W0]
12451:             			while(indexLFN--)
00A15A  500F83     SUB W0, W3, [W15]
00A15C  3AFFFC     BRA NZ, 0xA156
00A15E  780088     MOV W8, W1
00A160  EB4000     CLR.B W0
12452:             				recordFoundName[indexLFN] = fileFoundString[indexLFN];
00A156  7810A5     MOV [W5--], [W1--]
00A158  E80000     INC W0, W0
12453:             		}
12454:             		#endif
12455:             
12456:             		for(j = 0; j < FILE_NAME_SIZE_8P3 + 2 ; j++)
00A164  E84000     INC.B W0, W0
00A166  504FED     SUB.B W0, #0xD, [W15]
00A168  3AFFFC     BRA NZ, 0xA162
00A16A  2FFDC0     MOV #0xFFDC, W0
00A16C  478080     ADD W15, W0, W1
12457:             		{
12458:                         rec->filename[j] = 0;
00A162  EB5880     CLR.B [W1++]
12459:             		}
12460:             
12461:                     if (fo->attributes != ATTR_VOLUME)
00A16E  97B81F     MOV [W15-14], W0
00A170  500FE8     SUB W0, #0x8, [W15]
00A172  320022     BRA Z, 0xA1B8
00A174  780188     MOV W8, W3
00A176  EB4100     CLR.B W2
00A178  B3C204     MOV #0x20, W4
00A17A  370005     BRA 0xA186
12462:                     {
12463:                         for (i = 0, j = 0; (j < 8) && (fo->name[j] != 0x20); i++, j++)
00A17E  E84102     INC.B W2, W2
00A180  E80081     INC W1, W1
00A182  514FE8     SUB.B W2, #0x8, [W15]
00A184  320003     BRA Z, 0xA18C
00A186  784011     MOV.B [W1], W0
00A188  504F84     SUB.B W0, W4, [W15]
00A18A  3AFFF8     BRA NZ, 0xA17C
12464:                         {
12465:                            rec->filename[i] = fo->name[j];
00A17C  785980     MOV.B W0, [W3++]
12466:                         }
12467:             
12468:             			if(fo->name[8] != 0x20)
00A18C  B3C204     MOV #0x20, W4
00A18E  97E04F     MOV.B [W15-28], W0
00A190  504F84     SUB.B W0, W4, [W15]
00A192  320018     BRA Z, 0xA1C4
12469:             			{
12470:                         	rec->filename[i++] = '.';
00A194  FB8082     ZE W2, W1
00A196  B3C2E0     MOV #0x2E, W0
00A198  78F400     MOV.B W0, [W8+W1]
00A19A  E84082     INC.B W2, W1
00A19C  5781FC     SUB W15, #0x1C, W3
00A19E  784284     MOV.B W4, W5
00A1A0  418263     ADD W3, #0x3, W4
00A1A2  370006     BRA 0xA1B0
12471:             
12472:             	            // Move to the extension, even if there are more space chars
12473:             	            for (j = 8; (j < 11) && (fo->name[j] != 0x20); i++, j++)
00A1A8  E84081     INC.B W1, W1
00A1AA  E80183     INC W3, W3
00A1AC  518F84     SUB W3, W4, [W15]
00A1AE  32000A     BRA Z, 0xA1C4
00A1B0  784113     MOV.B [W3], W2
00A1B2  514F85     SUB.B W2, W5, [W15]
00A1B4  3AFFF7     BRA NZ, 0xA1A4
00A1B6  370006     BRA 0xA1C4
00A1B8  780108     MOV W8, W2
00A1BA  780001     MOV W1, W0
00A1BC  4080EB     ADD W1, #0xB, W1
12474:             	            {
12475:             	               rec->filename[i] = fo->name[j];
00A1A4  FB8001     ZE W1, W0
00A1A6  787402     MOV.B W2, [W8+W0]
12476:             	            }
12477:             			}
12478:                     }
12479:                     else
12480:                     {
12481:                         for (i = 0; i < DIR_NAMECOMP; i++)
00A1C0  500F81     SUB W0, W1, [W15]
00A1C2  3AFFFD     BRA NZ, 0xA1BE
12482:                         {
12483:                             rec->filename[i] = fo->name[i];
00A1BE  785930     MOV.B [W0++], [W2++]
12484:                         }
12485:                     }
12486:             
12487:                     rec->attributes = fo->attributes;
00A1C4  97F0AF     MOV.B [W15-14], W1
00A1C6  984C51     MOV.B W1, [W8+13]
12488:                     rec->filesize = fo->size;
00A1C8  97A91F     MOV [W15-46], W2
00A1CA  97A9AF     MOV [W15-44], W3
00A1CC  980472     MOV W2, [W8+14]
00A1CE  980C03     MOV W3, [W8+16]
12489:                     rec->timestamp = (DWORD)((DWORD)fo->date << 16) + fo->time;
00A1D0  97A95F     MOV [W15-38], W2
00A1D2  200003     MOV #0x0, W3
00A1D4  DD11C0     SL W2, #0, W3
00A1D6  200002     MOV #0x0, W2
00A1D8  97A84F     MOV [W15-40], W0
00A1DA  410000     ADD W2, W0, W0
00A1DC  4980E0     ADDC W3, #0x0, W1
00A1DE  980C10     MOV W0, [W8+18]
00A1E0  980C21     MOV W1, [W8+20]
12490:                     rec->entry = fo->entry;
00A1E2  97B1FF     MOV [W15-18], W3
00A1E4  980C63     MOV W3, [W8+28]
00A1E6  EB0000     CLR W0
12491:                     return 0;
12492:                 }
12493:             }
00A1EE  FA003E     LNK #0x3E
00A1F0  BE9F88     MOV.D W8, [W15++]
00A1F2  BE9F8A     MOV.D W10, [W15++]
00A1F4  781F8C     MOV W12, [W15++]
00A1F6  780580     MOV W0, W11
00A1F8  780601     MOV W1, W12
00A1FA  780402     MOV W2, W8
12494:             
12495:             /***********************************************************************************
12496:               Function:
12497:                 int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec)
12498:               Summary:
12499:                 Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices.
12500:               Conditions:
12501:                 None
12502:               Input:
12503:                 fileName - The name to search for
12504:                          - Parital string search characters
12505:                          - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*)
12506:                          - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T)
12507:                 attr -            The attributes that a found file may have
12508:                      - ATTR_READ_ONLY -  File may be read only
12509:                      - ATTR_HIDDEN -     File may be a hidden file
12510:                      - ATTR_SYSTEM -     File may be a system file
12511:                      - ATTR_VOLUME -     Entry may be a volume label
12512:                      - ATTR_DIRECTORY -  File may be a directory
12513:                      - ATTR_ARCHIVE -    File may have archive attribute
12514:                      - ATTR_MASK -       All attributes
12515:                 rec -             pointer to a structure to put the file information in
12516:               Return Values:
12517:                 0 -  File was found
12518:                 -1 - No file matching the specified criteria was found
12519:               Side Effects:
12520:                 Search criteria from previous wFindFirst call on passed SearchRec object
12521:                 will be lost. "utf16LFNfound" is overwritten after subsequent wFindFirst/FindNext
12522:                 operations.It is the responsibility of the application to read the "utf16LFNfound"
12523:                 before it is lost.The FSerrno variable will be changed.
12524:               Description:
12525:                 Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices.
12526:                 The wFindFirst function will search for a file based on parameters passed in
12527:                 by the user.  This function will use the FILEfind function to parse through
12528:                 the current working directory searching for entries that match the specified
12529:                 parameters.  If a file is found, its parameters are copied into the SearchRec
12530:                 structure, as are the initial parameters passed in by the user and the position
12531:                 of the file entry in the current working directory.If the return value of the 
12532:                 function is 0 then "utf16LFNfoundLength" indicates whether the file found was 
12533:                 long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero
12534:                 for long file name and is zero for 8P3 format."utf16LFNfound" points to the
12535:                 address of long file name if found during the operation.
12536:               Remarks:
12537:                 Call FindFirst or FindFirstpgm before calling FindNext
12538:               ***********************************************************************************/
12539:             
12540:             #ifdef SUPPORT_LFN
12541:             int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec)
12542:             {
12543:             	int result;
12544:             	utfModeFileName = TRUE;
00A37A  200013     MOV #0x1, W3
00A37C  8B85A3     MOV W3, utfModeFileName
12545:             	result = FindFirst ((const char *)fileName,attr,rec);
00A37E  07FF37     RCALL FindFirst
12546:             	utfModeFileName = FALSE;
00A380  EB0080     CLR W1
00A382  8B85A1     MOV W1, utfModeFileName
12547:             	return result;
12548:             }
00A386  B0082F     ADD #0x82, W15
00A388  BE9F88     MOV.D W8, [W15++]
00A38A  BE9F8A     MOV.D W10, [W15++]
00A38C  BE9F8C     MOV.D W12, [W15++]
00A38E  781F8E     MOV W14, [W15++]
00A390  780700     MOV W0, W14
12549:             #endif
12550:             
12551:             #endif
12552:             
12553:             #ifdef ALLOW_FSFPRINTF
12554:             
12555:             
12556:             /**********************************************************************
12557:               Function:
12558:                 int FSputc (char c, FSFILE * file)
12559:               Summary:
12560:                 FSfprintf helper function to write a char
12561:               Conditions:
12562:                 This function should not be called by the user.
12563:               Input:
12564:                 c - The character to write to the file.
12565:                 file - The file to write to.
12566:               Return Values:
12567:                 0 -   The character was written successfully
12568:                 EOF - The character was not written to the file.
12569:               Side Effects:
12570:                 None
12571:               Description:
12572:                 This is a helper function for FSfprintf.  It will write one
12573:                 character to a file.
12574:               Remarks:
12575:                 None
12576:               **********************************************************************/
12577:             
12578:             int FSputc (char c, FSFILE * file)
12579:             {
12580:                 if (FSfwrite ((void *)&c, 1, 1, file) != 1)
12581:                     return EOF;
12582:                 else
12583:                     return 0;
12584:             }
12585:             
12586:             
12587:             /**********************************************************************
12588:               Function:
12589:                 int str_put_n_chars (FSFILE * handle, unsigned char n, char c)
12590:               Summary:
12591:                 FSfprintf helper function to write a char multiple times
12592:               Conditions:
12593:                 This function should not be called by the user.
12594:               Input:
12595:                 handle - The file to write to.
12596:                 n -      The number of times to write that character to a file.
12597:                 c - The character to write to the file.
12598:               Return Values:
12599:                 0 -   The characters were written successfully
12600:                 EOF - The characters were not written to the file.
12601:               Side Effects:
12602:                 None
12603:               Description:
12604:                 This funciton is used by the FSfprintf function to write multiple
12605:                 instances of a single character to a file (for example, when
12606:                 padding a format specifier with leading spacez or zeros).
12607:               Remarks:
12608:                 None.
12609:               **********************************************************************/
12610:             
12611:             
12612:             unsigned char str_put_n_chars (FSFILE * handle, unsigned char n, char c)
12613:             {
12614:                 while (n--)
12615:                 if (FSputc (c, handle) == EOF)
12616:                     return 1;
12617:                 return 0;
12618:             }
12619:             
12620:             
12621:             /**********************************************************************
12622:               Function:
12623:                 // PIC24/30/33/32
12624:                 int FSfprintf (FSFILE * fptr, const char * fmt, ...)
12625:                 // PIC18
12626:                 int FSfpritnf (FSFILE * fptr, const rom char * fmt, ...)
12627:               Summary:
12628:                 Function to write formatted strings to a file
12629:               Conditions:
12630:                 For PIC18, integer promotion must be enabled in the project build
12631:                 options menu.  File opened in a write mode.
12632:               Input:
12633:                 fptr - A pointer to the file to write to.
12634:                 fmt -  A string of characters and format specifiers to write to
12635:                        the file
12636:                 ... -  Additional arguments inserted in the string by format
12637:                        specifiers
12638:               Returns:
12639:                 The number of characters written to the file
12640:               Side Effects:
12641:                 The FSerrno variable will be changed.
12642:               Description:
12643:                 Writes a specially formatted string to a file.
12644:               Remarks:
12645:                 Consult AN1045 for a full description of how to use format
12646:                 specifiers.
12647:               **********************************************************************/
12648:             
12649:             #ifdef __18CXX
12650:             int FSfprintf (FSFILE *fptr, const rom char *fmt, ...)
12651:             #else
12652:             int FSfprintf (FSFILE *fptr, const char * fmt, ...)
12653:             #endif
12654:             {
12655:                 va_list ap;
12656:                 int n;
12657:             
12658:                 va_start (ap, fmt);
12659:                 n = FSvfprintf (fptr, fmt, ap);
12660:                 va_end (ap);
12661:                 return n;
12662:             }
12663:             
12664:             
12665:             /**********************************************************************
12666:               Function:
12667:                 // PIC24/30/33/32
12668:                 int FSvfprintf (FSFILE * handle, const char * formatString, va_list ap)
12669:                 // PIC18
12670:                 int FSvfpritnf (auto FSFILE * handle, auto const rom char * formatString, auto va_list ap)
12671:               Summary:
12672:                 Helper function for FSfprintf
12673:               Conditions:
12674:                 This function should not be called by the user.
12675:               Input:
12676:                 handle -        A pointer to the file to write to.
12677:                 formatString -  A string of characters and format specifiers to write to
12678:                                 the file
12679:                 ap -            A structure pointing to the arguments on the stack
12680:               Returns:
12681:                 The number of characters written to the file
12682:               Side Effects:
12683:                 The FSerrno variable will be changed.
12684:               Description:
12685:                 This helper function will access the elements passed to FSfprintf
12686:               Remarks:
12687:                 Consult AN1045 for a full description of how to use format
12688:                 specifiers.
12689:               **********************************************************************/
12690:             
12691:             #ifdef __18CXX
12692:             int FSvfprintf (auto FSFILE *handle, auto const rom char * formatString, auto va_list ap)
12693:             #else
12694:             int FSvfprintf (FSFILE *handle, const char * formatString, va_list ap)
12695:             #endif
12696:             {
12697:                 unsigned char c;
12698:                 int count = 0;
12699:             
12700:                 for (c = *formatString; c; c = *++formatString)
12701:                 {
12702:                     if (c == '%')
12703:                     {
12704:                         unsigned char    flags = 0;
12705:                         unsigned char    width = 0;
12706:                         unsigned char    precision = 0;
12707:                         unsigned char    have_precision = 0;
12708:                         unsigned char    size = 0;
12709:             #ifndef __18CXX
12710:                         unsigned char   size2 = 0;
12711:             #endif
12712:                         unsigned char    space_cnt;
12713:                         unsigned char    cval;
12714:             #ifdef __18CXX
12715:                         unsigned long    larg;
12716:                         far rom char *   romstring;
12717:             #else
12718:                         unsigned long long larg;
12719:             #endif
12720:                         char *         ramstring;
12721:                         int n;
12722:             
12723:                         FSerrno = CE_GOOD;
12724:             
12725:                         c = *++formatString;
12726:             
12727:                         while ((c == '-') || (c == '+') || (c == ' ') || (c == '#') || (c == '0'))
12728:                         {
12729:                             switch (c)
12730:                             {
12731:                                 case '-':
12732:                                     flags |= _FLAG_MINUS;
12733:                                     break;
12734:                                 case '+':
12735:                                     flags |= _FLAG_PLUS;
12736:                                     break;
12737:                                 case ' ':
12738:                                     flags |= _FLAG_SPACE;
12739:                                     break;
12740:                                 case '#':
12741:                                     flags |= _FLAG_OCTO;
12742:                                     break;
12743:                                 case '0':
12744:                                     flags |= _FLAG_ZERO;
12745:                                     break;
12746:                             }
12747:                             c = *++formatString;
12748:                         }
12749:                         /* the optional width field is next */
12750:                         if (c == '*')
12751:                         {
12752:                             n = va_arg (ap, int);
12753:                             if (n < 0)
12754:                             {
12755:                                 flags |= _FLAG_MINUS;
12756:                                 width = -n;
12757:                             }
12758:                             else
12759:                                 width = n;
12760:                             c = *++formatString;
12761:                         }
12762:                         else
12763:                         {
12764:                             cval = 0;
12765:                             while ((unsigned char) isdigit (c))
12766:                             {
12767:                                 cval = cval * 10 + c - '0';
12768:                                 c = *++formatString;
12769:                             }
12770:                             width = cval;
12771:                         }
12772:             
12773:                         /* if '-' is specified, '0' is ignored */
12774:                         if (flags & _FLAG_MINUS)
12775:                             flags &= ~_FLAG_ZERO;
12776:             
12777:                         /* the optional precision field is next */
12778:                         if (c == '.')
12779:                         {
12780:                             c = *++formatString;
12781:                             if (c == '*')
12782:                             {
12783:                                 n = va_arg (ap, int);
12784:                                 if (n >= 0)
12785:                                 {
12786:                                     precision = n;
12787:                                     have_precision = 1;
12788:                                 }
12789:                                 c = *++formatString;
12790:                             }
12791:                             else
12792:                             {
12793:                                 cval = 0;
12794:                                 while ((unsigned char) isdigit (c))
12795:                                 {
12796:                                     cval = cval * 10 + c - '0';
12797:                                     c = *++formatString;
12798:                                 }
12799:                                 precision = cval;
12800:                                 have_precision = 1;
12801:                             }
12802:                         }
12803:             
12804:                         /* the optional 'h' specifier. since int and short int are
12805:                             the same size for MPLAB C18, this is a NOP for us. */
12806:                         if (c == 'h')
12807:                         {
12808:                             c = *++formatString;
12809:                             /* if 'c' is another 'h' character, this is an 'hh'
12810:                                 specifier and the size is 8 bits */
12811:                             if (c == 'h')
12812:                             {
12813:                                 size = _FMT_BYTE;
12814:                                 c = *++formatString;
12815:                             }
12816:                         }
12817:                         else if ((c == 't') || (c == 'z'))
12818:                             c = *++formatString;
12819:             #ifdef __18CXX
12820:                         else if ((c == 'H') || (c == 'T') || (c == 'Z'))
12821:                         {
12822:                             size = _FMT_SHRTLONG;
12823:                             c = *++formatString;
12824:                         }
12825:                         else if ((c == 'l') || (c == 'j'))
12826:             #else
12827:                         else if ((c == 'q') || (c == 'j'))
12828:                         {
12829:                             size = _FMT_LONGLONG;
12830:                             c = *++formatString;
12831:                         }
12832:                         else if (c == 'l')
12833:             #endif
12834:                         {
12835:                             size = _FMT_LONG;
12836:                             c = *++formatString;
12837:                         }
12838:             
12839:                         switch (c)
12840:                         {
12841:                             case '\0':
12842:                             /* this is undefined behaviour. we have a trailing '%' character
12843:                                 in the string, perhaps with some flags, width, precision
12844:                                 stuff as well, but no format specifier. We'll, arbitrarily,
12845:                                 back up a character so that the loop will terminate
12846:                                 properly when it loops back and we'll output a '%'
12847:                                 character. */
12848:                                 --formatString;
12849:                             /* fallthrough */
12850:                             case '%':
12851:                                 if (FSputc ('%', handle) == EOF)
12852:                                 {
12853:                                     FSerrno = CE_WRITE_ERROR;
12854:                                     return EOF;
12855:                                 }
12856:                                 ++count;
12857:                                 break;
12858:                             case 'c':
12859:                                 space_cnt = 0;
12860:                                 if (width > 1)
12861:                                 {
12862:                                     space_cnt = width - 1;
12863:                                     count += space_cnt;
12864:                                 }
12865:                                 if (space_cnt && !(flags & _FLAG_MINUS))
12866:                                 {
12867:                                     if (str_put_n_chars (handle, space_cnt, ' '))
12868:                                     {
12869:                                         FSerrno = CE_WRITE_ERROR;
12870:                                         return EOF;
12871:                                     }
12872:                                     space_cnt = 0;
12873:                                 }
12874:                                 c = va_arg (ap, int);
12875:                                 if (FSputc (c, handle) == EOF)
12876:                                 {
12877:                                     FSerrno = CE_WRITE_ERROR;
12878:                                     return EOF;
12879:                                 }
12880:                                 ++count;
12881:                                 if (str_put_n_chars (handle, space_cnt, ' '))
12882:                                 {
12883:                                     FSerrno = CE_WRITE_ERROR;
12884:                                     return EOF;
12885:                                 }
12886:                                 break;
12887:                             case 'S':
12888:             #ifdef __18CXX
12889:                                 if (size == _FMT_SHRTLONG)
12890:                                     romstring = va_arg (ap, rom far char *);
12891:                                 else
12892:                                     romstring = (far rom char*)va_arg (ap, rom near char *);
12893:                                 n = strlenpgm (romstring);
12894:                                 /* Normalize the width based on the length of the actual
12895:                                     string and the precision. */
12896:                                 if (have_precision && precision < (unsigned char) n)
12897:                                     n = precision;
12898:                                 if (width < (unsigned char) n)
12899:                                     width = n;
12900:                                 space_cnt = width - (unsigned char) n;
12901:                                 count += space_cnt;
12902:                                 /* we've already calculated the space count that the width
12903:                                     will require. now we want the width field to have the
12904:                                     number of character to display from the string itself,
12905:                                     limited by the length of the actual string and the
12906:                                     specified precision. */
12907:                                 if (have_precision && precision < width)
12908:                                     width = precision;
12909:                                 /* if right justified, we print the spaces before the
12910:                                     string */
12911:                                 if (!(flags & _FLAG_MINUS))
12912:                                 {
12913:                                     if (str_put_n_chars (handle, space_cnt, ' '))
12914:                                     {
12915:                                         FSerrno = CE_WRITE_ERROR;
12916:                                         return EOF;
12917:                                     }
12918:                                     space_cnt = 0;
12919:                                 }
12920:                                 cval = 0;
12921:                                 for (c = *romstring; c && cval < width; c = *++romstring)
12922:                                 {
12923:                                     if (FSputc (c, handle) == EOF)
12924:                                     {
12925:                                         FSerrno = CE_WRITE_ERROR;
12926:                                         return EOF;
12927:                                     }
12928:                                     ++count;
12929:                                     ++cval;
12930:                                 }
12931:                                 /* If there are spaces left, it's left justified.
12932:                                     Either way, calling the function unconditionally
12933:                                     is smaller code. */
12934:                                 if (str_put_n_chars (handle, space_cnt, ' '))
12935:                                 {
12936:                                     FSerrno = CE_WRITE_ERROR;
12937:                                     return EOF;
12938:                                 }
12939:                                 break;
12940:             #endif
12941:                             case 's':
12942:                                 ramstring = va_arg (ap, char *);
12943:                                 n = strlen (ramstring);
12944:                                 /* Normalize the width based on the length of the actual
12945:                                     string and the precision. */
12946:                                 if (have_precision && precision < (unsigned char) n)
12947:                                     n = precision;
12948:                                 if (width < (unsigned char) n)
12949:                                     width = n;
12950:                                 space_cnt = width - (unsigned char) n;
12951:                                 count += space_cnt;
12952:                                 /* we've already calculated the space count that the width
12953:                                     will require. now we want the width field to have the
12954:                                     number of character to display from the string itself,
12955:                                     limited by the length of the actual string and the
12956:                                     specified precision. */
12957:                                 if (have_precision && precision < width)
12958:                                     width = precision;
12959:                                 /* if right justified, we print the spaces before the string */
12960:                                 if (!(flags & _FLAG_MINUS))
12961:                                 {
12962:                                     if (str_put_n_chars (handle, space_cnt, ' '))
12963:                                     {
12964:                                         FSerrno = CE_WRITE_ERROR;
12965:                                         return EOF;
12966:                                     }
12967:                                     space_cnt = 0;
12968:                                 }
12969:                                 cval = 0;
12970:                                 for (c = *ramstring; c && cval < width; c = *++ramstring)
12971:                                 {
12972:                                     if (FSputc (c, handle) == EOF)
12973:                                     {
12974:                                         FSerrno = CE_WRITE_ERROR;
12975:                                         return EOF;
12976:                                     }
12977:                                     ++count;
12978:                                     ++cval;
12979:                                 }
12980:                                 /* If there are spaces left, it's left justified.
12981:                                     Either way, calling the function unconditionally
12982:                                     is smaller code. */
12983:                                 if (str_put_n_chars (handle, space_cnt, ' '))
12984:                                 {
12985:                                     FSerrno = CE_WRITE_ERROR;
12986:                                     return EOF;
12987:                                 }
12988:                                 break;
12989:                             case 'd':
12990:                             case 'i':
12991:                                 flags |= _FLAG_SIGNED;
12992:                             /* fall through */
12993:                             case 'o':
12994:                             case 'u':
12995:                             case 'x':
12996:                             case 'X':
12997:                             case 'b':
12998:                             case 'B':
12999:                                 /* This is a bit of a trick. The 'l' and 'hh' size
13000:                                     specifiers are valid only for the integer conversions,
13001:                                     not the 'p' or 'P' conversions, and are ignored for the
13002:                                     latter. By jumping over the additional size specifier
13003:                                     checks here we get the best code size since we can
13004:                                     limit the size checks in the remaining code. */
13005:                                 if (size == _FMT_LONG)
13006:                                 {
13007:                                     if (flags & _FLAG_SIGNED)
13008:                                         larg = va_arg (ap, long int);
13009:                                     else
13010:                                         larg = va_arg (ap, unsigned long int);
13011:                                     goto _do_integer_conversion;
13012:                                 }
13013:                                 else if (size == _FMT_BYTE)
13014:                                 {
13015:                                     if (flags & _FLAG_SIGNED)
13016:                                         larg = (signed char) va_arg (ap, int);
13017:                                     else
13018:                                         larg = (unsigned char) va_arg (ap, unsigned int);
13019:                                     goto _do_integer_conversion;
13020:                                 }
13021:             #ifndef __18CXX
13022:                                 else if (size == _FMT_LONGLONG)
13023:                                 {
13024:                                     if (flags & _FLAG_SIGNED)
13025:                                         larg = (signed long long)va_arg (ap, long long);
13026:                                     else
13027:                                         larg = (unsigned long long) va_arg (ap, unsigned long long);
13028:                                     goto _do_integer_conversion;
13029:                                 }
13030:             #endif
13031:                                 /* fall trough */
13032:                             case 'p':
13033:                             case 'P':
13034:             #ifdef __18CXX
13035:                                 if (size == _FMT_SHRTLONG)
13036:                                 {
13037:                                     if (flags & _FLAG_SIGNED)
13038:                                         larg = va_arg (ap, short long int);
13039:                                     else
13040:                                         larg = va_arg (ap, unsigned short long int);
13041:                                 }
13042:                                 else
13043:             #endif
13044:                                     if (flags & _FLAG_SIGNED)
13045:                                         larg = va_arg (ap, int);
13046:                                     else
13047:                                         larg = va_arg (ap, unsigned int);
13048:                                 _do_integer_conversion:
13049:                                     /* default precision is 1 */
13050:                                     if (!have_precision)
13051:                                         precision = 1;
13052:                                     {
13053:                                         unsigned char digit_cnt = 0;
13054:                                         unsigned char prefix_cnt = 0;
13055:                                         unsigned char sign_char;
13056:                                         /* A 32 bit number will require at most 32 digits in the
13057:                                             string representation (binary format). */
13058:             #ifdef __18CXX
13059:                                         char buf[33];
13060:                                         /* Start storing digits least-significant first */
13061:                                         char *q = &buf[31];
13062:                                         /* null terminate the string */
13063:                                         buf[32] = '\0';
13064:             #else
13065:                                         char buf[65];
13066:                                         char *q = &buf[63];
13067:                                         buf[64] = '\0';
13068:             #endif
13069:                                         space_cnt = 0;
13070:                                         size = 10;
13071:             
13072:                                         switch (c)
13073:                                         {
13074:                                             case 'b':
13075:                                             case 'B':
13076:                                                 size = 2;
13077:             #ifndef __18CXX
13078:                                                 size2 = 1;
13079:             #endif
13080:                                                 break;
13081:                                             case 'o':
13082:                                                 size = 8;
13083:             #ifndef __18CXX
13084:                                                 size2 = 3;
13085:             #endif
13086:                                                 break;
13087:                                             case 'p':
13088:                                             case 'P':
13089:                                                 /* from here on out, treat 'p' conversions just
13090:                                                     like 'x' conversions. */
13091:                                                 c += 'x' - 'p';
13092:                                             /* fall through */
13093:                                             case 'x':
13094:                                             case 'X':
13095:                                                 size = 16;
13096:             #ifndef __18CXX
13097:                                                 size2 = 4;
13098:             #endif
13099:                                                 break;
13100:                                         }// switch (c)
13101:             
13102:                                         /* if it's an unsigned conversion, we should ignore the
13103:                                             ' ' and '+' flags */
13104:                                         if (!(flags & _FLAG_SIGNED))
13105:                                             flags &= ~(_FLAG_PLUS | _FLAG_SPACE);
13106:             
13107:                                         /* if it's a negative value, we need to negate the
13108:                                             unsigned version before we convert to text. Using
13109:                                             unsigned for this allows us to (ab)use the 2's
13110:                                             complement system to avoid overflow and be able to
13111:                                             adequately handle LONG_MIN.
13112:             
13113:                                             We'll figure out what sign character to print, if
13114:                                             any, here as well. */
13115:             #ifdef __18CXX
13116:                                         if (flags & _FLAG_SIGNED && ((long) larg < 0))
13117:                                         {
13118:                                             larg = -(long) larg;
13119:             #else
13120:                                         if (flags & _FLAG_SIGNED && ((long long) larg < 0))
13121:                                         {
13122:                                             larg = -(long long) larg;
13123:             #endif
13124:                                             sign_char = '-';
13125:                                             ++digit_cnt;
13126:                                         }
13127:                                         else if (flags & _FLAG_PLUS)
13128:                                         {
13129:                                     sign_char = '+';
13130:                                     ++digit_cnt;
13131:                                  }
13132:                                   else if (flags & _FLAG_SPACE)
13133:                                   {
13134:                                             sign_char = ' ';
13135:                                             ++digit_cnt;
13136:                                         }
13137:                                         else
13138:                                             sign_char = '\0';
13139:                                         /* get the digits for the actual number. If the
13140:                                             precision is zero and the value is zero, the result
13141:                                             is no characters. */
13142:                                         if (precision || larg)
13143:                                         {
13144:                                             do
13145:                                             {
13146:             #ifdef __18CXX
13147:                                                 cval = s_digits[larg % size];
13148:                                                 if ((c == 'X') && (cval >= 'a'))
13149:                                                     cval -= 'a' - 'A';
13150:                                                 larg /= size;
13151:             #else
13152:                                                 // larg is congruent mod size2 to its lower 16 bits
13153:                                                 // for size2 = 2^n, 0 <= n <= 4
13154:                                                 if (size2 != 0)
13155:                                                     cval = s_digits[(unsigned int) larg % size];
13156:                                                 else
13157:                                                     cval = s_digits[larg % size];
13158:                                                 if ((c == 'X') && (cval >= 'a'))
13159:                                                     cval -= 'a' - 'A';
13160:                                                 if (size2 != 0)
13161:                                                     larg = larg >> size2;
13162:                                                 else
13163:                                                     larg /= size;
13164:             #endif
13165:                                                 *q-- = cval;
13166:                                                 ++digit_cnt;
13167:                                             } while (larg);
13168:                                             /* if the '#' flag was specified and we're dealing
13169:                                                 with an 'o', 'b', 'B', 'x', or 'X' conversion,
13170:                                                 we need a bit more. */
13171:                                             if (flags & _FLAG_OCTO)
13172:                                             {
13173:                                                 if (c == 'o')
13174:                                                 {
13175:                                                     /* per the standard, for octal, the '#' flag
13176:                                                         makes the precision be at least one more
13177:                                                         than the number of digits in the number */
13178:                                                     if (precision <= digit_cnt)
13179:                                                         precision = digit_cnt + 1;
13180:                                                 }
13181:                                                 else if ((c == 'x') || (c == 'X') || (c == 'b') || (c == 'B'))
13182:                                                     prefix_cnt = 2;
13183:                                             }
13184:                                         }
13185:                                         else
13186:                                             digit_cnt = 0;
13187:             
13188:                                         /* The leading zero count depends on whether the '0'
13189:                                             flag was specified or not. If it was not, then the
13190:                                             count is the difference between the specified
13191:                                             precision and the number of digits (including the
13192:                                             sign character, if any) to be printed; otherwise,
13193:                                             it's as if the precision were equal to the max of
13194:                                             the specified precision and the field width. If a
13195:                                             precision was specified, the '0' flag is ignored,
13196:                                             however. */
13197:                                         if ((flags & _FLAG_ZERO) && (width > precision)
13198:                                             && !have_precision)
13199:                                             precision = width;
13200:                                         /* for the rest of the processing, precision contains
13201:                                             the leading zero count for the conversion. */
13202:                                         if (precision > digit_cnt)
13203:                                             precision -= digit_cnt;
13204:                                         else
13205:                                             precision = 0;
13206:                                         /* the space count is the difference between the field
13207:                                             width and the digit count plus the leading zero
13208:                                             count. If the width is less than the digit count
13209:                                             plus the leading zero count, the space count is
13210:                                             zero. */
13211:                                         if (width > precision + digit_cnt + prefix_cnt)
13212:                                             space_cnt =   width - precision - digit_cnt - prefix_cnt;
13213:             
13214:                                         /* for output, we check the justification, if it's
13215:                                             right justified and the space count is positive, we
13216:                                             emit the space characters first. */
13217:                                         if (!(flags & _FLAG_MINUS) && space_cnt)
13218:                                         {
13219:                                             if (str_put_n_chars (handle, space_cnt, ' '))
13220:                                             {
13221:                                                 FSerrno = CE_WRITE_ERROR;
13222:                                                 return EOF;
13223:                                             }
13224:                                             count += space_cnt;
13225:                                             space_cnt = 0;
13226:                                         }
13227:                                         /* if we have a sign character to print, that comes
13228:                                             next */
13229:                                         if (sign_char)
13230:                                             if (FSputc (sign_char, handle) == EOF)
13231:                                             {
13232:                                                 FSerrno = CE_WRITE_ERROR;
13233:                                                 return EOF;
13234:                                             }
13235:                                         /* if we have a prefix (0b, 0B, 0x or 0X), that's next */
13236:                                         if (prefix_cnt)
13237:                                         {
13238:                                             if (FSputc ('0', handle) == EOF)
13239:                                             {
13240:                                                 FSerrno = CE_WRITE_ERROR;
13241:                                                 return EOF;
13242:                                             }
13243:                                             if (FSputc (c, handle) == EOF)
13244:                                             {
13245:                                                 FSerrno = CE_WRITE_ERROR;
13246:                                                 return EOF;
13247:                                             }
13248:                                         }
13249:                                         /* if we have leading zeros, they follow. the prefix, if any
13250:                                             is included in the number of digits when determining how
13251:                                             many leading zeroes are needed. */
13252:             //                            if (precision > prefix_cnt)
13253:               //                              precision -= prefix_cnt;
13254:                                         if (str_put_n_chars (handle, precision, '0'))
13255:                                         {
13256:                                             FSerrno = CE_WRITE_ERROR;
13257:                                             return EOF;
13258:                                         }
13259:                                         /* print the actual number */
13260:                                         for (cval = *++q; cval; cval = *++q)
13261:                                             if (FSputc (cval, handle) == EOF)
13262:                                             {
13263:                                                 FSerrno = CE_WRITE_ERROR;
13264:                                                 return EOF;
13265:                                             }
13266:                                         /* if there are any spaces left, they go to right-pad
13267:                                             the field */
13268:                                         if (str_put_n_chars (handle, space_cnt, ' '))
13269:                                         {
13270:                                             FSerrno = CE_WRITE_ERROR;
13271:                                             return EOF;
13272:                                         }
13273:             
13274:                                         count += precision + digit_cnt + space_cnt + prefix_cnt;
13275:                                     }
13276:                                     break;
13277:                             case 'n':
13278:                                 switch (size)
13279:                                 {
13280:                                     case _FMT_LONG:
13281:                                         *(long *) va_arg (ap, long *) = count;
13282:                                         break;
13283:             #ifdef __18CXX
13284:                                     case _FMT_SHRTLONG:
13285:                                         *(short long *) va_arg (ap, short long *) = count;
13286:                                         break;
13287:             #else
13288:                                     case _FMT_LONGLONG:
13289:                                         *(long long *) va_arg (ap, long long *) = count;
13290:                                         break;
13291:             #endif
13292:                                     case _FMT_BYTE:
13293:                                         *(signed char *) va_arg (ap, signed char *) = count;
13294:                                         break;
13295:                                     default:
13296:                                         *(int *) va_arg (ap, int *) = count;
13297:                                         break;
13298:                                 }
13299:                                 break;
13300:                             default:
13301:                                 /* undefined behaviour. we do nothing */
13302:                                 break;
13303:                         }
13304:                     }
13305:                     else
13306:                     {
13307:                         if (FSputc (c, handle) == EOF)
13308:                         {
13309:                             FSerrno = CE_WRITE_ERROR;
13310:                             return EOF;
13311:                         }
13312:                         ++count;
13313:                     }
13314:                 }
13315:                 return count;
13316:             }
13317:             
13318:             
13319:             
13320:             #endif
13321:             
13322:             
13323:             
13324:             
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libconn/connection.c  ----
014BB8  781F88     MOV W8, [W15++]
0156B4  780080     MOV W0, W1
01588A  780080     MOV W0, W1
015A7C  780201     MOV W1, W4
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include "connection.h"
31:                
32:                #include <string.h>
33:                #include <assert.h>
34:                #include <stdint.h>
35:                
36:                #include "logging.h"
37:                #include "usb_config.h"
38:                #include "usb_host_android.h"
39:                #include "usb_host_bluetooth.h"
40:                #include "adb_private.h"
41:                #include "adb_file_private.h"
42:                #include "bt_app.h"
43:                #include "accessory.h"
44:                
45:                typedef enum {
46:                  STATE_BT_DISCONNECTED,
47:                  STATE_BT_INITIALIZING,
48:                  STATE_BT_INITIALIZED,
49:                } BT_STATE;
50:                
51:                typedef enum {
52:                  STATE_ADB_DISCONNECTED,
53:                  STATE_ADB_INITIALIZING,
54:                  STATE_ADB_INITIALIZED
55:                } ADB_STATE;
56:                
57:                typedef enum {
58:                  STATE_ACC_DISCONNECTED,
59:                  STATE_ACC_INITIALIZING,
60:                  STATE_ACC_INITIALIZED
61:                } ACC_STATE;
62:                
63:                static BT_STATE bt_state;
64:                static ADB_STATE adb_state;
65:                static ACC_STATE acc_state;
66:                
67:                #define BUF_SIZE 1024
68:                static uint8_t buf[BUF_SIZE];  // shared between Bluetooth and accessory, as
69:                                               // they are mutually exclusive
70:                
71:                static void ConnBTTasks() {
72:                  switch (bt_state) {
01374A  831EE0     MOV bt_state, W0
01374C  E00000     CP0 W0
01374E  320003     BRA Z, 0x13756
013750  500FE2     SUB W0, #0x2, [W15]
013752  3E0018     BRA GTU, 0x13784
013754  370008     BRA 0x13766
73:                    case STATE_BT_DISCONNECTED:
74:                      if (USBHostBluetoothIsDeviceAttached()) {
013756  26E420     MOV #0x6E42, W0
013758  E00010     CP0 [W0]
01375A  320014     BRA Z, 0x13784
75:                        BTInit(buf, BUF_SIZE);
01375C  204001     MOV #0x400, W1
01375E  25FD80     MOV #0x5FD8, W0
013760  07085D     RCALL BTInit
76:                        bt_state = STATE_BT_INITIALIZING;
013762  200010     MOV #0x1, W0
013764  370005     BRA 0x13770
77:                      }
78:                      break;
79:                
80:                    case STATE_BT_INITIALIZING:
81:                    case STATE_BT_INITIALIZED:
82:                      if (!USBHostBluetoothIsDeviceAttached()) {
013766  26E420     MOV #0x6E42, W0
013768  E00010     CP0 [W0]
01376A  3A0004     BRA NZ, 0x13774
83:                        // disconnected
84:                        BTShutdown();
01376C  071805     RCALL BTShutdown
85:                        bt_state = STATE_BT_DISCONNECTED;
01376E  EB0000     CLR W0
013770  8B1EE0     MOV W0, bt_state
013772  370008     BRA 0x13784
86:                      } else {
87:                #ifndef USB_ENABLE_TRANSFER_EVENT
88:                        USBHostBluetoothTasks();
013774  07FD41     RCALL USBHostBluetoothTasks
89:                #endif
90:                        BTTasks();
013776  0714C5     RCALL BTTasks
91:                        bt_state = BTAccepting() ? STATE_BT_INITIALIZED : STATE_BT_INITIALIZING;
013778  07173E     RCALL BTAccepting
01377A  EA0080     NEG W0, W1
01377C  708080     IOR W1, W0, W1
01377E  DE08CF     LSR W1, #15, W1
013780  E80081     INC W1, W1
013782  8B1EE1     MOV W1, bt_state
92:                      }
93:                      break;
94:                  }
95:                }
96:                
97:                static void ConnADBTasks() {
98:                  int res;
99:                
100:                 if (!ADBAttached()) {
013784  0717A9     RCALL ADBAttached
013786  E00000     CP0 W0
013788  320019     BRA Z, 0x137BC
101:                   adb_state = STATE_ADB_DISCONNECTED;
102:                   return;
103:                 }
104:               
105:                 switch (adb_state) {
01378A  831ED0     MOV adb_state, W0
01378C  E00000     CP0 W0
01378E  320003     BRA Z, 0x13796
013790  500FE2     SUB W0, #0x2, [W15]
013792  3E0015     BRA GTU, 0x137BE
013794  370006     BRA 0x137A2
106:                   case STATE_ADB_DISCONNECTED:
107:                     if (ADBAttached()) {
013796  0717A0     RCALL ADBAttached
013798  E00000     CP0 W0
01379A  320011     BRA Z, 0x137BE
108:                       ADBInit();
01379C  071690     RCALL ADBInit
109:                       ADBFileInit();
01379E  071697     RCALL ADBFileInit
0137A0  37000C     BRA 0x137BA
110:                       adb_state = STATE_ADB_INITIALIZING;
111:                     }
112:                     break;
113:               
114:                   case STATE_ADB_INITIALIZING:
115:                   case STATE_ADB_INITIALIZED:
116:                     res = ADBTasks();
0137A2  07E747     RCALL ADBTasks
117:                     if (res == -1) {
0137A4  400FE1     ADD W0, #0x1, [W15]
0137A6  3A0002     BRA NZ, 0x137AC
118:                       log_printf("Error occured. Resetting Android USB.");
119:                       USBHostAndroidReset();
0137A8  071666     RCALL USBHostAndroidReset
0137AA  370009     BRA 0x137BE
120:                       break;
121:                     }
122:                     if (res == 1) {
0137AC  500FE1     SUB W0, #0x1, [W15]
0137AE  3A0003     BRA NZ, 0x137B6
123:                       ADBFileTasks();
0137B0  070887     RCALL ADBFileTasks
124:                       adb_state = STATE_ADB_INITIALIZED;
0137B2  200020     MOV #0x2, W0
0137B4  370003     BRA 0x137BC
125:                     } else if (res == 0) {
0137B6  E00000     CP0 W0
0137B8  3A0002     BRA NZ, 0x137BE
126:                       adb_state = STATE_ADB_INITIALIZING;
0137BA  200010     MOV #0x1, W0
0137BC  8B1ED0     MOV W0, adb_state
127:                     }
128:                     break;
129:                 }
130:               }
131:               
132:               void ConnAccessoryTasks() {
133:                 switch (acc_state) {
014BBA  831EC0     MOV acc_state, W0
014BBC  E00000     CP0 W0
014BBE  320003     BRA Z, 0x14BC6
014BC0  500FE2     SUB W0, #0x2, [W15]
014BC2  3E001C     BRA GTU, 0x14BFC
014BC4  370009     BRA 0x14BD8
134:                   case STATE_ACC_DISCONNECTED:
135:                     if (USBHostAndroidIsInterfaceAttached(ANDROID_INTERFACE_ACC)) {
014BC6  270A60     MOV #0x70A6, W0
014BC8  780010     MOV [W0], W0
014BCA  600061     AND W0, #0x1, W0
014BCC  320017     BRA Z, 0x14BFC
136:                       AccessoryInit(buf, BUF_SIZE);
014BCE  204001     MOV #0x400, W1
014BD0  25FD80     MOV #0x5FD8, W0
014BD2  070C9B     RCALL AccessoryInit
137:                       acc_state = STATE_ACC_INITIALIZING;
014BD4  200010     MOV #0x1, W0
014BD6  370011     BRA 0x14BFA
138:                     }
139:                     break;
140:               
141:                   case STATE_ACC_INITIALIZING:
142:                   case STATE_ACC_INITIALIZED:
143:                     if (!USBHostAndroidIsInterfaceAttached(ANDROID_INTERFACE_ACC)) {
014BD8  270A60     MOV #0x70A6, W0
014BDA  780010     MOV [W0], W0
014BDC  600461     AND W0, #0x1, W8
014BDE  3A0003     BRA NZ, 0x14BE6
144:                       AccessoryShutdown();
014BE0  070D78     RCALL AccessoryShutdown
145:                       acc_state = STATE_ACC_DISCONNECTED;
014BE2  8B1EC8     MOV W8, acc_state
014BE4  37000B     BRA 0x14BFC
146:                     } else {
147:                       int res = AccessoryTasks();
014BE6  07F369     RCALL AccessoryTasks
014BE8  780080     MOV W0, W1
148:                       if (res == -1) {
014BEA  400FE1     ADD W0, #0x1, [W15]
014BEC  3A0002     BRA NZ, 0x14BF2
149:                         log_printf("Error occured. Resetting Android USB.");
150:                         USBHostAndroidReset();
014BEE  070C43     RCALL USBHostAndroidReset
014BF0  370005     BRA 0x14BFC
151:                         break;
152:                       }
153:                       acc_state = res ? STATE_ACC_INITIALIZED : STATE_ACC_INITIALIZING;
014BF2  EA0000     NEG W0, W0
014BF4  700001     IOR W0, W1, W0
014BF6  DE004F     LSR W0, #15, W0
014BF8  E80000     INC W0, W0
014BFA  8B1EC0     MOV W0, acc_state
154:                     }
155:                 }
156:               }
157:               
158:               void ConnectionInit() {
159:                 BOOL res = USBHostInit(0);
0164FC  B80060     MUL.UU W0, #0, W0
0164FE  07F76E     RCALL USBHostInit
160:                 (void) res;  // get rid of unused warning.
161:                 assert(res);
162:                 bt_state = STATE_BT_DISCONNECTED;
016500  EB0000     CLR W0
016502  8B1EE0     MOV W0, bt_state
163:                 adb_state = STATE_ADB_DISCONNECTED;
016504  8B1ED0     MOV W0, adb_state
164:                 acc_state = STATE_ACC_DISCONNECTED;
016506  8B1EC0     MOV W0, acc_state
165:               }
166:               
167:               BOOL ConnectionTasks() {
168:                 USBHostTasks();
013746  07C41E     RCALL USBHostTasks
169:               #ifndef USB_ENABLE_TRANSFER_EVENT
170:                 USBHostAndroidTasks();
013748  070479     RCALL USBHostAndroidTasks
171:               #endif
172:                 ConnBTTasks();
173:                 ConnADBTasks();
174:                 ConnAccessoryTasks();
0137BE  0709FC     RCALL ConnAccessoryTasks
175:               
176:                 return USBHostDeviceStatus(0 /* ignored */) == USB_DEVICE_ATTACHED;
0137C0  EB4000     CLR.B W0
0137C2  070DF1     RCALL USBHostDeviceStatus
0137C4  EB0100     CLR W2
0137C6  B3C301     MOV #0x30, W1
0137C8  504F81     SUB.B W0, W1, [W15]
0137CA  3A0001     BRA NZ, 0x137CE
0137CC  200012     MOV #0x1, W2
177:               }
178:               
179:               void ConnectionResetUSB() {
180:                 USBHostShutdown();
016770  37F650     BRA USBHostShutdown
181:               }
182:               
183:               BOOL ConnectionTypeSupported(CHANNEL_TYPE con) {
184:                 switch (con) {
01588C  500FE1     SUB W0, #0x1, [W15]
01588E  320009     BRA Z, 0x158A2
015890  390004     BRA NC, 0x1589A
015892  EB0000     CLR W0
015894  508FE2     SUB W1, #0x2, [W15]
015896  3A000E     BRA NZ, 0x158B4
015898  370009     BRA 0x158AC
185:                   case CHANNEL_TYPE_ADB:
186:                     return adb_state >= STATE_ADB_INITIALIZING;
01589A  831ED0     MOV adb_state, W0
01589C  E00000     CP0 W0
01589E  32000A     BRA Z, 0x158B4
0158A0  050010     RETLW #0x1, W0
187:                   case CHANNEL_TYPE_ACC:
188:                     return acc_state >= STATE_ACC_INITIALIZING;
0158A2  831EC0     MOV acc_state, W0
0158A4  E00000     CP0 W0
0158A6  320006     BRA Z, 0x158B4
0158A8  780001     MOV W1, W0
0158AA  060000     RETURN
189:                   case CHANNEL_TYPE_BT:
190:                     return bt_state >= STATE_BT_INITIALIZING;
0158AC  831EE0     MOV bt_state, W0
0158AE  E00000     CP0 W0
0158B0  320001     BRA Z, 0x158B4
0158B2  200010     MOV #0x1, W0
191:                   default:
192:                     return FALSE;
193:                 }
194:               }
195:               
196:               BOOL ConnectionCanOpenChannel(CHANNEL_TYPE con) {
197:                 switch (con) {
0156B6  500FE1     SUB W0, #0x1, [W15]
0156B8  320008     BRA Z, 0x156CA
0156BA  390004     BRA NC, 0x156C4
0156BC  EB0100     CLR W2
0156BE  500FE2     SUB W0, #0x2, [W15]
0156C0  3A000F     BRA NZ, 0x156E0
0156C2  370009     BRA 0x156D6
198:                   case CHANNEL_TYPE_ADB:
199:                     return adb_state == STATE_ADB_INITIALIZED;
0156C4  EB0100     CLR W2
0156C6  831ED0     MOV adb_state, W0
0156C8  370008     BRA 0x156DA
200:                   case CHANNEL_TYPE_ACC:
201:                     return acc_state == STATE_ACC_INITIALIZED;
0156CA  EB0100     CLR W2
0156CC  831EC0     MOV acc_state, W0
0156CE  500FE2     SUB W0, #0x2, [W15]
0156D0  3A0007     BRA NZ, 0x156E0
0156D2  780101     MOV W1, W2
0156D4  370005     BRA 0x156E0
202:                   case CHANNEL_TYPE_BT:
203:                     return bt_state == STATE_BT_INITIALIZED;
0156D6  EB0100     CLR W2
0156D8  831EE0     MOV bt_state, W0
0156DA  500FE2     SUB W0, #0x2, [W15]
0156DC  3A0001     BRA NZ, 0x156E0
0156DE  200012     MOV #0x1, W2
204:                   default:
205:                     return FALSE;
206:                 }
207:               }
208:               
209:               CHANNEL_HANDLE ConnectionOpenChannelAdb(const char *name, ChannelCallback cb) {
210:                 assert(ADBConnected());
211:                 return ADBOpen(name, cb) | (CHANNEL_TYPE_ADB << 8);
016772  37EAEC     BRA ADBOpen
212:               }
213:               
214:               CHANNEL_HANDLE ConnectionOpenChannelBtServer(ChannelCallback cb) {
215:                 assert(BTAccepting());
216:                 BTSetCallback(cb);
016738  070001     RCALL BTSetCallback
217:                 return CHANNEL_TYPE_BT << 8;  // only one BT channel currently
218:               }
219:               
220:               CHANNEL_HANDLE ConnectionOpenChannelAccessory(ChannelCallback cb) {
221:                 assert(acc_state == STATE_ACC_INITIALIZED);
222:                 return AccessoryOpenChannel(cb) | CHANNEL_TYPE_ACC << 8;
0166CC  07FF8A     RCALL AccessoryOpenChannel
0166CE  A08000     BSET W0, #8
223:               }
224:               
225:               void ConnectionSend(CHANNEL_HANDLE ch, const void *data, int size) {
226:                 switch (ch >> 8) {
015A7E  DE80C8     ASR W0, #8, W1
015A80  508FE1     SUB W1, #0x1, [W15]
015A82  320008     BRA Z, 0x15A94
015A84  508FE2     SUB W1, #0x2, [W15]
015A86  320009     BRA Z, 0x15A9A
015A88  E00001     CP0 W1
015A8A  3A000A     BRA NZ, 0x15AA0
227:                   case CHANNEL_TYPE_ADB:
228:                     ADBWrite(ch & 0xFF, data, size);
015A8C  DE91CF     ASR W2, #15, W3
015A8E  B20FF0     AND #0xFF, W0
015A90  780084     MOV W4, W1
015A92  370425     BRA ADBWrite
229:                     break;
230:               
231:                   case CHANNEL_TYPE_ACC:
232:                     AccessoryWrite(ch & 0xFF, data, size);
015A94  B20FF0     AND #0xFF, W0
015A96  780084     MOV W4, W1
015A98  3705D1     BRA AccessoryWrite
233:                     break;
234:               
235:                   case CHANNEL_TYPE_BT:
236:                     assert((ch & 0xFF) == 0);
237:                     BTWrite(data, size);
238:                     break;
239:                 }
240:               }
241:               
242:               BOOL ConnectionCanSend(CHANNEL_HANDLE ch) {
243:                   switch (ch >> 8) {
015BF8  DE80C8     ASR W0, #8, W1
015BFA  508FE1     SUB W1, #0x1, [W15]
015BFC  320008     BRA Z, 0x15C0E
015BFE  508FE2     SUB W1, #0x2, [W15]
015C00  320009     BRA Z, 0x15C14
015C02  EB0100     CLR W2
015C04  E00001     CP0 W1
015C06  3A0008     BRA NZ, 0x15C18
244:                   case CHANNEL_TYPE_ADB:
245:                     return ADBChannelReady(ch & 0xFF);
015C08  B20FF0     AND #0xFF, W0
015C0A  07011B     RCALL ADBChannelReady
015C0C  370004     BRA 0x15C16
246:               
247:                   case CHANNEL_TYPE_ACC:
248:                     return AccessoryCanWrite(ch & 0xFF);
015C0E  B20FF0     AND #0xFF, W0
015C10  07FED1     RCALL AccessoryCanWrite
015C12  370001     BRA 0x15C16
249:               
250:                   case CHANNEL_TYPE_BT:
251:                     assert((ch & 0xFF) == 0);
252:                     return BTCanWrite();
015C14  070595     RCALL BTCanWrite
015C16  780100     MOV W0, W2
253:               
254:                   default:
255:                     return FALSE;
256:                 }
257:               }
258:               
259:               int ConnectionGetMaxPacket(CHANNEL_HANDLE ch) {
260:                   switch (ch >> 8) {
0162B2  DE8048     ASR W0, #8, W0
0162B4  330006     BRA N, 0x162C2
0162B6  27FFF1     MOV #0x7FFF, W1
0162B8  500FE1     SUB W0, #0x1, [W15]
0162BA  340004     BRA LE, 0x162C4
0162BC  200F21     MOV #0xF2, W1
0162BE  500FE2     SUB W0, #0x2, [W15]
0162C0  320001     BRA Z, 0x162C4
0162C2  EB0080     CLR W1
261:                   case CHANNEL_TYPE_ADB:
262:                   case CHANNEL_TYPE_ACC:
263:                     return 0x7FFF;  // unlimited
264:               
265:                   case CHANNEL_TYPE_BT:
266:                     assert((ch & 0xFF) == 0);
267:                     return 242;
268:               
269:                   default:
270:                     return 0;
271:                 }
272:               }
273:               
274:               void ConnectionCloseChannel(CHANNEL_HANDLE ch) {
275:                   switch (ch >> 8) {
0160E8  DE80C8     ASR W0, #8, W1
0160EA  508FE1     SUB W1, #0x1, [W15]
0160EC  320006     BRA Z, 0x160FA
0160EE  508FE2     SUB W1, #0x2, [W15]
0160F0  320006     BRA Z, 0x160FE
0160F2  E00001     CP0 W1
0160F4  3A0005     BRA NZ, 0x16100
276:                   case CHANNEL_TYPE_ADB:
277:                     ADBClose(ch & 0xFF);
0160F6  B20FF0     AND #0xFF, W0
0160F8  3700E7     BRA ADBClose
278:                     break;
279:               
280:                   case CHANNEL_TYPE_ACC:
281:                     AccessoryCloseChannel(ch & 0xFF);
0160FA  B20FF0     AND #0xFF, W0
0160FC  370277     BRA AccessoryCloseChannel
282:                     break;
283:               
284:                   case CHANNEL_TYPE_BT:
285:                     assert((ch & 0xFF) == 0);
286:                     BTClose();
287:                     break;
288:                 }
289:               }
290:               
291:               BOOL USB_ApplicationEventHandler(BYTE address, USB_EVENT event, void *data, DWORD size) {
292:                 // Handle specific events.
293:                 switch (event) {
294:                  case EVENT_VBUS_REQUEST_POWER:
295:                   // We'll let anything attach.
296:                   return TRUE;
297:               
298:                  case EVENT_VBUS_RELEASE_POWER:
299:                   // We aren't keeping track of power.
300:                   return TRUE;
301:               
302:                  case EVENT_HUB_ATTACH:
303:                   log_printf("***** USB Error - hubs are not supported *****");
304:                   return TRUE;
305:               
306:                  case EVENT_UNSUPPORTED_DEVICE:
307:                   log_printf("***** USB Error - device is not supported *****");
308:                   return TRUE;
309:               
310:                  case EVENT_CANNOT_ENUMERATE:
311:                   log_printf("***** USB Error - cannot enumerate device *****");
312:                   return TRUE;
313:               
314:                  case EVENT_CLIENT_INIT_ERROR:
315:                   log_printf("***** USB Error - client driver initialization error *****");
316:                   return TRUE;
317:               
318:                  case EVENT_OUT_OF_MEMORY:
319:                   log_printf("***** USB Error - out of heap memory *****");
320:                   return TRUE;
321:               
322:                  case EVENT_UNSPECIFIED_ERROR:   // This should never be generated.
323:                   log_printf("***** USB Error - unspecified *****");
324:                   return TRUE;
325:               
326:                  default:
327:                   return FALSE;
328:                 }
329:               }  // USB_ApplicationEventHandler
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libconn/bt_app.c  --------
012BB4  FA0006     LNK #0x6
012BB6  781F88     MOV W8, [W15++]
012BB8  780403     MOV W3, W8
01481C  BE9F88     MOV.D W8, [W15++]
01481E  780480     MOV W0, W9
014820  780401     MOV W1, W8
016102  781F88     MOV W8, [W15++]
016600  780180     MOV W0, W3
016602  780101     MOV W1, W2
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                // Application-layer Bluetooth logic.
31:                
32:                #include "bt_app.h"
33:                
34:                #include <string.h>
35:                #include <assert.h>
36:                #include <stdio.h>
37:                
38:                #include "logging.h"
39:                #include "hci.h"
40:                #include "l2cap.h"
41:                #include "rfcomm.h"
42:                #include "sdp.h"
43:                #include "btstack_memory.h"
44:                #include "hci_transport.h"
45:                #include "btstack/sdp_util.h"
46:                
47:                static void DummyCallback(int h, const void *data, UINT32 size) {
48:                }
49:                
50:                static uint8_t    rfcomm_channel_nr = 1;
51:                static uint16_t   rfcomm_channel_id;
52:                static uint8_t    spp_service_buffer[128] __attribute__((aligned(__alignof(service_record_item_t))));
53:                static uint8_t    rfcomm_send_credit = 0;
54:                static BTCallback client_callback;
55:                static char       local_name[] = "PIXEL (00:00)";  // the digits will be replaced by the MSB of the BD-ADDR
56:                
57:                static void PacketHandler(void * connection, uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size) {
58:                  bd_addr_t event_addr;
59:                  uint8_t rfcomm_channel_nr;
60:                  uint16_t mtu;
61:                
62:                  switch (packet_type) {
012BBA  50CFE4     SUB.B W1, #0x4, [W15]
012BBC  320003     BRA Z, 0x12BC4
012BBE  50CFE7     SUB.B W1, #0x7, [W15]
012BC0  3A0076     BRA NZ, 0x12CAE
012BC2  37006D     BRA 0x12C9E
63:                    case HCI_EVENT_PACKET:
64:                      switch (packet[0]) {
012BC4  784093     MOV.B [W3], W1
012BC6  B3C600     MOV #0x60, W0
012BC8  50CF80     SUB.B W1, W0, [W15]
012BCA  320012     BRA Z, 0x12BF0
012BCC  3E0007     BRA GTU, 0x12BDC
012BCE  50CFF6     SUB.B W1, #0x16, [W15]
012BD0  32003C     BRA Z, 0x12C4A
012BD2  50CFF7     SUB.B W1, #0x17, [W15]
012BD4  320031     BRA Z, 0x12C38
012BD6  50CFEE     SUB.B W1, #0xE, [W15]
012BD8  3A006A     BRA NZ, 0x12CAE
012BDA  370011     BRA 0x12BFE
012BDC  B3C810     MOV #0x81, W0
012BDE  50CF80     SUB.B W1, W0, [W15]
012BE0  320056     BRA Z, 0x12C8E
012BE2  E84000     INC.B W0, W0
012BE4  50CF80     SUB.B W1, W0, [W15]
012BE6  32003E     BRA Z, 0x12C64
012BE8  E9C000     DEC2.B W0, W0
012BEA  50CF80     SUB.B W1, W0, [W15]
012BEC  3A0060     BRA NZ, 0x12CAE
012BEE  370045     BRA 0x12C7A
65:                        case BTSTACK_EVENT_STATE:
66:                          // bt stack activated, get started - set local name
67:                          if (packet[2] == HCI_STATE_WORKING) {
012BF0  904023     MOV.B [W3+2], W0
012BF2  504FE2     SUB.B W0, #0x2, [W15]
012BF4  3A005C     BRA NZ, 0x12CAE
68:                            hci_send_cmd(&hci_write_local_name, local_name);
012BF6  270C90     MOV #0x70C9, W0
012BF8  781F80     MOV W0, [W15++]
012BFA  2EA720     MOV #0xEA72, W0
012BFC  370022     BRA 0x12C42
69:                          }
70:                          break;
71:                
72:                        case HCI_EVENT_COMMAND_COMPLETE:
73:                          if (COMMAND_COMPLETE_EVENT(packet, hci_read_bd_addr)) {
012BFE  904033     MOV.B [W3+3], W0
012C00  FB8000     ZE W0, W0
012C02  9040C3     MOV.B [W3+4], W1
012C04  DD08C8     SL W1, #8, W1
012C06  700081     IOR W0, W1, W1
012C08  2EA180     MOV #0xEA18, W0
012C0A  508F90     SUB W1, [W0], [W15]
012C0C  3A000F     BRA NZ, 0x12C2C
74:                            bt_flip_addr(event_addr, &packet[6]);
012C0E  4180E6     ADD W3, #0x6, W1
012C10  78000E     MOV W14, W0
012C12  071AAB     RCALL bt_flip_addr
75:                            log_printf("BD-ADDR: %s\n\r", bd_addr_to_str(event_addr));
76:                            sprintf(local_name, "PIXEL (%02X:%02X)", event_addr[4], event_addr[5]);
012C14  90405E     MOV.B [W14+5], W0
012C16  FB8000     ZE W0, W0
012C18  781F80     MOV W0, [W15++]
012C1A  90404E     MOV.B [W14+4], W0
012C1C  FB8000     ZE W0, W0
012C1E  781F80     MOV W0, [W15++]
012C20  270780     MOV #0x7078, W0
012C22  781F80     MOV W0, [W15++]
012C24  270C90     MOV #0x70C9, W0
012C26  079583     RCALL _sprintf_cdnopuxX
77:                            break;
012C28  5787E6     SUB W15, #0x6, W15
012C2A  370041     BRA 0x12CAE
78:                          }
79:                          if (COMMAND_COMPLETE_EVENT(packet, hci_write_local_name)) {
012C2C  2EA720     MOV #0xEA72, W0
012C2E  508F90     SUB W1, [W0], [W15]
012C30  3A003E     BRA NZ, 0x12CAE
80:                            hci_discoverable_control(1);
012C32  B3C010     MOV #0x1, W0
012C34  071B6A     RCALL hci_discoverable_control
012C36  37003B     BRA 0x12CAE
81:                            break;
82:                          }
83:                          break;
84:                
85:                        case HCI_EVENT_LINK_KEY_REQUEST:
86:                          // deny link key request
87:                          log_printf("Link key request\n\r");
88:                          bt_flip_addr(event_addr, &packet[2]);
012C38  E88083     INC2 W3, W1
012C3A  78000E     MOV W14, W0
012C3C  071A96     RCALL bt_flip_addr
89:                          hci_send_cmd(&hci_link_key_request_negative_reply, &event_addr);
012C3E  781F8E     MOV W14, [W15++]
012C40  2EAD80     MOV #0xEAD8, W0
012C42  781F80     MOV W0, [W15++]
012C44  071B06     RCALL hci_send_cmd
90:                          break;
012C46  5787E4     SUB W15, #0x4, W15
012C48  370032     BRA 0x12CAE
91:                
92:                        case HCI_EVENT_PIN_CODE_REQUEST:
93:                          // inform about pin code request
94:                          log_printf("Pin code request - using '4545'\n\r");
95:                          bt_flip_addr(event_addr, &packet[2]);
012C4A  E88083     INC2 W3, W1
012C4C  78000E     MOV W14, W0
012C4E  071A8D     RCALL bt_flip_addr
96:                          hci_send_cmd(&hci_pin_code_request_reply, &event_addr, 4, "4545");
012C50  2708A0     MOV #0x708A, W0
012C52  781F80     MOV W0, [W15++]
012C54  200040     MOV #0x4, W0
012C56  781F80     MOV W0, [W15++]
012C58  781F8E     MOV W14, [W15++]
012C5A  2EAD40     MOV #0xEAD4, W0
012C5C  781F80     MOV W0, [W15++]
012C5E  071AF9     RCALL hci_send_cmd
97:                          break;
012C60  5787E8     SUB W15, #0x8, W15
012C62  370025     BRA 0x12CAE
98:                
99:                        case RFCOMM_EVENT_INCOMING_CONNECTION:
100:                         // data: event (8), len(8), address(48), channel (8), rfcomm_cid (16)
101:                         bt_flip_addr(event_addr, &packet[2]);
012C64  E88083     INC2 W3, W1
012C66  78000E     MOV W14, W0
012C68  071A80     RCALL bt_flip_addr
102:                         rfcomm_channel_nr = packet[8];
103:                         rfcomm_channel_id = READ_BT_16(packet, 9);
012C6A  904818     MOV.B [W8+9], W0
012C6C  FB8000     ZE W0, W0
012C6E  9048A8     MOV.B [W8+10], W1
012C70  DD08C8     SL W1, #8, W1
012C72  700001     IOR W0, W1, W0
012C74  8B7FF0     MOV W0, rfcomm_channel_id
104:                         log_printf("RFCOMM channel %u requested for %s\n\r", rfcomm_channel_nr, bd_addr_to_str(event_addr));
105:                         rfcomm_accept_connection_internal(rfcomm_channel_id);
012C76  07130D     RCALL rfcomm_accept_connection_internal
012C78  37001A     BRA 0x12CAE
106:                         break;
107:               
108:                       case RFCOMM_EVENT_OPEN_CHANNEL_COMPLETE:
109:                         // data: event(8), len(8), status (8), address (48), server channel(8), rfcomm_cid(16), max frame size(16)
110:                         if (packet[2]) {
012C7A  904023     MOV.B [W3+2], W0
012C7C  E00400     CP0.B W0
012C7E  3A0017     BRA NZ, 0x12CAE
111:                           log_printf("RFCOMM channel open failed, status %u\n\r", packet[2]);
112:                         } else {
113:                           rfcomm_channel_id = READ_BT_16(packet, 12);
012C80  9048C3     MOV.B [W3+12], W1
012C82  FB8081     ZE W1, W1
012C84  904853     MOV.B [W3+13], W0
012C86  DD0048     SL W0, #8, W0
012C88  708080     IOR W1, W0, W1
012C8A  8B7FF1     MOV W1, rfcomm_channel_id
012C8C  37000D     BRA 0x12CA8
114:                           rfcomm_send_credit = 1;
115:                           mtu = READ_BT_16(packet, 14);
116:                           log_printf("\n\rRFCOMM channel open succeeded. New RFCOMM Channel ID %u, max frame size %u\n\r", rfcomm_channel_id, mtu);
117:                         }
118:                         break;
119:               
120:                       case RFCOMM_EVENT_CHANNEL_CLOSED:
121:                         log_printf("RFCOMM channel closed.");
122:                         client_callback(rfcomm_channel_id, NULL, 0);
012C8E  837FF0     MOV rfcomm_channel_id, W0
012C90  B81160     MUL.UU W2, #0, W2
012C92  EB0080     CLR W1
012C94  837FE4     MOV client_callback, W4
012C96  010004     CALL W4
123:                         rfcomm_channel_id = 0;
012C98  EB0000     CLR W0
012C9A  8B7FF0     MOV W0, rfcomm_channel_id
012C9C  370008     BRA 0x12CAE
124:                         break;
125:               
126:                       default:
127:                         break;
128:                     }
129:                     break;
130:               
131:                   case RFCOMM_DATA_PACKET:
132:                     client_callback(rfcomm_channel_id, packet, size);
012C9E  B82161     MUL.UU W4, #1, W2
012CA0  837FF0     MOV rfcomm_channel_id, W0
012CA2  780088     MOV W8, W1
012CA4  837FE4     MOV client_callback, W4
012CA6  010004     CALL W4
133:                     rfcomm_send_credit = 1;
012CA8  B3C011     MOV #0x1, W1
012CAA  26FFA0     MOV #0x6FFA, W0
012CAC  784801     MOV.B W1, [W0]
134:               
135:                   default:
136:                     break;
137:                 }
138:               }
139:               
140:               void BTInit(void *buf, int size) {
141:                 btstack_memory_init();
014822  07FFD2     RCALL btstack_memory_init
142:               
143:                 // init HCI
144:                 hci_transport_t * transport = hci_transport_mchpusb_instance(buf, size);
014824  780088     MOV W8, W1
014826  780009     MOV W9, W0
014828  07089B     RCALL hci_transport_mchpusb_instance
145:                 bt_control_t * control = NULL;
146:                 hci_uart_config_t * config = NULL;
147:                 const remote_device_db_t * remote_db = &remote_device_db_memory;
148:                 hci_init(transport, config, control, remote_db);
01482A  2EE483     MOV #0xEE48, W3
01482C  EB0100     CLR W2
01482E  EB0080     CLR W1
014830  0703CF     RCALL hci_init
149:               
150:                 // init L2CAP
151:                 l2cap_init();
014832  070B37     RCALL l2cap_init
152:                 l2cap_register_packet_handler(PacketHandler);
014834  252F00     MOV #0x52F0, W0
014836  070F98     RCALL l2cap_register_packet_handler
153:               
154:                 // init RFCOMM
155:                 rfcomm_init();
014838  070EBC     RCALL rfcomm_init
156:                 rfcomm_register_packet_handler(PacketHandler);
01483A  252F00     MOV #0x52F0, W0
01483C  070F8F     RCALL rfcomm_register_packet_handler
157:                 rfcomm_register_service_internal(NULL, rfcomm_channel_nr, 100); // reserved channel, mtu=100
01483E  200642     MOV #0x64, W2
014840  270C80     MOV #0x70C8, W0
014842  784090     MOV.B [W0], W1
014844  EB0000     CLR W0
014846  070F06     RCALL rfcomm_register_service_internal
158:               
159:                 // init SDP, create record for SPP and register with SDP
160:                 sdp_init();
014848  070EBA     RCALL sdp_init
161:                 memset(spp_service_buffer, 0, sizeof (spp_service_buffer));
01484A  26F7A8     MOV #0x6F7A, W8
01484C  200802     MOV #0x80, W2
01484E  EB0080     CLR W1
014850  780008     MOV W8, W0
014852  078766     RCALL memset
162:                 service_record_item_t * service_record_item = (service_record_item_t *) spp_service_buffer;
163:                 sdp_create_spp_service((uint8_t*) & service_record_item->service_record, 1, "IOIO-App");
014854  2708F2     MOV #0x708F, W2
014856  200011     MOV #0x1, W1
014858  26F840     MOV #0x6F84, W0
01485A  07E9FF     RCALL sdp_create_spp_service
164:                 log_printf("SDP service buffer size: %u\n\r", (uint16_t) (sizeof (service_record_item_t) + de_get_len((uint8_t*) & service_record_item->service_record)));
165:                 sdp_register_service_internal(NULL, service_record_item);
01485C  780088     MOV W8, W1
01485E  EB0000     CLR W0
014860  07F68C     RCALL sdp_register_service_internal
166:               
167:                 hci_power_control(HCI_POWER_ON);
014862  200010     MOV #0x1, W0
014864  07F31A     RCALL hci_power_control
168:               
169:                 client_callback = DummyCallback;
014866  252F40     MOV #0x52F4, W0
014868  8B7FE0     MOV W0, client_callback
170:               }
171:               
172:               void BTShutdown() {
173:                 hci_close();
016778  37FD12     BRA hci_close
174:               }
175:               
176:               void BTTasks() {
177:                 hci_transport_mchpusb_tasks();
016104  07FE49     RCALL hci_transport_mchpusb_tasks
178:               
179:                 if (rfcomm_channel_id && rfcomm_send_credit) {
016106  837FF0     MOV rfcomm_channel_id, W0
016108  E00000     CP0 W0
01610A  320006     BRA Z, 0x16118
01610C  26FFA8     MOV #0x6FFA, W8
01610E  E00418     CP0.B [W8]
016110  320003     BRA Z, 0x16118
180:                   rfcomm_grant_credits(rfcomm_channel_id, 1);
016112  B3C011     MOV #0x1, W1
016114  07FD25     RCALL rfcomm_grant_credits
181:                   rfcomm_send_credit = 0;
016116  EB4C00     CLR.B [W8]
182:                 }
183:               }
184:               
185:               int BTAccepting() {
0165F6  837FF0     MOV rfcomm_channel_id, W0
0165F8  E00000     CP0 W0
0165FA  320001     BRA Z, 0x165FE
0165FC  200010     MOV #0x1, W0
186:                 return rfcomm_channel_id != 0;
187:               }
188:               
189:               void BTSetCallback(BTCallback cb) {
190:                 client_callback = cb;
01673C  8B7FE0     MOV W0, client_callback
191:               }
192:               
193:               void BTWrite(const void *data, int size) {
194:                 assert(!(size >> 16));
195:                 rfcomm_send_internal(rfcomm_channel_id, (uint8_t *) data, size & 0xFFFF);
016604  837FF0     MOV rfcomm_channel_id, W0
016606  780083     MOV W3, W1
016608  37EC0F     BRA rfcomm_send_internal
196:               }
197:               
198:               int BTCanWrite() {
199:                 return rfcomm_can_send(rfcomm_channel_id);
016740  837FF0     MOV rfcomm_channel_id, W0
016742  37F721     BRA rfcomm_can_send
200:               }
201:               
202:               void BTClose() {
203:                 rfcomm_disconnect_internal(rfcomm_channel_id);
016744  837FF0     MOV rfcomm_channel_id, W0
016746  37FC7C     BRA rfcomm_disconnect_internal
204:               }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libconn/accessory.c  -----
0132BA  FA0006     LNK #0x6
0159B4  FA0002     LNK #0x2
0159B6  781F88     MOV W8, [W15++]
01663C  780001     MOV W1, W0
1:                 #include "accessory.h"
2:                 
3:                 #include <assert.h>
4:                 #include <stdint.h>
5:                 
6:                 #include "usb_host_android.h"
7:                 #include "logging.h"
8:                 #include "USB/usb_common.h"
9:                 
10:                typedef enum {
11:                  CHANNEL_INIT,
12:                  CHANNEL_WAIT_OPEN,
13:                  CHANNEL_OPEN,
14:                  CHANNEL_WAIT_CLOSED
15:                } CHANNEL_STATE;
16:                
17:                static void DummyCallback (int h, const void *data, UINT32 size) {}
18:                
19:                static ChannelCallback callback = &DummyCallback;
20:                static void *rx_buf;
21:                static int rx_buf_size;
22:                static CHANNEL_STATE channel_state;
23:                static uint8_t is_channel_open;
24:                
25:                
26:                void AccessoryInit(void *buf, int size) {
27:                  rx_buf = buf;
01650A  8B8820     MOV W0, rx_buf
28:                  rx_buf_size = size;
01650C  8B8811     MOV W1, rx_buf_size
29:                  is_channel_open = 0;
01650E  270FE0     MOV #0x70FE, W0
016510  EB4800     CLR.B [W0]
30:                  channel_state = CHANNEL_INIT;
016512  EB0000     CLR W0
016514  8B8800     MOV W0, channel_state
31:                }
32:                
33:                void AccessoryShutdown() {
34:                  log_printf("AccessoryShutdown()");
35:                  callback = &DummyCallback;
0166D2  252EC0     MOV #0x52EC, W0
0166D4  8B44B0     MOV W0, callback
36:                }
37:                
38:                int AccessoryTasks() {
39:                  DWORD size;
40:                  BYTE err;
41:                
42:                  switch (channel_state) {
0132BC  838800     MOV channel_state, W0
0132BE  500FE1     SUB W0, #0x1, [W15]
0132C0  32000D     BRA Z, 0x132DC
0132C2  390005     BRA NC, 0x132CE
0132C4  500FE2     SUB W0, #0x2, [W15]
0132C6  320024     BRA Z, 0x13310
0132C8  500FE3     SUB W0, #0x3, [W15]
0132CA  3A004B     BRA NZ, 0x13362
0132CC  37003C     BRA 0x13346
43:                    case CHANNEL_INIT:
44:                      USBHostAndroidRead(rx_buf, 1, ANDROID_INTERFACE_ACC);
0132CE  838820     MOV rx_buf, W0
0132D0  EB0080     CLR W1
0132D2  200012     MOV #0x1, W2
0132D4  200003     MOV #0x0, W3
0132D6  070F30     RCALL USBHostAndroidRead
45:                      channel_state = CHANNEL_WAIT_OPEN;
0132D8  200010     MOV #0x1, W0
0132DA  370042     BRA 0x13360
46:                      break;
47:                
48:                    case CHANNEL_WAIT_OPEN:
49:                      if (USBHostAndroidRxIsComplete(&err, &size, ANDROID_INTERFACE_ACC)) {
0132DC  EB0100     CLR W2
0132DE  5780E4     SUB W15, #0x4, W1
0132E0  578066     SUB W15, #0x6, W0
0132E2  0715FF     RCALL USBHostAndroidRxIsComplete
0132E4  E00000     CP0 W0
0132E6  32003D     BRA Z, 0x13362
50:                        if (err != USB_SUCCESS) {
0132E8  97F82F     MOV.B [W15-6], W0
0132EA  E00400     CP0.B W0
0132EC  3A0040     BRA NZ, 0x1336E
51:                          log_printf("Read failed with error code %d", err);
52:                          return -1;
53:                        }
54:                        USBHostAndroidWrite(&is_channel_open, 1, ANDROID_INTERFACE_ACC);
0132EE  EB0080     CLR W1
0132F0  200012     MOV #0x1, W2
0132F2  200003     MOV #0x0, W3
0132F4  270FE0     MOV #0x70FE, W0
0132F6  07103C     RCALL USBHostAndroidWrite
55:                        if (is_channel_open) {
0132F8  270FE0     MOV #0x70FE, W0
0132FA  E00410     CP0.B [W0]
0132FC  320007     BRA Z, 0x1330C
56:                          USBHostAndroidRead(rx_buf, rx_buf_size, ANDROID_INTERFACE_ACC);
0132FE  838812     MOV rx_buf_size, W2
013300  DE91CF     ASR W2, #15, W3
013302  838820     MOV rx_buf, W0
013304  EB0080     CLR W1
013306  070F18     RCALL USBHostAndroidRead
57:                          channel_state = CHANNEL_OPEN;
013308  200020     MOV #0x2, W0
01330A  37002A     BRA 0x13360
58:                        } else {
59:                          channel_state = CHANNEL_WAIT_CLOSED;
01330C  200030     MOV #0x3, W0
01330E  370028     BRA 0x13360
60:                        }
61:                      }
62:                      break;
63:                
64:                    case CHANNEL_OPEN:
65:                      if (USBHostAndroidRxIsComplete(&err, &size, ANDROID_INTERFACE_ACC)) {
013310  EB0100     CLR W2
013312  5780E4     SUB W15, #0x4, W1
013314  578066     SUB W15, #0x6, W0
013316  0715E5     RCALL USBHostAndroidRxIsComplete
013318  E00000     CP0 W0
01331A  320023     BRA Z, 0x13362
66:                        if (err != USB_SUCCESS) {
01331C  97F82F     MOV.B [W15-6], W0
01331E  E00400     CP0.B W0
013320  3A0026     BRA NZ, 0x1336E
67:                          log_printf("Read failed with error code %d", err);
68:                          return -1;
69:                        }
70:                        if (size) {
013322  97B96F     MOV [W15-4], W2
013324  97B9FF     MOV [W15-2], W3
013326  510FE0     SUB W2, #0x0, [W15]
013328  598FE0     SUBB W3, #0x0, [W15]
01332A  320004     BRA Z, 0x13334
71:                          callback(0, rx_buf, size);
01332C  838821     MOV rx_buf, W1
01332E  EB0000     CLR W0
013330  8344B4     MOV callback, W4
013332  010004     CALL W4
72:                        }
73:                        // Channel might have been closed from within the callback.
74:                        if (channel_state == CHANNEL_OPEN) {
013334  838800     MOV channel_state, W0
013336  500FE2     SUB W0, #0x2, [W15]
013338  3A0014     BRA NZ, 0x13362
75:                          USBHostAndroidRead(rx_buf, rx_buf_size, ANDROID_INTERFACE_ACC);
01333A  838812     MOV rx_buf_size, W2
01333C  DE91CF     ASR W2, #15, W3
01333E  838820     MOV rx_buf, W0
013340  EB0080     CLR W1
013342  070EFA     RCALL USBHostAndroidRead
013344  37000E     BRA 0x13362
76:                        }
77:                      }
78:                      break;
79:                
80:                    case CHANNEL_WAIT_CLOSED:
81:                      if (USBHostAndroidTxIsComplete(&err, ANDROID_INTERFACE_ACC)) {
013346  EB0080     CLR W1
013348  578066     SUB W15, #0x6, W0
01334A  0716F5     RCALL USBHostAndroidTxIsComplete
01334C  E00000     CP0 W0
01334E  320009     BRA Z, 0x13362
82:                        if (err != USB_SUCCESS) {
013350  97F82F     MOV.B [W15-6], W0
013352  E00400     CP0.B W0
013354  3A000C     BRA NZ, 0x1336E
83:                          log_printf("Write failed with error code %d", err);
84:                          return -1;
85:                        }
86:                        callback(0, NULL, 0);
013356  B81160     MUL.UU W2, #0, W2
013358  B80060     MUL.UU W0, #0, W0
01335A  8344B4     MOV callback, W4
01335C  010004     CALL W4
87:                        channel_state = CHANNEL_INIT;
01335E  EB0000     CLR W0
013360  8B8800     MOV W0, channel_state
88:                      }
89:                      break;
90:                  }
91:                  return channel_state == CHANNEL_INIT;
013362  EB0080     CLR W1
013364  838800     MOV channel_state, W0
013366  E00000     CP0 W0
013368  3A0003     BRA NZ, 0x13370
01336A  200011     MOV #0x1, W1
01336C  370001     BRA 0x13370
01336E  EB8080     SETM W1
92:                }
93:                
94:                CHANNEL_HANDLE AccessoryOpenChannel(ChannelCallback cb) {
95:                  assert(channel_state < CHANNEL_OPEN);
96:                
97:                  callback = cb;
0165E2  8B44B0     MOV W0, callback
98:                  is_channel_open = 1;
0165E4  B3C011     MOV #0x1, W1
0165E6  270FE0     MOV #0x70FE, W0
0165E8  784801     MOV.B W1, [W0]
99:                  return 0;
100:               }
101:               
102:               void AccessoryCloseChannel(CHANNEL_HANDLE h) {
103:                 assert(h == 0);
104:                 assert(channel_state == CHANNEL_OPEN);
105:                 is_channel_open = 0;
0165EC  270FE0     MOV #0x70FE, W0
0165EE  EB4800     CLR.B [W0]
106:                 channel_state = CHANNEL_WAIT_CLOSED;
0165F0  200030     MOV #0x3, W0
0165F2  8B8800     MOV W0, channel_state
107:               }
108:               
109:               void AccessoryWrite(CHANNEL_HANDLE h, const void *data, int size) {
110:                 assert(h == 0);
111:                 assert(channel_state == CHANNEL_OPEN);
112:                 USBHostAndroidWrite(data, size, ANDROID_INTERFACE_ACC);
01663E  DE91CF     ASR W2, #15, W3
016640  EB0080     CLR W1
016642  37F696     BRA USBHostAndroidWrite
113:               }
114:               
115:               int AccessoryCanWrite(CHANNEL_HANDLE h) {
116:                 BYTE err;
117:                 assert(h == 0);
118:                 assert(channel_state <= CHANNEL_OPEN);
119:                 if (channel_state != CHANNEL_OPEN) return 0;
0159B8  EB0400     CLR W8
0159BA  838800     MOV channel_state, W0
0159BC  500FE2     SUB W0, #0x2, [W15]
0159BE  3A000A     BRA NZ, 0x159D4
120:                 int res = USBHostAndroidTxIsComplete(&err, ANDROID_INTERFACE_ACC);
0159C0  EB0080     CLR W1
0159C2  578064     SUB W15, #0x4, W0
0159C4  0703B8     RCALL USBHostAndroidTxIsComplete
0159C6  780400     MOV W0, W8
121:                 if (res && err != USB_SUCCESS) {
0159C8  E00000     CP0 W0
0159CA  320004     BRA Z, 0x159D4
0159CC  97F84F     MOV.B [W15-4], W0
0159CE  E00400     CP0.B W0
0159D0  320001     BRA Z, 0x159D4
122:                   log_printf("Write failed with error code %d", err);
123:                   USBHostAndroidReset();
0159D2  070551     RCALL USBHostAndroidReset
124:                 }
125:                 return res;
126:               }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libbtstack/src/utils.c  --
015CEE  781F88     MOV W8, [W15++]
015CF0  784402     MOV.B W2, W8
015FEC  780200     MOV W0, W4
1:                 /*
2:                  * Copyright (C) 2009-2012 by Matthias Ringwald
3:                  *
4:                  * Redistribution and use in source and binary forms, with or without
5:                  * modification, are permitted provided that the following conditions
6:                  * are met:
7:                  *
8:                  * 1. Redistributions of source code must retain the above copyright
9:                  *    notice, this list of conditions and the following disclaimer.
10:                 * 2. Redistributions in binary form must reproduce the above copyright
11:                 *    notice, this list of conditions and the following disclaimer in the
12:                 *    documentation and/or other materials provided with the distribution.
13:                 * 3. Neither the name of the copyright holders nor the names of
14:                 *    contributors may be used to endorse or promote products derived
15:                 *    from this software without specific prior written permission.
16:                 * 4. Any redistribution, use, or modification is done solely for
17:                 *    personal benefit and not for any commercial purpose or for
18:                 *    monetary gain.
19:                 *
20:                 * THIS SOFTWARE IS PROVIDED BY MATTHIAS RINGWALD AND CONTRIBUTORS
21:                 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
22:                 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
23:                 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MATTHIAS
24:                 * RINGWALD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
25:                 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
26:                 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
27:                 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
28:                 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
29:                 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
30:                 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
31:                 * SUCH DAMAGE.
32:                 *
33:                 * Please inquire about commercial licensing options at btstack@ringwald.ch
34:                 *
35:                 */
36:                
37:                /*
38:                 *  utils.c
39:                 *
40:                 *  General utility functions
41:                 *
42:                 *  Created by Matthias Ringwald on 7/23/09.
43:                 */
44:                
45:                #include "config.h"
46:                #include <btstack/utils.h>
47:                #include <stdio.h>
48:                #include "debug.h"
49:                
50:                void bt_store_16(uint8_t *buffer, uint16_t pos, uint16_t value){
51:                    buffer[pos++] = value;
016614  78F002     MOV.B W2, [W0+W1]
52:                    buffer[pos++] = value >> 8;
016616  408080     ADD W1, W0, W1
016618  DE1148     LSR W2, #8, W2
01661A  984092     MOV.B W2, [W1+1]
53:                }
54:                
55:                void bt_store_32(uint8_t *buffer, uint16_t pos, uint32_t value){
56:                    buffer[pos++] = value;
016150  78F002     MOV.B W2, [W0+W1]
57:                    buffer[pos++] = value >> 8;
016152  408080     ADD W1, W0, W1
016154  DE1AC8     LSR W3, #8, W5
016156  DD1848     SL W3, #8, W0
016158  DE1248     LSR W2, #8, W4
01615A  700204     IOR W0, W4, W4
01615C  984094     MOV.B W4, [W1+1]
58:                    buffer[pos++] = value >> 16;
01615E  DE1A40     LSR W3, #0, W4
016160  200005     MOV #0x0, W5
016162  9840A4     MOV.B W4, [W1+2]
59:                    buffer[pos++] = value >> 24;
016164  DE1948     LSR W3, #8, W2
016166  9840B2     MOV.B W2, [W1+3]
60:                }
61:                
62:                void net_store_16(uint8_t *buffer, uint16_t pos, uint16_t value){
63:                    buffer[pos++] = value >> 8;
01661E  DE11C8     LSR W2, #8, W3
016620  78F003     MOV.B W3, [W0+W1]
64:                    buffer[pos++] = value;
016622  408080     ADD W1, W0, W1
016624  984092     MOV.B W2, [W1+1]
65:                }
66:                
67:                void net_store_32(uint8_t *buffer, uint16_t pos, uint32_t value){
68:                    buffer[pos++] = value >> 24;
015FD0  DE1A48     LSR W3, #8, W4
015FD2  200005     MOV #0x0, W5
015FD4  78F004     MOV.B W4, [W0+W1]
69:                    buffer[pos++] = value >> 16;
015FD6  408080     ADD W1, W0, W1
015FD8  DE1A40     LSR W3, #0, W4
015FDA  200005     MOV #0x0, W5
015FDC  984094     MOV.B W4, [W1+1]
70:                    buffer[pos++] = value >> 8;
015FDE  DE1AC8     LSR W3, #8, W5
015FE0  DD1848     SL W3, #8, W0
015FE2  DE1248     LSR W2, #8, W4
015FE4  700204     IOR W0, W4, W4
015FE6  9840A4     MOV.B W4, [W1+2]
71:                    buffer[pos++] = value;
015FE8  9840B2     MOV.B W2, [W1+3]
72:                }
73:                
74:                void bt_flip_addr(bd_addr_t dest, bd_addr_t src){
75:                    dest[0] = src[5];
01616A  904151     MOV.B [W1+5], W2
01616C  784802     MOV.B W2, [W0]
76:                    dest[1] = src[4];
01616E  904141     MOV.B [W1+4], W2
016170  984012     MOV.B W2, [W0+1]
77:                    dest[2] = src[3];
016172  904131     MOV.B [W1+3], W2
016174  984022     MOV.B W2, [W0+2]
78:                    dest[3] = src[2];
016176  904121     MOV.B [W1+2], W2
016178  984032     MOV.B W2, [W0+3]
79:                    dest[4] = src[1];
01617A  904111     MOV.B [W1+1], W2
01617C  984042     MOV.B W2, [W0+4]
80:                    dest[5] = src[0];
01617E  784091     MOV.B [W1], W1
016180  984051     MOV.B W1, [W0+5]
81:                }
82:                
83:                void hexdump(void *data, int size){
01659A  EB0000     CLR W0
01659C  370001     BRA 0x165A0
84:                    int i;
85:                    for (i=0; i<size;i++){
01659E  E80000     INC W0, W0
0165A0  500F81     SUB W0, W1, [W15]
0165A2  35FFFD     BRA LT, 0x1659E
86:                        log_info("%02X ", ((uint8_t *)data)[i]);
87:                    }
88:                    log_info("\n");
89:                }
90:                
91:                void printUUID(uint8_t *uuid) {
92:                    log_info("%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
93:                           uuid[0], uuid[1], uuid[2], uuid[3], uuid[4], uuid[5], uuid[6], uuid[7],
94:                           uuid[8], uuid[9], uuid[10], uuid[11], uuid[12], uuid[13], uuid[14], uuid[15]);
95:                }
96:                
97:                static char bd_addr_to_str_buffer[6*3];  // 12:45:78:01:34:67\0
98:                char * bd_addr_to_str(bd_addr_t addr){
99:                    sprintf(bd_addr_to_str_buffer, "%02x:%02x:%02x:%02x:%02x:%02x", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
015650  9040D0     MOV.B [W0+5], W1
015652  FB8081     ZE W1, W1
015654  781F81     MOV W1, [W15++]
015656  9040C0     MOV.B [W0+4], W1
015658  FB8081     ZE W1, W1
01565A  781F81     MOV W1, [W15++]
01565C  9040B0     MOV.B [W0+3], W1
01565E  FB8081     ZE W1, W1
015660  781F81     MOV W1, [W15++]
015662  9040A0     MOV.B [W0+2], W1
015664  FB8081     ZE W1, W1
015666  781F81     MOV W1, [W15++]
015668  904090     MOV.B [W0+1], W1
01566A  FB8081     ZE W1, W1
01566C  781F81     MOV W1, [W15++]
01566E  FB8010     ZE [W0], W0
015670  781F80     MOV W0, [W15++]
015672  2EC0C0     MOV #0xEC0C, W0
015674  781F80     MOV W0, [W15++]
015676  21FEA0     MOV #0x1FEA, W0
015678  02572E     CALL _sprintf_cdnopuxX
01567A  000000     NOP
01567C  5787EE     SUB W15, #0xE, W15
100:                   return (char *) bd_addr_to_str_buffer;
101:               }
102:               
103:               void print_bd_addr( bd_addr_t addr){
104:                   log_info("%s", bd_addr_to_str(addr));
105:               }
106:               
107:               #ifndef EMBEDDED
108:               int sscan_bd_addr(uint8_t * addr_string, bd_addr_t addr){
109:               	unsigned int bd_addr_buffer[BD_ADDR_LEN];  //for sscanf, integer needed
110:               	// reset result buffer
111:               	int i;
112:                   for (i = 0; i < BD_ADDR_LEN; i++) {
113:                       bd_addr_buffer[i] = 0;
114:                   }
115:                   
116:               	// parse
117:                   int result = sscanf( (char *) addr_string, "%2x:%2x:%2x:%2x:%2x:%2x", &bd_addr_buffer[0], &bd_addr_buffer[1], &bd_addr_buffer[2],
118:               						&bd_addr_buffer[3], &bd_addr_buffer[4], &bd_addr_buffer[5]);
119:               	// store
120:               	if (result == 6){
121:               		for (i = 0; i < BD_ADDR_LEN; i++) {
122:               			addr[i] = (uint8_t) bd_addr_buffer[i];
123:               		}
124:               	}
125:               	return (result == 6);
126:               }
127:               #endif
128:               
129:               /*  
130:                * CRC (reversed crc) lookup table as calculated by the table generator in ETSI TS 101 369 V6.3.0.
131:                */
132:               static const uint8_t crc8table[256] = {    /* reversed, 8-bit, poly=0x07 */
133:                   0x00, 0x91, 0xE3, 0x72, 0x07, 0x96, 0xE4, 0x75, 0x0E, 0x9F, 0xED, 0x7C, 0x09, 0x98, 0xEA, 0x7B,
134:                   0x1C, 0x8D, 0xFF, 0x6E, 0x1B, 0x8A, 0xF8, 0x69, 0x12, 0x83, 0xF1, 0x60, 0x15, 0x84, 0xF6, 0x67,
135:                   0x38, 0xA9, 0xDB, 0x4A, 0x3F, 0xAE, 0xDC, 0x4D, 0x36, 0xA7, 0xD5, 0x44, 0x31, 0xA0, 0xD2, 0x43,
136:                   0x24, 0xB5, 0xC7, 0x56, 0x23, 0xB2, 0xC0, 0x51, 0x2A, 0xBB, 0xC9, 0x58, 0x2D, 0xBC, 0xCE, 0x5F,
137:                   0x70, 0xE1, 0x93, 0x02, 0x77, 0xE6, 0x94, 0x05, 0x7E, 0xEF, 0x9D, 0x0C, 0x79, 0xE8, 0x9A, 0x0B,
138:                   0x6C, 0xFD, 0x8F, 0x1E, 0x6B, 0xFA, 0x88, 0x19, 0x62, 0xF3, 0x81, 0x10, 0x65, 0xF4, 0x86, 0x17,
139:                   0x48, 0xD9, 0xAB, 0x3A, 0x4F, 0xDE, 0xAC, 0x3D, 0x46, 0xD7, 0xA5, 0x34, 0x41, 0xD0, 0xA2, 0x33,
140:                   0x54, 0xC5, 0xB7, 0x26, 0x53, 0xC2, 0xB0, 0x21, 0x5A, 0xCB, 0xB9, 0x28, 0x5D, 0xCC, 0xBE, 0x2F,
141:                   0xE0, 0x71, 0x03, 0x92, 0xE7, 0x76, 0x04, 0x95, 0xEE, 0x7F, 0x0D, 0x9C, 0xE9, 0x78, 0x0A, 0x9B,
142:                   0xFC, 0x6D, 0x1F, 0x8E, 0xFB, 0x6A, 0x18, 0x89, 0xF2, 0x63, 0x11, 0x80, 0xF5, 0x64, 0x16, 0x87,
143:                   0xD8, 0x49, 0x3B, 0xAA, 0xDF, 0x4E, 0x3C, 0xAD, 0xD6, 0x47, 0x35, 0xA4, 0xD1, 0x40, 0x32, 0xA3,
144:                   0xC4, 0x55, 0x27, 0xB6, 0xC3, 0x52, 0x20, 0xB1, 0xCA, 0x5B, 0x29, 0xB8, 0xCD, 0x5C, 0x2E, 0xBF,
145:                   0x90, 0x01, 0x73, 0xE2, 0x97, 0x06, 0x74, 0xE5, 0x9E, 0x0F, 0x7D, 0xEC, 0x99, 0x08, 0x7A, 0xEB,
146:                   0x8C, 0x1D, 0x6F, 0xFE, 0x8B, 0x1A, 0x68, 0xF9, 0x82, 0x13, 0x61, 0xF0, 0x85, 0x14, 0x66, 0xF7,
147:                   0xA8, 0x39, 0x4B, 0xDA, 0xAF, 0x3E, 0x4C, 0xDD, 0xA6, 0x37, 0x45, 0xD4, 0xA1, 0x30, 0x42, 0xD3,
148:                   0xB4, 0x25, 0x57, 0xC6, 0xB3, 0x22, 0x50, 0xC1, 0xBA, 0x2B, 0x59, 0xC8, 0xBD, 0x2C, 0x5E, 0xCF
149:               };
150:               
151:               #define CRC8_INIT  0xFF          // Initial FCS value 
152:               #define CRC8_OK    0xCF          // Good final FCS value 
153:               /*-----------------------------------------------------------------------------------*/
154:               uint8_t crc8(uint8_t *data, uint16_t len)
155:               {
015FEE  EBC180     SETM.B W3
015FF0  EB0100     CLR W2
015FF2  2EB0C5     MOV #0xEB0C, W5
015FF4  370005     BRA 0x16000
156:                   uint16_t count;
157:                   uint8_t crc = CRC8_INIT;
158:                   for (count = 0; count < len; count++)
015FFE  E80102     INC W2, W2
016000  510F81     SUB W2, W1, [W15]
016002  39FFF9     BRA NC, 0x15FF6
016004  FB8003     ZE W3, W0
159:                       crc = crc8table[crc ^ data[count]];
015FF6  7A4062     MOV.B [W2+W4], W0
015FF8  69C000     XOR.B W3, W0, W0
015FFA  FB8000     ZE W0, W0
015FFC  7841E5     MOV.B [W5+W0], W3
160:                   return crc;
161:               }
162:               
163:               /*-----------------------------------------------------------------------------------*/
164:               uint8_t crc8_check(uint8_t *data, uint16_t len, uint8_t check_sum)
165:               {
166:                   uint8_t crc;
167:                   
168:                   crc = crc8(data, len);
015CF2  025FEC     CALL crc8
015CF4  000001     NOP
015CF6  EB4100     CLR.B W2
015CF8  684008     XOR.B W0, W8, W0
015CFA  FB8000     ZE W0, W0
015CFC  2EB0C1     MOV #0xEB0C, W1
015CFE  7840E1     MOV.B [W1+W0], W1
015D00  B3CCF0     MOV #0xCF, W0
015D02  50CF80     SUB.B W1, W0, [W15]
015D04  3A0001     BRA NZ, 0x15D08
015D06  B3C012     MOV #0x1, W2
015D08  A20402     BTG.B W2, #0
015D0A  FB8002     ZE W2, W0
169:                   
170:                   crc = crc8table[crc ^ check_sum];
171:                   if (crc == CRC8_OK) 
172:                       return 0;               /* Valid */
173:                   else 
174:                       return 1;               /* Failed */
175:                   
176:               }
177:               
178:               /*-----------------------------------------------------------------------------------*/
179:               uint8_t crc8_calc(uint8_t *data, uint16_t len)
180:               {
181:                   /* Ones complement */
182:                   return 0xFF - crc8(data, len);
016628  025FEC     CALL crc8
01662A  000001     NOP
01662C  EAC000     COM.B W0, W0
01662E  FB8000     ZE W0, W0
183:               }
184:               
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libbtstack/src/sdp_util.c  
011C5A  BE9F88     MOV.D W8, [W15++]
011C5C  BE9F8A     MOV.D W10, [W15++]
011C5E  781F8C     MOV W12, [W15++]
011C60  780480     MOV W0, W9
011C62  780581     MOV W1, W11
011C64  780602     MOV W2, W12
012648  FA0002     LNK #0x2
01264A  BE9F88     MOV.D W8, [W15++]
01264C  BE9F8A     MOV.D W10, [W15++]
01264E  780480     MOV W0, W9
012650  780401     MOV W1, W8
012652  780582     MOV W2, W11
013C64  FA0004     LNK #0x4
013C66  BE9F88     MOV.D W8, [W15++]
013C68  781F8A     MOV W10, [W15++]
013C6A  780480     MOV W0, W9
013C6C  780501     MOV W1, W10
013C6E  780404     MOV W4, W8
013DBA  BE9F88     MOV.D W8, [W15++]
013DBC  BE9F8A     MOV.D W10, [W15++]
013DBE  BE9F8C     MOV.D W12, [W15++]
013DC0  780500     MOV W0, W10
013DC2  780681     MOV W1, W13
013DC4  780602     MOV W2, W12
013E94  BE9F88     MOV.D W8, [W15++]
013E96  BE9F8A     MOV.D W10, [W15++]
013E98  BE9F8C     MOV.D W12, [W15++]
013E9A  781F8E     MOV W14, [W15++]
013E9C  780580     MOV W0, W11
013E9E  780701     MOV W1, W14
013EA0  780502     MOV W2, W10
013EA2  BE0404     MOV.D W4, W8
013FD4  BE9F88     MOV.D W8, [W15++]
013FD6  BE9F8A     MOV.D W10, [W15++]
013FD8  BE9F8C     MOV.D W12, [W15++]
013FDA  BE0600     MOV.D W0, W12
013FDC  780504     MOV W4, W10
014104  780280     MOV W0, W5
014106  780201     MOV W1, W4
0143A0  780200     MOV W0, W4
01471C  BE9F88     MOV.D W8, [W15++]
01471E  BE9F8A     MOV.D W10, [W15++]
014720  780480     MOV W0, W9
014722  780301     MOV W1, W6
014724  BE0502     MOV.D W2, W10
014A44  BE0200     MOV.D W0, W4
014A90  BE9F88     MOV.D W8, [W15++]
014A92  BE9F8A     MOV.D W10, [W15++]
014A94  BE9F8C     MOV.D W12, [W15++]
014A96  780500     MOV W0, W10
014A98  780681     MOV W1, W13
014A9A  780602     MOV W2, W12
014C48  781F88     MOV W8, [W15++]
014C4A  780281     MOV W1, W5
014C4C  780403     MOV W3, W8
014E60  FA0010     LNK #0x10
014E62  781F88     MOV W8, [W15++]
014E64  780403     MOV W3, W8
0150FC  BE9F88     MOV.D W8, [W15++]
0150FE  781F8A     MOV W10, [W15++]
015100  780400     MOV W0, W8
015102  780182     MOV W2, W3
015302  BE9F88     MOV.D W8, [W15++]
015304  BE9F8A     MOV.D W10, [W15++]
015306  780480     MOV W0, W9
015308  780501     MOV W1, W10
01585C  FA0010     LNK #0x10
01585E  781F88     MOV W8, [W15++]
015860  780080     MOV W0, W1
015862  780403     MOV W3, W8
01598A  FA000C     LNK #0xC
01598C  781F88     MOV W8, [W15++]
01598E  780404     MOV W4, W8
015BAC  780302     MOV W2, W6
015BAE  BE0104     MOV.D W4, W2
015BD2  BE9F88     MOV.D W8, [W15++]
015BD4  780481     MOV W1, W9
015BD6  780404     MOV W4, W8
015E20  BE9F88     MOV.D W8, [W15++]
015E22  780400     MOV W0, W8
016094  781F88     MOV W8, [W15++]
016096  780400     MOV W0, W8
0160B0  FA0008     LNK #0x8
0160CC  FA000A     LNK #0xA
016220  FA0004     LNK #0x4
016222  780181     MOV W1, W3
01629A  BE9F88     MOV.D W8, [W15++]
01629C  780480     MOV W0, W9
016378  FA0004     LNK #0x4
01638E  FA0004     LNK #0x4
0163A4  FA0004     LNK #0x4
0163BA  FA0004     LNK #0x4
0163D0  FA0002     LNK #0x2
1:                 /*
2:                  * Copyright (C) 2009-2012 by Matthias Ringwald
3:                  *
4:                  * Redistribution and use in source and binary forms, with or without
5:                  * modification, are permitted provided that the following conditions
6:                  * are met:
7:                  *
8:                  * 1. Redistributions of source code must retain the above copyright
9:                  *    notice, this list of conditions and the following disclaimer.
10:                 * 2. Redistributions in binary form must reproduce the above copyright
11:                 *    notice, this list of conditions and the following disclaimer in the
12:                 *    documentation and/or other materials provided with the distribution.
13:                 * 3. Neither the name of the copyright holders nor the names of
14:                 *    contributors may be used to endorse or promote products derived
15:                 *    from this software without specific prior written permission.
16:                 * 4. Any redistribution, use, or modification is done solely for
17:                 *    personal benefit and not for any commercial purpose or for
18:                 *    monetary gain.
19:                 *
20:                 * THIS SOFTWARE IS PROVIDED BY MATTHIAS RINGWALD AND CONTRIBUTORS
21:                 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
22:                 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
23:                 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MATTHIAS
24:                 * RINGWALD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
25:                 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
26:                 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
27:                 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
28:                 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
29:                 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
30:                 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
31:                 * SUCH DAMAGE.
32:                 *
33:                 * Please inquire about commercial licensing options at btstack@ringwald.ch
34:                 *
35:                 */
36:                
37:                /*
38:                 *  sdp_util.c
39:                 */
40:                
41:                #include <btstack/sdp_util.h>
42:                #include <btstack/utils.h>
43:                
44:                #include <stdio.h>
45:                #include <stdlib.h>
46:                #include <string.h>
47:                #include <stdint.h>
48:                
49:                // workaround for missing PRIx32 on mspgcc (16-bit MCU)
50:                #ifndef PRIx32
51:                #warning Using own: #define PRIx32 "lx"
52:                #define PRIx32 "lx"
53:                #endif
54:                
55:                // date element type names
56:                const char * const type_names[] = { "NIL", "UINT", "INT", "UUID", "STRING", "BOOL", "DES", "DEA", "URL"};
57:                
58:                // Bluetooth Base UUID: 00000000-0000-1000-8000- 00805F9B34FB
59:                const uint8_t sdp_bluetooth_base_uuid[] = { 0x00, 0x00, 0x00, 0x00, /* - */ 0x00, 0x00, /* - */ 0x10, 0x00, /* - */
60:                    0x80, 0x00, /* - */ 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB };
61:                
62:                void sdp_normalize_uuid(uint8_t *uuid, uint32_t shortUUID){
63:                    memcpy(uuid, sdp_bluetooth_base_uuid, 16);
016542  2EC2A1     MOV #0xEC2A, W1
016544  09000F     REPEAT #0xF
016546  785831     MOV.B [W1++], [W0++]
016548  B10100     SUB #0x10, W0
64:                    net_store_32(uuid, 0, shortUUID);
01654A  EB0080     CLR W1
01654C  045FD0     GOTO net_store_32
01654E  000001     NOP
65:                }
66:                
67:                // MARK: DataElement getter
68:                de_size_t de_get_size_type(uint8_t *header){
016714  FB8010     ZE [W0], W0
016716  600067     AND W0, #0x7, W0
69:                    return (de_size_t) (header[0] & 7);
013DE2  FB8000     ZE W0, W0
013DE4  6000E7     AND W0, #0x7, W1
014108  FB8011     ZE [W1], W0
01410A  6000E7     AND W0, #0x7, W1
0143A6  6000E7     AND W0, #0x7, W1
016362  FB8010     ZE [W0], W0
016364  600067     AND W0, #0x7, W0
70:                }
71:                
72:                de_type_t de_get_element_type(uint8_t *header){
01671A  FB8010     ZE [W0], W0
01671C  DE0043     LSR W0, #3, W0
73:                    return (de_type_t) (header[0] >> 3);
013DE0  7C406A     MOV.B [W10+W8], W0
0143A2  FB8010     ZE [W0], W0
0143A4  DE0143     LSR W0, #3, W2
74:                }
75:                
76:                int de_get_header_size(uint8_t * header){
77:                    de_size_t de_size = de_get_size_type(header);
78:                    if (de_size <= DE_SIZE_128) {
016366  200011     MOV #0x1, W1
016368  500FE4     SUB W0, #0x4, [W15]
01636A  360004     BRA LEU, 0x16374
79:                        return 1;
80:                    }
81:                    return 1 + (1 << (de_size-DE_SIZE_VAR_8));
01636C  5000E5     SUB W0, #0x5, W1
01636E  200010     MOV #0x1, W0
016370  DD0001     SL W0, W1, W0
016372  E80080     INC W0, W1
82:                }
83:                
84:                int de_get_data_size(uint8_t * header){
85:                    uint32_t result = 0;
86:                    de_type_t de_type = de_get_element_type(header);
87:                    de_size_t de_size = de_get_size_type(header);
88:                    switch (de_size){
0143A8  508FE6     SUB W1, #0x6, [W15]
0143AA  320008     BRA Z, 0x143BC
0143AC  508FE7     SUB W1, #0x7, [W15]
0143AE  32000D     BRA Z, 0x143CA
0143B0  508FE5     SUB W1, #0x5, [W15]
0143B2  3A001E     BRA NZ, 0x143F0
89:                        case DE_SIZE_VAR_8:
90:                            result = header[1];
0143B4  904014     MOV.B [W4+1], W0
0143B6  FB8000     ZE W0, W0
0143B8  200001     MOV #0x0, W1
0143BA  060000     RETURN
91:                            break;
92:                        case DE_SIZE_VAR_16:
93:                            result = READ_NET_16(header,1);
0143BC  9040A4     MOV.B [W4+2], W1
0143BE  FB8081     ZE W1, W1
0143C0  904014     MOV.B [W4+1], W0
0143C2  DD0048     SL W0, #8, W0
0143C4  708080     IOR W1, W0, W1
0143C6  B80861     MUL.UU W1, #1, W0
0143C8  060000     RETURN
94:                            break;
95:                        case DE_SIZE_VAR_32:
96:                            result = READ_NET_32(header,1);
0143CA  904144     MOV.B [W4+4], W2
0143CC  FB8102     ZE W2, W2
0143CE  200003     MOV #0x0, W3
0143D0  904034     MOV.B [W4+3], W0
0143D2  DD0048     SL W0, #8, W0
0143D4  200001     MOV #0x0, W1
0143D6  710100     IOR W2, W0, W2
0143D8  718181     IOR W3, W1, W3
0143DA  904024     MOV.B [W4+2], W0
0143DC  FB8080     ZE W0, W1
0143DE  200000     MOV #0x0, W0
0143E0  710100     IOR W2, W0, W2
0143E2  718181     IOR W3, W1, W3
0143E4  904014     MOV.B [W4+1], W0
0143E6  DD00C8     SL W0, #8, W1
0143E8  200000     MOV #0x0, W0
0143EA  710000     IOR W2, W0, W0
0143EC  718081     IOR W3, W1, W1
0143EE  060000     RETURN
97:                            break;
98:                        default:
99:                        // case DE_SIZE_8:
100:                       // case DE_SIZE_16:
101:                       // case DE_SIZE_32:
102:                       // case DE_SIZE_64:
103:                       // case DE_SIZE_128:
104:                           if (de_type == DE_NIL) return 0;
0143F0  EB0000     CLR W0
0143F2  E00402     CP0.B W2
0143F4  320002     BRA Z, 0x143FA
105:                           return 1 << de_size;
0143F6  200010     MOV #0x1, W0
0143F8  DD0001     SL W0, W1, W0
106:                   }
107:                   return result;    
108:               }
109:               
110:               int de_get_len(uint8_t *header){
111:                   return de_get_header_size(header) + de_get_data_size(header); 
01629E  026362     CALL de_get_header_size
0162A0  000001     NOP
0162A2  780400     MOV W0, W8
0162A4  780009     MOV W9, W0
0162A6  0243A0     CALL de_get_data_size
0162A8  000001     NOP
0162AA  440400     ADD W8, W0, W8
112:               }
113:               
114:               // @returns: element is valid UUID
115:               int de_get_normalized_uuid(uint8_t *uuid128, uint8_t *element){
116:                   de_type_t uuidType = de_get_element_type(element);
117:                   de_size_t uuidSize = de_get_size_type(element);
118:                   if (uuidType != DE_UUID) return 0;
01410C  DE0043     LSR W0, #3, W0
01410E  504FE3     SUB.B W0, #0x3, [W15]
014110  3A002A     BRA NZ, 0x14166
119:                   uint32_t shortUUID;
120:                   switch (uuidSize){
014112  508FE2     SUB W1, #0x2, [W15]
014114  32000B     BRA Z, 0x1412C
014116  508FE4     SUB W1, #0x4, [W15]
014118  32001C     BRA Z, 0x14152
01411A  508FE1     SUB W1, #0x1, [W15]
01411C  3A0024     BRA NZ, 0x14166
121:                       case DE_SIZE_16:
122:                           shortUUID = READ_NET_16(element, 1);
01411E  9040A4     MOV.B [W4+2], W1
014120  FB8081     ZE W1, W1
014122  904014     MOV.B [W4+1], W0
014124  DD0048     SL W0, #8, W0
014126  708080     IOR W1, W0, W1
014128  B80961     MUL.UU W1, #1, W2
01412A  370019     BRA 0x1415E
123:                           break;
124:                       case DE_SIZE_32:
125:                           shortUUID = READ_NET_32(element, 1);
01412C  904144     MOV.B [W4+4], W2
01412E  FB8102     ZE W2, W2
014130  200003     MOV #0x0, W3
014132  904034     MOV.B [W4+3], W0
014134  DD0048     SL W0, #8, W0
014136  200001     MOV #0x0, W1
014138  710100     IOR W2, W0, W2
01413A  718181     IOR W3, W1, W3
01413C  904024     MOV.B [W4+2], W0
01413E  FB8080     ZE W0, W1
014140  200000     MOV #0x0, W0
014142  710100     IOR W2, W0, W2
014144  718181     IOR W3, W1, W3
014146  904014     MOV.B [W4+1], W0
014148  DD00C8     SL W0, #8, W1
01414A  200000     MOV #0x0, W0
01414C  710100     IOR W2, W0, W2
01414E  718181     IOR W3, W1, W3
014150  370006     BRA 0x1415E
126:                           break;
127:                       case DE_SIZE_128:
128:                           memcpy(uuid128, element+1, 16);
014152  E80004     INC W4, W0
014154  09000F     REPEAT #0xF
014156  785AB0     MOV.B [W0++], [W5++]
014158  B10105     SUB #0x10, W5
01415A  B10100     SUB #0x10, W0
01415C  370003     BRA 0x14164
129:                           return 1;
130:                       default:
131:                           return 0;
132:                   }
133:                   sdp_normalize_uuid(uuid128, shortUUID);
01415E  780005     MOV W5, W0
014160  026542     CALL sdp_normalize_uuid
014162  000001     NOP
014164  050010     RETLW #0x1, W0
134:                   return 1;
135:               }
136:               
137:               // functions to create record
138:               static void de_store_descriptor(uint8_t * header, de_type_t type, de_size_t size){
139:                   header[0] = (type << 3) | size; 
016720  DD08C3     SL W1, #3, W1
016722  70C802     IOR.B W1, W2, [W0]
140:               }
141:               
142:               void de_store_descriptor_with_len(uint8_t * header, de_type_t type, de_size_t size, uint32_t len){
143:                   header[0] = (type << 3) | size; 
015BB0  DD08C3     SL W1, #3, W1
015BB2  70C806     IOR.B W1, W6, [W0]
144:                   switch (size){
015BB4  530FE6     SUB W6, #0x6, [W15]
015BB6  320006     BRA Z, 0x15BC4
015BB8  530FE7     SUB W6, #0x7, [W15]
015BBA  320007     BRA Z, 0x15BCA
015BBC  530FE5     SUB W6, #0x5, [W15]
015BBE  3A0008     BRA NZ, 0x15BD0
145:                       case DE_SIZE_VAR_8:
146:                           header[1] = len;
015BC0  984014     MOV.B W4, [W0+1]
015BC2  060000     RETURN
147:                           break;
148:                       case DE_SIZE_VAR_16:
149:                           net_store_16(header, 1, len);
015BC4  200011     MOV #0x1, W1
015BC6  04661E     GOTO net_store_16
015BC8  000001     NOP
150:                           break;
151:                       case DE_SIZE_VAR_32:
152:                           net_store_32(header, 1, len);
153:                           break;
154:                       default:
155:                           break;
156:                   }
157:               }
158:               
159:               // MARK: DataElement creation
160:               
161:               /* starts a new sequence in empty buffer - first call */
162:               void de_create_sequence(uint8_t *header){
163:                   de_store_descriptor_with_len( header, DE_DES, DE_SIZE_VAR_16, 0); // DES, 2 Byte Length
016632  B82260     MUL.UU W4, #0, W4
016634  200062     MOV #0x6, W2
016636  200061     MOV #0x6, W1
016638  045BAC     GOTO de_store_descriptor_with_len
01663A  000001     NOP
164:               };
165:               
166:               /* starts a sub-sequence, @returns handle for sub-sequence */
167:               uint8_t * de_push_sequence(uint8_t *header){
168:                   int element_len = de_get_len(header);
016098  02629A     CALL de_get_len
01609A  000001     NOP
01609C  440400     ADD W8, W0, W8
169:                   de_store_descriptor_with_len(header+element_len, DE_DES, DE_SIZE_VAR_16, 0); // DES, 2 Byte Length
01609E  B82260     MUL.UU W4, #0, W4
0160A0  200062     MOV #0x6, W2
0160A2  200061     MOV #0x6, W1
0160A4  780008     MOV W8, W0
0160A6  025BAC     CALL de_store_descriptor_with_len
0160A8  000001     NOP
170:                   return header + element_len;
171:               }
172:               
173:               /* closes the current sequence and updates the parent sequence */
174:               void de_pop_sequence(uint8_t * parent, uint8_t * child){
175:                   int child_len = de_get_len(child);
015E2E  780001     MOV W1, W0
015E30  02629A     CALL de_get_len
015E32  000001     NOP
015E34  448100     ADD W9, W0, W2
015E36  200011     MOV #0x1, W1
015E38  780008     MOV W8, W0
015E3A  02661E     CALL net_store_16
015E3C  000001     NOP
176:                   int data_size_parent = READ_NET_16(parent,1);
177:                   net_store_16(parent, 1, data_size_parent + child_len);
015E24  904020     MOV.B [W0+2], W0
015E26  FB8100     ZE W0, W2
015E28  904018     MOV.B [W8+1], W0
015E2A  DD0048     SL W0, #8, W0
015E2C  710480     IOR W2, W0, W9
178:               }
179:               
180:               /* adds a single number value and 16+32 bit UUID to the sequence */
181:               void de_add_number(uint8_t *seq, de_type_t type, de_size_t size, uint32_t value){
182:                   int data_size   = READ_NET_16(seq,1);
013EA4  904020     MOV.B [W0+2], W0
013EA6  FB8000     ZE W0, W0
013EA8  90409B     MOV.B [W11+1], W1
013EAA  DD08C8     SL W1, #8, W1
013EAC  700601     IOR W0, W1, W12
183:                   int element_size = 1;   // e.g. for DE_TYPE_NIL
184:                   de_store_descriptor(seq+3+data_size, type, size); 
013EAE  45868C     ADD W11, W12, W13
013EB0  468063     ADD W13, #0x3, W0
013EB2  78008E     MOV W14, W1
013EB4  026720     CALL de_store_descriptor
013EB6  000001     NOP
185:                   switch (size){
013EB8  550FE1     SUB W10, #0x1, [W15]
013EBA  320009     BRA Z, 0x13ECE
013EBC  390003     BRA NC, 0x13EC4
013EBE  550FE2     SUB W10, #0x2, [W15]
013EC0  3A0014     BRA NZ, 0x13EEA
013EC2  37000C     BRA 0x13EDC
186:                       case DE_SIZE_8:
187:                           if (type != DE_NIL){
013EC4  E0000E     CP0 W14
013EC6  320011     BRA Z, 0x13EEA
188:                               seq[4+data_size] = value;
013EC8  9846C8     MOV.B W8, [W13+4]
013ECA  200020     MOV #0x2, W0
013ECC  37000F     BRA 0x13EEC
189:                               element_size = 2;
190:                           }
191:                           break;
192:                       case DE_SIZE_16:
193:                           net_store_16(seq, 4+data_size, value);
013ECE  4600E4     ADD W12, #0x4, W1
013ED0  780108     MOV W8, W2
013ED2  78000B     MOV W11, W0
013ED4  02661E     CALL net_store_16
013ED6  000001     NOP
013ED8  200030     MOV #0x3, W0
013EDA  370008     BRA 0x13EEC
194:                           element_size = 3;
195:                           break;
196:                       case DE_SIZE_32:
197:                           net_store_32(seq, 4+data_size, value);
013EDC  4600E4     ADD W12, #0x4, W1
013EDE  BE0108     MOV.D W8, W2
013EE0  78000B     MOV W11, W0
013EE2  025FD0     CALL net_store_32
013EE4  000001     NOP
013EE6  200050     MOV #0x5, W0
013EE8  370001     BRA 0x13EEC
013EEA  200010     MOV #0x1, W0
198:                           element_size = 5;
199:                           break;
200:                       default:
201:                           break;
202:                   }
203:                   net_store_16(seq, 1, data_size+element_size);
013EEC  460100     ADD W12, W0, W2
013EEE  200011     MOV #0x1, W1
013EF0  78000B     MOV W11, W0
013EF2  02661E     CALL net_store_16
013EF4  000001     NOP
204:               }
205:               
206:               /* add a single block of data, e.g. as DE_STRING, DE_URL */
207:               void de_add_data( uint8_t *seq, de_type_t type, uint16_t size, uint8_t *data){
208:                   int data_size   = READ_NET_16(seq,1);
014726  904020     MOV.B [W0+2], W0
014728  FB8000     ZE W0, W0
01472A  904099     MOV.B [W9+1], W1
01472C  DD08C8     SL W1, #8, W1
01472E  700401     IOR W0, W1, W8
014730  200003     MOV #0x0, W3
014732  448088     ADD W9, W8, W1
209:                   if (size > 0xff) {
014734  200FF0     MOV #0xFF, W0
014736  550F80     SUB W10, W0, [W15]
014738  360008     BRA LEU, 0x1474A
210:                       // use 16-bit lengh information (3 byte header)
211:                       de_store_descriptor_with_len(seq+3+data_size, type, DE_SIZE_VAR_16, size); 
01473A  408063     ADD W1, #0x3, W0
01473C  BE0202     MOV.D W2, W4
01473E  200062     MOV #0x6, W2
014740  780086     MOV W6, W1
014742  025BAC     CALL de_store_descriptor_with_len
014744  000001     NOP
212:                       data_size += 3;
014746  440463     ADD W8, #0x3, W8
014748  370007     BRA 0x14758
213:                   } else {
214:                       // use 8-bit lengh information (2 byte header)
215:                       de_store_descriptor_with_len(seq+3+data_size, type, DE_SIZE_VAR_8, size); 
01474A  408063     ADD W1, #0x3, W0
01474C  BE0202     MOV.D W2, W4
01474E  200052     MOV #0x5, W2
014750  780086     MOV W6, W1
014752  025BAC     CALL de_store_descriptor_with_len
014754  000001     NOP
216:                       data_size += 2;
014756  E88408     INC2 W8, W8
217:                   }
218:                   memcpy( seq + 3 + data_size, data, size);
014758  448008     ADD W9, W8, W0
01475A  400063     ADD W0, #0x3, W0
01475C  78010A     MOV W10, W2
01475E  78008B     MOV W11, W1
014760  0256DE     CALL memcpy
014762  000000     NOP
219:                   data_size += size;
220:                   net_store_16(seq, 1, data_size);
014764  44010A     ADD W8, W10, W2
014766  200011     MOV #0x1, W1
014768  780009     MOV W9, W0
01476A  02661E     CALL net_store_16
01476C  000001     NOP
221:               }
222:               
223:               void de_add_uuid128(uint8_t * seq, uint8_t * uuid){
224:                   int data_size   = READ_NET_16(seq,1);
01530A  904020     MOV.B [W0+2], W0
01530C  FB8080     ZE W0, W1
01530E  904019     MOV.B [W9+1], W0
015310  DD0048     SL W0, #8, W0
015312  708580     IOR W1, W0, W11
225:                   de_store_descriptor(seq+3+data_size, DE_UUID, DE_SIZE_128); 
015314  44840B     ADD W9, W11, W8
015316  440063     ADD W8, #0x3, W0
015318  200042     MOV #0x4, W2
01531A  200031     MOV #0x3, W1
01531C  026720     CALL de_store_descriptor
01531E  000001     NOP
226:                   memcpy( seq + 4 + data_size, uuid, 16);
015320  440464     ADD W8, #0x4, W8
015322  09000F     REPEAT #0xF
015324  785C3A     MOV.B [W10++], [W8++]
015326  B10108     SUB #0x10, W8
015328  B1010A     SUB #0x10, W10
227:                   net_store_16(seq, 1, data_size+1+16);
01532A  458171     ADD W11, #0x11, W2
01532C  200011     MOV #0x1, W1
01532E  780009     MOV W9, W0
015330  02661E     CALL net_store_16
015332  000001     NOP
228:               }
229:               
230:               void sdp_add_attribute(uint8_t *seq, uint16_t attributeID, uint8_t attributeValue){
231:               }
232:               
233:               // MARK: DataElementSequence traversal
234:               typedef int (*de_traversal_callback_t)(uint8_t * element, de_type_t type, de_size_t size, void *context);
235:               static void de_traverse_sequence(uint8_t * element, de_traversal_callback_t handler, void *context){
236:                   de_type_t type = de_get_element_type(element);
237:                   if (type != DE_DES) return;
014A9C  FB8010     ZE [W0], W0
014A9E  DE0043     LSR W0, #3, W0
014AA0  504FE6     SUB.B W0, #0x6, [W15]
014AA2  3A0018     BRA NZ, 0x14AD4
238:                   int pos = de_get_header_size(element);
014AA4  78000A     MOV W10, W0
014AA6  026362     CALL de_get_header_size
014AA8  000001     NOP
014AAA  780480     MOV W0, W9
239:                   int end_pos = de_get_len(element);
014AAC  78000A     MOV W10, W0
014AAE  02629A     CALL de_get_len
014AB0  000001     NOP
014AB2  780580     MOV W0, W11
014AB4  37000D     BRA 0x14AD0
240:                   while (pos < end_pos){
014AD0  548F8B     SUB W9, W11, [W15]
014AD2  35FFF1     BRA LT, 0x14AB6
241:                       de_type_t elemType = de_get_element_type(element + pos);
014AB6  450409     ADD W10, W9, W8
242:                       de_size_t elemSize = de_get_size_type(element + pos);
243:                       uint8_t done = (*handler)(element + pos, elemType, elemSize, context); 
014AB8  FB8098     ZE [W8], W1
014ABA  608167     AND W1, #0x7, W2
014ABC  DE08C3     LSR W1, #3, W1
014ABE  78018C     MOV W12, W3
014AC0  780008     MOV W8, W0
014AC2  01000D     CALL W13
244:                       if (done) break;
014AC4  E00400     CP0.B W0
014AC6  3A0006     BRA NZ, 0x14AD4
245:                       pos += de_get_len(element + pos);
014AC8  780008     MOV W8, W0
014ACA  02629A     CALL de_get_len
014ACC  000001     NOP
014ACE  448480     ADD W9, W0, W9
246:                   }
247:               }
248:               
249:               // MARK: AttributeList traversal
250:               typedef int (*sdp_attribute_list_traversal_callback_t)(uint16_t attributeID, uint8_t * attributeValue, de_type_t type, de_size_t size, void *context);
251:               static void sdp_attribute_list_traverse_sequence(uint8_t * element, sdp_attribute_list_traversal_callback_t handler, void *context){
252:                   de_type_t type = de_get_element_type(element);
253:                   if (type != DE_DES) return;
013DC6  FB8010     ZE [W0], W0
013DC8  DE0043     LSR W0, #3, W0
013DCA  504FE6     SUB.B W0, #0x6, [W15]
013DCC  3A0029     BRA NZ, 0x13E20
254:                   int pos = de_get_header_size(element);
013DCE  78000A     MOV W10, W0
013DD0  026362     CALL de_get_header_size
013DD2  000001     NOP
013DD4  780400     MOV W0, W8
255:                   int end_pos = de_get_len(element);
013DD6  78000A     MOV W10, W0
013DD8  02629A     CALL de_get_len
013DDA  000001     NOP
013DDC  780580     MOV W0, W11
013DDE  37001E     BRA 0x13E1C
256:                   while (pos < end_pos){
013E1C  540F8B     SUB W8, W11, [W15]
013E1E  35FFE0     BRA LT, 0x13DE0
257:                       de_type_t idType = de_get_element_type(element + pos);
258:                       de_size_t idSize = de_get_size_type(element + pos);
259:                       if (idType != DE_UINT || idSize != DE_SIZE_16) break; // wrong type
013DE6  DE0043     LSR W0, #3, W0
013DE8  504FE1     SUB.B W0, #0x1, [W15]
013DEA  3A001A     BRA NZ, 0x13E20
013DEC  508FE1     SUB W1, #0x1, [W15]
013DEE  3A0018     BRA NZ, 0x13E20
260:                       uint16_t attribute_id = READ_NET_16(element, pos + 1);
013DF0  450008     ADD W10, W8, W0
013DF2  9040A0     MOV.B [W0+2], W1
013DF4  FB8081     ZE W1, W1
013DF6  904010     MOV.B [W0+1], W0
013DF8  DD0048     SL W0, #8, W0
013DFA  708000     IOR W1, W0, W0
261:                       pos += 3;
013DFC  4404E3     ADD W8, #0x3, W9
262:                       if (pos >= end_pos) break; // array out of bounds
013DFE  548F8B     SUB W9, W11, [W15]
013E00  3D000F     BRA GE, 0x13E20
263:                       de_type_t valueType = de_get_element_type(element + pos);
013E02  450409     ADD W10, W9, W8
264:                       de_size_t valueSize = de_get_size_type(element + pos);
265:                       uint8_t done = (*handler)(attribute_id, element + pos, valueType, valueSize, context); 
013E04  FB8198     ZE [W8], W3
013E06  DE1943     LSR W3, #3, W2
013E08  78020C     MOV W12, W4
013E0A  6181E7     AND W3, #0x7, W3
013E0C  780088     MOV W8, W1
013E0E  01000D     CALL W13
266:                       if (done) break;
013E10  E00400     CP0.B W0
013E12  3A0006     BRA NZ, 0x13E20
267:                       pos += de_get_len(element + pos);
013E14  780008     MOV W8, W0
013E16  02629A     CALL de_get_len
013E18  000001     NOP
013E1A  448400     ADD W9, W0, W8
268:                   }
269:               }
270:               
271:               // MARK: AttributeID in AttributeIDList 
272:               // attribute ID in AttributeIDList
273:               // context { result, attributeID }
274:               struct sdp_context_attributeID_search {
275:                   int result;
276:                   uint16_t attributeID;
277:               };
278:               static int sdp_traversal_attributeID_search(uint8_t * element, de_type_t type, de_size_t size, void *my_context){
279:                   struct sdp_context_attributeID_search * context = (struct sdp_context_attributeID_search *) my_context;
280:                   if (type != DE_UINT) return 0;
014A46  508FE1     SUB W1, #0x1, [W15]
014A48  3A0020     BRA NZ, 0x14A8A
281:                   switch (size) {
014A4A  510FE1     SUB W2, #0x1, [W15]
014A4C  320003     BRA Z, 0x14A54
014A4E  510FE2     SUB W2, #0x2, [W15]
014A50  3A001C     BRA NZ, 0x14A8A
014A52  370009     BRA 0x14A66
282:                       case DE_SIZE_16:
283:                           if (READ_NET_16(element, 1) == context->attributeID) {
014A54  904020     MOV.B [W0+2], W0
014A56  FB8000     ZE W0, W0
014A58  904094     MOV.B [W4+1], W1
014A5A  DD08C8     SL W1, #8, W1
014A5C  700001     IOR W0, W1, W0
014A5E  900093     MOV [W3+2], W1
014A60  500F81     SUB W0, W1, [W15]
014A62  3A0013     BRA NZ, 0x14A8A
014A64  37000F     BRA 0x14A84
284:                               context->result = 1;
285:                               return 1;
286:                           }
287:                           break;
288:                       case DE_SIZE_32:
289:                           if (READ_NET_16(element, 1) <= context->attributeID
014A66  900113     MOV [W3+2], W2
014A68  9040A0     MOV.B [W0+2], W1
014A6A  FB8081     ZE W1, W1
014A6C  904010     MOV.B [W0+1], W0
014A6E  DD0048     SL W0, #8, W0
014A70  708080     IOR W1, W0, W1
014A72  508F82     SUB W1, W2, [W15]
014A74  3E000A     BRA GTU, 0x14A8A
014A76  9040C4     MOV.B [W4+4], W1
014A78  FB8081     ZE W1, W1
014A7A  904034     MOV.B [W4+3], W0
014A7C  DD0048     SL W0, #8, W0
014A7E  708080     IOR W1, W0, W1
014A80  510F81     SUB W2, W1, [W15]
014A82  3E0003     BRA GTU, 0x14A8A
290:                           &&  context->attributeID <= READ_NET_16(element, 3)) {
291:                               context->result = 1;
014A84  780985     MOV W5, [W3]
014A86  780085     MOV W5, W1
014A88  370001     BRA 0x14A8C
292:                               return 1;
014A8A  EB0080     CLR W1
293:                           }
294:                           break;
295:                       default:
296:                           break;
297:                   }
298:                   return 0;
299:               }
300:               int sdp_attribute_list_constains_id(uint8_t *attributeIDList, uint16_t attributeID){
301:                   struct sdp_context_attributeID_search attributeID_search;
302:                   attributeID_search.result = 0;
0163BC  EB0100     CLR W2
0163BE  9FBFE2     MOV W2, [W15-4]
303:                   attributeID_search.attributeID = attributeID;
0163C0  9FBFF1     MOV W1, [W15-2]
304:                   de_traverse_sequence(attributeIDList, sdp_traversal_attributeID_search, &attributeID_search);
0163C2  578164     SUB W15, #0x4, W2
0163C4  253881     MOV #0x5388, W1
0163C6  024A90     CALL de_traverse_sequence
0163C8  000001     NOP
0163CA  97B86F     MOV [W15-4], W0
305:                   return attributeID_search.result;
306:               }
307:               
308:               // MARK: Append Attributes for AttributeIDList
309:               // pre: buffer contains DES with 2 byte length field
310:               struct sdp_context_append_attributes {
311:                   uint8_t * buffer;
312:                   uint16_t startOffset;     // offset of when to start copying
313:                   uint16_t maxBytes;
314:                   uint16_t usedBytes;
315:                   uint8_t *attributeIDList;
316:               };
317:               
318:               static int sdp_traversal_append_attributes(uint16_t attributeID, uint8_t * attributeValue, de_type_t type, de_size_t size, void *my_context){
319:                   struct sdp_context_append_attributes * context = (struct sdp_context_append_attributes *) my_context;
320:                   if (sdp_attribute_list_constains_id(context->attributeIDList, attributeID)) {
013FDE  900044     MOV [W4+8], W0
013FE0  78008C     MOV W12, W1
013FE2  0263BA     CALL sdp_attribute_list_constains_id
013FE4  000001     NOP
013FE6  E00000     CP0 W0
013FE8  3A0002     BRA NZ, 0x13FEE
013FEA  780100     MOV W0, W2
013FEC  370022     BRA 0x14032
321:                       // DES_HEADER(3) + DES_DATA + (UINT16(3) + attribute)
322:                       uint16_t data_size = READ_NET_16(context->buffer, 1);
013FEE  78041A     MOV [W10], W8
013FF0  9040A8     MOV.B [W8+2], W1
013FF2  FB8081     ZE W1, W1
013FF4  904018     MOV.B [W8+1], W0
013FF6  DD0048     SL W0, #8, W0
013FF8  708580     IOR W1, W0, W11
323:                       int attribute_len = de_get_len(attributeValue);
013FFA  78000D     MOV W13, W0
013FFC  02629A     CALL de_get_len
013FFE  000001     NOP
014000  780480     MOV W0, W9
324:                       if (3 + data_size + (3 + attribute_len) <= context->maxBytes) {
014002  458000     ADD W11, W0, W0
014004  400066     ADD W0, #0x6, W0
014006  9000AA     MOV [W10+4], W1
014008  200012     MOV #0x1, W2
01400A  500F81     SUB W0, W1, [W15]
01400C  3E0012     BRA GTU, 0x14032
325:                           // copy Attribute
326:                           de_add_number(context->buffer, DE_UINT, DE_SIZE_16, attributeID);   
01400E  B86261     MUL.UU W12, #1, W4
014010  200011     MOV #0x1, W1
014012  780008     MOV W8, W0
014014  023E94     CALL de_add_number
014016  000001     NOP
327:                           data_size += 3; // 3 bytes
014018  458463     ADD W11, #0x3, W8
328:                           memcpy(context->buffer + 3 + data_size, attributeValue, attribute_len);
01401A  44001A     ADD W8, [W10], W0
01401C  400063     ADD W0, #0x3, W0
01401E  780109     MOV W9, W2
014020  78008D     MOV W13, W1
014022  0256DE     CALL memcpy
014024  000000     NOP
329:                           net_store_16(context->buffer,1,data_size+attribute_len);
014026  440109     ADD W8, W9, W2
014028  200011     MOV #0x1, W1
01402A  78001A     MOV [W10], W0
01402C  02661E     CALL net_store_16
01402E  000001     NOP
014030  EB0100     CLR W2
330:                       } else {
331:                           // not enought space left -> continue with previous element
332:                           return 1;
333:                       }
334:                   }
335:                   return 0;
336:               }
337:               
338:               // maxBytes: maximal size of data element sequence
339:               uint16_t sdp_append_attributes_in_attributeIDList(uint8_t *record, uint8_t *attributeIDList, uint16_t startOffset, uint16_t maxBytes, uint8_t *buffer){
340:                   struct sdp_context_append_attributes context;
341:                   context.buffer = buffer;
0160CE  9FBFB4     MOV W4, [W15-10]
342:                   context.maxBytes = maxBytes;
0160D0  9FBFD3     MOV W3, [W15-6]
343:                   context.usedBytes = 0;
0160D2  EB0180     CLR W3
0160D4  9FBFE3     MOV W3, [W15-4]
344:                   context.startOffset = startOffset;
0160D6  9FBFC2     MOV W2, [W15-8]
345:                   context.attributeIDList = attributeIDList;
0160D8  9FBFF1     MOV W1, [W15-2]
346:                   sdp_attribute_list_traverse_sequence(record, sdp_traversal_append_attributes, &context);
0160DA  57816A     SUB W15, #0xA, W2
0160DC  253781     MOV #0x5378, W1
0160DE  023DBA     CALL sdp_attribute_list_traverse_sequence
0160E0  000001     NOP
0160E2  97B86F     MOV [W15-4], W0
347:                   return context.usedBytes;
348:               }
349:               
350:               // MARK: Filter attributes that match attribute list from startOffset and a max nr bytes
351:               struct sdp_context_filter_attributes {
352:                   uint8_t * buffer;
353:                   uint16_t startOffset;     // offset of when to start copying
354:                   uint16_t maxBytes;
355:                   uint16_t usedBytes;
356:                   uint8_t *attributeIDList;
357:                   int      complete;
358:               };
359:               
360:               // copy data with given start offset and max bytes, returns OK if all data has been copied
361:               static int spd_append_range(struct sdp_context_filter_attributes* context, uint16_t len, uint8_t *data){
362:                   int ok = 1;
363:                   uint16_t remainder_len = len - context->startOffset;
015104  900110     MOV [W0+2], W2
015106  508482     SUB W1, W2, W9
364:                   if (context->maxBytes < remainder_len){
015108  900020     MOV [W0+4], W0
01510A  20001A     MOV #0x1, W10
01510C  500F89     SUB W0, W9, [W15]
01510E  310002     BRA C, 0x15114
015110  780480     MOV W0, W9
015112  EB0500     CLR W10
365:                       remainder_len = context->maxBytes;
366:                       ok = 0;
367:                   }
368:                   memcpy(context->buffer, &data[context->startOffset], remainder_len);
015114  780018     MOV [W8], W0
015116  418082     ADD W3, W2, W1
015118  780109     MOV W9, W2
01511A  0256DE     CALL memcpy
01511C  000000     NOP
369:                   context->usedBytes += remainder_len;
01511E  900038     MOV [W8+6], W0
015120  448000     ADD W9, W0, W0
015122  980430     MOV W0, [W8+6]
370:                   context->buffer    += remainder_len;
015124  448C18     ADD W9, [W8], [W8]
371:                   context->maxBytes  -= remainder_len;
015126  900028     MOV [W8+4], W0
015128  500009     SUB W0, W9, W0
01512A  980420     MOV W0, [W8+4]
372:                   context->startOffset = 0;
01512C  EB0000     CLR W0
01512E  980410     MOV W0, [W8+2]
373:                   return ok;
374:               }
375:               
376:               static int sdp_traversal_filter_attributes(uint16_t attributeID, uint8_t * attributeValue, de_type_t type, de_size_t size, void *my_context){
377:                   struct sdp_context_filter_attributes * context = (struct sdp_context_filter_attributes *) my_context;
378:               
379:                   if (!sdp_attribute_list_constains_id(context->attributeIDList, attributeID)) return 0;
013C70  900044     MOV [W4+8], W0
013C72  780089     MOV W9, W1
013C74  0263BA     CALL sdp_attribute_list_constains_id
013C76  000001     NOP
013C78  E00000     CP0 W0
013C7A  32002A     BRA Z, 0x13CD0
380:               
381:                   // { Attribute ID (Descriptor, big endian 16-bit ID), AttributeValue (data)}
382:               
383:                   // handle Attribute ID
384:                   if (context->startOffset >= 3){
013C7C  900018     MOV [W8+2], W0
013C7E  500FE2     SUB W0, #0x2, [W15]
013C80  360003     BRA LEU, 0x13C88
385:                       context->startOffset -= 3;
013C82  500063     SUB W0, #0x3, W0
013C84  980410     MOV W0, [W8+2]
013C86  370011     BRA 0x13CAA
386:                   } else {
387:                       uint8_t idBuffer[3];
388:                       de_store_descriptor(idBuffer, DE_UINT,  DE_SIZE_16);
013C88  200012     MOV #0x1, W2
013C8A  200011     MOV #0x1, W1
013C8C  57806A     SUB W15, #0xA, W0
013C8E  026720     CALL de_store_descriptor
013C90  000001     NOP
389:                       net_store_16(idBuffer,1,attributeID);
013C92  780109     MOV W9, W2
013C94  200011     MOV #0x1, W1
013C96  57806A     SUB W15, #0xA, W0
013C98  02661E     CALL net_store_16
013C9A  000001     NOP
390:                       
391:                       int ok = spd_append_range(context, 3, idBuffer);
013C9C  57816A     SUB W15, #0xA, W2
013C9E  200031     MOV #0x3, W1
013CA0  780008     MOV W8, W0
013CA2  0250FC     CALL spd_append_range
013CA4  000001     NOP
392:                       if (!ok) {
013CA6  E00000     CP0 W0
013CA8  320010     BRA Z, 0x13CCA
393:                           context->complete = 0;
394:                           return 1;
395:                       }
396:                   }
397:                   
398:                   // handle Attribute Value
399:                   int attribute_len = de_get_len(attributeValue);
013CAC  78000A     MOV W10, W0
013CAE  02629A     CALL de_get_len
013CB0  000001     NOP
013CB2  780080     MOV W0, W1
400:                   if (context->startOffset >= attribute_len) {
013CAA  900498     MOV [W8+2], W9
013CB4  548F80     SUB W9, W0, [W15]
013CB6  390003     BRA NC, 0x13CBE
401:                       context->startOffset -= attribute_len;
013CB8  548000     SUB W9, W0, W0
013CBA  980410     MOV W0, [W8+2]
013CBC  370009     BRA 0x13CD0
402:                       return 0;
403:                   }
404:                   
405:                   int ok = spd_append_range(context, attribute_len, attributeValue);
013CBE  78010A     MOV W10, W2
013CC0  780008     MOV W8, W0
013CC2  0250FC     CALL spd_append_range
013CC4  000001     NOP
406:                   if (!ok) {
013CC6  E00000     CP0 W0
013CC8  3A0003     BRA NZ, 0x13CD0
407:                       context->complete = 0;
013CCA  980450     MOV W0, [W8+10]
013CCC  200010     MOV #0x1, W0
013CCE  370001     BRA 0x13CD2
408:                       return 1;
013CD0  EB0000     CLR W0
409:                   }
410:                   return 0;
411:               }
412:               
413:               int sdp_filter_attributes_in_attributeIDList(uint8_t *record, uint8_t *attributeIDList, uint16_t startOffset, uint16_t maxBytes, uint16_t *usedBytes, uint8_t *buffer){
414:               
415:                   struct sdp_context_filter_attributes context;
416:                   context.buffer = buffer;
015990  9FBF95     MOV W5, [W15-14]
417:                   context.maxBytes = maxBytes;
015992  9FBFB3     MOV W3, [W15-10]
418:                   context.usedBytes = 0;
015994  EB0180     CLR W3
015996  9FBFC3     MOV W3, [W15-8]
419:                   context.startOffset = startOffset;
015998  9FBFA2     MOV W2, [W15-12]
420:                   context.attributeIDList = attributeIDList;
01599A  9FBFD1     MOV W1, [W15-6]
421:                   context.complete = 1;
01599C  200011     MOV #0x1, W1
01599E  9FBFE1     MOV W1, [W15-4]
422:               
423:                   sdp_attribute_list_traverse_sequence(record, sdp_traversal_filter_attributes, &context);
0159A0  57816E     SUB W15, #0xE, W2
0159A2  253741     MOV #0x5374, W1
0159A4  023DBA     CALL sdp_attribute_list_traverse_sequence
0159A6  000001     NOP
424:               
425:                   *usedBytes = context.usedBytes;
0159A8  97B84F     MOV [W15-8], W0
0159AA  780C00     MOV W0, [W8]
0159AC  97B86F     MOV [W15-4], W0
426:                   return context.complete;
427:               }
428:               
429:               // MARK: Get sum of attributes matching attribute list
430:               struct sdp_context_get_filtered_size {
431:                   uint8_t *attributeIDList;
432:                   uint16_t size;
433:               };
434:               
435:               static int sdp_traversal_get_filtered_size(uint16_t attributeID, uint8_t * attributeValue, de_type_t type, de_size_t size, void *my_context){
436:                   struct sdp_context_get_filtered_size * context = (struct sdp_context_get_filtered_size *) my_context;
437:                   if (sdp_attribute_list_constains_id(context->attributeIDList, attributeID)) {
015BD8  780080     MOV W0, W1
015BDA  780014     MOV [W4], W0
015BDC  0263BA     CALL sdp_attribute_list_constains_id
015BDE  000001     NOP
015BE0  E00000     CP0 W0
015BE2  320007     BRA Z, 0x15BF2
438:                       context->size += 3 + de_get_len(attributeValue);
015BE4  780009     MOV W9, W0
015BE6  02629A     CALL de_get_len
015BE8  000001     NOP
015BEA  900098     MOV [W8+2], W1
015BEC  400001     ADD W0, W1, W0
015BEE  400063     ADD W0, #0x3, W0
015BF0  980410     MOV W0, [W8+2]
439:                   }
440:                   return 0;
441:               }
442:               
443:               int spd_get_filtered_size(uint8_t *record, uint8_t *attributeIDList){
444:                   struct sdp_context_get_filtered_size context;
445:                   context.size = 0;
016390  EB0100     CLR W2
016392  9FBFF2     MOV W2, [W15-2]
446:                   context.attributeIDList = attributeIDList;
016394  9FBFE1     MOV W1, [W15-4]
447:                   sdp_attribute_list_traverse_sequence(record, sdp_traversal_get_filtered_size, &context);
016396  578164     SUB W15, #0x4, W2
016398  253701     MOV #0x5370, W1
01639A  023DBA     CALL sdp_attribute_list_traverse_sequence
01639C  000001     NOP
01639E  97B87F     MOV [W15-2], W0
448:                   return context.size;
449:               }
450:               
451:               // MARK: Get AttributeValue for AttributeID
452:               // find attribute (ELEMENT) by ID
453:               struct sdp_context_attribute_by_id {
454:                   uint16_t  attributeID;
455:                   uint8_t * attributeValue;
456:               };
457:               static int sdp_traversal_attribute_by_id(uint16_t attributeID, uint8_t * attributeValue, de_type_t attributeType, de_size_t size, void *my_context){
458:                   struct sdp_context_attribute_by_id * context = (struct sdp_context_attribute_by_id *) my_context;
459:                   if (attributeID == context->attributeID) {
016550  EB0180     CLR W3
016552  500F94     SUB W0, [W4], [W15]
016554  3A0002     BRA NZ, 0x1655A
460:                       context->attributeValue = attributeValue;
016556  980211     MOV W1, [W4+2]
016558  200013     MOV #0x1, W3
461:                       return 1;
462:                   }
463:                   return 0;
464:               }
465:               
466:               uint8_t * sdp_get_attribute_value_for_attribute_id(uint8_t * record, uint16_t attributeID){
467:                   struct sdp_context_attribute_by_id context;
468:                   context.attributeValue = NULL;
01637A  EB0100     CLR W2
01637C  9FBFF2     MOV W2, [W15-2]
469:                   context.attributeID = attributeID;
01637E  9FBFE1     MOV W1, [W15-4]
470:                   sdp_attribute_list_traverse_sequence(record, sdp_traversal_attribute_by_id, &context);
016380  578164     SUB W15, #0x4, W2
016382  2536C1     MOV #0x536C, W1
016384  023DBA     CALL sdp_attribute_list_traverse_sequence
016386  000001     NOP
016388  97B87F     MOV [W15-2], W0
471:                   return context.attributeValue;
472:               }
473:               
474:               // MARK: Set AttributeValue for AttributeID
475:               struct sdp_context_set_attribute_for_id {
476:                   uint16_t  attributeID;
477:                   uint32_t  attributeValue;
478:                   uint8_t   attributeFound;
479:               };
480:               static int sdp_traversal_set_attribute_for_id(uint16_t attributeID, uint8_t * attributeValue, de_type_t attributeType, de_size_t size, void *my_context){
481:                   struct sdp_context_set_attribute_for_id * context = (struct sdp_context_set_attribute_for_id *) my_context;
482:                   if (attributeID == context->attributeID) {
014C4E  EB0180     CLR W3
014C50  500F94     SUB W0, [W4], [W15]
014C52  3A001B     BRA NZ, 0x14C8A
483:                       context->attributeFound = 1;
014C54  B3C010     MOV #0x1, W0
014C56  984260     MOV.B W0, [W4+6]
484:                       switch (size){
014C58  540FE1     SUB W8, #0x1, [W15]
014C5A  320009     BRA Z, 0x14C6E
014C5C  390003     BRA NC, 0x14C64
014C5E  540FE2     SUB W8, #0x2, [W15]
014C60  3A0013     BRA NZ, 0x14C88
014C62  37000C     BRA 0x14C7C
485:                           case DE_SIZE_8:
486:                               if (attributeType != DE_NIL){
014C64  E00002     CP0 W2
014C66  320010     BRA Z, 0x14C88
487:                                   attributeValue[1] = context->attributeValue;
014C68  9040A4     MOV.B [W4+2], W1
014C6A  984291     MOV.B W1, [W5+1]
014C6C  37000D     BRA 0x14C88
488:                               }
489:                               break;
490:                           case DE_SIZE_16:
491:                               net_store_16(attributeValue, 1, context->attributeValue);
014C6E  900114     MOV [W4+2], W2
014C70  780088     MOV W8, W1
014C72  780005     MOV W5, W0
014C74  02661E     CALL net_store_16
014C76  000001     NOP
014C78  780188     MOV W8, W3
014C7A  370007     BRA 0x14C8A
492:                               break;
493:                           case DE_SIZE_32:
494:                               net_store_32(attributeValue, 1, context->attributeValue);
014C7C  900114     MOV [W4+2], W2
014C7E  9001A4     MOV [W4+4], W3
014C80  200011     MOV #0x1, W1
014C82  780005     MOV W5, W0
014C84  025FD0     CALL net_store_32
014C86  000001     NOP
014C88  200013     MOV #0x1, W3
495:                               break;
496:                               // Might want to support STRINGS to, copy upto original length
497:                           default:
498:                               break;
499:                       }        
500:                       return 1;
501:                   }
502:                   return 0;
503:               }
504:               uint8_t sdp_set_attribute_value_for_attribute_id(uint8_t * record, uint16_t attributeID, uint32_t value){
505:                   struct sdp_context_set_attribute_for_id context;
506:                   context.attributeID = attributeID;
0160B2  9FBFC1     MOV W1, [W15-8]
507:                   context.attributeValue = value;
0160B4  9FBFD2     MOV W2, [W15-6]
0160B6  9FBFE3     MOV W3, [W15-4]
508:                   context.attributeFound = 0;
0160B8  EB4080     CLR.B W1
0160BA  9FFFE1     MOV.B W1, [W15-2]
509:                   sdp_attribute_list_traverse_sequence(record, sdp_traversal_set_attribute_for_id, &context);
0160BC  578168     SUB W15, #0x8, W2
0160BE  253681     MOV #0x5368, W1
0160C0  023DBA     CALL sdp_attribute_list_traverse_sequence
0160C2  000001     NOP
0160C4  97F86F     MOV.B [W15-2], W0
0160C6  FB8000     ZE W0, W0
510:                   return context.attributeFound;
511:               }
512:               
513:               // MARK: ServiceRecord contains UUID
514:               // service record contains UUID
515:               // context { normalizedUUID }
516:               struct sdp_context_contains_uuid128 {
517:                   uint8_t * uuid128;
518:                   int result;
519:               };
520:               int sdp_record_contains_UUID128(uint8_t *record, uint8_t *uuid128);
521:               static int sdp_traversal_contains_UUID128(uint8_t * element, de_type_t type, de_size_t size, void *my_context){
522:                   struct sdp_context_contains_uuid128 * context = (struct sdp_context_contains_uuid128 *) my_context;
523:                   uint8_t normalizedUUID[16];
524:                   if (type == DE_UUID){
014E66  508FE3     SUB W1, #0x3, [W15]
014E68  3A0011     BRA NZ, 0x14E8C
525:                       uint8_t uuidOK = de_get_normalized_uuid(normalizedUUID, element);
014E6A  780080     MOV W0, W1
014E6C  578072     SUB W15, #0x12, W0
014E6E  024104     CALL de_get_normalized_uuid
014E70  000001     NOP
526:                       context->result = uuidOK && memcmp(context->uuid128, normalizedUUID, 16) == 0;
014E72  E00400     CP0.B W0
014E74  320008     BRA Z, 0x14E86
014E76  200102     MOV #0x10, W2
014E78  5780F2     SUB W15, #0x12, W1
014E7A  780018     MOV [W8], W0
014E7C  0256EC     CALL memcmp
014E7E  000000     NOP
014E80  200011     MOV #0x1, W1
014E82  E00000     CP0 W0
014E84  320001     BRA Z, 0x14E88
014E86  EB0080     CLR W1
014E88  980411     MOV W1, [W8+2]
014E8A  370006     BRA 0x14E98
527:                   }
528:                   if (type == DE_DES){
014E8C  508FE6     SUB W1, #0x6, [W15]
014E8E  3A0004     BRA NZ, 0x14E98
529:                       context->result = sdp_record_contains_UUID128(element, context->uuid128);
014E90  780093     MOV [W3], W1
014E92  0263A4     CALL sdp_record_contains_UUID128
014E94  000001     NOP
014E96  980410     MOV W0, [W8+2]
014E98  900018     MOV [W8+2], W0
530:                   }
531:                   return context->result;
532:               }
533:               int sdp_record_contains_UUID128(uint8_t *record, uint8_t *uuid128){
534:                   struct sdp_context_contains_uuid128 context;
535:                   context.uuid128 = uuid128;
0163A6  9FBFE1     MOV W1, [W15-4]
536:                   context.result = 0;
0163A8  EB0080     CLR W1
0163AA  9FBFF1     MOV W1, [W15-2]
537:                   de_traverse_sequence(record, sdp_traversal_contains_UUID128, &context);
0163AC  578164     SUB W15, #0x4, W2
0163AE  253841     MOV #0x5384, W1
0163B0  024A90     CALL de_traverse_sequence
0163B2  000001     NOP
0163B4  97B87F     MOV [W15-2], W0
538:                   return context.result;
539:               }
540:                   
541:               // MARK: ServiceRecord matches SearchServicePattern
542:               // if UUID in searchServicePattern is not found in record => false
543:               // context { result, record }
544:               struct sdp_context_match_pattern {
545:                   uint8_t * record;
546:                   int result;
547:               };
548:               int sdp_traversal_match_pattern(uint8_t * element, de_type_t attributeType, de_size_t size, void *my_context){
549:                   struct sdp_context_match_pattern * context = (struct sdp_context_match_pattern *) my_context;
550:                   uint8_t normalizedUUID[16];
551:                   uint8_t uuidOK = de_get_normalized_uuid(normalizedUUID, element);
015864  578072     SUB W15, #0x12, W0
015866  024104     CALL de_get_normalized_uuid
015868  000001     NOP
552:                   if (!uuidOK || !sdp_record_contains_UUID128(context->record, normalizedUUID)){
01586A  E00400     CP0.B W0
01586C  320007     BRA Z, 0x1587C
01586E  5780F2     SUB W15, #0x12, W1
015870  780018     MOV [W8], W0
015872  0263A4     CALL sdp_record_contains_UUID128
015874  000001     NOP
015876  EB0080     CLR W1
015878  E00000     CP0 W0
01587A  3A0003     BRA NZ, 0x15882
553:                       context->result = 0;
01587C  EB0000     CLR W0
01587E  980410     MOV W0, [W8+2]
015880  200011     MOV #0x1, W1
554:                       return 1;
555:                   }
556:                   return 0;
557:               }
558:               int sdp_record_matches_service_search_pattern(uint8_t *record, uint8_t *serviceSearchPattern){
559:                   struct sdp_context_match_pattern context;
560:                   context.record = record;
016224  9FBFE0     MOV W0, [W15-4]
561:                   context.result = 1;
016226  200010     MOV #0x1, W0
016228  9FBFF0     MOV W0, [W15-2]
562:                   de_traverse_sequence(serviceSearchPattern, sdp_traversal_match_pattern, &context);
01622A  578164     SUB W15, #0x4, W2
01622C  253801     MOV #0x5380, W1
01622E  780003     MOV W3, W0
016230  024A90     CALL de_traverse_sequence
016232  000001     NOP
016234  97B87F     MOV [W15-2], W0
563:                   return context.result;
564:               }
565:               
566:               // MARK: Dump DataElement
567:               // context { indent }
568:               static int de_traversal_dump_data(uint8_t * element, de_type_t de_type, de_size_t de_size, void *my_context){
569:                   int indent = *(int*) my_context;
012654  780193     MOV [W3], W3
012656  9FBFB3     MOV W3, [W15-10]
012658  EB0500     CLR W10
01265A  370006     BRA 0x12668
570:                   int i;
571:                   for (i=0; i<indent;i++) printf("    ");
01265C  2EC760     MOV #0xEC76, W0
01265E  781F80     MOV W0, [W15++]
012660  025952     CALL _printf_cdnopsuxX
012662  000000     NOP
012664  E8050A     INC W10, W10
012666  E9878F     DEC2 W15, W15
012668  97B83F     MOV [W15-10], W0
01266A  550F80     SUB W10, W0, [W15]
01266C  35FFF7     BRA LT, 0x1265C
572:                   int pos     = de_get_header_size(element);
01266E  780009     MOV W9, W0
012670  026362     CALL de_get_header_size
012672  000001     NOP
012674  780500     MOV W0, W10
573:                   int end_pos = de_get_len(element);
012676  780009     MOV W9, W0
012678  02629A     CALL de_get_len
01267A  000001     NOP
01267C  781F80     MOV W0, [W15++]
01267E  781F88     MOV W8, [W15++]
012680  440088     ADD W8, W8, W1
012682  2EC640     MOV #0xEC64, W0
012684  789FE0     MOV [W0+W1], [W15++]
012686  2EC7B0     MOV #0xEC7B, W0
012688  781F80     MOV W0, [W15++]
01268A  025952     CALL _printf_cdnopsuxX
01268C  000000     NOP
574:                   printf("type %5s (%u), element len %2u ", type_names[de_type], de_type, end_pos);
575:                   if (de_type == DE_DES) {
01268E  5787E8     SUB W15, #0x8, W15
012690  540FE6     SUB W8, #0x6, [W15]
012692  3A000C     BRA NZ, 0x126AC
576:               		printf("\n");
012694  2000A0     MOV #0xA, W0
012696  025960     CALL putchar
012698  000000     NOP
577:                       indent++;
01269A  97B83F     MOV [W15-10], W0
01269C  E80000     INC W0, W0
01269E  9FBFB0     MOV W0, [W15-10]
578:                       de_traverse_sequence(element, de_traversal_dump_data, (void *)&indent);
0126A0  57816A     SUB W15, #0xA, W2
0126A2  2537C1     MOV #0x537C, W1
0126A4  780009     MOV W9, W0
0126A6  024A90     CALL de_traverse_sequence
0126A8  000001     NOP
0126AA  37005A     BRA 0x12760
579:                   } else if (de_type == DE_UUID && de_size == DE_SIZE_128) {
0126AC  540FE3     SUB W8, #0x3, [W15]
0126AE  3A000E     BRA NZ, 0x126CC
0126B0  558FE4     SUB W11, #0x4, [W15]
0126B2  3A0027     BRA NZ, 0x12702
0126C8  E9878F     DEC2 W15, W15
0126CA  37004A     BRA 0x12760
580:                       printf(", value: ");
0126B4  2EC9B0     MOV #0xEC9B, W0
0126B6  781F80     MOV W0, [W15++]
0126B8  025952     CALL _printf_cdnopsuxX
0126BA  000000     NOP
581:                       printUUID(element+1);
0126BC  E80009     INC W9, W0
0126BE  02677A     CALL printUUID
0126C0  000001     NOP
582:                       printf("\n");
0126C2  2000A0     MOV #0xA, W0
0126C4  025960     CALL putchar
0126C6  000000     NOP
583:                   } else if (de_type == DE_STRING) {
0126CC  540FE4     SUB W8, #0x4, [W15]
0126CE  3A0019     BRA NZ, 0x12702
584:                       int len = 0;
585:                       switch (de_size){
0126D0  558FE5     SUB W11, #0x5, [W15]
0126D2  320004     BRA Z, 0x126DC
0126D4  EB0400     CLR W8
0126D6  558FE6     SUB W11, #0x6, [W15]
0126D8  3A0009     BRA NZ, 0x126EC
0126DA  370003     BRA 0x126E2
586:                           case DE_SIZE_VAR_8:
587:                               len = element[1];
0126DC  904019     MOV.B [W9+1], W0
0126DE  FB8400     ZE W0, W8
0126E0  370005     BRA 0x126EC
588:                               break;
589:                           case DE_SIZE_VAR_16:
590:                               len = READ_NET_16(element, 1);
0126E2  9040A9     MOV.B [W9+2], W1
0126E4  FB8081     ZE W1, W1
0126E6  904019     MOV.B [W9+1], W0
0126E8  DD0048     SL W0, #8, W0
0126EA  708400     IOR W1, W0, W8
591:                               break;
592:                           default:
593:                               break;
594:                       }
595:                       printf("len %u (0x%02x)\n", len, len);
0126EC  781F88     MOV W8, [W15++]
0126EE  781F88     MOV W8, [W15++]
0126F0  2ECA50     MOV #0xECA5, W0
0126F2  781F80     MOV W0, [W15++]
0126F4  025952     CALL _printf_cdnopsuxX
0126F6  000000     NOP
596:                       hexdump(&element[pos], len);
0126F8  44800A     ADD W9, W10, W0
0126FA  780088     MOV W8, W1
0126FC  02659A     CALL hexdump
0126FE  000001     NOP
012700  37002E     BRA 0x1275E
597:                   } else {
598:                       uint32_t value = 0;
599:                       switch (de_size) {
012702  558FE1     SUB W11, #0x1, [W15]
012704  32000A     BRA Z, 0x1271A
012706  390003     BRA NC, 0x1270E
012708  558FE2     SUB W11, #0x2, [W15]
01270A  3A0023     BRA NZ, 0x12752
01270C  37000E     BRA 0x1272A
600:                           case DE_SIZE_8:
601:                               if (de_type != DE_NIL){
01270E  E00008     CP0 W8
012710  320020     BRA Z, 0x12752
602:                                   value = element[pos];
012712  7D4069     MOV.B [W9+W10], W0
012714  FB8000     ZE W0, W0
012716  200001     MOV #0x0, W1
012718  37001D     BRA 0x12754
603:                               }
604:                               break;
605:                           case DE_SIZE_16:
606:               				value = READ_NET_16(element,pos);
01271A  44800A     ADD W9, W10, W0
01271C  904090     MOV.B [W0+1], W1
01271E  FB8081     ZE W1, W1
012720  FB8010     ZE [W0], W0
012722  DD0048     SL W0, #8, W0
012724  708080     IOR W1, W0, W1
012726  B80861     MUL.UU W1, #1, W0
012728  370015     BRA 0x12754
607:                               break;
608:                           case DE_SIZE_32:
609:               				value = READ_NET_32(element,pos);
01272A  44820A     ADD W9, W10, W4
01272C  904134     MOV.B [W4+3], W2
01272E  FB8102     ZE W2, W2
012730  200003     MOV #0x0, W3
012732  904024     MOV.B [W4+2], W0
012734  DD0048     SL W0, #8, W0
012736  200001     MOV #0x0, W1
012738  710100     IOR W2, W0, W2
01273A  718181     IOR W3, W1, W3
01273C  904014     MOV.B [W4+1], W0
01273E  FB8080     ZE W0, W1
012740  200000     MOV #0x0, W0
012742  710100     IOR W2, W0, W2
012744  718181     IOR W3, W1, W3
012746  784014     MOV.B [W4], W0
012748  DD00C8     SL W0, #8, W1
01274A  200000     MOV #0x0, W0
01274C  710000     IOR W2, W0, W0
01274E  718081     IOR W3, W1, W1
012750  370001     BRA 0x12754
012752  B80060     MUL.UU W0, #0, W0
610:                               break;
611:                           default:
612:                               break;
613:                       }
614:                       printf(", value: 0x%08" PRIx32 "\n", value);
012754  BE9F80     MOV.D W0, [W15++]
012756  2ECB60     MOV #0xECB6, W0
012758  781F80     MOV W0, [W15++]
01275A  025952     CALL _printf_cdnopsuxX
01275C  000000     NOP
01275E  5787E6     SUB W15, #0x6, W15
615:                   }
616:                   return 0;
617:               }
618:               
619:               void de_dump_data_element(uint8_t * record){
620:                   int indent = 0;
0163D2  EB0080     CLR W1
0163D4  9FBFF1     MOV W1, [W15-2]
621:                   // hack to get root DES, too.
622:                   de_type_t type = de_get_element_type(record);
623:                   de_size_t size = de_get_size_type(record);
624:                   de_traversal_dump_data(record, type, size, (void*) &indent);
0163D6  FB8090     ZE [W0], W1
0163D8  608167     AND W1, #0x7, W2
0163DA  DE08C3     LSR W1, #3, W1
0163DC  E9818F     DEC2 W15, W3
0163DE  022648     CALL de_traversal_dump_data
0163E0  000001     NOP
625:               }
626:               
627:               void sdp_create_spp_service(uint8_t *service, int service_id, const char *name){
628:               	
629:               	uint8_t* attribute;
630:               	de_create_sequence(service);
011C66  026632     CALL de_create_sequence
011C68  000001     NOP
631:                   
632:                   // 0x0000 "Service Record Handle"
633:               	de_add_number(service, DE_UINT, DE_SIZE_16, SDP_ServiceRecordHandle);
011C6A  B82260     MUL.UU W4, #0, W4
011C6C  200012     MOV #0x1, W2
011C6E  200011     MOV #0x1, W1
011C70  780009     MOV W9, W0
011C72  023E94     CALL de_add_number
011C74  000001     NOP
634:               	de_add_number(service, DE_UINT, DE_SIZE_32, 0x10001);
011C76  200014     MOV #0x1, W4
011C78  200015     MOV #0x1, W5
011C7A  200022     MOV #0x2, W2
011C7C  200011     MOV #0x1, W1
011C7E  780009     MOV W9, W0
011C80  023E94     CALL de_add_number
011C82  000001     NOP
635:                   
636:               	// 0x0001 "Service Class ID List"
637:               	de_add_number(service,  DE_UINT, DE_SIZE_16, SDP_ServiceClassIDList);
011C84  200014     MOV #0x1, W4
011C86  200005     MOV #0x0, W5
011C88  200012     MOV #0x1, W2
011C8A  200011     MOV #0x1, W1
011C8C  780009     MOV W9, W0
011C8E  023E94     CALL de_add_number
011C90  000001     NOP
638:               	attribute = de_push_sequence(service);
011C92  780009     MOV W9, W0
011C94  026094     CALL de_push_sequence
011C96  000001     NOP
011C98  780400     MOV W0, W8
639:               	{
640:               		de_add_number(attribute,  DE_UUID, DE_SIZE_16, 0x1101 );
011C9A  211014     MOV #0x1101, W4
011C9C  200005     MOV #0x0, W5
011C9E  200012     MOV #0x1, W2
011CA0  200031     MOV #0x3, W1
011CA2  023E94     CALL de_add_number
011CA4  000001     NOP
641:               	}
642:               	de_pop_sequence(service, attribute);
011CA6  780088     MOV W8, W1
011CA8  780009     MOV W9, W0
011CAA  025E20     CALL de_pop_sequence
011CAC  000001     NOP
643:               	
644:               	// 0x0004 "Protocol Descriptor List"
645:               	de_add_number(service,  DE_UINT, DE_SIZE_16, SDP_ProtocolDescriptorList);
011CAE  200044     MOV #0x4, W4
011CB0  200005     MOV #0x0, W5
011CB2  200012     MOV #0x1, W2
011CB4  200011     MOV #0x1, W1
011CB6  780009     MOV W9, W0
011CB8  023E94     CALL de_add_number
011CBA  000001     NOP
646:               	attribute = de_push_sequence(service);
011CBC  780009     MOV W9, W0
011CBE  026094     CALL de_push_sequence
011CC0  000001     NOP
011CC2  780500     MOV W0, W10
647:               	{
648:               		uint8_t* l2cpProtocol = de_push_sequence(attribute);
011CC4  026094     CALL de_push_sequence
011CC6  000001     NOP
011CC8  780400     MOV W0, W8
649:               		{
650:               			de_add_number(l2cpProtocol,  DE_UUID, DE_SIZE_16, 0x0100);
011CCA  201004     MOV #0x100, W4
011CCC  200005     MOV #0x0, W5
011CCE  200012     MOV #0x1, W2
011CD0  200031     MOV #0x3, W1
011CD2  023E94     CALL de_add_number
011CD4  000001     NOP
651:               		}
652:               		de_pop_sequence(attribute, l2cpProtocol);
011CD6  780088     MOV W8, W1
011CD8  78000A     MOV W10, W0
011CDA  025E20     CALL de_pop_sequence
011CDC  000001     NOP
653:               		
654:               		uint8_t* rfcomm = de_push_sequence(attribute);
011CDE  78000A     MOV W10, W0
011CE0  026094     CALL de_push_sequence
011CE2  000001     NOP
011CE4  780400     MOV W0, W8
655:               		{
656:               			de_add_number(rfcomm,  DE_UUID, DE_SIZE_16, 0x0003);  // rfcomm_service
011CE6  200034     MOV #0x3, W4
011CE8  200005     MOV #0x0, W5
011CEA  200012     MOV #0x1, W2
011CEC  200031     MOV #0x3, W1
011CEE  023E94     CALL de_add_number
011CF0  000001     NOP
657:               			de_add_number(rfcomm,  DE_UINT, DE_SIZE_8,  service_id);  // rfcomm channel
011CF2  B95A61     MUL.SU W11, #1, W4
011CF4  EB0100     CLR W2
011CF6  200011     MOV #0x1, W1
011CF8  780008     MOV W8, W0
011CFA  023E94     CALL de_add_number
011CFC  000001     NOP
658:               		}
659:               		de_pop_sequence(attribute, rfcomm);
011CFE  780088     MOV W8, W1
011D00  78000A     MOV W10, W0
011D02  025E20     CALL de_pop_sequence
011D04  000001     NOP
660:               	}
661:               	de_pop_sequence(service, attribute);
011D06  78008A     MOV W10, W1
011D08  780009     MOV W9, W0
011D0A  025E20     CALL de_pop_sequence
011D0C  000001     NOP
662:               	
663:               	// 0x0005 "Public Browse Group"
664:               	de_add_number(service,  DE_UINT, DE_SIZE_16, SDP_BrowseGroupList); // public browse group
011D0E  200054     MOV #0x5, W4
011D10  200005     MOV #0x0, W5
011D12  200012     MOV #0x1, W2
011D14  200011     MOV #0x1, W1
011D16  780009     MOV W9, W0
011D18  023E94     CALL de_add_number
011D1A  000001     NOP
665:               	attribute = de_push_sequence(service);
011D1C  780009     MOV W9, W0
011D1E  026094     CALL de_push_sequence
011D20  000001     NOP
011D22  780400     MOV W0, W8
666:               	{
667:               		de_add_number(attribute,  DE_UUID, DE_SIZE_16, 0x1002 );
011D24  210024     MOV #0x1002, W4
011D26  200005     MOV #0x0, W5
011D28  200012     MOV #0x1, W2
011D2A  200031     MOV #0x3, W1
011D2C  023E94     CALL de_add_number
011D2E  000001     NOP
668:               	}
669:               	de_pop_sequence(service, attribute);
011D30  780088     MOV W8, W1
011D32  780009     MOV W9, W0
011D34  025E20     CALL de_pop_sequence
011D36  000001     NOP
670:               	
671:               	// 0x0006
672:               	de_add_number(service,  DE_UINT, DE_SIZE_16, SDP_LanguageBaseAttributeIDList);
011D38  200064     MOV #0x6, W4
011D3A  200005     MOV #0x0, W5
011D3C  200012     MOV #0x1, W2
011D3E  200011     MOV #0x1, W1
011D40  780009     MOV W9, W0
011D42  023E94     CALL de_add_number
011D44  000001     NOP
673:               	attribute = de_push_sequence(service);
011D46  780009     MOV W9, W0
011D48  026094     CALL de_push_sequence
011D4A  000001     NOP
011D4C  780400     MOV W0, W8
674:               	{
675:               		de_add_number(attribute, DE_UINT, DE_SIZE_16, 0x656e);
011D4E  2656E4     MOV #0x656E, W4
011D50  200005     MOV #0x0, W5
011D52  200012     MOV #0x1, W2
011D54  200011     MOV #0x1, W1
011D56  023E94     CALL de_add_number
011D58  000001     NOP
676:               		de_add_number(attribute, DE_UINT, DE_SIZE_16, 0x006a);
011D5A  2006A4     MOV #0x6A, W4
011D5C  200005     MOV #0x0, W5
011D5E  200012     MOV #0x1, W2
011D60  200011     MOV #0x1, W1
011D62  780008     MOV W8, W0
011D64  023E94     CALL de_add_number
011D66  000001     NOP
677:               		de_add_number(attribute, DE_UINT, DE_SIZE_16, 0x0100);
011D68  201004     MOV #0x100, W4
011D6A  200005     MOV #0x0, W5
011D6C  200012     MOV #0x1, W2
011D6E  200011     MOV #0x1, W1
011D70  780008     MOV W8, W0
011D72  023E94     CALL de_add_number
011D74  000001     NOP
678:               	}
679:               	de_pop_sequence(service, attribute);
011D76  780088     MOV W8, W1
011D78  780009     MOV W9, W0
011D7A  025E20     CALL de_pop_sequence
011D7C  000001     NOP
680:               	
681:               	// 0x0009 "Bluetooth Profile Descriptor List"
682:               	de_add_number(service,  DE_UINT, DE_SIZE_16, SDP_BluetoothProfileDescriptorList);
011D7E  200094     MOV #0x9, W4
011D80  200005     MOV #0x0, W5
011D82  200012     MOV #0x1, W2
011D84  200011     MOV #0x1, W1
011D86  780009     MOV W9, W0
011D88  023E94     CALL de_add_number
011D8A  000001     NOP
683:               	attribute = de_push_sequence(service);
011D8C  780009     MOV W9, W0
011D8E  026094     CALL de_push_sequence
011D90  000001     NOP
011D92  780500     MOV W0, W10
684:               	{
685:               		uint8_t *sppProfile = de_push_sequence(attribute);
011D94  026094     CALL de_push_sequence
011D96  000001     NOP
011D98  780400     MOV W0, W8
686:               		{
687:               			de_add_number(sppProfile,  DE_UUID, DE_SIZE_16, 0x1101);
011D9A  211014     MOV #0x1101, W4
011D9C  200005     MOV #0x0, W5
011D9E  200012     MOV #0x1, W2
011DA0  200031     MOV #0x3, W1
011DA2  023E94     CALL de_add_number
011DA4  000001     NOP
688:               			de_add_number(sppProfile,  DE_UINT, DE_SIZE_16, 0x0100);
011DA6  201004     MOV #0x100, W4
011DA8  200005     MOV #0x0, W5
011DAA  200012     MOV #0x1, W2
011DAC  200011     MOV #0x1, W1
011DAE  780008     MOV W8, W0
011DB0  023E94     CALL de_add_number
011DB2  000001     NOP
689:               		}
690:               		de_pop_sequence(attribute, sppProfile);
011DB4  780088     MOV W8, W1
011DB6  78000A     MOV W10, W0
011DB8  025E20     CALL de_pop_sequence
011DBA  000001     NOP
691:               	}
692:               	de_pop_sequence(service, attribute);
011DBC  78008A     MOV W10, W1
011DBE  780009     MOV W9, W0
011DC0  025E20     CALL de_pop_sequence
011DC2  000001     NOP
693:               	
694:               	// 0x0100 "ServiceName"
695:               	de_add_number(service,  DE_UINT, DE_SIZE_16, 0x0100);
011DC4  201004     MOV #0x100, W4
011DC6  200005     MOV #0x0, W5
011DC8  200012     MOV #0x1, W2
011DCA  200011     MOV #0x1, W1
011DCC  780009     MOV W9, W0
011DCE  023E94     CALL de_add_number
011DD0  000001     NOP
696:               	de_add_data(service,  DE_STRING, strlen(name), (uint8_t *) name);
011DD2  78000C     MOV W12, W0
011DD4  02578A     CALL strlen
011DD6  000000     NOP
011DD8  780100     MOV W0, W2
011DDA  78018C     MOV W12, W3
011DDC  200041     MOV #0x4, W1
011DDE  780009     MOV W9, W0
011DE0  02471C     CALL de_add_data
011DE2  000001     NOP
697:               }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libbtstack/src/sdp.c  ----
0120F4  4787EC     ADD W15, #0xC, W15
0120F6  BE9F88     MOV.D W8, [W15++]
0120F8  BE9F8A     MOV.D W10, [W15++]
0120FA  BE9F8C     MOV.D W12, [W15++]
0120FC  781F8E     MOV W14, [W15++]
0120FE  BE0400     MOV.D W0, W8
012884  4787E8     ADD W15, #0x8, W15
012886  BE9F88     MOV.D W8, [W15++]
012888  BE9F8A     MOV.D W10, [W15++]
01288A  BE9F8C     MOV.D W12, [W15++]
01288C  781F8E     MOV W14, [W15++]
01288E  BE0400     MOV.D W0, W8
012AAE  4787E8     ADD W15, #0x8, W15
012AB0  BE9F88     MOV.D W8, [W15++]
012AB2  BE9F8A     MOV.D W10, [W15++]
012AB4  BE9F8C     MOV.D W12, [W15++]
012AB6  781F8E     MOV W14, [W15++]
012AB8  BE0400     MOV.D W0, W8
013376  BE9F88     MOV.D W8, [W15++]
013378  781F8A     MOV W10, [W15++]
01337A  780181     MOV W1, W3
01337C  780402     MOV W2, W8
01357A  FA0008     LNK #0x8
01357C  BE9F88     MOV.D W8, [W15++]
01357E  BE9F8A     MOV.D W10, [W15++]
013580  781F8C     MOV W12, [W15++]
013582  780600     MOV W0, W12
013584  780501     MOV W1, W10
0149F8  781F88     MOV W8, [W15++]
01582E  BE9F88     MOV.D W8, [W15++]
015830  780100     MOV W0, W2
015832  780481     MOV W1, W9
015A54  780280     MOV W0, W5
015F96  BE0200     MOV.D W0, W4
016206  780180     MOV W0, W3
1:                 /*
2:                  * Copyright (C) 2009-2012 by Matthias Ringwald
3:                  *
4:                  * Redistribution and use in source and binary forms, with or without
5:                  * modification, are permitted provided that the following conditions
6:                  * are met:
7:                  *
8:                  * 1. Redistributions of source code must retain the above copyright
9:                  *    notice, this list of conditions and the following disclaimer.
10:                 * 2. Redistributions in binary form must reproduce the above copyright
11:                 *    notice, this list of conditions and the following disclaimer in the
12:                 *    documentation and/or other materials provided with the distribution.
13:                 * 3. Neither the name of the copyright holders nor the names of
14:                 *    contributors may be used to endorse or promote products derived
15:                 *    from this software without specific prior written permission.
16:                 * 4. Any redistribution, use, or modification is done solely for
17:                 *    personal benefit and not for any commercial purpose or for
18:                 *    monetary gain.
19:                 *
20:                 * THIS SOFTWARE IS PROVIDED BY MATTHIAS RINGWALD AND CONTRIBUTORS
21:                 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
22:                 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
23:                 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MATTHIAS
24:                 * RINGWALD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
25:                 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
26:                 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
27:                 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
28:                 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
29:                 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
30:                 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
31:                 * SUCH DAMAGE.
32:                 *
33:                 * Please inquire about commercial licensing options at btstack@ringwald.ch
34:                 *
35:                 */
36:                
37:                /*
38:                 * Implementation of the Service Discovery Protocol Server 
39:                 */
40:                
41:                #include "sdp.h"
42:                
43:                
44:                #include <stdio.h>
45:                #include <string.h>
46:                
47:                #include <btstack/sdp_util.h>
48:                
49:                #include "hci_dump.h"
50:                #include "l2cap.h"
51:                
52:                #include "debug.h"
53:                
54:                // max reserved ServiceRecordHandle
55:                #define maxReservedServiceRecordHandle 0xffff
56:                
57:                // max SDP response
58:                #define SDP_RESPONSE_BUFFER_SIZE (HCI_ACL_BUFFER_SIZE-HCI_ACL_HEADER_SIZE)
59:                
60:                static void sdp_packet_handler(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size);
61:                
62:                // registered service records
63:                static linked_list_t sdp_service_records = NULL;
64:                
65:                // our handles start after the reserved range
66:                static uint32_t sdp_next_service_record_handle = maxReservedServiceRecordHandle + 2;
67:                
68:                static uint8_t sdp_response_buffer[SDP_RESPONSE_BUFFER_SIZE];
69:                
70:                static void (*app_packet_handler)(void * connection, uint8_t packet_type,
71:                                                  uint16_t channel, uint8_t *packet, uint16_t size) = NULL;
72:                
73:                static uint16_t l2cap_cid = 0;
74:                static uint16_t sdp_response_size = 0;
75:                
76:                void sdp_init(){
77:                    // register with l2cap psm sevices - max MTU
78:                    l2cap_register_service_internal(NULL, sdp_packet_handler, PSM_SDP, 0xffff);
0165BE  EB8180     SETM W3
0165C0  200012     MOV #0x1, W2
0165C2  253641     MOV #0x5364, W1
0165C4  EB0000     CLR W0
0165C6  044344     GOTO l2cap_register_service_internal
0165C8  000001     NOP
79:                }
80:                
81:                // register packet handler
82:                void sdp_register_packet_handler(void (*handler)(void * connection, uint8_t packet_type,
83:                                                                 uint16_t channel, uint8_t *packet, uint16_t size)){
84:                	app_packet_handler = handler;
0166BC  8B64D0     MOV W0, app_packet_handler
85:                    l2cap_cid = 0;
0166BE  EB0000     CLR W0
0166C0  8B64E0     MOV W0, l2cap_cid
86:                }
87:                
88:                uint32_t sdp_get_service_record_handle(uint8_t * record){
89:                    uint8_t * serviceRecordHandleAttribute = sdp_get_attribute_value_for_attribute_id(record, SDP_ServiceRecordHandle);
0149FA  EB0080     CLR W1
0149FC  026378     CALL sdp_get_attribute_value_for_attribute_id
0149FE  000001     NOP
014A00  780400     MOV W0, W8
90:                    if (!serviceRecordHandleAttribute) return 0;
014A02  E00000     CP0 W0
014A04  32001C     BRA Z, 0x14A3E
91:                    if (de_get_element_type(serviceRecordHandleAttribute) != DE_UINT) return 0;
014A06  02671A     CALL de_get_element_type
014A08  000001     NOP
014A0A  500FE1     SUB W0, #0x1, [W15]
014A0C  3A0018     BRA NZ, 0x14A3E
92:                    if (de_get_size_type(serviceRecordHandleAttribute) != DE_SIZE_32) return 0;
014A0E  780008     MOV W8, W0
014A10  026714     CALL de_get_size_type
014A12  000001     NOP
014A14  500FE2     SUB W0, #0x2, [W15]
014A16  3A0013     BRA NZ, 0x14A3E
93:                    return READ_NET_32(serviceRecordHandleAttribute, 1); 
014A18  904148     MOV.B [W8+4], W2
014A1A  FB8102     ZE W2, W2
014A1C  200003     MOV #0x0, W3
014A1E  904038     MOV.B [W8+3], W0
014A20  DD0048     SL W0, #8, W0
014A22  200001     MOV #0x0, W1
014A24  710100     IOR W2, W0, W2
014A26  718181     IOR W3, W1, W3
014A28  904028     MOV.B [W8+2], W0
014A2A  FB8080     ZE W0, W1
014A2C  200000     MOV #0x0, W0
014A2E  710100     IOR W2, W0, W2
014A30  718181     IOR W3, W1, W3
014A32  904018     MOV.B [W8+1], W0
014A34  DD00C8     SL W0, #8, W1
014A36  200000     MOV #0x0, W0
014A38  710000     IOR W2, W0, W0
014A3A  718081     IOR W3, W1, W1
014A3C  370001     BRA 0x14A40
014A3E  B80060     MUL.UU W0, #0, W0
94:                }
95:                
96:                // data: event(8), len(8), status(8), service_record_handle(32)
97:                static void sdp_emit_service_registered(void *connection, uint32_t handle, uint8_t status) {
98:                    if (!app_packet_handler) return;
0135D6  8364D0     MOV app_packet_handler, W0
0135D8  E00000     CP0 W0
0135DA  320017     BRA Z, 0x1360A
99:                    uint8_t event[7];
100:                   event[0] = SDP_SERVICE_REGISTERED;
0135DC  B3C900     MOV #0x90, W0
0135DE  9FEFE0     MOV.B W0, [W15-18]
101:                   event[1] = sizeof(event) - 2;
0135E0  B3C050     MOV #0x5, W0
0135E2  9FEFF0     MOV.B W0, [W15-17]
102:                   event[2] = status;
0135E4  9FF781     MOV.B W1, [W15-16]
103:                   bt_store_32(event, 3, handle);
0135E6  B81160     MUL.UU W2, #0, W2
0135E8  200031     MOV #0x3, W1
0135EA  578072     SUB W15, #0x12, W0
0135EC  026150     CALL bt_store_32
0135EE  000001     NOP
104:                   hci_dump_packet(HCI_EVENT_PACKET, 0, event, sizeof(event));
0135F0  200073     MOV #0x7, W3
0135F2  578172     SUB W15, #0x12, W2
0135F4  EB4080     CLR.B W1
0135F6  B3C040     MOV #0x4, W0
0135F8  026798     CALL hci_dump_packet
0135FA  000001     NOP
105:               	(*app_packet_handler)(connection, HCI_EVENT_PACKET, 0, (uint8_t *) event, sizeof(event));
0135FC  200074     MOV #0x7, W4
0135FE  5781F2     SUB W15, #0x12, W3
013600  EB0100     CLR W2
013602  B3C041     MOV #0x4, W1
013604  78000C     MOV W12, W0
013606  8364D5     MOV app_packet_handler, W5
013608  010005     CALL W5
106:               }
107:               
108:               service_record_item_t * sdp_get_record_for_handle(uint32_t handle){
109:                   linked_item_t *it;
110:                   for (it = (linked_item_t *) sdp_service_records; it ; it = it->next){
0128F2  8364C9     MOV sdp_service_records, W9
0128F4  370008     BRA 0x12906
012904  780499     MOV [W9], W9
012906  E00009     CP0 W9
012908  3AFFF6     BRA NZ, 0x128F6
01290A  37003E     BRA 0x12988
0135A2  8364C2     MOV sdp_service_records, W2
0135A4  370006     BRA 0x135B2
0135B0  780112     MOV [W2], W2
0135B2  E00002     CP0 W2
0135B4  3AFFF8     BRA NZ, 0x135A6
0135B6  37000A     BRA 0x135CC
015774  8364C5     MOV sdp_service_records, W5
015776  8388D2     MOV sdp_next_service_record_handle, W2
015778  8388E3     MOV 0x711C, W3
01577A  370001     BRA 0x1577E
01577C  BE0106     MOV.D W6, W2
01577E  410361     ADD W2, #0x1, W6
015780  4983E0     ADDC W3, #0x0, W7
015782  780205     MOV W5, W4
015784  370006     BRA 0x15792
015790  780214     MOV [W4], W4
015792  E00004     CP0 W4
015794  3AFFF8     BRA NZ, 0x15786
015A56  8364C4     MOV sdp_service_records, W4
015A58  370006     BRA 0x15A66
015A64  780214     MOV [W4], W4
015A66  E00004     CP0 W4
015A68  3AFFF8     BRA NZ, 0x15A5A
015A6A  060000     RETURN
015F98  8364C0     MOV sdp_service_records, W0
015F9A  370007     BRA 0x15FAA
015FA8  780012     MOV [W2], W0
015FAA  E00000     CP0 W0
015FAC  3AFFF7     BRA NZ, 0x15F9C
015FAE  780100     MOV W0, W2
111:                       service_record_item_t * item = (service_record_item_t *) it;
015F9C  780100     MOV W0, W2
112:                       if (item->service_record_handle == handle){
0128F6  900039     MOV [W9+6], W0
0128F8  9000C9     MOV [W9+8], W1
0128FA  97B17F     MOV [W15-18], W2
0128FC  97B98F     MOV [W15-16], W3
0128FE  500F82     SUB W0, W2, [W15]
012900  588F83     SUBB W1, W3, [W15]
012902  320004     BRA Z, 0x1290C
0135A6  900032     MOV [W2+6], W0
0135A8  9000C2     MOV [W2+8], W1
0135AA  500F88     SUB W0, W8, [W15]
0135AC  588F89     SUBB W1, W9, [W15]
0135AE  320004     BRA Z, 0x135B8
015786  900034     MOV [W4+6], W0
015788  9000C4     MOV [W4+8], W1
01578A  500F82     SUB W0, W2, [W15]
01578C  588F83     SUBB W1, W3, [W15]
01578E  32FFF6     BRA Z, 0x1577C
015A5A  900034     MOV [W4+6], W0
015A5C  9000C4     MOV [W4+8], W1
015A5E  500F82     SUB W0, W2, [W15]
015A60  588F83     SUBB W1, W3, [W15]
015A62  320004     BRA Z, 0x15A6C
015F9E  9000C0     MOV [W0+8], W1
015FA0  900030     MOV [W0+6], W0
015FA2  500F84     SUB W0, W4, [W15]
015FA4  588F85     SUBB W1, W5, [W15]
015FA6  320004     BRA Z, 0x15FB0
113:                           return item;
114:                       }
115:                   }
116:                   return NULL;
117:               }
118:               
119:               // get next free, unregistered service record handle
120:               uint32_t sdp_create_service_record_handle(void){
121:                   uint32_t handle = 0;
122:                   do {
123:                       handle = sdp_next_service_record_handle++;
124:                       if (sdp_get_record_for_handle(handle)) handle = 0;
125:                   } while (handle == 0);
015796  510FE0     SUB W2, #0x0, [W15]
015798  598FE0     SUBB W3, #0x0, [W15]
01579A  32FFF0     BRA Z, 0x1577C
01579C  8B88D6     MOV W6, sdp_next_service_record_handle
01579E  8B88E7     MOV W7, 0x711C
126:                   return handle;
127:               }
128:               
129:               #ifdef EMBEDDED
130:               
131:               // register service record internally - this special version doesn't copy the record, it should not be freeed
132:               // pre: AttributeIDs are in ascending order
133:               // pre: ServiceRecordHandle is first attribute and valid
134:               // pre: record
135:               // @returns ServiceRecordHandle or 0 if registration failed
136:               uint32_t sdp_register_service_internal(void *connection, service_record_item_t * record_item){
137:                   // get user record handle
138:                   uint32_t record_handle = record_item->service_record_handle;
013586  900431     MOV [W1+6], W8
013588  9004C1     MOV [W1+8], W9
139:                   // get actual record
140:                   uint8_t *record = record_item->service_record;
01358A  4085EA     ADD W1, #0xA, W11
141:                   
142:                   // check for ServiceRecordHandle attribute, returns pointer or null
143:                   uint8_t * req_record_handle = sdp_get_attribute_value_for_attribute_id(record, SDP_ServiceRecordHandle);
01358C  EB0080     CLR W1
01358E  78000B     MOV W11, W0
013590  026378     CALL sdp_get_attribute_value_for_attribute_id
013592  000001     NOP
144:                   if (!req_record_handle) {
013594  E00000     CP0 W0
013596  3A0002     BRA NZ, 0x1359C
013598  B84460     MUL.UU W8, #0, W8
01359A  370037     BRA 0x1360A
145:                       log_error("SDP Error - record does not contain ServiceRecordHandle attribute\n");
146:                       return 0;
147:                   }
148:                   
149:                   // validate service record handle is not in reserved range
150:                   if (record_handle <= maxReservedServiceRecordHandle) record_handle = 0;
01359C  440FE1     ADD W8, #0x1, [W15]
01359E  5C8FE0     SUBB W9, #0x0, [W15]
0135A0  36000B     BRA LEU, 0x135B8
151:                   
152:                   // check if already in use
153:                   if (record_handle) {
154:                       if (sdp_get_record_for_handle(record_handle)) {
155:                           record_handle = 0;
156:                       }
157:                   }
158:                   
159:                   // create new handle if needed
160:                   if (!record_handle){
161:                       record_handle = sdp_create_service_record_handle();
0135B8  025774     CALL sdp_create_service_record_handle
0135BA  000001     NOP
0135BC  BE0400     MOV.D W0, W8
162:                       // Write the handle back into the record too
163:                       record_item->service_record_handle = record_handle;
0135BE  980530     MOV W0, [W10+6]
0135C0  980541     MOV W1, [W10+8]
164:                       sdp_set_attribute_value_for_attribute_id(record, SDP_ServiceRecordHandle, record_handle);
0135C2  BE0100     MOV.D W0, W2
0135C4  EB0080     CLR W1
0135C6  78000B     MOV W11, W0
0135C8  0260B0     CALL sdp_set_attribute_value_for_attribute_id
0135CA  000001     NOP
165:                   }
166:                   
167:                   // add to linked list
168:                   linked_list_add(&sdp_service_records, (linked_item_t *) record_item);
0135CC  78008A     MOV W10, W1
0135CE  26C980     MOV #0x6C98, W0
0135D0  0263E6     CALL linked_list_add
0135D2  000001     NOP
169:                   
170:                   sdp_emit_service_registered(connection, 0, record_item->service_record_handle);
0135D4  9000BA     MOV [W10+6], W1
171:                   
172:                   return record_handle;
173:               }
174:               
175:               #else
176:               
177:               // AttributeIDList used to remove ServiceRecordHandle
178:               static const uint8_t removeServiceRecordHandleAttributeIDList[] = { 0x36, 0x00, 0x05, 0x0A, 0x00, 0x01, 0xFF, 0xFF };
179:               
180:               // register service record internally - the normal version creates a copy of the record
181:               // pre: AttributeIDs are in ascending order => ServiceRecordHandle is first attribute if present
182:               // @returns ServiceRecordHandle or 0 if registration failed
183:               uint32_t sdp_register_service_internal(void *connection, uint8_t * record){
184:               
185:                   // dump for now
186:                   // printf("Register service record\n");
187:                   // de_dump_data_element(record);
188:                   
189:                   // get user record handle
190:                   uint32_t record_handle = sdp_get_service_record_handle(record);
191:               
192:                   // validate service record handle is not in reserved range
193:                   if (record_handle <= maxReservedServiceRecordHandle) record_handle = 0;
194:                   
195:                   // check if already in use
196:                   if (record_handle) {
197:                       if (sdp_get_record_for_handle(record_handle)) {
198:                           record_handle = 0;
199:                       }
200:                   }
201:                   
202:                   // create new handle if needed
203:                   if (!record_handle){
204:                       record_handle = sdp_create_service_record_handle();
205:                   }
206:                   
207:                   // calculate size of new service record: DES (2 byte len) 
208:                   // + ServiceRecordHandle attribute (UINT16 UINT32) + size of existing attributes
209:                   uint16_t recordSize =  3 + (3 + 5) + de_get_data_size(record);
210:                       
211:                   // alloc memory for new service_record_item
212:                   service_record_item_t * newRecordItem = (service_record_item_t *) malloc(recordSize + sizeof(service_record_item_t));
213:                   if (!newRecordItem) {
214:                       sdp_emit_service_registered(connection, 0, BTSTACK_MEMORY_ALLOC_FAILED);
215:                       return 0;
216:                   }
217:                   // link new service item to client connection
218:                   newRecordItem->connection = connection;
219:                   
220:                   // set new handle
221:                   newRecordItem->service_record_handle = record_handle;
222:               
223:                   // create updated service record
224:                   uint8_t * newRecord = (uint8_t *) &(newRecordItem->service_record);
225:                   
226:                   // create DES for new record
227:                   de_create_sequence(newRecord);
228:                   
229:                   // set service record handle
230:                   de_add_number(newRecord, DE_UINT, DE_SIZE_16, 0);
231:                   de_add_number(newRecord, DE_UINT, DE_SIZE_32, record_handle);
232:                   
233:                   // add other attributes
234:                   sdp_append_attributes_in_attributeIDList(record, (uint8_t *) removeServiceRecordHandleAttributeIDList, 0, recordSize, newRecord);
235:                   
236:                   // dump for now
237:                   // de_dump_data_element(newRecord);
238:                   // printf("reserved size %u, actual size %u\n", recordSize, de_get_len(newRecord));
239:                   
240:                   // add to linked list
241:                   linked_list_add(&sdp_service_records, (linked_item_t *) newRecordItem);
242:                   
243:                   sdp_emit_service_registered(connection, 0, newRecordItem->service_record_handle);
244:               
245:                   return record_handle;
246:               }
247:               
248:               #endif
249:               
250:               // unregister service record internally
251:               // 
252:               // makes sure one client cannot remove service records of other clients
253:               //
254:               void sdp_unregister_service_internal(void *connection, uint32_t service_record_handle){
255:                   service_record_item_t * record_item = sdp_get_record_for_handle(service_record_handle);
256:                   if (record_item && record_item->connection == connection) {
015A6C  900024     MOV [W4+4], W0
015A6E  500F85     SUB W0, W5, [W15]
015A70  3A0004     BRA NZ, 0x15A7A
257:                       linked_list_remove(&sdp_service_records, (linked_item_t *) record_item);
258:                   }
259:               }
260:               
261:               // remove all service record for a client connection
262:               void sdp_unregister_services_for_connection(void *connection){
263:                   linked_item_t *it = (linked_item_t *) &sdp_service_records;
016208  26C982     MOV #0x6C98, W2
01620A  370006     BRA 0x16218
264:                   while (it->next){
016218  780092     MOV [W2], W1
01621A  E00001     CP0 W1
01621C  3AFFF7     BRA NZ, 0x1620C
265:                       service_record_item_t *record_item = (service_record_item_t *) it->next;
266:                       if (record_item->connection == connection){
01620C  900021     MOV [W1+4], W0
01620E  500F83     SUB W0, W3, [W15]
016210  320002     BRA Z, 0x16216
016212  780101     MOV W1, W2
016214  370001     BRA 0x16218
267:                           it->next = it->next->next;
016216  780911     MOV [W1], [W2]
268:               #ifndef EMBEDDED
269:                           free(record_item);
270:               #endif
271:                       } else {
272:                           it = it->next;
273:                       }
274:                   }
275:               }
276:               
277:               // PDU
278:               // PDU ID (1), Transaction ID (2), Param Length (2), Param 1, Param 2, ..
279:               
280:               int sdp_create_error_response(uint16_t transaction_id, uint16_t error_code){
281:                   sdp_response_buffer[0] = SDP_ErrorResponse;
015834  26CA08     MOV #0x6CA0, W8
015836  B3C010     MOV #0x1, W0
015838  784C00     MOV.B W0, [W8]
282:                   net_store_16(sdp_response_buffer, 1, transaction_id);
01583A  200011     MOV #0x1, W1
01583C  780008     MOV W8, W0
01583E  02661E     CALL net_store_16
015840  000001     NOP
283:                   net_store_16(sdp_response_buffer, 3, 2);
015842  200022     MOV #0x2, W2
015844  200031     MOV #0x3, W1
015846  780008     MOV W8, W0
015848  02661E     CALL net_store_16
01584A  000001     NOP
284:                   net_store_16(sdp_response_buffer, 5, error_code); // invalid syntax
01584C  780109     MOV W9, W2
01584E  200051     MOV #0x5, W1
015850  780008     MOV W8, W0
015852  02661E     CALL net_store_16
015854  000001     NOP
285:                   return 7;
286:               }
287:               
288:               int sdp_handle_service_search_request(uint8_t * packet, uint16_t remote_mtu){
289:                   
290:                   // get request details
291:                   uint16_t  transaction_id = READ_NET_16(packet, 1);
012ABA  9040A0     MOV.B [W0+2], W1
012ABC  FB8081     ZE W1, W1
012ABE  904010     MOV.B [W0+1], W0
012AC0  DD0048     SL W0, #8, W0
012AC2  708080     IOR W1, W0, W1
012AC4  9FBF81     MOV W1, [W15-16]
292:                   // not used yet - uint16_t  param_len = READ_NET_16(packet, 3);
293:                   uint8_t * serviceSearchPattern = &packet[5];
012AC6  440665     ADD W8, #0x5, W12
294:                   uint16_t  serviceSearchPatternLen = de_get_len(serviceSearchPattern);
012AC8  78000C     MOV W12, W0
012ACA  02629A     CALL de_get_len
012ACC  000001     NOP
295:                   uint16_t  maximumServiceRecordCount = READ_NET_16(packet, 5 + serviceSearchPatternLen);
012ACE  440100     ADD W8, W0, W2
012AD0  9040E2     MOV.B [W2+6], W1
012AD2  FB8081     ZE W1, W1
012AD4  904052     MOV.B [W2+5], W0
012AD6  DD0048     SL W0, #8, W0
012AD8  708500     IOR W1, W0, W10
296:                   uint8_t * continuationState = &packet[5+serviceSearchPatternLen+2];
297:                   
298:                   // calc maxumumServiceRecordCount based on remote MTU
299:                   uint16_t maxNrServiceRecordsPerResponse = (remote_mtu - (9+3))/4;
012ADA  54806C     SUB W9, #0xC, W0
012ADC  DE0042     LSR W0, #2, W0
012ADE  9FB7F0     MOV W0, [W15-18]
300:                   
301:                   // continuation state contains index of next service record to examine
302:                   int      continuation = 0;
303:                   uint16_t continuation_index = 0;
304:                   if (continuationState[0] == 2){
012AE0  904072     MOV.B [W2+7], W0
012AE2  EB0080     CLR W1
012AE4  9FB7E1     MOV W1, [W15-20]
012AE6  504FE2     SUB.B W0, #0x2, [W15]
012AE8  3A0012     BRA NZ, 0x12B0E
012AEA  37000B     BRA 0x12B02
305:                       continuation_index = READ_NET_16(continuationState, 1);
012B02  904892     MOV.B [W2+9], W1
012B04  FB8081     ZE W1, W1
012B06  904802     MOV.B [W2+8], W0
012B08  DD0048     SL W0, #8, W0
012B0A  708080     IOR W1, W0, W1
012B0C  9FB7E1     MOV W1, [W15-20]
306:                   }
307:                   
308:                   // get and limit total count
309:                   linked_item_t *it;
310:                   uint16_t total_service_count   = 0;
311:                   for (it = (linked_item_t *) sdp_service_records; it ; it = it->next){
012B0E  8364C9     MOV sdp_service_records, W9
012B10  EB0700     CLR W14
012B12  370008     BRA 0x12B24
012B22  780499     MOV [W9], W9
012B24  E00009     CP0 W9
012B26  3AFFF6     BRA NZ, 0x12B14
312:                       service_record_item_t * item = (service_record_item_t *) it;
313:                       if (!sdp_record_matches_service_search_pattern(item->service_record, serviceSearchPattern)) continue;
012B14  44806A     ADD W9, #0xA, W0
012B16  78008C     MOV W12, W1
012B18  026220     CALL sdp_record_matches_service_search_pattern
012B1A  000001     NOP
012B1C  E00000     CP0 W0
012B1E  320001     BRA Z, 0x12B22
314:                       total_service_count++;
012B20  E8070E     INC W14, W14
315:                   }
316:                   if (total_service_count > maximumServiceRecordCount){
012B28  570F8A     SUB W14, W10, [W15]
012B2A  360001     BRA LEU, 0x12B2E
012B2C  78070A     MOV W10, W14
317:                       total_service_count = maximumServiceRecordCount;
318:                   }
319:                   
320:                   // ServiceRecordHandleList at 9
321:                   uint16_t pos = 9;
322:                   uint16_t current_service_count  = 0;
323:                   uint16_t current_service_index  = 0;
324:                   uint16_t matching_service_count = 0;
325:                   for (it = (linked_item_t *) sdp_service_records; it ; it = it->next, ++current_service_index){
012B2E  8364CA     MOV sdp_service_records, W10
012B30  200098     MOV #0x9, W8
012B32  780689     MOV W9, W13
012B34  78058D     MOV W13, W11
012B36  37001A     BRA 0x12B6C
012B68  78051A     MOV [W10], W10
012B6A  E80489     INC W9, W9
012B6C  E0000A     CP0 W10
012B6E  3AFFE4     BRA NZ, 0x12B38
326:                       service_record_item_t * item = (service_record_item_t *) it;
327:               
328:                       if (!sdp_record_matches_service_search_pattern(item->service_record, serviceSearchPattern)) continue;
012B38  45006A     ADD W10, #0xA, W0
012B3A  78008C     MOV W12, W1
012B3C  026220     CALL sdp_record_matches_service_search_pattern
012B3E  000001     NOP
012B40  E00000     CP0 W0
012B42  320012     BRA Z, 0x12B68
329:                       matching_service_count++;
012B44  E8058B     INC W11, W11
330:                       
331:                       if (current_service_index < continuation_index) continue;
012B46  97B06F     MOV [W15-20], W0
012B48  548F80     SUB W9, W0, [W15]
012B4A  39000E     BRA NC, 0x12B68
332:               
333:                       net_store_32(sdp_response_buffer, pos, item->service_record_handle);
012B4C  90013A     MOV [W10+6], W2
012B4E  9001CA     MOV [W10+8], W3
012B50  780088     MOV W8, W1
012B52  26CA00     MOV #0x6CA0, W0
012B54  025FD0     CALL net_store_32
012B56  000001     NOP
334:                       pos += 4;
012B58  440164     ADD W8, #0x4, W2
335:                       current_service_count++;
012B5A  E8068D     INC W13, W13
336:                       
337:                       if (matching_service_count >= total_service_count) break;
012AEC  780402     MOV W2, W8
012AEE  370040     BRA 0x12B70
012B5C  558F8E     SUB W11, W14, [W15]
012B5E  31FFC6     BRA C, 0x12AEC
338:               
339:                       if (current_service_count >= maxNrServiceRecordsPerResponse){
012B60  97B0FF     MOV [W15-18], W1
012B62  568F81     SUB W13, W1, [W15]
012B64  31FFC5     BRA C, 0x12AF0
340:                           continuation = 1;
341:                           continuation_index = current_service_index + 1;
342:                           break;
343:                       }
344:                   }
345:                   
346:                   // Store continuation state
347:                   if (continuation) {
348:                       sdp_response_buffer[pos++] = 2;
012AF0  26CA00     MOV #0x6CA0, W0
012AF2  B3C021     MOV #0x2, W1
012AF4  797001     MOV.B W1, [W0+W2]
349:                       net_store_16(sdp_response_buffer, pos, continuation_index);
012AF6  E80109     INC W9, W2
012AF8  4400E5     ADD W8, #0x5, W1
012AFA  02661E     CALL net_store_16
012AFC  000001     NOP
350:                       pos += 2;
012AFE  4404E7     ADD W8, #0x7, W9
012B00  37003B     BRA 0x12B78
012B66  780402     MOV W2, W8
351:                   } else {
352:                       sdp_response_buffer[pos++] = 0;
012B70  EB4080     CLR.B W1
012B72  26CA00     MOV #0x6CA0, W0
012B74  7C7001     MOV.B W1, [W0+W8]
012B76  E80488     INC W8, W9
353:                   }
354:               
355:                   // header
356:                   sdp_response_buffer[0] = SDP_ServiceSearchResponse;
012B78  26CA08     MOV #0x6CA0, W8
012B7A  B3C030     MOV #0x3, W0
012B7C  784C00     MOV.B W0, [W8]
357:                   net_store_16(sdp_response_buffer, 1, transaction_id);
012B7E  97B90F     MOV [W15-16], W2
012B80  200011     MOV #0x1, W1
012B82  780008     MOV W8, W0
012B84  02661E     CALL net_store_16
012B86  000001     NOP
358:                   net_store_16(sdp_response_buffer, 3, pos - 5); // size of variable payload
012B88  548165     SUB W9, #0x5, W2
012B8A  200031     MOV #0x3, W1
012B8C  780008     MOV W8, W0
012B8E  02661E     CALL net_store_16
012B90  000001     NOP
359:                   net_store_16(sdp_response_buffer, 5, total_service_count);
012B92  78010E     MOV W14, W2
012B94  200051     MOV #0x5, W1
012B96  780008     MOV W8, W0
012B98  02661E     CALL net_store_16
012B9A  000001     NOP
360:                   net_store_16(sdp_response_buffer, 7, current_service_count);
012B9C  78010D     MOV W13, W2
012B9E  200071     MOV #0x7, W1
012BA0  780008     MOV W8, W0
012BA2  02661E     CALL net_store_16
012BA4  000001     NOP
361:                   
362:                   return pos;
363:               }
364:               
365:               int sdp_handle_service_attribute_request(uint8_t * packet, uint16_t remote_mtu){
366:                   
367:                   // get request details
368:                   uint16_t  transaction_id = READ_NET_16(packet, 1);
012890  9040A0     MOV.B [W0+2], W1
012892  FB8081     ZE W1, W1
012894  904010     MOV.B [W0+1], W0
012896  DD0048     SL W0, #8, W0
012898  708700     IOR W1, W0, W14
369:                   // not used yet - uint16_t  param_len = READ_NET_16(packet, 3);
370:                   uint32_t  serviceRecordHandle = READ_NET_32(packet, 5);
01289A  904908     MOV.B [W8+8], W2
01289C  FB8102     ZE W2, W2
01289E  200003     MOV #0x0, W3
0128A0  904078     MOV.B [W8+7], W0
0128A2  DD0048     SL W0, #8, W0
0128A4  200001     MOV #0x0, W1
0128A6  710100     IOR W2, W0, W2
0128A8  718181     IOR W3, W1, W3
0128AA  904068     MOV.B [W8+6], W0
0128AC  FB8080     ZE W0, W1
0128AE  200000     MOV #0x0, W0
0128B0  710100     IOR W2, W0, W2
0128B2  718181     IOR W3, W1, W3
0128B4  904058     MOV.B [W8+5], W0
0128B6  DD00C8     SL W0, #8, W1
0128B8  200000     MOV #0x0, W0
0128BA  710100     IOR W2, W0, W2
0128BC  718181     IOR W3, W1, W3
0128BE  9FB7F2     MOV W2, [W15-18]
0128C0  9FBF83     MOV W3, [W15-16]
371:                   uint16_t  maximumAttributeByteCount = READ_NET_16(packet, 9);
0128C2  9048A8     MOV.B [W8+10], W1
0128C4  FB8081     ZE W1, W1
0128C6  904818     MOV.B [W8+9], W0
0128C8  DD0048     SL W0, #8, W0
0128CA  708500     IOR W1, W0, W10
372:                   uint8_t * attributeIDList = &packet[11];
0128CC  44066B     ADD W8, #0xB, W12
373:                   uint16_t  attributeIDListLen = de_get_len(attributeIDList);
0128CE  78000C     MOV W12, W0
0128D0  02629A     CALL de_get_len
0128D2  000001     NOP
374:                   uint8_t * continuationState = &packet[11+attributeIDListLen];
0128D4  440400     ADD W8, W0, W8
0128D6  4400EB     ADD W8, #0xB, W1
375:                   
376:                   // calc maximumAttributeByteCount based on remote MTU
377:                   uint16_t maximumAttributeByteCount2 = remote_mtu - (7+3);
0128D8  54806A     SUB W9, #0xA, W0
378:                   if (maximumAttributeByteCount2 < maximumAttributeByteCount) {
0128DA  500F8A     SUB W0, W10, [W15]
0128DC  310001     BRA C, 0x128E0
0128DE  780500     MOV W0, W10
379:                       maximumAttributeByteCount = maximumAttributeByteCount2;
380:                   }
381:                   
382:                   // continuation state contains the offset into the complete response
383:                   uint16_t continuation_offset = 0;
384:                   if (continuationState[0] == 2){
0128E0  EB0680     CLR W13
0128E2  B3C020     MOV #0x2, W0
0128E4  104F91     SUBR.B W0, [W1], [W15]
0128E6  3A0005     BRA NZ, 0x128F2
385:                       continuation_offset = READ_NET_16(continuationState, 1);
0128E8  9048D8     MOV.B [W8+13], W1
0128EA  FB8081     ZE W1, W1
0128EC  904848     MOV.B [W8+12], W0
0128EE  DD0048     SL W0, #8, W0
0128F0  708680     IOR W1, W0, W13
386:                   }
387:                   
388:                   // get service record
389:                   service_record_item_t * item = sdp_get_record_for_handle(serviceRecordHandle);
390:                   if (!item){
391:                       // service record handle doesn't exist
392:                       return sdp_create_error_response(transaction_id, 0x0002); /// invalid Service Record Handle
012988  200021     MOV #0x2, W1
01298A  78000E     MOV W14, W0
01298C  02582E     CALL sdp_create_error_response
01298E  000001     NOP
393:                   }
394:                   
395:                   
396:                   // AttributeList - starts at offset 7
397:                   uint16_t pos = 7;
398:                   
399:                   if (continuation_offset == 0){
01290C  200078     MOV #0x7, W8
01290E  E0000D     CP0 W13
012910  3A000C     BRA NZ, 0x1292A
400:                       
401:                       // get size of this record
402:                       uint16_t filtered_attributes_size = spd_get_filtered_size(item->service_record, attributeIDList);
012912  44806A     ADD W9, #0xA, W0
012914  78008C     MOV W12, W1
012916  02638E     CALL spd_get_filtered_size
012918  000001     NOP
403:                       
404:                       // store DES
405:                       de_store_descriptor_with_len(&sdp_response_buffer[pos], DE_DES, DE_SIZE_VAR_16, filtered_attributes_size);
01291A  B80261     MUL.UU W0, #1, W4
01291C  200062     MOV #0x6, W2
01291E  200061     MOV #0x6, W1
012920  26CA70     MOV #0x6CA7, W0
012922  025BAC     CALL de_store_descriptor_with_len
012924  000001     NOP
406:                       maximumAttributeByteCount -= 3;
012926  550563     SUB W10, #0x3, W10
012928  2000A8     MOV #0xA, W8
407:                       pos += 3;
408:                   }
409:               
410:                   // copy maximumAttributeByteCount from record
411:                   uint16_t bytes_used;
412:                   int complete = sdp_filter_attributes_in_attributeIDList(item->service_record, attributeIDList, continuation_offset, maximumAttributeByteCount, &bytes_used, &sdp_response_buffer[pos]);
01292A  26CA0B     MOV #0x6CA0, W11
01292C  44806A     ADD W9, #0xA, W0
01292E  44028B     ADD W8, W11, W5
012930  578274     SUB W15, #0x14, W4
012932  78018A     MOV W10, W3
012934  78010D     MOV W13, W2
012936  78008C     MOV W12, W1
012938  02598A     CALL sdp_filter_attributes_in_attributeIDList
01293A  000001     NOP
413:                   pos += bytes_used;
01293C  97B0EF     MOV [W15-20], W1
01293E  440481     ADD W8, W1, W9
012940  E80189     INC W9, W3
414:                   
415:                   uint16_t attributeListByteCount = pos - 7;
012942  548567     SUB W9, #0x7, W10
416:               
417:                   if (complete) {
012944  E00000     CP0 W0
012946  320004     BRA Z, 0x12950
418:                       sdp_response_buffer[pos++] = 0;
012948  EB4000     CLR.B W0
01294A  7CF580     MOV.B W0, [W11+W9]
01294C  780483     MOV W3, W9
01294E  370008     BRA 0x12960
419:                   } else {
420:                       continuation_offset += bytes_used;
421:                       sdp_response_buffer[pos++] = 2;
012950  B3C020     MOV #0x2, W0
012952  7CF580     MOV.B W0, [W11+W9]
422:                       net_store_16(sdp_response_buffer, pos, continuation_offset);
012954  468101     ADD W13, W1, W2
012956  780083     MOV W3, W1
012958  78000B     MOV W11, W0
01295A  02661E     CALL net_store_16
01295C  000001     NOP
423:                       pos += 2;
01295E  4484E3     ADD W9, #0x3, W9
424:                   }
425:               
426:                   // header
427:                   sdp_response_buffer[0] = SDP_ServiceAttributeResponse;
012960  26CA08     MOV #0x6CA0, W8
012962  B3C050     MOV #0x5, W0
012964  784C00     MOV.B W0, [W8]
428:                   net_store_16(sdp_response_buffer, 1, transaction_id);
012966  78010E     MOV W14, W2
012968  200011     MOV #0x1, W1
01296A  780008     MOV W8, W0
01296C  02661E     CALL net_store_16
01296E  000001     NOP
429:                   net_store_16(sdp_response_buffer, 3, pos - 5);  // size of variable payload
012970  548165     SUB W9, #0x5, W2
012972  200031     MOV #0x3, W1
012974  780008     MOV W8, W0
012976  02661E     CALL net_store_16
012978  000001     NOP
430:                   net_store_16(sdp_response_buffer, 5, attributeListByteCount); 
01297A  78010A     MOV W10, W2
01297C  200051     MOV #0x5, W1
01297E  780008     MOV W8, W0
012980  02661E     CALL net_store_16
012982  000001     NOP
431:                   
432:                   return pos;
012984  780009     MOV W9, W0
012986  370004     BRA 0x12990
433:               }
434:               
435:               static uint16_t sdp_get_size_for_service_search_attribute_response(uint8_t * serviceSearchPattern, uint8_t * attributeIDList){
436:                   uint16_t total_response_size = 0;
437:                   linked_item_t *it;
438:                   for (it = (linked_item_t *) sdp_service_records; it ; it = it->next){
012162  8364C8     MOV sdp_service_records, W8
012164  EB0580     CLR W11
012166  37000E     BRA 0x12184
012182  780418     MOV [W8], W8
012184  E00008     CP0 W8
012186  3AFFF0     BRA NZ, 0x12168
439:                       service_record_item_t * item = (service_record_item_t *) it;
440:                       
441:                       if (!sdp_record_matches_service_search_pattern(item->service_record, serviceSearchPattern)) continue;
012168  4404EA     ADD W8, #0xA, W9
01216A  97B0FF     MOV [W15-18], W1
01216C  780009     MOV W9, W0
01216E  026220     CALL sdp_record_matches_service_search_pattern
012170  000001     NOP
012172  E00000     CP0 W0
012174  320006     BRA Z, 0x12182
442:                       
443:                       // for all service records that match
444:                       total_response_size += 3 + spd_get_filtered_size(item->service_record, attributeIDList);
012176  78008D     MOV W13, W1
012178  780009     MOV W9, W0
01217A  02638E     CALL spd_get_filtered_size
01217C  000001     NOP
01217E  458000     ADD W11, W0, W0
012180  4005E3     ADD W0, #0x3, W11
445:                   }
446:                   return total_response_size;
447:               }
448:               
449:               int sdp_handle_service_search_attribute_request(uint8_t * packet, uint16_t remote_mtu){
450:                   
451:                   // SDP header before attribute sevice list: 7
452:                   // Continuation, worst case: 5
453:                   
454:                   // get request details
455:                   uint16_t  transaction_id = READ_NET_16(packet, 1);
012100  9040A0     MOV.B [W0+2], W1
012102  FB8081     ZE W1, W1
012104  904010     MOV.B [W0+1], W0
012106  DD0048     SL W0, #8, W0
012108  708080     IOR W1, W0, W1
01210A  9FBF81     MOV W1, [W15-16]
456:                   // not used yet - uint16_t  param_len = READ_NET_16(packet, 3);
457:                   uint8_t * serviceSearchPattern = &packet[5];
01210C  440065     ADD W8, #0x5, W0
01210E  9FB7F0     MOV W0, [W15-18]
458:                   uint16_t  serviceSearchPatternLen = de_get_len(serviceSearchPattern);
012110  02629A     CALL de_get_len
012112  000001     NOP
012114  780580     MOV W0, W11
459:                   uint16_t  maximumAttributeByteCount = READ_NET_16(packet, 5 + serviceSearchPatternLen);
012116  440100     ADD W8, W0, W2
012118  9040E2     MOV.B [W2+6], W1
01211A  FB8081     ZE W1, W1
01211C  904052     MOV.B [W2+5], W0
01211E  DD0048     SL W0, #8, W0
012120  708500     IOR W1, W0, W10
460:                   uint8_t * attributeIDList = &packet[5+serviceSearchPatternLen+2];
012122  4106E7     ADD W2, #0x7, W13
461:                   uint16_t  attributeIDListLen = de_get_len(attributeIDList);
012124  78000D     MOV W13, W0
012126  02629A     CALL de_get_len
012128  000001     NOP
462:                   uint8_t * continuationState = &packet[5+serviceSearchPatternLen+2+attributeIDListLen];
01212A  458000     ADD W11, W0, W0
01212C  440400     ADD W8, W0, W8
01212E  4400E7     ADD W8, #0x7, W1
463:                   
464:                   // calc maximumAttributeByteCount based on remote MTU, SDP header and reserved Continuation block
465:                   uint16_t maximumAttributeByteCount2 = remote_mtu - 12;
012130  54806C     SUB W9, #0xC, W0
466:                   if (maximumAttributeByteCount2 < maximumAttributeByteCount) {
012132  500F8A     SUB W0, W10, [W15]
012134  310001     BRA C, 0x12138
012136  780500     MOV W0, W10
467:                       maximumAttributeByteCount = maximumAttributeByteCount2;
468:                   }
469:                   
470:                   // continuation state contains: index of next service record to examine
471:                   // continuation state contains: byte offset into this service record
472:                   uint16_t continuation_service_index = 0;
473:                   uint16_t continuation_offset = 0;
474:                   if (continuationState[0] == 4){
012138  EB0000     CLR W0
01213A  9FB7E0     MOV W0, [W15-20]
01213C  B3C040     MOV #0x4, W0
01213E  104F91     SUBR.B W0, [W1], [W15]
012140  3A0010     BRA NZ, 0x12162
475:                       continuation_service_index = READ_NET_16(continuationState, 1);
012142  904898     MOV.B [W8+9], W1
012144  FB8081     ZE W1, W1
012146  904808     MOV.B [W8+8], W0
012148  DD0048     SL W0, #8, W0
01214A  708080     IOR W1, W0, W1
01214C  9FB7E1     MOV W1, [W15-20]
476:                       continuation_offset = READ_NET_16(continuationState, 3);
01214E  9048B8     MOV.B [W8+11], W1
012150  FB8081     ZE W1, W1
012152  904828     MOV.B [W8+10], W0
012154  DD0048     SL W0, #8, W0
012156  708400     IOR W1, W0, W8
477:                   }
478:               
479:                   // printf("--> sdp_handle_service_search_attribute_request, cont %u/%u, max %u\n", continuation_service_index, continuation_offset, maximumAttributeByteCount);
480:                   
481:                   // AttributeLists - starts at offset 7
482:                   uint16_t pos = 7;
483:                   
484:                   // add DES with total size for first request
485:                   if (continuation_service_index == 0 && continuation_offset == 0){
012158  97B06F     MOV [W15-20], W0
01215A  E00000     CP0 W0
01215C  3A0021     BRA NZ, 0x121A0
01215E  E00008     CP0 W8
012160  3A001F     BRA NZ, 0x121A0
486:                       uint16_t total_response_size = sdp_get_size_for_service_search_attribute_response(serviceSearchPattern, attributeIDList);
487:                       de_store_descriptor_with_len(&sdp_response_buffer[pos], DE_DES, DE_SIZE_VAR_16, total_response_size);
012188  B85A61     MUL.UU W11, #1, W4
01218A  200062     MOV #0x6, W2
01218C  200061     MOV #0x6, W1
01218E  26CA70     MOV #0x6CA7, W0
012190  025BAC     CALL de_store_descriptor_with_len
012192  000001     NOP
488:                       // log_info("total response size %u\n", total_response_size);
489:                       pos += 3;
490:                       maximumAttributeByteCount -= 3;
012194  550563     SUB W10, #0x3, W10
012196  2000AB     MOV #0xA, W11
012198  370004     BRA 0x121A2
0121A0  20007B     MOV #0x7, W11
491:                   }
492:                   
493:                   // create attribute list
494:                   int      first_answer = 1;
495:                   int      continuation = 0;
496:                   uint16_t current_service_index = 0;
497:                   linked_item_t *it = (linked_item_t *) sdp_service_records;
0121A2  8364CC     MOV sdp_service_records, W12
0121A4  200010     MOV #0x1, W0
0121A6  9FB7D0     MOV W0, [W15-22]
0121A8  EB0700     CLR W14
0121AA  370032     BRA 0x12210
498:                   for ( ; it ; it = it->next, ++current_service_index){
01220C  78061C     MOV [W12], W12
01220E  E8070E     INC W14, W14
012210  E0000C     CP0 W12
012212  3AFFCC     BRA NZ, 0x121AC
012214  78000C     MOV W12, W0
012216  E8008B     INC W11, W1
012218  26CA09     MOV #0x6CA0, W9
499:                       service_record_item_t * item = (service_record_item_t *) it;
500:                       
501:                       if (current_service_index < continuation_service_index ) continue;
0121AC  97B06F     MOV [W15-20], W0
0121AE  570F80     SUB W14, W0, [W15]
0121B0  39002D     BRA NC, 0x1220C
502:                       if (!sdp_record_matches_service_search_pattern(item->service_record, serviceSearchPattern)) continue;
0121B2  4604EA     ADD W12, #0xA, W9
0121B4  97B0FF     MOV [W15-18], W1
0121B6  780009     MOV W9, W0
0121B8  026220     CALL sdp_record_matches_service_search_pattern
0121BA  000001     NOP
0121BC  E00000     CP0 W0
0121BE  320026     BRA Z, 0x1220C
503:               
504:                       if (continuation_offset == 0){
0121C0  E00008     CP0 W8
0121C2  3A0014     BRA NZ, 0x121EC
505:                           
506:                           // get size of this record
507:                           uint16_t filtered_attributes_size = spd_get_filtered_size(item->service_record, attributeIDList);
0121C4  78008D     MOV W13, W1
0121C6  780009     MOV W9, W0
0121C8  02638E     CALL spd_get_filtered_size
0121CA  000001     NOP
0121CC  780080     MOV W0, W1
508:                           
509:                           // stop if complete record doesn't fits into response but we already have a partial response
510:                           if ((filtered_attributes_size + 3 > maximumAttributeByteCount) && !first_answer) {
0121CE  400063     ADD W0, #0x3, W0
0121D0  500F8A     SUB W0, W10, [W15]
0121D2  360003     BRA LEU, 0x121DA
0121D4  97B05F     MOV [W15-22], W0
0121D6  E00000     CP0 W0
0121D8  32FFE1     BRA Z, 0x1219C
511:                               continuation = 1;
512:                               break;
513:                           }
514:                           
515:                           // store DES
516:                           de_store_descriptor_with_len(&sdp_response_buffer[pos], DE_DES, DE_SIZE_VAR_16, filtered_attributes_size);
0121DA  26CA00     MOV #0x6CA0, W0
0121DC  458000     ADD W11, W0, W0
0121DE  B80A61     MUL.UU W1, #1, W4
0121E0  200062     MOV #0x6, W2
0121E2  200061     MOV #0x6, W1
0121E4  025BAC     CALL de_store_descriptor_with_len
0121E6  000001     NOP
517:                           pos += 3;
0121E8  4585E3     ADD W11, #0x3, W11
518:                           maximumAttributeByteCount -= 3;
0121EA  550563     SUB W10, #0x3, W10
519:                       }
520:                       
521:                       first_answer = 0;
522:                   
523:                       // copy maximumAttributeByteCount from record
524:                       uint16_t bytes_used;
525:                       int complete = sdp_filter_attributes_in_attributeIDList(item->service_record, attributeIDList, continuation_offset, maximumAttributeByteCount, &bytes_used, &sdp_response_buffer[pos]);
0121EC  26CA05     MOV #0x6CA0, W5
0121EE  458285     ADD W11, W5, W5
0121F0  578278     SUB W15, #0x18, W4
0121F2  78018A     MOV W10, W3
0121F4  780108     MOV W8, W2
0121F6  78008D     MOV W13, W1
0121F8  780009     MOV W9, W0
0121FA  02598A     CALL sdp_filter_attributes_in_attributeIDList
0121FC  000001     NOP
526:                       pos += bytes_used;
0121FE  97B0CF     MOV [W15-24], W1
012200  458581     ADD W11, W1, W11
527:                       maximumAttributeByteCount -= bytes_used;
012202  550501     SUB W10, W1, W10
528:                       
529:                       if (complete) {
012204  E00000     CP0 W0
012206  32FFC9     BRA Z, 0x1219A
530:                           continuation_offset = 0;
531:                           continue;
532:                       }
533:                       
534:                       continuation = 1;
535:                       continuation_offset += bytes_used;
01219A  440401     ADD W8, W1, W8
01219C  200010     MOV #0x1, W0
01219E  37003B     BRA 0x12216
536:                       break;
012208  EB0400     CLR W8
01220A  9FB7D8     MOV W8, [W15-22]
537:                   }
538:                   
539:                   uint16_t attributeListsByteCount = pos - 7;
01221A  558567     SUB W11, #0x7, W10
540:                   
541:                   // Continuation State
542:                   if (continuation){
01221C  E00000     CP0 W0
01221E  32000D     BRA Z, 0x1223A
543:                       sdp_response_buffer[pos++] = 4;
012220  B3C040     MOV #0x4, W0
012222  7DF480     MOV.B W0, [W9+W11]
544:                       net_store_16(sdp_response_buffer, pos, (uint16_t) current_service_index);
012224  78010E     MOV W14, W2
012226  780009     MOV W9, W0
012228  02661E     CALL net_store_16
01222A  000001     NOP
545:                       pos += 2;
546:                       net_store_16(sdp_response_buffer, pos, continuation_offset);
01222C  4580E3     ADD W11, #0x3, W1
01222E  780108     MOV W8, W2
012230  780009     MOV W9, W0
012232  02661E     CALL net_store_16
012234  000001     NOP
547:                       pos += 2;
012236  4584E5     ADD W11, #0x5, W9
012238  370002     BRA 0x1223E
548:                   } else {
549:                       // complete
550:                       sdp_response_buffer[pos++] = 0;
01223A  7DF480     MOV.B W0, [W9+W11]
01223C  780481     MOV W1, W9
551:                   }
552:                       
553:                   // create SDP header
554:                   sdp_response_buffer[0] = SDP_ServiceSearchAttributeResponse;
01223E  26CA08     MOV #0x6CA0, W8
012240  B3C070     MOV #0x7, W0
012242  784C00     MOV.B W0, [W8]
555:                   net_store_16(sdp_response_buffer, 1, transaction_id);
012244  97B90F     MOV [W15-16], W2
012246  200011     MOV #0x1, W1
012248  780008     MOV W8, W0
01224A  02661E     CALL net_store_16
01224C  000001     NOP
556:                   net_store_16(sdp_response_buffer, 3, pos - 5);  // size of variable payload
01224E  548165     SUB W9, #0x5, W2
012250  200031     MOV #0x3, W1
012252  780008     MOV W8, W0
012254  02661E     CALL net_store_16
012256  000001     NOP
557:                   net_store_16(sdp_response_buffer, 5, attributeListsByteCount);
012258  78010A     MOV W10, W2
01225A  200051     MOV #0x5, W1
01225C  780008     MOV W8, W0
01225E  02661E     CALL net_store_16
012260  000001     NOP
558:                   
559:                   return pos;
560:               }
561:               
562:               static void sdp_try_respond(void){
563:                   if (!sdp_response_size ) return;
015C64  8364F0     MOV sdp_response_size, W0
015C66  E00000     CP0 W0
015C68  32000E     BRA Z, 0x15C86
564:                   if (!l2cap_cid) return;
015C6A  8364E0     MOV l2cap_cid, W0
015C6C  E00000     CP0 W0
015C6E  32000B     BRA Z, 0x15C86
565:                   if (!l2cap_can_send_packet_now(l2cap_cid)) return;
015C70  025DFE     CALL l2cap_can_send_packet_now
015C72  000001     NOP
015C74  E00000     CP0 W0
015C76  320007     BRA Z, 0x15C86
566:                   
567:                   // update state before sending packet (avoid getting called when new l2cap credit gets emitted)
568:                   uint16_t size = sdp_response_size;
015C78  8364F2     MOV sdp_response_size, W2
569:                   sdp_response_size = 0;
015C7A  EB0000     CLR W0
015C7C  8B64F0     MOV W0, sdp_response_size
570:                   l2cap_send_internal(l2cap_cid, sdp_response_buffer, size);
571:               }
572:               
573:               // we assume that we don't get two requests in a row
574:               static void sdp_packet_handler(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size){
575:               	uint16_t transaction_id;
576:                   SDP_PDU_ID_t pdu_id;
577:                   uint16_t remote_mtu;
578:                   // uint16_t param_len;
579:                   
580:               	switch (packet_type) {
01337E  504FE4     SUB.B W0, #0x4, [W15]
013380  320028     BRA Z, 0x133D2
013382  504FE6     SUB.B W0, #0x6, [W15]
013384  3A0053     BRA NZ, 0x1342C
581:               			
582:               		case L2CAP_DATA_PACKET:
583:                           pdu_id = (SDP_PDU_ID_t) packet[0];
013386  784492     MOV.B [W2], W9
584:                           transaction_id = READ_NET_16(packet, 1);
013388  9040A2     MOV.B [W2+2], W1
01338A  FB8081     ZE W1, W1
01338C  904012     MOV.B [W2+1], W0
01338E  DD0048     SL W0, #8, W0
013390  708500     IOR W1, W0, W10
585:                           // param_len = READ_NET_16(packet, 3);
586:                           remote_mtu = l2cap_get_remote_mtu_for_local_cid(channel);
013392  780003     MOV W3, W0
013394  0261D2     CALL l2cap_get_remote_mtu_for_local_cid
013396  000001     NOP
013398  780080     MOV W0, W1
587:                           // account for our buffer
588:                           if (remote_mtu > SDP_RESPONSE_BUFFER_SIZE){
01339A  200FC0     MOV #0xFC, W0
01339C  508F80     SUB W1, W0, [W15]
01339E  360001     BRA LEU, 0x133A2
0133A0  780080     MOV W0, W1
589:                               remote_mtu = SDP_RESPONSE_BUFFER_SIZE;
590:                           }
591:                           
592:                           // printf("SDP Request: type %u, transaction id %u, len %u, mtu %u\n", pdu_id, transaction_id, param_len, remote_mtu);
593:                           switch (pdu_id){
0133A2  54CFE4     SUB.B W9, #0x4, [W15]
0133A4  320008     BRA Z, 0x133B6
0133A6  54CFE6     SUB.B W9, #0x6, [W15]
0133A8  32000A     BRA Z, 0x133BE
0133AA  54CFE2     SUB.B W9, #0x2, [W15]
0133AC  3A000C     BRA NZ, 0x133C6
594:                                   
595:                               case SDP_ServiceSearchRequest:
596:                                   sdp_response_size = sdp_handle_service_search_request(packet, remote_mtu);
0133AE  780008     MOV W8, W0
0133B0  022AAE     CALL sdp_handle_service_search_request
0133B2  000001     NOP
0133B4  37000C     BRA 0x133CE
597:                                   break;
598:                                                       
599:                               case SDP_ServiceAttributeRequest:
600:                                   sdp_response_size = sdp_handle_service_attribute_request(packet, remote_mtu);
0133B6  780008     MOV W8, W0
0133B8  022884     CALL sdp_handle_service_attribute_request
0133BA  000001     NOP
0133BC  370008     BRA 0x133CE
601:                                   break;
602:                                   
603:                               case SDP_ServiceSearchAttributeRequest:
604:                                   sdp_response_size = sdp_handle_service_search_attribute_request(packet, remote_mtu);
0133BE  780008     MOV W8, W0
0133C0  0220F4     CALL sdp_handle_service_search_attribute_request
0133C2  000001     NOP
0133C4  370004     BRA 0x133CE
605:                                   break;
606:                                   
607:                               default:
608:                                   sdp_response_size = sdp_create_error_response(transaction_id, 0x0003); // invalid syntax
0133C6  200031     MOV #0x3, W1
0133C8  78000A     MOV W10, W0
0133CA  02582E     CALL sdp_create_error_response
0133CC  000001     NOP
0133CE  8B64F0     MOV W0, sdp_response_size
0133D0  370025     BRA 0x1341C
609:                                   break;
610:                           }
611:                           
612:                           sdp_try_respond();
613:                           
614:               			break;
615:               			
616:               		case HCI_EVENT_PACKET:
617:               			
618:               			switch (packet[0]) {
0133D2  784092     MOV.B [W2], W1
0133D4  B3C710     MOV #0x71, W0
0133D6  50CF80     SUB.B W1, W0, [W15]
0133D8  320024     BRA Z, 0x13422
0133DA  3E0007     BRA GTU, 0x133EA
0133DC  50407D     SUB.B W0, #0x1D, W0
0133DE  50CF80     SUB.B W1, W0, [W15]
0133E0  32001D     BRA Z, 0x1341C
0133E2  40407C     ADD.B W0, #0x1C, W0
0133E4  50CF80     SUB.B W1, W0, [W15]
0133E6  3A0022     BRA NZ, 0x1342C
0133E8  370015     BRA 0x13414
0133EA  B3C720     MOV #0x72, W0
0133EC  50CF80     SUB.B W1, W0, [W15]
0133EE  320004     BRA Z, 0x133F8
0133F0  E8C000     INC2.B W0, W0
0133F2  50CF80     SUB.B W1, W0, [W15]
0133F4  3A001B     BRA NZ, 0x1342C
0133F6  370012     BRA 0x1341C
619:               
620:               				case L2CAP_EVENT_INCOMING_CONNECTION:
621:                                   if (l2cap_cid) {
0133F8  8364E0     MOV l2cap_cid, W0
0133FA  E00000     CP0 W0
0133FC  320005     BRA Z, 0x13408
622:                                       // CONNECTION REJECTED DUE TO LIMITED RESOURCES 
623:                                       l2cap_decline_connection_internal(channel, 0x0d);
0133FE  B3C0D1     MOV #0xD, W1
013400  780003     MOV W3, W0
013402  025F78     CALL l2cap_decline_connection_internal
013404  000001     NOP
013406  370012     BRA 0x1342C
624:                                       break;
625:                                   }
626:                                   // accept
627:                                   l2cap_cid = channel;
013408  8B64E3     MOV W3, l2cap_cid
628:                                   sdp_response_size = 0;
01340A  8B64F0     MOV W0, sdp_response_size
629:                                   l2cap_accept_connection_internal(channel);
01340C  780003     MOV W3, W0
01340E  02605C     CALL l2cap_accept_connection_internal
013410  000001     NOP
013412  37000C     BRA 0x1342C
630:               					break;
631:                                   
632:                               case L2CAP_EVENT_CHANNEL_OPENED:
633:                                   if (packet[2]) {
013414  904022     MOV.B [W2+2], W0
013416  E00400     CP0.B W0
013418  320009     BRA Z, 0x1342C
01341A  370006     BRA 0x13428
634:                                       // open failed -> reset
635:                                       l2cap_cid = 0;
636:                                   }
637:                                   break;
638:               
639:                               case L2CAP_EVENT_CREDITS:
640:                               case DAEMON_EVENT_HCI_PACKET_SENT:
641:                                   sdp_try_respond();
01341C  025C64     CALL sdp_try_respond
01341E  000001     NOP
013420  370005     BRA 0x1342C
642:                                   break;
643:                               
644:                               case L2CAP_EVENT_CHANNEL_CLOSED:
645:                                   if (channel == l2cap_cid){
013422  8364E0     MOV l2cap_cid, W0
013424  518F80     SUB W3, W0, [W15]
013426  3A0002     BRA NZ, 0x1342C
646:                                       // reset
647:                                       l2cap_cid = 0;
013428  EB0000     CLR W0
01342A  8B64E0     MOV W0, l2cap_cid
648:                                   }
649:                                   break;
650:               					                    
651:               				default:
652:               					// other event
653:               					break;
654:               			}
655:               			break;
656:               			
657:               		default:
658:               			// other packet type
659:               			break;
660:               	}
661:               }
662:               
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libbtstack/src/rfcomm.c  -
00F956  FA0016     LNK #0x16
00F958  781F88     MOV W8, [W15++]
00F95A  780400     MOV W0, W8
00F95C  780181     MOV W1, W3
010044  4787F0     ADD W15, #0x10, W15
010046  BE9F88     MOV.D W8, [W15++]
010048  BE9F8A     MOV.D W10, [W15++]
01004A  BE9F8C     MOV.D W12, [W15++]
01004C  781F8E     MOV W14, [W15++]
01004E  784600     MOV.B W0, W12
010050  9FB7F1     MOV W1, [W15-18]
010052  780482     MOV W2, W9
010054  9FBF83     MOV W3, [W15-16]
01299C  FA0012     LNK #0x12
01299E  780300     MOV W0, W6
0129A0  780181     MOV W1, W3
013432  4787E4     ADD W15, #0x4, W15
013434  BE9F88     MOV.D W8, [W15++]
013436  BE9F8A     MOV.D W10, [W15++]
013438  BE9F8C     MOV.D W12, [W15++]
01343A  781F8E     MOV W14, [W15++]
01343C  780580     MOV W0, W11
01343E  784501     MOV.B W1, W10
013440  784682     MOV.B W2, W13
013442  784703     MOV.B W3, W14
013444  9FBF84     MOV W4, [W15-16]
013446  780485     MOV W5, W9
0136B0  FA0002     LNK #0x2
0136B2  BE9F88     MOV.D W8, [W15++]
0138EA  BE9F88     MOV.D W8, [W15++]
0138EC  BE9F8A     MOV.D W10, [W15++]
0138EE  780580     MOV W0, W11
0138F0  780501     MOV W1, W10
0138F2  784482     MOV.B W2, W9
0139FC  BE9F88     MOV.D W8, [W15++]
0139FE  BE9F8A     MOV.D W10, [W15++]
013A00  BE9F8C     MOV.D W12, [W15++]
013A02  780580     MOV W0, W11
013A04  780501     MOV W1, W10
013A06  784482     MOV.B W2, W9
013A08  784603     MOV.B W3, W12
013A0A  784684     MOV.B W4, W13
013BEE  BE9F88     MOV.D W8, [W15++]
013BF0  BE9F8A     MOV.D W10, [W15++]
013BF2  BE9F8C     MOV.D W12, [W15++]
013BF4  780500     MOV W0, W10
013BF6  784481     MOV.B W1, W9
013BF8  780582     MOV W2, W11
013BFA  784603     MOV.B W3, W12
013BFC  784684     MOV.B W4, W13
013E28  BE9F88     MOV.D W8, [W15++]
013E2A  780180     MOV W0, W3
013E2C  780301     MOV W1, W6
013E2E  780202     MOV W2, W4
0140A0  FA0006     LNK #0x6
0140A2  BE9F88     MOV.D W8, [W15++]
0140A4  781F8A     MOV W10, [W15++]
014168  FA0010     LNK #0x10
01416A  781F88     MOV W8, [W15++]
01416C  780400     MOV W0, W8
01428A  BE9F88     MOV.D W8, [W15++]
01428C  BE9F8A     MOV.D W10, [W15++]
01428E  780500     MOV W0, W10
014290  784481     MOV.B W1, W9
014292  780582     MOV W2, W11
0143FC  FA0010     LNK #0x10
0143FE  BE9F88     MOV.D W8, [W15++]
014400  780480     MOV W0, W9
014402  784402     MOV.B W2, W8
014456  BE9F88     MOV.D W8, [W15++]
014458  781F8A     MOV W10, [W15++]
01445A  780480     MOV W0, W9
014ADC  FA000C     LNK #0xC
014ADE  781F88     MOV W8, [W15++]
014AE0  780400     MOV W0, W8
014B26  BE9F88     MOV.D W8, [W15++]
014B28  780480     MOV W0, W9
01500C  BE9F88     MOV.D W8, [W15++]
01500E  780480     MOV W0, W9
015172  781F88     MOV W8, [W15++]
015174  784080     MOV.B W0, W1
01525A  FA0004     LNK #0x4
01525C  781F88     MOV W8, [W15++]
01525E  780400     MOV W0, W8
015292  780100     MOV W0, W2
015682  FA0004     LNK #0x4
015684  781F88     MOV W8, [W15++]
015686  780400     MOV W0, W8
015744  FA0002     LNK #0x2
015746  BE9F88     MOV.D W8, [W15++]
015748  780480     MOV W0, W9
01590C  FA0004     LNK #0x4
015936  BE9F88     MOV.D W8, [W15++]
015938  780400     MOV W0, W8
01593A  784481     MOV.B W1, W9
015B3A  BE9F88     MOV.D W8, [W15++]
015B3C  780480     MOV W0, W9
015B60  780180     MOV W0, W3
015D54  780100     MOV W0, W2
015D76  780100     MOV W0, W2
015E62  780180     MOV W0, W3
016040  780100     MOV W0, W2
016336  781F88     MOV W8, [W15++]
016338  780400     MOV W0, W8
01634C  781F88     MOV W8, [W15++]
01634E  780400     MOV W0, W8
1:                 /*
2:                  * Copyright (C) 2009-2012 by Matthias Ringwald
3:                  * 
4:                  * Redistribution and use in source and binary forms, with or without
5:                  * modification, are permitted provided that the following conditions
6:                  * are met:
7:                  *
8:                  * 1. Redistributions of source code must retain the above copyright
9:                  *    notice, this list of conditions and the following disclaimer.
10:                 * 2. Redistributions in binary form must reproduce the above copyright
11:                 *    notice, this list of conditions and the following disclaimer in the
12:                 *    documentation and/or other materials provided with the distribution.
13:                 * 3. Neither the name of the copyright holders nor the names of
14:                 *    contributors may be used to endorse or promote products derived
15:                 *    from this software without specific prior written permission.
16:                 * 4. Any redistribution, use, or modification is done solely for
17:                 *    personal benefit and not for any commercial purpose or for
18:                 *    monetary gain.
19:                 *
20:                 * THIS SOFTWARE IS PROVIDED BY MATTHIAS RINGWALD AND CONTRIBUTORS
21:                 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
22:                 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
23:                 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MATTHIAS
24:                 * RINGWALD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
25:                 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
26:                 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
27:                 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
28:                 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
29:                 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
30:                 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
31:                 * SUCH DAMAGE.
32:                 *
33:                 * Please inquire about commercial licensing options at btstack@ringwald.ch
34:                 *
35:                 */
36:                
37:                /*
38:                 *  rfcomm.c
39:                 */
40:                
41:                #include <stdio.h>
42:                #include <stdlib.h>
43:                #include <string.h> // memcpy
44:                #include <stdint.h>
45:                
46:                #include <btstack/btstack.h>
47:                #include <btstack/hci_cmds.h>
48:                #include <btstack/utils.h>
49:                
50:                #include <btstack/utils.h>
51:                #include "btstack_memory.h"
52:                #include "hci.h"
53:                #include "hci_dump.h"
54:                #include "debug.h"
55:                #include "rfcomm.h"
56:                
57:                // workaround for missing PRIxPTR on mspgcc (16/20-bit MCU)
58:                #ifndef PRIxPTR
59:                #if defined(__MSP430X__)  &&  defined(__MSP430X_LARGE__)
60:                #define PRIxPTR "lx"
61:                #else
62:                #define PRIxPTR "x"
63:                #endif
64:                #endif
65:                
66:                
67:                // Control field values      bit no.       1 2 3 4 PF 6 7 8
68:                #define BT_RFCOMM_SABM       0x3F       // 1 1 1 1  1 1 0 0
69:                #define BT_RFCOMM_UA         0x73       // 1 1 0 0  1 1 1 0
70:                #define BT_RFCOMM_DM         0x0F       // 1 1 1 1  0 0 0 0
71:                #define BT_RFCOMM_DM_PF      0x1F		// 1 1 1 1  1 0 0 0
72:                #define BT_RFCOMM_DISC       0x53       // 1 1 0 0  1 0 1 0
73:                #define BT_RFCOMM_UIH        0xEF       // 1 1 1 1  0 1 1 1
74:                #define BT_RFCOMM_UIH_PF     0xFF       // 1 1 1 1  0 1 1 1
75:                
76:                // Multiplexer message types 
77:                #define BT_RFCOMM_CLD_CMD    0xC3
78:                #define BT_RFCOMM_FCON_CMD   0xA3
79:                #define BT_RFCOMM_FCON_RSP   0xA1
80:                #define BT_RFCOMM_FCOFF_CMD  0x63
81:                #define BT_RFCOMM_FCOFF_RSP  0x61
82:                #define BT_RFCOMM_MSC_CMD    0xE3
83:                #define BT_RFCOMM_MSC_RSP    0xE1
84:                #define BT_RFCOMM_NSC_RSP    0x11
85:                #define BT_RFCOMM_PN_CMD     0x83
86:                #define BT_RFCOMM_PN_RSP     0x81
87:                #define BT_RFCOMM_RLS_CMD    0x53
88:                #define BT_RFCOMM_RLS_RSP    0x51
89:                #define BT_RFCOMM_RPN_CMD    0x93
90:                #define BT_RFCOMM_RPN_RSP    0x91
91:                #define BT_RFCOMM_TEST_CMD   0x23
92:                #define BT_RFCOMM_TEST_RSP   0x21
93:                
94:                #define RFCOMM_MULIPLEXER_TIMEOUT_MS 60000
95:                
96:                // FCS calc 
97:                #define BT_RFCOMM_CODE_WORD         0xE0 // pol = x8+x2+x1+1
98:                #define BT_RFCOMM_CRC_CHECK_LEN     3
99:                #define BT_RFCOMM_UIHCRC_CHECK_LEN  2
100:               
101:               #include "l2cap.h"
102:               
103:               // used for debugging
104:               // #define RFCOMM_LOG_CREDITS
105:               
106:               // global rfcomm data
107:               static uint16_t      rfcomm_client_cid_generator;  // used for client channel IDs
108:               
109:               // linked lists for all
110:               static linked_list_t rfcomm_multiplexers = NULL;
111:               static linked_list_t rfcomm_channels = NULL;
112:               static linked_list_t rfcomm_services = NULL;
113:               
114:               static void (*app_packet_handler)(void * connection, uint8_t packet_type,
115:                                                 uint16_t channel, uint8_t *packet, uint16_t size);
116:               
117:               static void rfcomm_run(void);
118:               static void rfcomm_hand_out_credits(void);
119:               static void rfcomm_channel_state_machine(rfcomm_channel_t *channel, rfcomm_channel_event_t *event);
120:               static void rfcomm_channel_state_machine_2(rfcomm_multiplexer_t * multiplexer, uint8_t dlci, rfcomm_channel_event_t *event);
121:               static int rfcomm_channel_ready_for_open(rfcomm_channel_t *channel);
122:               static void rfcomm_multiplexer_state_machine(rfcomm_multiplexer_t * multiplexer, RFCOMM_MULTIPLEXER_EVENT event);
123:               
124:               
125:               // MARK: RFCOMM CLIENT EVENTS
126:               
127:               // data: event (8), len(8), address(48), channel (8), rfcomm_cid (16)
128:               static void rfcomm_emit_connection_request(rfcomm_channel_t *channel) {
129:                   log_info("RFCOMM_EVENT_INCOMING_CONNECTION addr %s channel #%u cid 0x%02x",
130:                            bd_addr_to_str(channel->multiplexer->remote_addr), channel->dlci>>1, channel->rfcomm_cid);
131:                   uint8_t event[11];
132:                   event[0] = RFCOMM_EVENT_INCOMING_CONNECTION;
014AE2  B3C820     MOV #0x82, W0
014AE4  9FF7A0     MOV.B W0, [W15-14]
133:                   event[1] = sizeof(event) - 2;
014AE6  B3C090     MOV #0x9, W0
014AE8  9FF7B0     MOV.B W0, [W15-13]
134:                   bt_flip_addr(&event[2], channel->multiplexer->remote_addr);
014AEA  9000A8     MOV [W8+4], W1
014AEC  4080F1     ADD W1, #0x11, W1
014AEE  57806C     SUB W15, #0xC, W0
014AF0  02616A     CALL bt_flip_addr
014AF2  000001     NOP
135:                   event[8] = channel->dlci >> 1;
014AF4  904818     MOV.B [W8+9], W0
014AF6  FB8000     ZE W0, W0
014AF8  D10000     LSR W0, W0
014AFA  9FFFA0     MOV.B W0, [W15-6]
136:                   bt_store_16(event, 9, channel->rfcomm_cid);
014AFC  900138     MOV [W8+6], W2
014AFE  200091     MOV #0x9, W1
014B00  57806E     SUB W15, #0xE, W0
014B02  026614     CALL bt_store_16
014B04  000001     NOP
137:                   hci_dump_packet(HCI_EVENT_PACKET, 0, event, sizeof(event));
014B06  2000B3     MOV #0xB, W3
014B08  57816E     SUB W15, #0xE, W2
014B0A  EB4080     CLR.B W1
014B0C  B3C040     MOV #0x4, W0
014B0E  026798     CALL hci_dump_packet
014B10  000001     NOP
138:               	(*app_packet_handler)(channel->connection, HCI_EVENT_PACKET, 0, (uint8_t *) event, sizeof(event));
014B12  901028     MOV [W8+36], W0
014B14  2000B4     MOV #0xB, W4
014B16  5781EE     SUB W15, #0xE, W3
014B18  EB0100     CLR W2
014B1A  B3C041     MOV #0x4, W1
014B1C  8387D5     MOV app_packet_handler, W5
014B1E  010005     CALL W5
139:               }
140:               
141:               // API Change: BTstack-0.3.50x uses
142:               // data: event(8), len(8), status (8), address (48), server channel(8), rfcomm_cid(16), max frame size(16)
143:               // next Cydia release will use SVN version of this
144:               // data: event(8), len(8), status (8), address (48), handle (16), server channel(8), rfcomm_cid(16), max frame size(16)
145:               static void rfcomm_emit_channel_opened(rfcomm_channel_t *channel, uint8_t status) {
146:                   log_info("RFCOMM_EVENT_OPEN_CHANNEL_COMPLETE status 0x%x addr %s handle 0x%x channel #%u cid 0x%02x mtu %u",
147:                            status, bd_addr_to_str(channel->multiplexer->remote_addr), channel->multiplexer->con_handle,
148:                            channel->dlci>>1, channel->rfcomm_cid, channel->max_frame_size);
149:                   uint8_t event[16];
150:                   uint8_t pos = 0;
151:                   event[pos++] = RFCOMM_EVENT_OPEN_CHANNEL_COMPLETE;
01416E  B3C800     MOV #0x80, W0
014170  9FEFE0     MOV.B W0, [W15-18]
152:                   event[pos++] = sizeof(event) - 2;
014172  B3C0E0     MOV #0xE, W0
014174  9FEFF0     MOV.B W0, [W15-17]
153:                   event[pos++] = status;
014176  9FF781     MOV.B W1, [W15-16]
154:                   bt_flip_addr(&event[pos], channel->multiplexer->remote_addr); pos += 6;
014178  9000A8     MOV [W8+4], W1
01417A  4080F1     ADD W1, #0x11, W1
01417C  57806F     SUB W15, #0xF, W0
01417E  02616A     CALL bt_flip_addr
014180  000001     NOP
155:                   bt_store_16(event,  pos, channel->multiplexer->con_handle);   pos += 2;
014182  900028     MOV [W8+4], W0
014184  900940     MOV [W0+24], W2
014186  200091     MOV #0x9, W1
014188  578072     SUB W15, #0x12, W0
01418A  026614     CALL bt_store_16
01418C  000001     NOP
156:               	event[pos++] = channel->dlci >> 1;
01418E  904818     MOV.B [W8+9], W0
014190  FB8000     ZE W0, W0
014192  D10000     LSR W0, W0
014194  9FFF90     MOV.B W0, [W15-7]
157:               	bt_store_16(event, pos, channel->rfcomm_cid); pos += 2;       // channel ID
014196  900138     MOV [W8+6], W2
014198  2000C1     MOV #0xC, W1
01419A  578072     SUB W15, #0x12, W0
01419C  026614     CALL bt_store_16
01419E  000001     NOP
158:               	bt_store_16(event, pos, channel->max_frame_size); pos += 2;   // max frame size
0141A0  900938     MOV [W8+22], W2
0141A2  2000E1     MOV #0xE, W1
0141A4  578072     SUB W15, #0x12, W0
0141A6  026614     CALL bt_store_16
0141A8  000001     NOP
159:                   hci_dump_packet(HCI_EVENT_PACKET, 0, event, sizeof(event));
0141AA  200103     MOV #0x10, W3
0141AC  578172     SUB W15, #0x12, W2
0141AE  EB4080     CLR.B W1
0141B0  B3C040     MOV #0x4, W0
0141B2  026798     CALL hci_dump_packet
0141B4  000001     NOP
160:               	(*app_packet_handler)(channel->connection, HCI_EVENT_PACKET, 0, (uint8_t *) event, pos);
0141B6  901028     MOV [W8+36], W0
0141B8  200104     MOV #0x10, W4
0141BA  5781F2     SUB W15, #0x12, W3
0141BC  EB0100     CLR W2
0141BE  B3C041     MOV #0x4, W1
0141C0  8387D5     MOV app_packet_handler, W5
0141C2  010005     CALL W5
161:               }
162:               
163:               static void rfcomm_emit_channel_open_failed_outgoing_memory(void * connection, bd_addr_t *addr, uint8_t server_channel){
164:                   log_info("RFCOMM_EVENT_OPEN_CHANNEL_COMPLETE BTSTACK_MEMORY_ALLOC_FAILED addr %s",
165:                            bd_addr_to_str(*addr));
166:                   uint8_t event[16];
167:                   uint8_t pos = 0;
168:                   event[pos++] = RFCOMM_EVENT_OPEN_CHANNEL_COMPLETE;
014404  B3C800     MOV #0x80, W0
014406  9FEFC0     MOV.B W0, [W15-20]
169:                   event[pos++] = sizeof(event) - 2;
014408  B3C0E0     MOV #0xE, W0
01440A  9FEFD0     MOV.B W0, [W15-19]
170:                   event[pos++] = BTSTACK_MEMORY_ALLOC_FAILED;
01440C  B3C560     MOV #0x56, W0
01440E  9FEFE0     MOV.B W0, [W15-18]
171:                   bt_flip_addr(&event[pos], *addr); pos += 6;
014410  578071     SUB W15, #0x11, W0
014412  02616A     CALL bt_flip_addr
014414  000001     NOP
172:                   bt_store_16(event,  pos, 0);   pos += 2;
014416  EB0100     CLR W2
014418  200091     MOV #0x9, W1
01441A  578074     SUB W15, #0x14, W0
01441C  026614     CALL bt_store_16
01441E  000001     NOP
173:               	event[pos++] = server_channel;
014420  9FF7F8     MOV.B W8, [W15-9]
174:               	bt_store_16(event, pos, 0); pos += 2;   // channel ID
014422  EB0100     CLR W2
014424  2000C1     MOV #0xC, W1
014426  578074     SUB W15, #0x14, W0
014428  026614     CALL bt_store_16
01442A  000001     NOP
175:               	bt_store_16(event, pos, 0); pos += 2;   // max frame size
01442C  EB0100     CLR W2
01442E  2000E1     MOV #0xE, W1
014430  578074     SUB W15, #0x14, W0
014432  026614     CALL bt_store_16
014434  000001     NOP
176:                   hci_dump_packet(HCI_EVENT_PACKET, 0, event, sizeof(event));
014436  200103     MOV #0x10, W3
014438  578174     SUB W15, #0x14, W2
01443A  EB4080     CLR.B W1
01443C  B3C040     MOV #0x4, W0
01443E  026798     CALL hci_dump_packet
014440  000001     NOP
177:               	(*app_packet_handler)(connection, HCI_EVENT_PACKET, 0, (uint8_t *) event, pos);
014442  200104     MOV #0x10, W4
014444  5781F4     SUB W15, #0x14, W3
014446  EB0100     CLR W2
014448  B3C041     MOV #0x4, W1
01444A  780009     MOV W9, W0
01444C  8387D5     MOV app_packet_handler, W5
01444E  010005     CALL W5
178:               }
179:               
180:               // data: event(8), len(8), creidts incoming(8), new credits incoming(8), credits outgoing(8)
181:               static inline void rfcomm_emit_credit_status(rfcomm_channel_t * channel) {
182:               #ifdef RFCOMM_LOG_CREDITS
183:                   log_info("RFCOMM_LOG_CREDITS incoming %u new_incoming %u outgoing %u", channel->credits_incoming, channel->new_credits_incoming, channel->credits_outgoing);
184:                   uint8_t event[5];
185:                   event[0] = 0x88;
186:                   event[1] = sizeof(event) - 2;
187:                   event[2] = channel->credits_incoming;
188:                   event[3] = channel->new_credits_incoming;
189:                   event[4] = channel->credits_outgoing;
190:                   hci_dump_packet(HCI_EVENT_PACKET, 0, event, sizeof(event));
191:               #endif
192:               }
193:               
194:               // data: event(8), len(8), rfcomm_cid(16)
195:               static void rfcomm_emit_channel_closed(rfcomm_channel_t * channel) {
196:                   log_info("RFCOMM_EVENT_CHANNEL_CLOSED cid 0x%02x", channel->rfcomm_cid);
197:                   uint8_t event[4];
198:                   event[0] = RFCOMM_EVENT_CHANNEL_CLOSED;
015260  B3C810     MOV #0x81, W0
015262  9FFFA0     MOV.B W0, [W15-6]
199:                   event[1] = sizeof(event) - 2;
015264  B3C020     MOV #0x2, W0
015266  9FFFB0     MOV.B W0, [W15-5]
200:                   bt_store_16(event, 2, channel->rfcomm_cid);
015268  900138     MOV [W8+6], W2
01526A  200021     MOV #0x2, W1
01526C  578066     SUB W15, #0x6, W0
01526E  026614     CALL bt_store_16
015270  000001     NOP
201:                   hci_dump_packet(HCI_EVENT_PACKET, 0, event, sizeof(event));
015272  200043     MOV #0x4, W3
015274  578166     SUB W15, #0x6, W2
015276  EB4080     CLR.B W1
015278  784003     MOV.B W3, W0
01527A  026798     CALL hci_dump_packet
01527C  000001     NOP
202:               	(*app_packet_handler)(channel->connection, HCI_EVENT_PACKET, 0, (uint8_t *) event, sizeof(event));
01527E  901028     MOV [W8+36], W0
015280  200044     MOV #0x4, W4
015282  5781E6     SUB W15, #0x6, W3
015284  EB0100     CLR W2
015286  784084     MOV.B W4, W1
015288  8387D5     MOV app_packet_handler, W5
01528A  010005     CALL W5
203:               }
204:               
205:               static void rfcomm_emit_credits(rfcomm_channel_t * channel, uint8_t credits) {
206:                   log_info("RFCOMM_EVENT_CREDITS cid 0x%02x credits %u", channel->rfcomm_cid, credits);
207:                   uint8_t event[5];
208:                   event[0] = RFCOMM_EVENT_CREDITS;
0140C8  B3C840     MOV #0x84, W0
0140CA  9FF7C0     MOV.B W0, [W15-12]
209:                   event[1] = sizeof(event) - 2;
0140CC  B3C030     MOV #0x3, W0
0140CE  9FF7D0     MOV.B W0, [W15-11]
210:                   bt_store_16(event, 2, channel->rfcomm_cid);
0140D0  900139     MOV [W9+6], W2
0140D2  200021     MOV #0x2, W1
0140D4  57806C     SUB W15, #0xC, W0
0140D6  026614     CALL bt_store_16
0140D8  000001     NOP
211:                   event[4] = credits;
0140DA  9FFF88     MOV.B W8, [W15-8]
212:                   hci_dump_packet(HCI_EVENT_PACKET, 0, event, sizeof(event));
0140DC  200053     MOV #0x5, W3
0140DE  57816C     SUB W15, #0xC, W2
0140E0  78408A     MOV.B W10, W1
0140E2  B3C040     MOV #0x4, W0
0140E4  026798     CALL hci_dump_packet
0140E6  000001     NOP
213:               	(*app_packet_handler)(channel->connection, HCI_EVENT_PACKET, 0, (uint8_t *) event, sizeof(event));
0140E8  901029     MOV [W9+36], W0
0140EA  200054     MOV #0x5, W4
0140EC  5781EC     SUB W15, #0xC, W3
0140EE  EB0100     CLR W2
0140F0  B3C041     MOV #0x4, W1
0140F2  8387D5     MOV app_packet_handler, W5
0140F4  010005     CALL W5
214:               }
215:               
216:               static void rfcomm_emit_service_registered(void *connection, uint8_t status, uint8_t channel){
217:                   log_info("RFCOMM_EVENT_SERVICE_REGISTERED status 0x%x channel #%u", status, channel);
218:                   uint8_t event[4];
219:                   event[0] = RFCOMM_EVENT_SERVICE_REGISTERED;
015688  B3C850     MOV #0x85, W0
01568A  9FFFA0     MOV.B W0, [W15-6]
220:                   event[1] = sizeof(event) - 2;
01568C  B3C020     MOV #0x2, W0
01568E  9FFFB0     MOV.B W0, [W15-5]
221:                   event[2] = status;
015690  9FFFC1     MOV.B W1, [W15-4]
222:                   event[3] = channel;
015692  9FFFD2     MOV.B W2, [W15-3]
223:                   hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
015694  200043     MOV #0x4, W3
015696  578166     SUB W15, #0x6, W2
015698  EB4080     CLR.B W1
01569A  784003     MOV.B W3, W0
01569C  026798     CALL hci_dump_packet
01569E  000001     NOP
224:               	(*app_packet_handler)(connection, HCI_EVENT_PACKET, 0, (uint8_t *) event, sizeof(event));
0156A0  200044     MOV #0x4, W4
0156A2  5781E6     SUB W15, #0x6, W3
0156A4  EB0100     CLR W2
0156A6  784084     MOV.B W4, W1
0156A8  780008     MOV W8, W0
0156AA  8387D5     MOV app_packet_handler, W5
0156AC  010005     CALL W5
225:               }
226:               
227:               // MARK: RFCOMM MULTIPLEXER HELPER
228:               
229:               static uint16_t rfcomm_max_frame_size_for_l2cap_mtu(uint16_t l2cap_mtu){
230:               
231:                   // Assume RFCOMM header with credits and single byte length field
232:                   uint16_t max_frame_size = l2cap_mtu - 5;
010182  508265     SUB W1, #0x5, W4
014B4C  5000E5     SUB W0, #0x5, W1
233:                   
234:                   // single byte can denote len up to 127
235:                   if (max_frame_size > 127) {
010184  2007F0     MOV #0x7F, W0
010186  520F80     SUB W4, W0, [W15]
010188  360001     BRA LEU, 0x1018C
014B4E  2007F0     MOV #0x7F, W0
014B50  508F80     SUB W1, W0, [W15]
014B52  360001     BRA LEU, 0x14B56
236:                       max_frame_size--;
01018A  508266     SUB W1, #0x6, W4
014B54  5100E6     SUB W2, #0x6, W1
237:                   }
238:               
239:                   log_info("rfcomm_max_frame_size_for_l2cap_mtu:  %u -> %u\n", l2cap_mtu, max_frame_size);
240:                   return max_frame_size;
241:               }
242:               
243:               static void rfcomm_multiplexer_initialize(rfcomm_multiplexer_t *multiplexer){
244:               
245:                   memset(multiplexer, 0, sizeof(rfcomm_multiplexer_t));
014B34  200202     MOV #0x20, W2
014B36  EB0080     CLR W1
014B38  025720     CALL memset
014B3A  000000     NOP
246:               
247:                   multiplexer->state = RFCOMM_MULTIPLEXER_CLOSED;
014B3C  200010     MOV #0x1, W0
014B3E  980460     MOV W0, [W8+12]
248:                   multiplexer->l2cap_credits = 0;
014B40  EB4000     CLR.B W0
014B42  985400     MOV.B W0, [W8+16]
249:                   multiplexer->send_dm_for_dlci = 0;
014B44  985C60     MOV.B W0, [W8+30]
250:                   multiplexer->max_frame_size = rfcomm_max_frame_size_for_l2cap_mtu(l2cap_max_mtu());
014B46  0266B4     CALL l2cap_max_mtu
014B48  000001     NOP
014B4A  780100     MOV W0, W2
014B56  980C61     MOV W1, [W8+28]
251:               }
252:               
253:               static rfcomm_multiplexer_t * rfcomm_multiplexer_create_for_addr(bd_addr_t *addr){
254:                   
255:                   // alloc structure 
256:                   rfcomm_multiplexer_t * multiplexer = btstack_memory_rfcomm_multiplexer_get();
014B2A  0266F6     CALL btstack_memory_rfcomm_multiplexer_get
014B2C  000001     NOP
014B2E  780400     MOV W0, W8
257:                   if (!multiplexer) return NULL;
014B30  E00000     CP0 W0
014B32  32001B     BRA Z, 0x14B6A
258:                   
259:                   // fill in 
260:                   rfcomm_multiplexer_initialize(multiplexer);
261:                   BD_ADDR_COPY(&multiplexer->remote_addr, addr);
014B58  440071     ADD W8, #0x11, W0
014B5A  090005     REPEAT #0x5
014B5C  785839     MOV.B [W9++], [W0++]
014B5E  B10060     SUB #0x6, W0
014B60  B10069     SUB #0x6, W9
262:               
263:                   // add to services list
264:                   linked_list_add(&rfcomm_multiplexers, (linked_item_t *) multiplexer);
014B62  780088     MOV W8, W1
014B64  270F80     MOV #0x70F8, W0
014B66  0263E6     CALL linked_list_add
014B68  000001     NOP
265:                   
266:                   return multiplexer;
267:               }
268:               
269:               static rfcomm_multiplexer_t * rfcomm_multiplexer_for_addr(bd_addr_t *addr){
270:                   linked_item_t *it;
271:                   for (it = (linked_item_t *) rfcomm_multiplexers; it ; it = it->next){
015B3E  8387C0     MOV rfcomm_multiplexers, W0
015B40  370009     BRA 0x15B54
015B52  780018     MOV [W8], W0
015B54  E00000     CP0 W0
015B56  3AFFF5     BRA NZ, 0x15B42
015B58  780400     MOV W0, W8
272:                       rfcomm_multiplexer_t * multiplexer = ((rfcomm_multiplexer_t *) it);
015B42  780400     MOV W0, W8
273:                       if (BD_ADDR_CMP(addr, multiplexer->remote_addr) == 0) {
015B44  4000F1     ADD W0, #0x11, W1
015B46  200062     MOV #0x6, W2
015B48  780009     MOV W9, W0
015B4A  0256EC     CALL memcmp
015B4C  000000     NOP
015B4E  E00000     CP0 W0
015B50  320004     BRA Z, 0x15B5A
274:                           return multiplexer;
275:                       };
276:                   }
277:                   return NULL;
278:               }
279:               
280:               static rfcomm_multiplexer_t * rfcomm_multiplexer_for_l2cap_cid(uint16_t l2cap_cid) {
281:                   linked_item_t *it;
282:                   for (it = (linked_item_t *) rfcomm_multiplexers; it ; it = it->next){
01019A  8387C8     MOV rfcomm_multiplexers, W8
01019C  370004     BRA 0x101A6
0101A4  780418     MOV [W8], W8
0101A6  E00008     CP0 W8
0101A8  3AFFFA     BRA NZ, 0x1019E
0101AA  370064     BRA 0x10274
0101D0  8387C2     MOV rfcomm_multiplexers, W2
0101D2  370004     BRA 0x101DC
0101DA  780112     MOV [W2], W2
0101DC  E00002     CP0 W2
0101DE  3AFFFA     BRA NZ, 0x101D4
0101E0  370049     BRA 0x10274
0101F2  8387C2     MOV rfcomm_multiplexers, W2
0101F4  370005     BRA 0x10200
0101FE  780112     MOV [W2], W2
010200  E00002     CP0 W2
010202  3AFFF9     BRA NZ, 0x101F6
010204  37003C     BRA 0x1027E
01027E  8387C3     MOV rfcomm_multiplexers, W3
010280  370005     BRA 0x1028C
01028A  780193     MOV [W3], W3
01028C  E00003     CP0 W3
01028E  3AFFF9     BRA NZ, 0x10282
010290  370003     BRA 0x10298
283:                       rfcomm_multiplexer_t * multiplexer = ((rfcomm_multiplexer_t *) it);
284:                       if (multiplexer->l2cap_cid == l2cap_cid) {
01019E  900078     MOV [W8+14], W0
0101A0  500F81     SUB W0, W1, [W15]
0101A2  320004     BRA Z, 0x101AC
0101D4  900072     MOV [W2+14], W0
0101D6  500F81     SUB W0, W1, [W15]
0101D8  320004     BRA Z, 0x101E2
0101F6  900072     MOV [W2+14], W0
0101F8  97B0FF     MOV [W15-18], W1
0101FA  500F81     SUB W0, W1, [W15]
0101FC  320004     BRA Z, 0x10206
010282  900073     MOV [W3+14], W0
010284  97B17F     MOV [W15-18], W2
010286  500F82     SUB W0, W2, [W15]
010288  320004     BRA Z, 0x10292
285:                           return multiplexer;
286:                       };
287:                   }
288:                   return NULL;
289:               }
290:               
291:               #ifdef HAVE_TICK
292:               static int rfcomm_multiplexer_has_channels(rfcomm_multiplexer_t * multiplexer){
293:                   linked_item_t *it;
294:                   for (it = (linked_item_t *) rfcomm_channels; it ; it = it->next){
295:                       rfcomm_channel_t * channel = ((rfcomm_channel_t *) it);
296:                       if (channel->multiplexer == multiplexer) {
297:                           return 1;
298:                       }
299:                   }
300:                   return 0;
301:               }
302:               #endif
303:               
304:               // MARK: RFCOMM CHANNEL HELPER
305:               
306:               static void rfcomm_dump_channels(void){
307:               #ifndef EMBEDDED
308:                   linked_item_t * it;
309:                   int channels = 0;
310:                   for (it = (linked_item_t *) rfcomm_channels; it ; it = it->next){
311:                       rfcomm_channel_t * channel = (rfcomm_channel_t *) it;
312:                       log_info("Channel #%u: addr %p, state %u\n", channels, channel, channel->state);
313:                       channels++;
314:                   }
315:               #endif
316:               }
317:               
318:               static void rfcomm_channel_initialize(rfcomm_channel_t *channel, rfcomm_multiplexer_t *multiplexer, 
319:                                              rfcomm_service_t *service, uint8_t server_channel){
320:                   
321:                   // don't use 0 as channel id
322:                   if (rfcomm_client_cid_generator == 0) ++rfcomm_client_cid_generator;
0138FE  8387E0     MOV rfcomm_client_cid_generator, W0
013900  E00000     CP0 W0
013902  3A0002     BRA NZ, 0x13908
013904  200010     MOV #0x1, W0
013906  8B87E0     MOV W0, rfcomm_client_cid_generator
013908  FB8489     ZE W9, W9
323:                   
324:                   // setup channel
325:                   memset(channel, 0, sizeof(rfcomm_channel_t));
01390A  200262     MOV #0x26, W2
01390C  EB0080     CLR W1
01390E  780008     MOV W8, W0
013910  025720     CALL memset
013912  000000     NOP
326:                   
327:                   channel->state             = RFCOMM_CHANNEL_CLOSED;
013914  200012     MOV #0x1, W2
013916  980C02     MOV W2, [W8+16]
328:                   channel->state_var         = RFCOMM_CHANNEL_STATE_VAR_NONE;
013918  EB0080     CLR W1
01391A  980C11     MOV W1, [W8+18]
329:                   
330:                   channel->multiplexer      = multiplexer;
01391C  98042B     MOV W11, [W8+4]
331:                   channel->service          = service;
01391E  98140A     MOV W10, [W8+32]
332:                   channel->rfcomm_cid       = rfcomm_client_cid_generator++;
013920  8387E0     MOV rfcomm_client_cid_generator, W0
013922  980430     MOV W0, [W8+6]
013924  E80000     INC W0, W0
013926  8B87E0     MOV W0, rfcomm_client_cid_generator
333:                   channel->max_frame_size   = multiplexer->max_frame_size;
013928  90086B     MOV [W11+28], W0
01392A  980C30     MOV W0, [W8+22]
334:               
335:                   channel->credits_incoming = 0;
01392C  984C51     MOV.B W1, [W8+13]
336:                   channel->credits_outgoing = 0;
01392E  984C31     MOV.B W1, [W8+11]
337:                   channel->packets_granted  = 0;
013930  984C21     MOV.B W1, [W8+10]
338:               
339:                   // incoming flow control not active
340:                   channel->new_credits_incoming  = 0x30;
013932  B3C300     MOV #0x30, W0
013934  984C40     MOV.B W0, [W8+12]
341:                   channel->incoming_flow_control = 0;
013936  984C61     MOV.B W1, [W8+14]
342:                   
343:               	if (service) {
013938  E0000A     CP0 W10
01393A  32000F     BRA Z, 0x1395A
344:               		// incoming connection
345:               		channel->outgoing = 0;
01393C  984C01     MOV.B W1, [W8+8]
346:               		channel->dlci = (server_channel << 1) |  multiplexer->outgoing;
01393E  448009     ADD W9, W9, W0
013940  9058AB     MOV.B [W11+26], W1
013942  70C080     IOR.B W1, W0, W1
013944  984C11     MOV.B W1, [W8+9]
347:                       if (channel->max_frame_size > service->max_frame_size) {
013946  9000BA     MOV [W10+6], W1
013948  900838     MOV [W8+22], W0
01394A  500F81     SUB W0, W1, [W15]
01394C  360001     BRA LEU, 0x13950
348:                           channel->max_frame_size = service->max_frame_size;
01394E  980C31     MOV W1, [W8+22]
349:                       }
350:                       channel->incoming_flow_control = service->incoming_flow_control;
013950  90480A     MOV.B [W10+8], W0
013952  984C60     MOV.B W0, [W8+14]
351:                       channel->new_credits_incoming  = service->incoming_initial_credits;
013954  904D1A     MOV.B [W10+9], W10
013956  984C4A     MOV.B W10, [W8+12]
013958  370006     BRA 0x13966
352:               	} else {
353:               		// outgoing connection
354:               		channel->outgoing = 1;
01395A  984C02     MOV.B W2, [W8+8]
355:               		channel->dlci = (server_channel << 1) | (multiplexer->outgoing ^ 1);
01395C  448089     ADD W9, W9, W1
01395E  90582B     MOV.B [W11+26], W0
013960  A20400     BTG.B W0, #0
013962  704001     IOR.B W0, W1, W0
013964  984C10     MOV.B W0, [W8+9]
356:               	}
357:               }
358:               
359:               // service == NULL -> outgoing channel
360:               static rfcomm_channel_t * rfcomm_channel_create(rfcomm_multiplexer_t * multiplexer,
361:                                                               rfcomm_service_t * service, uint8_t server_channel){
362:               
363:                   log_info("rfcomm_channel_create for service %p, channel %u --- list of channels:\n", service, server_channel);
364:                   rfcomm_dump_channels();
365:               
366:                   // alloc structure 
367:                   rfcomm_channel_t * channel = btstack_memory_rfcomm_channel_get();
0138F4  026702     CALL btstack_memory_rfcomm_channel_get
0138F6  000001     NOP
0138F8  780400     MOV W0, W8
368:                   if (!channel) return NULL;
0138FA  E00000     CP0 W0
0138FC  320038     BRA Z, 0x1396E
369:                   
370:                   // fill in 
371:                   rfcomm_channel_initialize(channel, multiplexer, service, server_channel);
372:                   
373:                   // add to services list
374:                   linked_list_add(&rfcomm_channels, (linked_item_t *) channel);
013966  780088     MOV W8, W1
013968  270F60     MOV #0x70F6, W0
01396A  0263E6     CALL linked_list_add
01396C  000001     NOP
375:                   
376:                   return channel;
377:               }
378:               
379:               static rfcomm_channel_t * rfcomm_channel_for_rfcomm_cid(uint16_t rfcomm_cid){
380:                   linked_item_t *it;
381:                   for (it = (linked_item_t *) rfcomm_channels; it ; it = it->next){
013E30  8387B8     MOV rfcomm_channels, W8
013E32  370004     BRA 0x13E3C
013E3A  780418     MOV [W8], W8
013E3C  E00008     CP0 W8
013E3E  3AFFFA     BRA NZ, 0x13E34
013E40  780488     MOV W8, W9
013E42  370025     BRA 0x13E8E
015294  8387B1     MOV rfcomm_channels, W1
015296  370004     BRA 0x152A0
01529E  780091     MOV [W1], W1
0152A0  E00001     CP0 W1
0152A2  3AFFFA     BRA NZ, 0x15298
0152A4  060000     RETURN
015588  8387B1     MOV rfcomm_channels, W1
01558A  370004     BRA 0x15594
015592  780091     MOV [W1], W1
015594  E00001     CP0 W1
015596  3AFFFA     BRA NZ, 0x1558C
015598  37000D     BRA 0x155B4
015B62  8387B2     MOV rfcomm_channels, W2
015B64  370004     BRA 0x15B6E
015B6C  780112     MOV [W2], W2
015B6E  E00002     CP0 W2
015B70  3AFFFA     BRA NZ, 0x15B66
015B72  060000     RETURN
015D78  8387B1     MOV rfcomm_channels, W1
015D7A  370004     BRA 0x15D84
015D82  780091     MOV [W1], W1
015D84  E00001     CP0 W1
015D86  3AFFFA     BRA NZ, 0x15D7C
015D88  060000     RETURN
016042  8387B1     MOV rfcomm_channels, W1
016044  370004     BRA 0x1604E
01604C  780091     MOV [W1], W1
01604E  E00001     CP0 W1
016050  3AFFFA     BRA NZ, 0x16046
016052  370002     BRA 0x16058
382:                       rfcomm_channel_t * channel = ((rfcomm_channel_t *) it);
383:                       if (channel->rfcomm_cid == rfcomm_cid) {
013E34  900038     MOV [W8+6], W0
013E36  500F83     SUB W0, W3, [W15]
013E38  320005     BRA Z, 0x13E44
015298  900031     MOV [W1+6], W0
01529A  500F82     SUB W0, W2, [W15]
01529C  320004     BRA Z, 0x152A6
01558C  900031     MOV [W1+6], W0
01558E  500F82     SUB W0, W2, [W15]
015590  320004     BRA Z, 0x1559A
015B66  900032     MOV [W2+6], W0
015B68  500F83     SUB W0, W3, [W15]
015B6A  320004     BRA Z, 0x15B74
015D7C  900031     MOV [W1+6], W0
015D7E  500F82     SUB W0, W2, [W15]
015D80  320004     BRA Z, 0x15D8A
016046  900031     MOV [W1+6], W0
016048  500F82     SUB W0, W2, [W15]
01604A  320004     BRA Z, 0x16054
384:                           return channel;
385:                       };
386:                   }
387:                   return NULL;
388:               }
389:               
390:               static rfcomm_channel_t * rfcomm_channel_for_multiplexer_and_dlci(rfcomm_multiplexer_t * multiplexer, uint8_t dlci){
391:                   linked_item_t *it;
392:                   for (it = (linked_item_t *) rfcomm_channels; it ; it = it->next){
015E64  8387B0     MOV rfcomm_channels, W0
015E66  370008     BRA 0x15E78
015E76  780012     MOV [W2], W0
015E78  E00000     CP0 W0
015E7A  3AFFF6     BRA NZ, 0x15E68
015E7C  780100     MOV W0, W2
393:                       rfcomm_channel_t * channel = ((rfcomm_channel_t *) it);
015E68  780100     MOV W0, W2
394:                       if (channel->dlci == dlci && channel->multiplexer == multiplexer) {
015E6A  904810     MOV.B [W0+9], W0
015E6C  504F81     SUB.B W0, W1, [W15]
015E6E  3A0003     BRA NZ, 0x15E76
015E70  900022     MOV [W2+4], W0
015E72  500F83     SUB W0, W3, [W15]
015E74  320004     BRA Z, 0x15E7E
395:                           return channel;
396:                       };
397:                   }
398:                   return NULL;
399:               }
400:               
401:               static rfcomm_service_t * rfcomm_service_for_channel(uint8_t server_channel){
402:                   linked_item_t *it;
403:                   for (it = (linked_item_t *) rfcomm_services; it ; it = it->next){
013BFE  8387A1     MOV rfcomm_services, W1
013C00  370004     BRA 0x13C0A
013C08  780091     MOV [W1], W1
013C0A  E00001     CP0 W1
013C0C  3AFFFA     BRA NZ, 0x13C02
013C0E  37001D     BRA 0x13C4A
0142A0  8387A8     MOV rfcomm_services, W8
0142A2  370004     BRA 0x142AC
0142AA  780418     MOV [W8], W8
0142AC  E00008     CP0 W8
0142AE  3AFFFA     BRA NZ, 0x142A4
0142B0  370017     BRA 0x142E0
015176  8387A8     MOV rfcomm_services, W8
015178  370004     BRA 0x15182
015180  780418     MOV [W8], W8
015182  E00008     CP0 W8
015184  3AFFFA     BRA NZ, 0x1517A
015186  370010     BRA 0x151A8
404:                       rfcomm_service_t * service = ((rfcomm_service_t *) it);
405:                       if ( service->server_channel == server_channel){
013C02  904041     MOV.B [W1+4], W0
013C04  504F89     SUB.B W0, W9, [W15]
013C06  320004     BRA Z, 0x13C10
0142A4  904048     MOV.B [W8+4], W0
0142A6  504F82     SUB.B W0, W2, [W15]
0142A8  320004     BRA Z, 0x142B2
01517A  904048     MOV.B [W8+4], W0
01517C  504F81     SUB.B W0, W1, [W15]
01517E  320004     BRA Z, 0x15188
406:                           return service;
407:                       };
408:                   }
409:                   return NULL;
410:               }
411:               
412:               // MARK: RFCOMM SEND
413:               
414:               /**
415:                * @param credits - only used for RFCOMM flow control in UIH wiht P/F = 1
416:                */
417:               static int rfcomm_send_packet_for_multiplexer(rfcomm_multiplexer_t *multiplexer, uint8_t address, uint8_t control, uint8_t credits, uint8_t *data, uint16_t len){
418:               
419:                   if (!l2cap_can_send_packet_now(multiplexer->l2cap_cid)) return BTSTACK_ACL_BUFFERS_FULL;
013448  900070     MOV [W0+14], W0
01344A  025DFE     CALL l2cap_can_send_packet_now
01344C  000001     NOP
01344E  200571     MOV #0x57, W1
013450  E00000     CP0 W0
013452  32003B     BRA Z, 0x134CA
420:                   
421:                   uint8_t * rfcomm_out_buffer = l2cap_get_outgoing_buffer();
013454  0266AC     CALL l2cap_get_outgoing_buffer
013456  000001     NOP
013458  780400     MOV W0, W8
422:                   
423:               	uint16_t pos = 0;
424:               	uint8_t crc_fields = 3;
425:               	
426:               	rfcomm_out_buffer[pos++] = address;
01345A  78480A     MOV.B W10, [W0]
427:               	rfcomm_out_buffer[pos++] = control;
01345C  98401D     MOV.B W13, [W0+1]
428:               	
429:               	// length field can be 1 or 2 octets
430:               	if (len < 128){
01345E  2007F0     MOV #0x7F, W0
013460  548F80     SUB W9, W0, [W15]
013462  3E0005     BRA GTU, 0x1346E
431:               		rfcomm_out_buffer[pos++] = (len << 1)| 1;     // bits 0-6
013464  44C009     ADD.B W9, W9, W0
013466  A00400     BSET.B W0, #0
013468  984420     MOV.B W0, [W8+2]
01346A  20003A     MOV #0x3, W10
01346C  370005     BRA 0x13478
432:               	} else {
433:               		rfcomm_out_buffer[pos++] = (len & 0x7f) << 1; // bits 0-6
01346E  D04009     SL.B W9, W0
013470  984420     MOV.B W0, [W8+2]
434:               		rfcomm_out_buffer[pos++] = len >> 7;          // bits 7-14
013472  DE4847     LSR W9, #7, W0
013474  984430     MOV.B W0, [W8+3]
013476  20004A     MOV #0x4, W10
013478  78460A     MOV.B W10, W12
435:               		crc_fields++;
436:               	}
437:               
438:               	// add credits for UIH frames when PF bit is set
439:               	if (control == BT_RFCOMM_UIH_PF){
01347A  46CFE1     ADD.B W13, #0x1, [W15]
01347C  3A0002     BRA NZ, 0x13482
440:               		rfcomm_out_buffer[pos++] = credits;
01347E  7D740E     MOV.B W14, [W8+W10]
013480  E8050A     INC W10, W10
441:               	}
442:               	
443:               	// copy actual data
444:               	if (len) {
013482  E00009     CP0 W9
013484  320006     BRA Z, 0x13492
445:               		memcpy(&rfcomm_out_buffer[pos], data, len);
013486  44000A     ADD W8, W10, W0
013488  780109     MOV W9, W2
01348A  97B88F     MOV [W15-16], W1
01348C  0256DE     CALL memcpy
01348E  000000     NOP
446:               		pos += len;
013490  450509     ADD W10, W9, W10
447:               	}
448:               	
449:               	// UIH frames only calc FCS over address + control (5.1.1)
450:               	if ((control & 0xef) == BT_RFCOMM_UIH){
013492  78008D     MOV W13, W1
013494  B20EF1     AND #0xEF, W1
013496  200EF0     MOV #0xEF, W0
013498  508F80     SUB W1, W0, [W15]
01349A  3A0001     BRA NZ, 0x1349E
01349C  B3C02C     MOV #0x2, W12
451:               		crc_fields = 2;
452:               	}
453:               	rfcomm_out_buffer[pos++] =  crc8_calc(rfcomm_out_buffer, crc_fields); // calc fcs
01349E  FB808C     ZE W12, W1
0134A0  780008     MOV W8, W0
0134A2  026628     CALL crc8_calc
0134A4  000001     NOP
0134A6  7D7400     MOV.B W0, [W8+W10]
0134A8  E8008A     INC W10, W1
454:               
455:                   int credits_taken = 0;
456:                   if (multiplexer->l2cap_credits){
0134AA  90500B     MOV.B [W11+16], W0
0134AC  EB0400     CLR W8
0134AE  E00400     CP0.B W0
0134B0  320003     BRA Z, 0x134B8
457:                       credits_taken++;
458:                       multiplexer->l2cap_credits--;
0134B2  E94000     DEC.B W0, W0
0134B4  985580     MOV.B W0, [W11+16]
0134B6  200018     MOV #0x1, W8
459:                   } else {
460:                       log_info( "rfcomm_send_packet addr %02x, ctrl %02x size %u without l2cap credits\n", address, control, pos);
461:                   }
462:                   
463:                   int err = l2cap_send_prepared(multiplexer->l2cap_cid, pos);
0134B8  90007B     MOV [W11+14], W0
0134BA  023B76     CALL l2cap_send_prepared
0134BC  000001     NOP
0134BE  780080     MOV W0, W1
464:                   
465:                   if (err) {
0134C0  E00000     CP0 W0
0134C2  320003     BRA Z, 0x134CA
466:                       // undo credit counting
467:                       multiplexer->l2cap_credits += credits_taken;
0134C4  90500B     MOV.B [W11+16], W0
0134C6  404008     ADD.B W0, W8, W0
0134C8  985580     MOV.B W0, [W11+16]
468:                   }
469:                   return err;
470:               }
471:               
472:               // C/R Flag in Address
473:               // - terms: initiator = station that creates multiplexer with SABM
474:               // - terms: responder = station that responds to multiplexer setup with UA
475:               // "For SABM, UA, DM and DISC frames C/R bit is set according to Table 1 in GSM 07.10, section 5.2.1.2"
476:               //    - command initiator = 1 /response responder = 1
477:               //    - command responder = 0 /response initiator = 0
478:               // "For UIH frames, the C/R bit is always set according to section 5.4.3.1 in GSM 07.10. 
479:               //  This applies independently of what is contained wthin the UIH frames, either data or control messages."
480:               //    - c/r = 1 for frames by initiating station, 0 = for frames by responding station
481:               
482:               // C/R Flag in Message
483:               // "In the message level, the C/R bit in the command type field is set as stated in section 5.4.6.2 in GSM 07.10." 
484:               //   - If the C/R bit is set to 1 the message is a command
485:               //   - if it is set to 0 the message is a response.
486:               
487:               // temp/old messge construction
488:               
489:               // new object oriented version
490:               static int rfcomm_send_sabm(rfcomm_multiplexer_t *multiplexer, uint8_t dlci){
491:               	uint8_t address = (1 << 0) | (multiplexer->outgoing << 1) | (dlci << 2);   // command
492:                   return rfcomm_send_packet_for_multiplexer(multiplexer, address, BT_RFCOMM_SABM, 0, NULL, 0);
016320  905920     MOV.B [W0+26], W2
016322  D04102     SL.B W2, W2
016324  DD08C2     SL W1, #2, W1
016326  70C082     IOR.B W1, W2, W1
016328  A00401     BSET.B W1, #0
01632A  EB0280     CLR W5
01632C  780205     MOV W5, W4
01632E  784185     MOV.B W5, W3
016330  B3C3F2     MOV #0x3F, W2
016332  043432     GOTO rfcomm_send_packet_for_multiplexer
016334  000001     NOP
493:               }
494:               
495:               static int rfcomm_send_disc(rfcomm_multiplexer_t *multiplexer, uint8_t dlci){
496:               	uint8_t address = (1 << 0) | (multiplexer->outgoing << 1) | (dlci << 2);  // command
497:                   return rfcomm_send_packet_for_multiplexer(multiplexer, address, BT_RFCOMM_DISC, 0, NULL, 0);
00FC80  905826     MOV.B [W6+26], W0
00FC82  D04000     SL.B W0, W0
00FC84  904898     MOV.B [W8+9], W1
00FC86  DD08C2     SL W1, #2, W1
00FC88  70C080     IOR.B W1, W0, W1
00FC8A  A00401     BSET.B W1, #0
00FC8C  EB0280     CLR W5
00FC8E  780205     MOV W5, W4
00FC90  784185     MOV.B W5, W3
00FC92  B3C532     MOV #0x53, W2
00FC94  780006     MOV W6, W0
00FC96  023432     CALL rfcomm_send_packet_for_multiplexer
00FC98  000001     NOP
498:               }
499:               
500:               static int rfcomm_send_ua(rfcomm_multiplexer_t *multiplexer, uint8_t dlci){
501:               	uint8_t address = (1 << 0) | ((multiplexer->outgoing ^ 1) << 1) | (dlci << 2); // response
502:                   return rfcomm_send_packet_for_multiplexer(multiplexer, address, BT_RFCOMM_UA, 0, NULL, 0);
01626A  905920     MOV.B [W0+26], W2
01626C  A20402     BTG.B W2, #0
01626E  D04102     SL.B W2, W2
016270  DD08C2     SL W1, #2, W1
016272  70C082     IOR.B W1, W2, W1
016274  A00401     BSET.B W1, #0
016276  EB0280     CLR W5
016278  780205     MOV W5, W4
01627A  784185     MOV.B W5, W3
01627C  B3C732     MOV #0x73, W2
01627E  043432     GOTO rfcomm_send_packet_for_multiplexer
016280  000001     NOP
503:               }
504:               
505:               static int rfcomm_send_dm_pf(rfcomm_multiplexer_t *multiplexer, uint8_t dlci){
506:               	uint8_t address = (1 << 0) | ((multiplexer->outgoing ^ 1) << 1) | (dlci << 2); // response
507:                   return rfcomm_send_packet_for_multiplexer(multiplexer, address, BT_RFCOMM_DM_PF, 0, NULL, 0);
016282  905920     MOV.B [W0+26], W2
016284  A20402     BTG.B W2, #0
016286  D04102     SL.B W2, W2
016288  DD08C2     SL W1, #2, W1
01628A  70C082     IOR.B W1, W2, W1
01628C  A00401     BSET.B W1, #0
01628E  EB0280     CLR W5
016290  780205     MOV W5, W4
016292  784185     MOV.B W5, W3
016294  B3C1F2     MOV #0x1F, W2
016296  043432     GOTO rfcomm_send_packet_for_multiplexer
016298  000001     NOP
508:               }
509:               
510:               static int rfcomm_send_uih_msc_cmd(rfcomm_multiplexer_t *multiplexer, uint8_t dlci, uint8_t signals) {
511:               	uint8_t address = (1 << 0) | (multiplexer->outgoing << 1);
00FB9A  9058A6     MOV.B [W6+26], W1
00FB9C  D04081     SL.B W1, W1
00FB9E  A00401     BSET.B W1, #0
512:               	uint8_t payload[4]; 
513:               	uint8_t pos = 0;
514:               	payload[pos++] = BT_RFCOMM_MSC_CMD;
00FBA0  578277     SUB W15, #0x17, W4
00FBA2  B3CE30     MOV #0xE3, W0
00FBA4  784A00     MOV.B W0, [W4]
515:               	payload[pos++] = 2 << 1 | 1;  // len
00FBA6  B3C050     MOV #0x5, W0
00FBA8  984210     MOV.B W0, [W4+1]
516:               	payload[pos++] = (1 << 0) | (1 << 1) | (dlci << 2); // CMD => C/R = 1
00FBAA  DD1142     SL W2, #2, W2
00FBAC  B34032     IOR.B #0x3, W2
00FBAE  9FEFB2     MOV.B W2, [W15-21]
517:               	payload[pos++] = signals;
00FBB0  B3C8D0     MOV #0x8D, W0
00FBB2  9FEFC0     MOV.B W0, [W15-20]
518:               	return rfcomm_send_packet_for_multiplexer(multiplexer, address, BT_RFCOMM_UIH, 0, (uint8_t *) payload, pos);
00FBB4  200045     MOV #0x4, W5
00FBB6  EB4180     CLR.B W3
00FBB8  B3CEF2     MOV #0xEF, W2
00FBBA  780006     MOV W6, W0
00FBBC  023432     CALL rfcomm_send_packet_for_multiplexer
00FBBE  000001     NOP
00FBC0  370019     BRA 0xFBF4
519:               }
520:               
521:               static int rfcomm_send_uih_msc_rsp(rfcomm_multiplexer_t *multiplexer, uint8_t dlci, uint8_t signals) {
522:               	uint8_t address = (1 << 0) | (multiplexer->outgoing<< 1);
01590E  9059A0     MOV.B [W0+26], W3
015910  D04303     SL.B W3, W6
015912  A00406     BSET.B W6, #0
523:               	uint8_t payload[4]; 
524:               	uint8_t pos = 0;
525:               	payload[pos++] = BT_RFCOMM_MSC_RSP;
015914  B3CE13     MOV #0xE1, W3
015916  9FFFC3     MOV.B W3, [W15-4]
526:               	payload[pos++] = 2 << 1 | 1;  // len
015918  B3C053     MOV #0x5, W3
01591A  9FFFD3     MOV.B W3, [W15-3]
527:               	payload[pos++] = (1 << 0) | (1 << 1) | (dlci << 2); // CMD => C/R = 1
01591C  DD08C2     SL W1, #2, W1
01591E  B34031     IOR.B #0x3, W1
015920  9FFFE1     MOV.B W1, [W15-2]
528:               	payload[pos++] = signals;
015922  9FFFF2     MOV.B W2, [W15-1]
529:               	return rfcomm_send_packet_for_multiplexer(multiplexer, address, BT_RFCOMM_UIH, 0, (uint8_t *) payload, pos);
015924  200045     MOV #0x4, W5
015926  578264     SUB W15, #0x4, W4
015928  EB4180     CLR.B W3
01592A  B3CEF2     MOV #0xEF, W2
01592C  784086     MOV.B W6, W1
01592E  023432     CALL rfcomm_send_packet_for_multiplexer
015930  000001     NOP
530:               }
531:               
532:               static int rfcomm_send_uih_pn_command(rfcomm_multiplexer_t *multiplexer, uint8_t dlci, uint16_t max_frame_size){
533:               	uint8_t payload[10];
534:               	uint8_t address = (1 << 0) | (multiplexer->outgoing << 1); 
00FB06  9058A6     MOV.B [W6+26], W1
00FB08  D04081     SL.B W1, W1
00FB0A  A00401     BSET.B W1, #0
535:               	uint8_t pos = 0;
536:               	payload[pos++] = BT_RFCOMM_PN_CMD;
00FB0C  57826C     SUB W15, #0xC, W4
00FB0E  B3C830     MOV #0x83, W0
00FB10  784A00     MOV.B W0, [W4]
537:               	payload[pos++] = 8 << 1 | 1;  // len
00FB12  B3C110     MOV #0x11, W0
00FB14  9FF7D0     MOV.B W0, [W15-11]
538:               	payload[pos++] = dlci;
00FB16  9FF7E3     MOV.B W3, [W15-10]
539:               	payload[pos++] = 0xf0; // pre-defined for Bluetooth, see 5.5.3 of TS 07.10 Adaption for RFCOMM
00FB18  B3CF00     MOV #0xF0, W0
00FB1A  9FF7F0     MOV.B W0, [W15-9]
540:               	payload[pos++] = 0; // priority
00FB1C  EB4180     CLR.B W3
00FB1E  9FFF83     MOV.B W3, [W15-8]
541:               	payload[pos++] = 0; // max 60 seconds ack
00FB20  9FFF93     MOV.B W3, [W15-7]
542:               	payload[pos++] = max_frame_size & 0xff; // max framesize low
00FB22  9FFFA2     MOV.B W2, [W15-6]
543:               	payload[pos++] = max_frame_size >> 8;   // max framesize high
00FB24  DE1148     LSR W2, #8, W2
00FB26  9FFFB2     MOV.B W2, [W15-5]
544:               	payload[pos++] = 0x00; // number of retransmissions
00FB28  9FFFC3     MOV.B W3, [W15-4]
545:               	payload[pos++] = 0x00; // (unused error recovery window) initial number of credits
00FB2A  9FFFD3     MOV.B W3, [W15-3]
546:               	return rfcomm_send_packet_for_multiplexer(multiplexer, address, BT_RFCOMM_UIH, 0, (uint8_t *) payload, pos);
00FB2C  2000A5     MOV #0xA, W5
00FB2E  B3CEF2     MOV #0xEF, W2
00FB30  780006     MOV W6, W0
00FB32  023432     CALL rfcomm_send_packet_for_multiplexer
00FB34  000001     NOP
00FB36  3700CE     BRA 0xFCD4
547:               }
548:               
549:               // "The response may not change the DLCI, the priority, the convergence layer, or the timer value." RFCOMM-tutorial.pdf
550:               static int rfcomm_send_uih_pn_response(rfcomm_multiplexer_t *multiplexer, uint8_t dlci,
551:                                                      uint8_t priority, uint16_t max_frame_size){
552:               	uint8_t payload[10];
553:               	uint8_t address = (1 << 0) | (multiplexer->outgoing << 1); 
00FA9A  9058A6     MOV.B [W6+26], W1
00FA9C  D04081     SL.B W1, W1
00FA9E  A00401     BSET.B W1, #0
554:               	uint8_t pos = 0;
555:               	payload[pos++] = BT_RFCOMM_PN_RSP;
00FAA0  57826C     SUB W15, #0xC, W4
00FAA2  B3C810     MOV #0x81, W0
00FAA4  784A00     MOV.B W0, [W4]
556:               	payload[pos++] = 8 << 1 | 1;  // len
00FAA6  B3C110     MOV #0x11, W0
00FAA8  9FF7D0     MOV.B W0, [W15-11]
557:               	payload[pos++] = dlci;
00FAAA  9FF7E3     MOV.B W3, [W15-10]
558:               	payload[pos++] = 0xe0; // pre defined for Bluetooth, see 5.5.3 of TS 07.10 Adaption for RFCOMM
00FAAC  B3CE00     MOV #0xE0, W0
00FAAE  9FF7F0     MOV.B W0, [W15-9]
559:               	payload[pos++] = priority; // priority
00FAB0  9FFF85     MOV.B W5, [W15-8]
560:               	payload[pos++] = 0; // max 60 seconds ack
00FAB2  EB4180     CLR.B W3
00FAB4  9FFF93     MOV.B W3, [W15-7]
561:               	payload[pos++] = max_frame_size & 0xff; // max framesize low
00FAB6  9FFFA2     MOV.B W2, [W15-6]
562:               	payload[pos++] = max_frame_size >> 8;   // max framesize high
00FAB8  DE1148     LSR W2, #8, W2
00FABA  9FFFB2     MOV.B W2, [W15-5]
563:               	payload[pos++] = 0x00; // number of retransmissions
00FABC  9FFFC3     MOV.B W3, [W15-4]
564:               	payload[pos++] = 0x00; // (unused error recovery window) initial number of credits
00FABE  9FFFD3     MOV.B W3, [W15-3]
565:               	return rfcomm_send_packet_for_multiplexer(multiplexer, address, BT_RFCOMM_UIH, 0, (uint8_t *) payload, pos);
00FAC0  2000A5     MOV #0xA, W5
00FAC2  B3CEF2     MOV #0xEF, W2
00FAC4  780006     MOV W6, W0
00FAC6  023432     CALL rfcomm_send_packet_for_multiplexer
00FAC8  000001     NOP
00FACA  370008     BRA 0xFADC
566:               }
567:               
568:               static int rfcomm_send_uih_rpn_rsp(rfcomm_multiplexer_t *multiplexer, uint8_t dlci, rfcomm_rpn_data_t *rpn_data) {
569:               	uint8_t payload[10];
570:               	uint8_t address = (1 << 0) | (multiplexer->outgoing << 1); 
00F9CA  9058A6     MOV.B [W6+26], W1
00F9CC  D04081     SL.B W1, W1
00F9CE  A00401     BSET.B W1, #0
571:               	uint8_t pos = 0;
572:               	payload[pos++] = BT_RFCOMM_RPN_RSP;
00F9D0  57826C     SUB W15, #0xC, W4
00F9D2  B3C910     MOV #0x91, W0
00F9D4  784A00     MOV.B W0, [W4]
573:               	payload[pos++] = 8 << 1 | 1;  // len
00F9D6  B3C110     MOV #0x11, W0
00F9D8  9FF7D0     MOV.B W0, [W15-11]
574:               	payload[pos++] = (1 << 0) | (1 << 1) | (dlci << 2); // CMD => C/R = 1
00F9DA  DD19C2     SL W3, #2, W3
00F9DC  B34033     IOR.B #0x3, W3
00F9DE  9FF7E3     MOV.B W3, [W15-10]
575:               	payload[pos++] = rpn_data->baud_rate;
00F9E0  784012     MOV.B [W2], W0
00F9E2  9FF7F0     MOV.B W0, [W15-9]
576:               	payload[pos++] = rpn_data->flags;
00F9E4  904012     MOV.B [W2+1], W0
00F9E6  9FFF80     MOV.B W0, [W15-8]
577:               	payload[pos++] = rpn_data->flow_control;
00F9E8  904022     MOV.B [W2+2], W0
00F9EA  9FFF90     MOV.B W0, [W15-7]
578:               	payload[pos++] = rpn_data->xon;
00F9EC  904032     MOV.B [W2+3], W0
00F9EE  9FFFA0     MOV.B W0, [W15-6]
579:               	payload[pos++] = rpn_data->xoff;
00F9F0  904042     MOV.B [W2+4], W0
00F9F2  9FFFB0     MOV.B W0, [W15-5]
580:               	payload[pos++] = rpn_data->parameter_mask_0;
00F9F4  904052     MOV.B [W2+5], W0
00F9F6  9FFFC0     MOV.B W0, [W15-4]
581:               	payload[pos++] = rpn_data->parameter_mask_1;
00F9F8  904162     MOV.B [W2+6], W2
00F9FA  9FFFD2     MOV.B W2, [W15-3]
582:               	return rfcomm_send_packet_for_multiplexer(multiplexer, address, BT_RFCOMM_UIH, 0, (uint8_t *) payload, pos);
00F9FC  2000A5     MOV #0xA, W5
00F9FE  EB4180     CLR.B W3
00FA00  370096     BRA 0xFB2E
583:               }
584:               
585:               static int rfcomm_send_uih_data(rfcomm_multiplexer_t *multiplexer, uint8_t dlci, uint8_t *data, uint16_t len){
586:               	uint8_t address = (1 << 0) | (multiplexer->outgoing << 1) | (dlci << 2); 
587:                   return rfcomm_send_packet_for_multiplexer(multiplexer, address, BT_RFCOMM_UIH, 0, data, len);
013E5A  905920     MOV.B [W0+26], W2
013E5C  D04102     SL.B W2, W2
013E5E  904898     MOV.B [W8+9], W1
013E60  DD08C2     SL W1, #2, W1
013E62  70C082     IOR.B W1, W2, W1
013E64  A00401     BSET.B W1, #0
013E66  780284     MOV W4, W5
013E68  780206     MOV W6, W4
013E6A  EB4180     CLR.B W3
013E6C  B3CEF2     MOV #0xEF, W2
013E6E  023432     CALL rfcomm_send_packet_for_multiplexer
013E70  000001     NOP
013E72  780480     MOV W0, W9
588:               }
589:               
590:               static void rfcomm_send_uih_credits(rfcomm_multiplexer_t *multiplexer, uint8_t dlci,  uint8_t credits){
591:                   uint8_t address = (1 << 0) | (multiplexer->outgoing << 1) |  (dlci << 2); 
592:                   rfcomm_send_packet_for_multiplexer(multiplexer, address, BT_RFCOMM_UIH_PF, credits, NULL, 0);
01593E  905920     MOV.B [W0+26], W2
015940  D04102     SL.B W2, W2
015942  904898     MOV.B [W8+9], W1
015944  DD08C2     SL W1, #2, W1
015946  70C082     IOR.B W1, W2, W1
015948  A00401     BSET.B W1, #0
01594A  EB0280     CLR W5
01594C  780205     MOV W5, W4
01594E  784189     MOV.B W9, W3
015950  EBC100     SETM.B W2
015952  023432     CALL rfcomm_send_packet_for_multiplexer
015954  000001     NOP
593:               }
594:               
595:               // MARK: RFCOMM MULTIPLEXER
596:               static void rfcomm_multiplexer_stop_timer(rfcomm_multiplexer_t * multiplexer){
597:                   if (multiplexer->timer_active) {
010122  900050     MOV [W0+10], W0
010124  E00000     CP0 W0
010126  320002     BRA Z, 0x1012C
01445C  900050     MOV [W0+10], W0
01445E  E00000     CP0 W0
014460  320002     BRA Z, 0x14466
598:                       run_loop_remove_timer(&multiplexer->timer);
599:                       multiplexer->timer_active = 0;
010128  EB0000     CLR W0
01012A  980550     MOV W0, [W10+10]
014462  EB0000     CLR W0
014464  9804D0     MOV W0, [W9+10]
600:                   }
601:               }
602:               static void rfcomm_multiplexer_free(rfcomm_multiplexer_t * multiplexer){
603:                   linked_list_remove( &rfcomm_multiplexers, (linked_item_t *) multiplexer);
01633A  780080     MOV W0, W1
01633C  270F80     MOV #0x70F8, W0
01633E  0263FC     CALL linked_list_remove
016340  000001     NOP
604:                   btstack_memory_rfcomm_multiplexer_free(multiplexer);
016342  780008     MOV W8, W0
016344  02668C     CALL btstack_memory_rfcomm_multiplexer_free
016346  000001     NOP
605:               }
606:               
607:               static void rfcomm_multiplexer_finalize(rfcomm_multiplexer_t * multiplexer){
608:                   
609:                   // remove (potential) timer
610:                   rfcomm_multiplexer_stop_timer(multiplexer);
611:                   
612:                   // close and remove all channels
613:                   linked_item_t *it = (linked_item_t *) &rfcomm_channels;
014466  270F6A     MOV #0x70F6, W10
014468  370015     BRA 0x14494
614:                   while (it->next){
014494  78041A     MOV [W10], W8
014496  E00008     CP0 W8
014498  3AFFE8     BRA NZ, 0x1446A
615:                       rfcomm_channel_t * channel = (rfcomm_channel_t *) it->next;
616:                       if (channel->multiplexer == multiplexer) {
01446A  900028     MOV [W8+4], W0
01446C  500F89     SUB W0, W9, [W15]
01446E  320002     BRA Z, 0x14474
014470  780508     MOV W8, W10
014472  370010     BRA 0x14494
617:                           // emit appropriate events
618:                           if (channel->state == RFCOMM_CHANNEL_OPEN) {
014474  900808     MOV [W8+16], W0
014476  500FE9     SUB W0, #0x9, [W15]
014478  3A0004     BRA NZ, 0x14482
619:                               rfcomm_emit_channel_closed(channel);
01447A  780008     MOV W8, W0
01447C  02525A     CALL rfcomm_emit_channel_closed
01447E  000001     NOP
014480  370004     BRA 0x1448A
620:                           } else {
621:                               rfcomm_emit_channel_opened(channel, RFCOMM_MULTIPLEXER_STOPPED); 
014482  B3C701     MOV #0x70, W1
014484  780008     MOV W8, W0
014486  024168     CALL rfcomm_emit_channel_opened
014488  000001     NOP
622:                           }
623:                           // remove from list
624:                           it->next = it->next->next;
01448A  78001A     MOV [W10], W0
01448C  780D10     MOV [W0], [W10]
625:                           // free channel struct
626:                           btstack_memory_rfcomm_channel_free(channel);
01448E  780008     MOV W8, W0
014490  02669C     CALL btstack_memory_rfcomm_channel_free
014492  000001     NOP
627:                       } else {
628:                           it = it->next;
629:                       }
630:                   }
631:                   
632:                   // keep reference to l2cap channel
633:                   uint16_t l2cap_cid = multiplexer->l2cap_cid;
01449A  900479     MOV [W9+14], W8
634:                   
635:                   // remove mutliplexer
636:                   rfcomm_multiplexer_free(multiplexer);
01449C  780009     MOV W9, W0
01449E  026336     CALL rfcomm_multiplexer_free
0144A0  000001     NOP
637:                   
638:                   // close l2cap multiplexer channel, too
639:                   l2cap_disconnect_internal(l2cap_cid, 0x13);
0144A2  B3C131     MOV #0x13, W1
0144A4  780008     MOV W8, W0
0144A6  026078     CALL l2cap_disconnect_internal
0144A8  000001     NOP
640:               }
641:               
642:               #ifdef HAVE_TICK
643:               static void rfcomm_multiplexer_timer_handler(timer_source_t *timer){
644:                   rfcomm_multiplexer_t * multiplexer = (rfcomm_multiplexer_t *) linked_item_get_user( (linked_item_t *) timer);
645:                   if (!rfcomm_multiplexer_has_channels(multiplexer)){
646:                       log_info( "rfcomm_multiplexer_timer_handler timeout: shutting down multiplexer!\n");
647:                       rfcomm_multiplexer_finalize(multiplexer);
648:                   }
649:               }
650:               #endif
651:               
652:               static void rfcomm_multiplexer_prepare_idle_timer(rfcomm_multiplexer_t * multiplexer){
653:               #ifdef HAVE_TICK
654:                   if (multiplexer->timer_active) {
655:                       run_loop_remove_timer(&multiplexer->timer);
656:                       multiplexer->timer_active = 0;
657:                   }
658:                   if (!rfcomm_multiplexer_has_channels(multiplexer)){
659:                       // start timer for multiplexer timeout check
660:                       run_loop_set_timer(&multiplexer->timer, RFCOMM_MULIPLEXER_TIMEOUT_MS);
661:                       multiplexer->timer.process = rfcomm_multiplexer_timer_handler;
662:                       linked_item_set_user((linked_item_t*) &multiplexer->timer, multiplexer);
663:                       run_loop_add_timer(&multiplexer->timer);
664:                       multiplexer->timer_active = 1;
665:                   }
666:               #endif
667:               }
668:               
669:               static void rfcomm_multiplexer_opened(rfcomm_multiplexer_t *multiplexer){
670:                   log_info("Multiplexer up and running\n");
671:                   multiplexer->state = RFCOMM_MULTIPLEXER_OPEN;
01574A  200070     MOV #0x7, W0
01574C  9804E0     MOV W0, [W9+12]
672:                   
673:                   rfcomm_channel_event_t event = { CH_EVT_MULTIPLEXER_READY };
01574E  2000C0     MOV #0xC, W0
015750  9FBFD0     MOV W0, [W15-6]
674:                   
675:                   // transition of channels that wait for multiplexer 
676:                   linked_item_t *it;
677:                   for (it = (linked_item_t *) rfcomm_channels; it ; it = it->next){
015752  8387B8     MOV rfcomm_channels, W8
015754  370008     BRA 0x15766
015764  780418     MOV [W8], W8
015766  E00008     CP0 W8
015768  3AFFF6     BRA NZ, 0x15756
678:                       rfcomm_channel_t * channel = ((rfcomm_channel_t *) it);
679:                       if (channel->multiplexer != multiplexer) continue;
015756  900028     MOV [W8+4], W0
015758  500F89     SUB W0, W9, [W15]
01575A  3A0004     BRA NZ, 0x15764
680:                       rfcomm_channel_state_machine(channel, &event);
01575C  5780E6     SUB W15, #0x6, W1
01575E  780008     MOV W8, W0
015760  02F956     CALL rfcomm_channel_state_machine
015762  000000     NOP
681:                   }        
682:                   
683:                   rfcomm_run();
01576A  0236B0     CALL rfcomm_run
01576C  000001     NOP
684:                   rfcomm_multiplexer_prepare_idle_timer(multiplexer);
685:               }
686:               
687:               
688:               /**
689:                * @return handled packet
690:                */
691:               static int rfcomm_multiplexer_hci_event_handler(uint8_t *packet, uint16_t size){
692:                   bd_addr_t event_addr;
693:                   uint16_t  psm;
694:                   uint16_t l2cap_cid;
695:                   hci_con_handle_t con_handle;
696:                   rfcomm_multiplexer_t *multiplexer = NULL;
697:                   uint8_t status;
698:                   
699:                   switch (packet[0]) {
010060  784092     MOV.B [W2], W1
010062  B3C710     MOV #0x71, W0
010064  50CF80     SUB.B W1, W0, [W15]
010066  3200AF     BRA Z, 0x101C6
010068  3E0007     BRA GTU, 0x10078
01006A  50407D     SUB.B W0, #0x1D, W0
01006C  50CF80     SUB.B W1, W0, [W15]
01006E  3200A8     BRA Z, 0x101C0
010070  40407C     ADD.B W0, #0x1C, W0
010072  50CF80     SUB.B W1, W0, [W15]
010074  3A00FF     BRA NZ, 0x10274
010076  370035     BRA 0x100E2
010078  B3C720     MOV #0x72, W0
01007A  50CF80     SUB.B W1, W0, [W15]
01007C  320004     BRA Z, 0x10086
01007E  E8C000     INC2.B W0, W0
010080  50CF80     SUB.B W1, W0, [W15]
010082  3A00F8     BRA NZ, 0x10274
010084  370085     BRA 0x10190
700:                           
701:                       // accept incoming PSM_RFCOMM connection if no multiplexer exists yet
702:                       case L2CAP_EVENT_INCOMING_CONNECTION:
703:                           // data: event(8), len(8), address(48), handle (16),  psm (16), source cid(16) dest cid(16)
704:                           bt_flip_addr(event_addr, &packet[2]);
010086  E88082     INC2 W2, W1
010088  57857A     SUB W15, #0x1A, W10
01008A  78000A     MOV W10, W0
01008C  02616A     CALL bt_flip_addr
01008E  000001     NOP
705:                           con_handle = READ_BT_16(packet,  8);
010090  904889     MOV.B [W9+8], W1
010092  FB8081     ZE W1, W1
010094  904819     MOV.B [W9+9], W0
010096  DD0048     SL W0, #8, W0
010098  708580     IOR W1, W0, W11
706:                           psm        = READ_BT_16(packet, 10); 
707:                           l2cap_cid  = READ_BT_16(packet, 12); 
01009A  9048C9     MOV.B [W9+12], W1
01009C  FB8081     ZE W1, W1
01009E  904859     MOV.B [W9+13], W0
0100A0  DD0048     SL W0, #8, W0
0100A2  708400     IOR W1, W0, W8
708:               
709:                           if (psm != PSM_RFCOMM) break;
0100A4  9048A9     MOV.B [W9+10], W1
0100A6  FB8081     ZE W1, W1
0100A8  904839     MOV.B [W9+11], W0
0100AA  DD0048     SL W0, #8, W0
0100AC  708080     IOR W1, W0, W1
0100AE  508FE3     SUB W1, #0x3, [W15]
0100B0  3A00E1     BRA NZ, 0x10274
710:               
711:                           multiplexer = rfcomm_multiplexer_for_addr(&event_addr);
0100B2  78000A     MOV W10, W0
0100B4  025B3A     CALL rfcomm_multiplexer_for_addr
0100B6  000001     NOP
712:                           
713:                           if (multiplexer) {
0100B8  E00000     CP0 W0
0100BA  3A0006     BRA NZ, 0x100C8
714:                               log_info("INCOMING_CONNECTION (l2cap_cid 0x%02x) for PSM_RFCOMM => decline - multiplexer already exists", l2cap_cid);
715:                               l2cap_decline_connection_internal(l2cap_cid,  0x04);    // no resources available
716:                               return 1;
717:                           }
718:                           
719:                           // create and inititialize new multiplexer instance (incoming)
720:                           multiplexer = rfcomm_multiplexer_create_for_addr(&event_addr);
0100BC  78000A     MOV W10, W0
0100BE  024B26     CALL rfcomm_multiplexer_create_for_addr
0100C0  000001     NOP
0100C2  780080     MOV W0, W1
721:                           if (!multiplexer){
0100C4  E00000     CP0 W0
0100C6  3A0005     BRA NZ, 0x100D2
722:                               log_info("INCOMING_CONNECTION (l2cap_cid 0x%02x) for PSM_RFCOMM => decline - no memory left", l2cap_cid);
723:                               l2cap_decline_connection_internal(l2cap_cid,  0x04);    // no resources available
0100C8  78408C     MOV.B W12, W1
0100CA  780008     MOV W8, W0
0100CC  025F78     CALL l2cap_decline_connection_internal
0100CE  000001     NOP
0100D0  370137     BRA 0x10340
724:                               return 1;
725:                           }
726:                           
727:                           multiplexer->con_handle = con_handle;
0100D2  98084B     MOV W11, [W0+24]
728:                           multiplexer->l2cap_cid = l2cap_cid;
0100D4  980078     MOV W8, [W0+14]
729:                           multiplexer->state = RFCOMM_MULTIPLEXER_W4_SABM_0;
0100D6  200050     MOV #0x5, W0
0100D8  9800E0     MOV W0, [W1+12]
730:                           
731:                           log_info("L2CAP_EVENT_INCOMING_CONNECTION (l2cap_cid 0x%02x) for PSM_RFCOMM => accept", l2cap_cid);
732:                           l2cap_accept_connection_internal(l2cap_cid);
0100DA  780008     MOV W8, W0
0100DC  02605C     CALL l2cap_accept_connection_internal
0100DE  000001     NOP
0100E0  37012F     BRA 0x10340
733:                           return 1;
734:                           
735:                       // l2cap connection opened -> store l2cap_cid, remote_addr
736:                       case L2CAP_EVENT_CHANNEL_OPENED: 
737:               
738:                           if (READ_BT_16(packet, 11) != PSM_RFCOMM) break;
0100E2  9048B2     MOV.B [W2+11], W1
0100E4  FB8081     ZE W1, W1
0100E6  904842     MOV.B [W2+12], W0
0100E8  DD0048     SL W0, #8, W0
0100EA  708680     IOR W1, W0, W13
0100EC  568FE3     SUB W13, #0x3, [W15]
0100EE  3A00C2     BRA NZ, 0x10274
739:                           
740:                           status = packet[2];
0100F0  904722     MOV.B [W2+2], W14
741:                           log_info("L2CAP_EVENT_CHANNEL_OPENED for PSM_RFCOMM, status %u\n", status);
742:                           
743:                           // get multiplexer for remote addr
744:                           con_handle = READ_BT_16(packet, 9);
0100F2  904892     MOV.B [W2+9], W1
0100F4  FB8081     ZE W1, W1
0100F6  904822     MOV.B [W2+10], W0
0100F8  DD0048     SL W0, #8, W0
0100FA  708080     IOR W1, W0, W1
0100FC  9FB7E1     MOV W1, [W15-20]
745:                           l2cap_cid = READ_BT_16(packet, 13);
0100FE  9048D2     MOV.B [W2+13], W1
010100  FB8081     ZE W1, W1
010102  904862     MOV.B [W2+14], W0
010104  DD0048     SL W0, #8, W0
010106  708580     IOR W1, W0, W11
746:                           bt_flip_addr(event_addr, &packet[3]);
010108  4100E3     ADD W2, #0x3, W1
01010A  57847A     SUB W15, #0x1A, W8
01010C  780008     MOV W8, W0
01010E  02616A     CALL bt_flip_addr
010110  000001     NOP
747:                           multiplexer = rfcomm_multiplexer_for_addr(&event_addr);
010112  780008     MOV W8, W0
010114  025B3A     CALL rfcomm_multiplexer_for_addr
010116  000001     NOP
010118  780500     MOV W0, W10
748:                           if (!multiplexer) {
01011A  E00000     CP0 W0
01011C  320111     BRA Z, 0x10340
749:                               log_error("L2CAP_EVENT_CHANNEL_OPENED but no multiplexer prepared\n");
750:                               return 1;
751:                           }
752:                           
753:                           // on l2cap open error discard everything
754:                           if (status){
01011E  E0040E     CP0.B W14
010120  32001C     BRA Z, 0x1015A
755:               
756:                               // remove (potential) timer
757:                               rfcomm_multiplexer_stop_timer(multiplexer);
758:               
759:                               // emit rfcomm_channel_opened with status and free channel
760:                               linked_item_t * it = (linked_item_t *) &rfcomm_channels;
01012C  270F69     MOV #0x70F6, W9
01012E  37000E     BRA 0x1014C
761:                               while (it->next) {
01014C  780419     MOV [W9], W8
01014E  E00008     CP0 W8
010150  3AFFEF     BRA NZ, 0x10130
762:                                   rfcomm_channel_t * channel = (rfcomm_channel_t *) it->next;
763:                                   if (channel->multiplexer == multiplexer){
010130  900028     MOV [W8+4], W0
010132  500F8A     SUB W0, W10, [W15]
010134  320002     BRA Z, 0x1013A
010136  780488     MOV W8, W9
010138  370009     BRA 0x1014C
764:                                       rfcomm_emit_channel_opened(channel, status);
01013A  78408E     MOV.B W14, W1
01013C  780008     MOV W8, W0
01013E  024168     CALL rfcomm_emit_channel_opened
010140  000001     NOP
765:                                       it->next = it->next->next;
010142  780019     MOV [W9], W0
010144  780C90     MOV [W0], [W9]
766:                                       btstack_memory_rfcomm_channel_free(channel);
010146  780008     MOV W8, W0
010148  02669C     CALL btstack_memory_rfcomm_channel_free
01014A  000001     NOP
767:                                   } else {
768:                                       it = it->next;
769:                                   }
770:                               }
771:               
772:                               // free multiplexer
773:                               rfcomm_multiplexer_free(multiplexer);
010152  78000A     MOV W10, W0
010154  026336     CALL rfcomm_multiplexer_free
010156  000001     NOP
010158  3700F3     BRA 0x10340
774:                               return 1;
775:                           }
776:                           
777:                           if (multiplexer->state == RFCOMM_MULTIPLEXER_W4_CONNECT) {
01015A  900060     MOV [W0+12], W0
01015C  500FE2     SUB W0, #0x2, [W15]
01015E  3A000C     BRA NZ, 0x10178
778:                               log_info("L2CAP_EVENT_CHANNEL_OPENED: outgoing connection\n");
779:                               // wrong remote addr
780:                               if (BD_ADDR_CMP(event_addr, multiplexer->remote_addr)) break;
010160  4500F1     ADD W10, #0x11, W1
010162  200062     MOV #0x6, W2
010164  780008     MOV W8, W0
010166  0256EC     CALL memcmp
010168  000000     NOP
01016A  E00000     CP0 W0
01016C  3A0083     BRA NZ, 0x10274
781:                               multiplexer->l2cap_cid = l2cap_cid;
01016E  98057B     MOV W11, [W10+14]
782:                               multiplexer->con_handle = con_handle;
010170  97B06F     MOV [W15-20], W0
010172  980D40     MOV W0, [W10+24]
783:                               // send SABM #0
784:                               multiplexer->state = RFCOMM_MULTIPLEXER_SEND_SABM_0;
010174  98056D     MOV W13, [W10+12]
010176  3700E4     BRA 0x10340
785:                           } else { // multiplexer->state == RFCOMM_MULTIPLEXER_W4_SABM_0
786:                               
787:                               // set max frame size based on l2cap MTU
788:                               multiplexer->max_frame_size = rfcomm_max_frame_size_for_l2cap_mtu(READ_BT_16(packet, 17));
010178  905019     MOV.B [W9+17], W0
01017A  FB8000     ZE W0, W0
01017C  9050A9     MOV.B [W9+18], W1
01017E  DD08C8     SL W1, #8, W1
010180  700081     IOR W0, W1, W1
01018C  980D64     MOV W4, [W10+28]
01018E  3700D8     BRA 0x10340
789:                           }
790:                           return 1;
791:                           
792:                           // l2cap disconnect -> state = RFCOMM_MULTIPLEXER_CLOSED;
793:                           
794:                       case L2CAP_EVENT_CREDITS:
795:                           // data: event(8), len(8), local_cid(16), credits(8)
796:                           l2cap_cid = READ_BT_16(packet, 2);
010190  9040A2     MOV.B [W2+2], W1
010192  FB8081     ZE W1, W1
010194  904032     MOV.B [W2+3], W0
010196  DD0048     SL W0, #8, W0
010198  708080     IOR W1, W0, W1
797:                           multiplexer = rfcomm_multiplexer_for_l2cap_cid(l2cap_cid);
798:                           if (!multiplexer) break;
799:                           multiplexer->l2cap_credits += packet[4];
0101AC  905008     MOV.B [W8+16], W0
0101AE  9040C9     MOV.B [W9+4], W1
0101B0  404001     ADD.B W0, W1, W0
0101B2  985400     MOV.B W0, [W8+16]
800:                           
801:                           // log_info("L2CAP_EVENT_CREDITS: %u (now %u)\n", packet[4], multiplexer->l2cap_credits);
802:               
803:                           // new credits, continue with signaling
804:                           rfcomm_run();
0101B4  0236B0     CALL rfcomm_run
0101B6  000001     NOP
805:                           
806:                           if (multiplexer->state != RFCOMM_MULTIPLEXER_OPEN) break;
0101B8  900068     MOV [W8+12], W0
0101BA  500FE7     SUB W0, #0x7, [W15]
0101BC  3A005B     BRA NZ, 0x10274
0101BE  3700B7     BRA 0x1032E
807:                           rfcomm_hand_out_credits();
808:                           return 1;
809:                       
810:                       case DAEMON_EVENT_HCI_PACKET_SENT:
811:                           // testing DMA done code
812:                           rfcomm_run();
0101C0  0236B0     CALL rfcomm_run
0101C2  000001     NOP
0101C4  370057     BRA 0x10274
813:                           break;
814:                           
815:                       case L2CAP_EVENT_CHANNEL_CLOSED:
816:                           // data: event (8), len(8), channel (16)
817:                           l2cap_cid = READ_BT_16(packet, 2);
0101C6  9040A2     MOV.B [W2+2], W1
0101C8  FB8081     ZE W1, W1
0101CA  904032     MOV.B [W2+3], W0
0101CC  DD0048     SL W0, #8, W0
0101CE  708080     IOR W1, W0, W1
818:                           multiplexer = rfcomm_multiplexer_for_l2cap_cid(l2cap_cid);
819:                           if (!multiplexer) break;
820:                           switch (multiplexer->state) {
0101E2  9000E2     MOV [W2+12], W1
0101E4  508FE7     SUB W1, #0x7, [W15]
0101E6  3E0046     BRA GTU, 0x10274
0101E8  200010     MOV #0x1, W0
0101EA  DD0001     SL W0, W1, W0
0101EC  B20B00     AND #0xB0, W0
0101EE  320042     BRA Z, 0x10274
0101F0  37003D     BRA 0x1026C
821:                               case RFCOMM_MULTIPLEXER_W4_SABM_0:
822:                               case RFCOMM_MULTIPLEXER_W4_UA_0:
823:                               case RFCOMM_MULTIPLEXER_OPEN:
824:                                   rfcomm_multiplexer_finalize(multiplexer);
825:                                   return 1;
826:                               default:
827:                                   break;
828:                           }
829:                           break;
830:                       default:
831:                           break;
832:                   }
833:                   return 0;
834:               }
835:               
836:               static int rfcomm_multiplexer_l2cap_packet_handler(uint16_t channel, uint8_t *packet, uint16_t size){
837:                   
838:                   // get or create a multiplexer for a certain device
839:                   rfcomm_multiplexer_t *multiplexer = rfcomm_multiplexer_for_l2cap_cid(channel);
840:                   if (!multiplexer) return 0;
841:                   
842:               	// but only care for multiplexer control channel
843:                   uint8_t frame_dlci = packet[0] >> 2;
844:                   if (frame_dlci) return 0;
010206  FB8019     ZE [W9], W0
010208  DE0242     LSR W0, #2, W4
01020A  E00404     CP0.B W4
01020C  3A0038     BRA NZ, 0x1027E
845:                   const uint8_t length_offset = (packet[2] & 1) ^ 1;  // to be used for pos >= 3
846:                   const uint8_t credit_offset = ((packet[1] & BT_RFCOMM_UIH_PF) == BT_RFCOMM_UIH_PF) ? 1 : 0;   // credits for uih_pf frames
01020E  904099     MOV.B [W9+1], W1
847:                   const uint8_t payload_offset = 3 + length_offset + credit_offset;
010210  904029     MOV.B [W9+2], W0
010212  604061     AND.B W0, #0x1, W0
010214  A20400     BTG.B W0, #0
010216  784184     MOV.B W4, W3
010218  40CFE1     ADD.B W1, #0x1, [W15]
01021A  3A0001     BRA NZ, 0x1021E
01021C  B3C013     MOV #0x1, W3
01021E  404003     ADD.B W0, W3, W0
010220  4041E3     ADD.B W0, #0x3, W3
848:                   switch (packet[1]){
010222  B3C530     MOV #0x53, W0
010224  50CF80     SUB.B W1, W0, [W15]
010226  32001A     BRA Z, 0x1025C
010228  3E0006     BRA GTU, 0x10236
01022A  50CFEF     SUB.B W1, #0xF, [W15]
01022C  32001F     BRA Z, 0x1026C
01022E  504074     SUB.B W0, #0x14, W0
010230  50CF80     SUB.B W1, W0, [W15]
010232  3A0025     BRA NZ, 0x1027E
010234  370006     BRA 0x10242
010236  B3C730     MOV #0x73, W0
010238  50CF80     SUB.B W1, W0, [W15]
01023A  320009     BRA Z, 0x1024E
01023C  40CFF1     ADD.B W1, #0x11, [W15]
01023E  3A001F     BRA NZ, 0x1027E
010240  370010     BRA 0x10262
849:                           
850:                       case BT_RFCOMM_SABM:
851:                           if (multiplexer->state == RFCOMM_MULTIPLEXER_W4_SABM_0){
010242  900062     MOV [W2+12], W0
010244  500FE5     SUB W0, #0x5, [W15]
010246  3A001B     BRA NZ, 0x1027E
852:                               log_info("Received SABM #0\n");
853:                               multiplexer->outgoing = 0;
010248  985924     MOV.B W4, [W2+26]
854:                               multiplexer->state = RFCOMM_MULTIPLEXER_SEND_UA_0;
01024A  200060     MOV #0x6, W0
01024C  370008     BRA 0x1025E
855:                               return 1;
856:                           }
857:                           break;
858:                           
859:                       case BT_RFCOMM_UA:
860:                           if (multiplexer->state == RFCOMM_MULTIPLEXER_W4_UA_0) {
01024E  900062     MOV [W2+12], W0
010250  500FE4     SUB W0, #0x4, [W15]
010252  3A0015     BRA NZ, 0x1027E
861:                               // UA #0 -> send UA #0, state = RFCOMM_MULTIPLEXER_OPEN
862:                               log_info("Received UA #0 \n");
863:                               rfcomm_multiplexer_opened(multiplexer);
010254  780002     MOV W2, W0
010256  025744     CALL rfcomm_multiplexer_opened
010258  000001     NOP
01025A  370072     BRA 0x10340
864:                               return 1;
865:                           }
866:                           break;
867:                           
868:                       case BT_RFCOMM_DISC:
869:                           // DISC #0 -> send UA #0, close multiplexer
870:                           log_info("Received DISC #0, (ougoing = %u)\n", multiplexer->outgoing);
871:                           multiplexer->state = RFCOMM_MULTIPLEXER_SEND_UA_0_AND_DISC;
01025C  200080     MOV #0x8, W0
01025E  980160     MOV W0, [W2+12]
010260  37006F     BRA 0x10340
872:                           return 1;
873:                           
874:                       case BT_RFCOMM_DM:
875:                           // DM #0 - we shouldn't get this, just give up
876:                           log_info("Received DM #0\n");
877:                           log_info("-> Closing down multiplexer\n");
878:                           rfcomm_multiplexer_finalize(multiplexer);
879:                           return 1;
880:                           
881:                       case BT_RFCOMM_UIH:
882:                           if (packet[payload_offset] == BT_RFCOMM_CLD_CMD){
010262  FB8003     ZE W3, W0
010264  7840E9     MOV.B [W9+W0], W1
010266  B3CC30     MOV #0xC3, W0
010268  50CF80     SUB.B W1, W0, [W15]
01026A  3A0009     BRA NZ, 0x1027E
883:                               // Multiplexer close down (CLD) -> close mutliplexer
884:                               log_info("Received Multiplexer close down command\n");
885:                               log_info("-> Closing down multiplexer\n");
886:                               rfcomm_multiplexer_finalize(multiplexer);
01026C  780002     MOV W2, W0
01026E  024456     CALL rfcomm_multiplexer_finalize
010270  000001     NOP
010272  370066     BRA 0x10340
887:                               return 1;
888:                           }
889:                           break;
890:                           
891:                       default:
892:                           break;
893:                           
894:                   }
895:                   return 0;
896:               }
897:               
898:               static void rfcomm_multiplexer_state_machine(rfcomm_multiplexer_t * multiplexer, RFCOMM_MULTIPLEXER_EVENT event){
899:                   
900:                   // process stored DM responses
901:                   if (multiplexer->send_dm_for_dlci){
0136C4  9058E8     MOV.B [W8+30], W1
0136C6  E00401     CP0.B W1
0136C8  320005     BRA Z, 0x136D4
902:                       rfcomm_send_dm_pf(multiplexer, multiplexer->send_dm_for_dlci);
0136CA  780008     MOV W8, W0
0136CC  026282     CALL rfcomm_send_dm_pf
0136CE  000001     NOP
903:                       multiplexer->send_dm_for_dlci = 0;
0136D0  EB4000     CLR.B W0
0136D2  985C60     MOV.B W0, [W8+30]
904:                   }
905:               
906:                   switch (multiplexer->state) {
0136D4  900068     MOV [W8+12], W0
0136D6  500FE6     SUB W0, #0x6, [W15]
0136D8  32000B     BRA Z, 0x136F0
0136DA  500FE8     SUB W0, #0x8, [W15]
0136DC  320013     BRA Z, 0x13704
0136DE  500FE3     SUB W0, #0x3, [W15]
0136E0  3A001A     BRA NZ, 0x13716
907:                       case RFCOMM_MULTIPLEXER_SEND_SABM_0:
908:                           switch (event) {
909:                               case MULT_EV_READY_TO_SEND:
910:                                   log_info("Sending SABM #0 - (multi 0x%p)\n", multiplexer);
911:                                   multiplexer->state = RFCOMM_MULTIPLEXER_W4_UA_0;
0136E2  200040     MOV #0x4, W0
0136E4  980460     MOV W0, [W8+12]
912:                                   rfcomm_send_sabm(multiplexer, 0);
0136E6  EB4080     CLR.B W1
0136E8  780008     MOV W8, W0
0136EA  026320     CALL rfcomm_send_sabm
0136EC  000001     NOP
0136EE  370013     BRA 0x13716
913:                                   break;
914:                               default:
915:                                   break;
916:                           }
917:                           break;
918:                       case RFCOMM_MULTIPLEXER_SEND_UA_0:
919:                           switch (event) {
920:                               case MULT_EV_READY_TO_SEND:
921:                                   log_info("Sending UA #0\n");
922:                                   multiplexer->state = RFCOMM_MULTIPLEXER_OPEN;
0136F0  200070     MOV #0x7, W0
0136F2  980460     MOV W0, [W8+12]
923:                                   rfcomm_send_ua(multiplexer, 0);
0136F4  EB4080     CLR.B W1
0136F6  780008     MOV W8, W0
0136F8  02626A     CALL rfcomm_send_ua
0136FA  000001     NOP
924:                                   rfcomm_multiplexer_opened(multiplexer);
0136FC  780008     MOV W8, W0
0136FE  025744     CALL rfcomm_multiplexer_opened
013700  000001     NOP
013702  370009     BRA 0x13716
925:                                   break;
926:                               default:
927:                                   break;
928:                           }
929:                           break;
930:                       case RFCOMM_MULTIPLEXER_SEND_UA_0_AND_DISC:
931:                           switch (event) {
932:                               case MULT_EV_READY_TO_SEND:
933:                                   log_info("Sending UA #0\n");
934:                                   log_info("Closing down multiplexer\n");
935:                                   multiplexer->state = RFCOMM_MULTIPLEXER_CLOSED;
013704  200010     MOV #0x1, W0
013706  980460     MOV W0, [W8+12]
936:                                   rfcomm_send_ua(multiplexer, 0);
013708  EB4080     CLR.B W1
01370A  780008     MOV W8, W0
01370C  02626A     CALL rfcomm_send_ua
01370E  000001     NOP
937:                                   rfcomm_multiplexer_finalize(multiplexer);
013710  780008     MOV W8, W0
013712  024456     CALL rfcomm_multiplexer_finalize
013714  000001     NOP
013716  780409     MOV W9, W8
938:                                   // try to detect authentication errors: drop link key if multiplexer closed before first channel got opened
939:                                   if (!multiplexer->at_least_one_connection){
940:                                       log_info("TODO: no connections established - delete link key prophylactically\n");
941:                                       // hci_send_cmd(&hci_delete_stored_link_key, multiplexer->remote_addr);
942:                                   }
943:                               default:
944:                                   break;
945:                           }
946:                           break;
947:                       default:
948:                           break;
949:                   }
950:               }
951:               
952:               // MARK: RFCOMM CHANNEL
953:               
954:               static void rfcomm_hand_out_credits(void){
955:                   linked_item_t * it;
956:                   for (it = (linked_item_t *) rfcomm_channels; it ; it = it->next){
0140A6  8387B9     MOV rfcomm_channels, W9
0140A8  370027     BRA 0x140F8
0140F6  780499     MOV [W9], W9
0140F8  E00009     CP0 W9
0140FA  3AFFD7     BRA NZ, 0x140AA
957:                       rfcomm_channel_t * channel = (rfcomm_channel_t *) it;
958:                       if (channel->state != RFCOMM_CHANNEL_OPEN) {
0140AA  900809     MOV [W9+16], W0
0140AC  500FE9     SUB W0, #0x9, [W15]
0140AE  3A0023     BRA NZ, 0x140F6
959:                           // log_info("RFCOMM_EVENT_CREDITS: multiplexer not open\n");
960:                           continue;
961:                       }
962:                       if (channel->packets_granted) {
0140B0  904D29     MOV.B [W9+10], W10
0140B2  E0040A     CP0.B W10
0140B4  3A0020     BRA NZ, 0x140F6
963:                           // log_info("RFCOMM_EVENT_CREDITS: already packets granted\n");
964:                           continue;
965:                       }
966:                       if (!channel->credits_outgoing) {
0140B6  904839     MOV.B [W9+11], W0
0140B8  E00400     CP0.B W0
0140BA  32001D     BRA Z, 0x140F6
967:                           // log_info("RFCOMM_EVENT_CREDITS: no outgoing credits\n");
968:                           continue;
969:                       }
970:                       if (!channel->multiplexer->l2cap_credits){
0140BC  900029     MOV [W9+4], W0
0140BE  905000     MOV.B [W0+16], W0
0140C0  E00400     CP0.B W0
0140C2  320019     BRA Z, 0x140F6
971:                           // log_info("RFCOMM_EVENT_CREDITS: no l2cap credits\n");
972:                           continue;
973:                       }
974:                       // channel open, multiplexer has l2cap credits and we didn't hand out credit before -> go!
975:                       // log_info("RFCOMM_EVENT_CREDITS: 1\n");
976:                       channel->packets_granted += 1;
0140C4  B3C018     MOV #0x1, W8
0140C6  984CA8     MOV.B W8, [W9+10]
977:                       rfcomm_emit_credits(channel, 1);
978:                   }        
979:               }
980:               
981:               static void rfcomm_channel_send_credits(rfcomm_channel_t *channel, uint8_t credits){
982:                   rfcomm_send_uih_credits(channel->multiplexer, channel->dlci, credits);
01593C  900020     MOV [W0+4], W0
983:                   channel->credits_incoming += credits;
015956  904858     MOV.B [W8+13], W0
015958  44C000     ADD.B W9, W0, W0
01595A  984C50     MOV.B W0, [W8+13]
984:                   
985:                   rfcomm_emit_credit_status(channel);
986:               }
987:               
988:               static void rfcomm_channel_opened(rfcomm_channel_t *rfChannel){
989:                   
990:                   log_info("rfcomm_channel_opened!\n");
991:                   
992:                   rfChannel->state = RFCOMM_CHANNEL_OPEN;
00FCBA  200090     MOV #0x9, W0
00FCBC  980C00     MOV W0, [W8+16]
993:                   rfcomm_emit_channel_opened(rfChannel, 0);
00FCBE  EB4080     CLR.B W1
00FCC0  780008     MOV W8, W0
00FCC2  024168     CALL rfcomm_emit_channel_opened
00FCC4  000001     NOP
994:                   rfcomm_hand_out_credits();
00FCC6  0240A0     CALL rfcomm_hand_out_credits
00FCC8  000001     NOP
995:               
996:                   // remove (potential) timer
997:                   rfcomm_multiplexer_t *multiplexer = rfChannel->multiplexer;
00FCCA  9000A8     MOV [W8+4], W1
998:                   if (multiplexer->timer_active) {
00FCCC  900051     MOV [W1+10], W0
00FCCE  E00000     CP0 W0
00FCD0  3AFF9C     BRA NZ, 0xFC0A
00FCD2  37FF9D     BRA 0xFC0E
999:                       run_loop_remove_timer(&multiplexer->timer);
1000:                      multiplexer->timer_active = 0;
00FC0A  EB0000     CLR W0
00FC0C  9800D0     MOV W0, [W1+10]
1001:                  }
1002:                  // hack for problem detecting authentication failure
1003:                  multiplexer->at_least_one_connection = 1;
00FC0E  B3C010     MOV #0x1, W0
00FC10  9858B0     MOV.B W0, [W1+27]
1004:                  
1005:                  // start next connection request if pending
1006:                  rfcomm_run();
00FC12  0236B0     CALL rfcomm_run
00FC14  000001     NOP
00FC16  37005E     BRA 0xFCD4
1007:              }
1008:              
1009:              static void rfcomm_channel_packet_handler_uih(rfcomm_multiplexer_t *multiplexer, uint8_t * packet, uint16_t size){
1010:                  const uint8_t frame_dlci = packet[0] >> 2;
1011:                  const uint8_t length_offset = (packet[2] & 1) ^ 1;  // to be used for pos >= 3
0102BC  904029     MOV.B [W9+2], W0
0102BE  604561     AND.B W0, #0x1, W10
0102C0  A2040A     BTG.B W10, #0
1012:                  const uint8_t credit_offset = ((packet[1] & BT_RFCOMM_UIH_PF) == BT_RFCOMM_UIH_PF) ? 1 : 0;   // credits for uih_pf frames
1013:                  const uint8_t payload_offset = 3 + length_offset + credit_offset;
0102C2  EAC002     COM.B W2, W0
0102C4  FB8000     ZE W0, W0
0102C6  E90000     DEC W0, W0
0102C8  DE004F     LSR W0, #15, W0
0102CA  454000     ADD.B W10, W0, W0
0102CC  404663     ADD.B W0, #0x3, W12
1014:              
1015:                  rfcomm_channel_t * channel = rfcomm_channel_for_multiplexer_and_dlci(multiplexer, frame_dlci);
0102CE  780003     MOV W3, W0
0102D0  025E62     CALL rfcomm_channel_for_multiplexer_and_dlci
0102D2  000001     NOP
0102D4  780400     MOV W0, W8
1016:                  if (!channel) return;
0102D6  E00000     CP0 W0
0102D8  320033     BRA Z, 0x10340
1017:                  
1018:                  // handle new outgoing credits
1019:                  if (packet[1] == BT_RFCOMM_UIH_PF) {
0102DA  EBC000     SETM.B W0
0102DC  104F9B     SUBR.B W0, [W11], [W15]
0102DE  3A000C     BRA NZ, 0x102F8
1020:                      
1021:                      // add them
1022:                      uint16_t new_credits = packet[3+length_offset];
1023:                      channel->credits_outgoing += new_credits;
0102E0  FB800A     ZE W10, W0
0102E2  448000     ADD W9, W0, W0
0102E4  904030     MOV.B [W0+3], W0
0102E6  9048B8     MOV.B [W8+11], W1
0102E8  404001     ADD.B W0, W1, W0
0102EA  984C30     MOV.B W0, [W8+11]
1024:                      log_info( "RFCOMM data UIH_PF, new credits: %u, now %u\n", new_credits, channel->credits_outgoing);
1025:              
1026:                      // notify channel statemachine 
1027:                      rfcomm_channel_event_t channel_event = { CH_EVT_RCVD_CREDITS };
0102EC  2000B0     MOV #0xB, W0
0102EE  9FB7A0     MOV W0, [W15-28]
1028:                      rfcomm_channel_state_machine(channel, &channel_event);
0102F0  5780FC     SUB W15, #0x1C, W1
0102F2  780008     MOV W8, W0
0102F4  02F956     CALL rfcomm_channel_state_machine
0102F6  000000     NOP
1029:                  }
1030:                  
1031:                  // contains payload?
1032:                  if (size - 1 > payload_offset){
0102F8  FB808C     ZE W12, W1
0102FA  97B90F     MOV [W15-16], W2
0102FC  E90002     DEC W2, W0
0102FE  500F81     SUB W0, W1, [W15]
010300  36000E     BRA LEU, 0x1031E
1033:              
1034:                      // log_info( "RFCOMM data UIH_PF, size %u, channel %p\n", size-payload_offset-1, rfChannel->connection);
1035:              
1036:                      // decrease incoming credit counter
1037:                      if (channel->credits_incoming > 0){
010302  904858     MOV.B [W8+13], W0
010304  E00400     CP0.B W0
010306  320002     BRA Z, 0x1030C
1038:                          channel->credits_incoming--;
010308  E94000     DEC.B W0, W0
01030A  984C50     MOV.B W0, [W8+13]
1039:                      }
1040:                      
1041:                      // deliver payload
1042:                      (*app_packet_handler)(channel->connection, RFCOMM_DATA_PACKET, channel->rfcomm_cid,
01030C  97B80F     MOV [W15-16], W0
01030E  500201     SUB W0, W1, W4
010310  900138     MOV [W8+6], W2
010312  901028     MOV [W8+36], W0
010314  E90204     DEC W4, W4
010316  448181     ADD W9, W1, W3
010318  78408D     MOV.B W13, W1
01031A  8387D5     MOV app_packet_handler, W5
01031C  010005     CALL W5
1043:                                            &packet[payload_offset], size-payload_offset-1);
1044:                  }
1045:                  
1046:                  // automatically provide new credits to remote device, if no incoming flow control
1047:                  if (!channel->incoming_flow_control && channel->credits_incoming < 5){
01031E  904868     MOV.B [W8+14], W0
010320  E00400     CP0.B W0
010322  3A0005     BRA NZ, 0x1032E
010324  904858     MOV.B [W8+13], W0
010326  504FE4     SUB.B W0, #0x4, [W15]
010328  3E0002     BRA GTU, 0x1032E
1048:                      channel->new_credits_incoming = 0x30;
01032A  B3C300     MOV #0x30, W0
01032C  984C40     MOV.B W0, [W8+12]
1049:                  }    
1050:                  
1051:                  rfcomm_emit_credit_status(channel);
1052:                  
1053:                  // we received new RFCOMM credits, hand them out if possible
1054:                  rfcomm_hand_out_credits();
01032E  0240A0     CALL rfcomm_hand_out_credits
010330  000001     NOP
010332  370006     BRA 0x10340
1055:              }
1056:              
1057:              static void rfcomm_channel_accept_pn(rfcomm_channel_t *channel, rfcomm_channel_event_pn_t *event){
1058:                  // priority of client request
1059:                  channel->pn_priority = event->priority;
015D56  904041     MOV.B [W1+4], W0
015D58  985140     MOV.B W0, [W2+20]
1060:                  
1061:                  // new credits
1062:                  channel->credits_outgoing = event->credits_outgoing;
015D5A  904051     MOV.B [W1+5], W0
015D5C  984930     MOV.B W0, [W2+11]
1063:                  
1064:                  // negotiate max frame size
1065:                  if (channel->max_frame_size > channel->multiplexer->max_frame_size) {
015D5E  900022     MOV [W2+4], W0
015D60  9009E0     MOV [W0+28], W3
015D62  900832     MOV [W2+22], W0
015D64  500F83     SUB W0, W3, [W15]
015D66  360001     BRA LEU, 0x15D6A
1066:                      channel->max_frame_size = channel->multiplexer->max_frame_size;
015D68  980933     MOV W3, [W2+22]
1067:                  }
1068:                  if (channel->max_frame_size > event->max_frame_size) {
015D6A  900091     MOV [W1+2], W1
015D6C  900832     MOV [W2+22], W0
015D6E  500F81     SUB W0, W1, [W15]
015D70  360001     BRA LEU, 0x15D74
1069:                      channel->max_frame_size = event->max_frame_size;
1070:                  }
1071:                  
1072:              }
1073:              
1074:              static void rfcomm_channel_finalize(rfcomm_channel_t *channel){
1075:              
1076:                  rfcomm_multiplexer_t *multiplexer = channel->multiplexer;
1077:              
1078:                  // remove from list
1079:                  linked_list_remove( &rfcomm_channels, (linked_item_t *) channel);
016350  780080     MOV W0, W1
016352  270F60     MOV #0x70F6, W0
016354  0263FC     CALL linked_list_remove
016356  000001     NOP
1080:              
1081:                  // free channel
1082:                  btstack_memory_rfcomm_channel_free(channel);
016358  780008     MOV W8, W0
01635A  02669C     CALL btstack_memory_rfcomm_channel_free
01635C  000001     NOP
1083:                  
1084:                  // update multiplexer timeout after channel was removed from list
1085:                  rfcomm_multiplexer_prepare_idle_timer(multiplexer);
1086:              }
1087:              
1088:              static void rfcomm_channel_state_machine_2(rfcomm_multiplexer_t * multiplexer, uint8_t dlci, rfcomm_channel_event_t *event){
1089:              
1090:                  // TODO: if client max frame size is smaller than RFCOMM_DEFAULT_SIZE, send PN
1091:              
1092:                  
1093:                  // lookup existing channel
1094:                  rfcomm_channel_t * channel = rfcomm_channel_for_multiplexer_and_dlci(multiplexer, dlci);
014294  025E62     CALL rfcomm_channel_for_multiplexer_and_dlci
014296  000001     NOP
1095:              
1096:                  // log_info("rfcomm_channel_state_machine_2 lookup dlci #%u = 0x%08x - event %u\n", dlci, (int) channel, event->type);
1097:              
1098:                  if (channel) {
014298  E00000     CP0 W0
01429A  3A001E     BRA NZ, 0x142D8
1099:                      rfcomm_channel_state_machine(channel, event);
1100:                      return;
1101:                  }
1102:                  
1103:                  // service registered?
1104:                  rfcomm_service_t * service = rfcomm_service_for_channel(dlci >> 1);
01429C  FB8009     ZE W9, W0
01429E  D10100     LSR W0, W2
1105:                  // log_info("rfcomm_channel_state_machine_2 service dlci #%u = 0x%08x\n", dlci, (int) service);
1106:                  if (!service) {
1107:                      // discard request by sending disconnected mode
1108:                      multiplexer->send_dm_for_dlci = dlci;
0142E0  985D69     MOV.B W9, [W10+30]
1109:                      return;
1110:                  }
1111:              
1112:                  // create channel for some events
1113:                  switch (event->type) {
0142B2  2000A0     MOV #0xA, W0
0142B4  100F9B     SUBR W0, [W11], [W15]
0142B6  3E0014     BRA GTU, 0x142E0
0142B8  78001B     MOV [W11], W0
0142BA  200011     MOV #0x1, W1
0142BC  DD0880     SL W1, W0, W1
0142BE  2060A0     MOV #0x60A, W0
0142C0  608080     AND W1, W0, W1
0142C2  32000E     BRA Z, 0x142E0
1114:                      case CH_EVT_RCVD_SABM:
1115:                      case CH_EVT_RCVD_PN:
1116:                      case CH_EVT_RCVD_RPN_REQ:
1117:                      case CH_EVT_RCVD_RPN_CMD:
1118:                          // setup incoming channel
1119:                          channel = rfcomm_channel_create(multiplexer, service, dlci >> 1);
0142C4  780088     MOV W8, W1
0142C6  78000A     MOV W10, W0
0142C8  0238EA     CALL rfcomm_channel_create
0142CA  000001     NOP
1120:                          if (!channel){
0142CC  E00000     CP0 W0
0142CE  3A0002     BRA NZ, 0x142D4
1121:                              // discard request by sending disconnected mode
1122:                              multiplexer->send_dm_for_dlci = dlci;
0142D0  985D69     MOV.B W9, [W10+30]
0142D2  370006     BRA 0x142E0
1123:                          }
1124:                          break;
1125:                      default:
1126:                          break;
1127:                  }
1128:              
1129:                  if (!channel) {
1130:                      // discard request by sending disconnected mode
1131:                      multiplexer->send_dm_for_dlci = dlci;
1132:                      return;
1133:                  }
1134:                  channel->connection = service->connection;
0142D4  900458     MOV [W8+10], W8
0142D6  981028     MOV W8, [W0+36]
1135:                  rfcomm_channel_state_machine(channel, event);
0142D8  78008B     MOV W11, W1
0142DA  02F956     CALL rfcomm_channel_state_machine
0142DC  000000     NOP
0142DE  370001     BRA 0x142E2
1136:              }
1137:              
1138:              void rfcomm_channel_packet_handler(rfcomm_multiplexer_t * multiplexer,  uint8_t *packet, uint16_t size){
1139:                  
1140:                  // rfcomm: (0) addr [76543 server channel] [2 direction: initiator uses 1] [1 C/R: CMD by initiator = 1] [0 EA=1]
1141:                  const uint8_t frame_dlci = packet[0] >> 2;
0129A2  FB8011     ZE [W1], W0
0129A4  DE02C2     LSR W0, #2, W5
0129A6  784385     MOV.B W5, W7
1142:                  uint8_t message_dlci; // used by commands in UIH(_PF) packets 
1143:              	uint8_t message_len;  //   "
1144:                  
1145:                  // rfcomm: (1) command/control
1146:                  // -- credits_offset = 1 if command == BT_RFCOMM_UIH_PF
1147:                  const uint8_t credit_offset = ((packet[1] & BT_RFCOMM_UIH_PF) == BT_RFCOMM_UIH_PF) ? 1 : 0;   // credits for uih_pf frames
0129A8  904111     MOV.B [W1+1], W2
1148:                  // rfcomm: (2) length. if bit 0 is cleared, 2 byte length is used. (little endian)
1149:                  const uint8_t length_offset = (packet[2] & 1) ^ 1;  // to be used for pos >= 3
1150:                  // rfcomm: (3+length_offset) credits if credits_offset == 1
1151:                  // rfcomm: (3+length_offest+credits_offset)
1152:                  const uint8_t payload_offset = 3 + length_offset + credit_offset;
0129AA  9040A1     MOV.B [W1+2], W1
0129AC  60C0E1     AND.B W1, #0x1, W1
0129AE  A20401     BTG.B W1, #0
0129B0  EAC002     COM.B W2, W0
0129B2  FB8000     ZE W0, W0
0129B4  E90000     DEC W0, W0
0129B6  DE004F     LSR W0, #15, W0
0129B8  40C080     ADD.B W1, W0, W1
0129BA  40C063     ADD.B W1, #0x3, W0
1153:                  
1154:                  rfcomm_channel_event_t event;
1155:                  rfcomm_channel_event_pn_t event_pn;
1156:                  rfcomm_channel_event_rpn_t event_rpn;
1157:              
1158:                  // switch by rfcomm message type
1159:                  switch(packet[1]) {
0129BC  B3C534     MOV #0x53, W4
0129BE  514F84     SUB.B W2, W4, [W15]
0129C0  320018     BRA Z, 0x129F2
0129C2  3E0008     BRA GTU, 0x129D4
0129C4  514FFF     SUB.B W2, #0x1F, [W15]
0129C6  320017     BRA Z, 0x129F6
0129C8  B3C3F0     MOV #0x3F, W0
0129CA  514F80     SUB.B W2, W0, [W15]
0129CC  32000B     BRA Z, 0x129E4
0129CE  514FEF     SUB.B W2, #0xF, [W15]
0129D0  3A006A     BRA NZ, 0x12AA6
0129D2  370011     BRA 0x129F6
0129D4  414FF1     ADD.B W2, #0x11, [W15]
0129D6  320014     BRA Z, 0x12A00
0129D8  414FE1     ADD.B W2, #0x1, [W15]
0129DA  320012     BRA Z, 0x12A00
0129DC  B3C730     MOV #0x73, W0
0129DE  514F80     SUB.B W2, W0, [W15]
0129E0  3A0062     BRA NZ, 0x12AA6
0129E2  370002     BRA 0x129E8
1160:                          
1161:                      case BT_RFCOMM_SABM:
1162:                          event.type = CH_EVT_RCVD_SABM;
0129E4  200010     MOV #0x1, W0
0129E6  370001     BRA 0x129EA
1163:                          log_info("Received SABM #%u\n", frame_dlci);
1164:                          rfcomm_channel_state_machine_2(multiplexer, frame_dlci, &event);
1165:                          break;
1166:                          
1167:                      case BT_RFCOMM_UA:
1168:                          event.type = CH_EVT_RCVD_UA;
0129E8  200020     MOV #0x2, W0
0129EA  9FB7F0     MOV W0, [W15-18]
1169:                          log_info("Received UA #%u - channel opened\n",frame_dlci);
1170:                          rfcomm_channel_state_machine_2(multiplexer, frame_dlci, &event);
0129EC  578172     SUB W15, #0x12, W2
0129EE  784085     MOV.B W5, W1
0129F0  370057     BRA 0x12AA0
1171:                          break;
1172:                          
1173:                      case BT_RFCOMM_DISC:
1174:                          event.type = CH_EVT_RCVD_DISC;
0129F2  200050     MOV #0x5, W0
0129F4  37FFFA     BRA 0x129EA
1175:                          rfcomm_channel_state_machine_2(multiplexer, frame_dlci, &event);
1176:                          break;
1177:                          
1178:                      case BT_RFCOMM_DM:
1179:                      case BT_RFCOMM_DM_PF:
1180:                          event.type = CH_EVT_RCVD_DM;
0129F6  200060     MOV #0x6, W0
0129F8  9FB7F0     MOV W0, [W15-18]
1181:                          rfcomm_channel_state_machine_2(multiplexer, frame_dlci, &event);
0129FA  578172     SUB W15, #0x12, W2
0129FC  784087     MOV.B W7, W1
0129FE  370050     BRA 0x12AA0
1182:                          break;
1183:                          
1184:                      case BT_RFCOMM_UIH_PF:
1185:                      case BT_RFCOMM_UIH:
1186:              
1187:                          message_len  = packet[payload_offset+1] >> 1;
012A00  FB8000     ZE W0, W0
012A02  418200     ADD W3, W0, W4
012A04  904014     MOV.B [W4+1], W0
012A06  FB8000     ZE W0, W0
012A08  D10100     LSR W0, W2
1188:              
1189:                          switch (packet[payload_offset]) {
012A0A  784094     MOV.B [W4], W1
012A0C  B3C930     MOV #0x93, W0
012A0E  50CF80     SUB.B W1, W0, [W15]
012A10  32002A     BRA Z, 0x12A66
012A12  3E0007     BRA GTU, 0x12A22
012A14  504072     SUB.B W0, #0x12, W0
012A16  50CF80     SUB.B W1, W0, [W15]
012A18  32000D     BRA Z, 0x12A34
012A1A  E8C000     INC2.B W0, W0
012A1C  50CF80     SUB.B W1, W0, [W15]
012A1E  3A0043     BRA NZ, 0x12AA6
012A20  370005     BRA 0x12A2C
012A22  40CFFF     ADD.B W1, #0x1F, [W15]
012A24  32001B     BRA Z, 0x12A5C
012A26  40CFFD     ADD.B W1, #0x1D, [W15]
012A28  3A003E     BRA NZ, 0x12AA6
012A2A  370013     BRA 0x12A52
1190:                              case BT_RFCOMM_PN_CMD:
1191:                                  message_dlci = packet[payload_offset+2];
012A2C  9040A4     MOV.B [W4+2], W1
1192:                                  event_pn.super.type = CH_EVT_RCVD_PN;
012A2E  578170     SUB W15, #0x10, W2
012A30  200030     MOV #0x3, W0
012A32  370003     BRA 0x12A3A
1193:                                  event_pn.priority = packet[payload_offset+4];
1194:                                  event_pn.max_frame_size = READ_BT_16(packet, payload_offset+6);
1195:                                  event_pn.credits_outgoing = packet[payload_offset+9];
1196:                                  log_info("Received UIH Parameter Negotiation Command for #%u\n", message_dlci);
1197:                                  rfcomm_channel_state_machine_2(multiplexer, message_dlci, (rfcomm_channel_event_t*) &event_pn);
1198:                                  break;
1199:                                  
1200:                              case BT_RFCOMM_PN_RSP:
1201:                                  message_dlci = packet[payload_offset+2];
012A34  9040A4     MOV.B [W4+2], W1
1202:                                  event_pn.super.type = CH_EVT_RCVD_PN_RSP;
012A36  578170     SUB W15, #0x10, W2
012A38  200040     MOV #0x4, W0
012A3A  780900     MOV W0, [W2]
1203:                                  event_pn.priority = packet[payload_offset+4];
012A3C  904044     MOV.B [W4+4], W0
012A3E  9FF7C0     MOV.B W0, [W15-12]
1204:                                  event_pn.max_frame_size = READ_BT_16(packet, payload_offset+6);
012A40  9041E4     MOV.B [W4+6], W3
012A42  FB8183     ZE W3, W3
012A44  904074     MOV.B [W4+7], W0
012A46  DD0048     SL W0, #8, W0
012A48  718180     IOR W3, W0, W3
012A4A  980113     MOV W3, [W2+2]
1205:                                  event_pn.credits_outgoing = packet[payload_offset+9];
012A4C  904A14     MOV.B [W4+9], W4
012A4E  9FF7D4     MOV.B W4, [W15-11]
012A50  370027     BRA 0x12AA0
1206:                                  log_info("UIH Parameter Negotiation Response max frame %u, credits %u\n",
1207:                                          event_pn.max_frame_size, event_pn.credits_outgoing);
1208:                                  rfcomm_channel_state_machine_2(multiplexer, message_dlci, (rfcomm_channel_event_t*) &event_pn);
1209:                                  break;
1210:                                  
1211:                              case BT_RFCOMM_MSC_CMD: 
1212:                                  message_dlci = packet[payload_offset+2] >> 2;
012A52  9040A4     MOV.B [W4+2], W1
012A54  FB8081     ZE W1, W1
012A56  DE08C2     LSR W1, #2, W1
1213:                                  event.type = CH_EVT_RCVD_MSC_CMD;
012A58  200070     MOV #0x7, W0
012A5A  37000E     BRA 0x12A78
1214:                                  log_info("Received MSC CMD for #%u, \n", message_dlci);
1215:                                  rfcomm_channel_state_machine_2(multiplexer, message_dlci, &event);
1216:                                  break;
1217:                                  
1218:                              case BT_RFCOMM_MSC_RSP:
1219:                                  message_dlci = packet[payload_offset+2] >> 2;
012A5C  9040A4     MOV.B [W4+2], W1
012A5E  FB8081     ZE W1, W1
012A60  DE08C2     LSR W1, #2, W1
1220:                                  event.type = CH_EVT_RCVD_MSC_RSP;
012A62  200080     MOV #0x8, W0
012A64  370009     BRA 0x12A78
1221:                                  log_info("Received MSC RSP for #%u\n", message_dlci);
1222:                                  rfcomm_channel_state_machine_2(multiplexer, message_dlci, &event);
1223:                                  break;
1224:                                  
1225:                              case BT_RFCOMM_RPN_CMD:
1226:                                  message_dlci = packet[payload_offset+2] >> 2;
012A66  904024     MOV.B [W4+2], W0
012A68  FB8000     ZE W0, W0
012A6A  DE00C2     LSR W0, #2, W1
1227:                                  switch (message_len){
012A6C  514FE1     SUB.B W2, #0x1, [W15]
012A6E  320003     BRA Z, 0x12A76
012A70  514FE8     SUB.B W2, #0x8, [W15]
012A72  3A0019     BRA NZ, 0x12AA6
012A74  370004     BRA 0x12A7E
1228:                                      case 1:
1229:                                          log_info("Received Remote Port Negotiation for #%u\n", message_dlci);
1230:                                          event.type = CH_EVT_RCVD_RPN_REQ;
012A76  2000A0     MOV #0xA, W0
012A78  9FB7F0     MOV W0, [W15-18]
1231:                                          rfcomm_channel_state_machine_2(multiplexer, message_dlci, &event);
012A7A  578172     SUB W15, #0x12, W2
012A7C  370011     BRA 0x12AA0
1232:                                          break;
1233:                                      case 8:
1234:                                          log_info("Received Remote Port Negotiation (Info) for #%u\n", message_dlci);
1235:                                          event_rpn.super.type = CH_EVT_RCVD_RPN_CMD;
012A7E  57816A     SUB W15, #0xA, W2
012A80  200090     MOV #0x9, W0
012A82  780900     MOV W0, [W2]
1236:                                          event_rpn.data.baud_rate = packet[payload_offset+3];
012A84  904034     MOV.B [W4+3], W0
012A86  9FFF80     MOV.B W0, [W15-8]
1237:                                          event_rpn.data.flags = packet[payload_offset+4];
012A88  904044     MOV.B [W4+4], W0
012A8A  9FFF90     MOV.B W0, [W15-7]
1238:                                          event_rpn.data.flow_control = packet[payload_offset+5];
012A8C  904054     MOV.B [W4+5], W0
012A8E  9FFFA0     MOV.B W0, [W15-6]
1239:                                          event_rpn.data.xon  = packet[payload_offset+6];
012A90  904064     MOV.B [W4+6], W0
012A92  9FFFB0     MOV.B W0, [W15-5]
1240:                                          event_rpn.data.xoff = packet[payload_offset+7];
012A94  904074     MOV.B [W4+7], W0
012A96  9FFFC0     MOV.B W0, [W15-4]
1241:                                          event_rpn.data.parameter_mask_0 = packet[payload_offset+8];
012A98  904804     MOV.B [W4+8], W0
012A9A  9FFFD0     MOV.B W0, [W15-3]
1242:                                          event_rpn.data.parameter_mask_1 = packet[payload_offset+9];
012A9C  904A14     MOV.B [W4+9], W4
012A9E  984904     MOV.B W4, [W2+8]
1243:                                          rfcomm_channel_state_machine_2(multiplexer, message_dlci, (rfcomm_channel_event_t*) &event_rpn);
012AA0  780006     MOV W6, W0
012AA2  02428A     CALL rfcomm_channel_state_machine_2
012AA4  000001     NOP
1244:                                          break;
1245:                                      default:
1246:                                          break;
1247:                                  }
1248:                                  break;
1249:                                  
1250:                              default:
1251:                                  log_error("Received unknown UIH packet - 0x%02x\n", packet[payload_offset]); 
1252:                                  break;
1253:                          }
1254:                          break;
1255:                          
1256:                      default:
1257:                          log_error("Received unknown RFCOMM message type %x\n", packet[1]);
1258:                          break;
1259:                  }
1260:                  
1261:                  // trigger next action - example W4_PN_RSP: transition to SEND_SABM which only depends on "can send"
1262:                  rfcomm_run();
012AA6  0236B0     CALL rfcomm_run
012AA8  000001     NOP
1263:              }
1264:              
1265:              void rfcomm_packet_handler(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size){
1266:                  
1267:                  // multiplexer handler
1268:                  int handled = 0;
1269:                  switch (packet_type) {
010056  504FE4     SUB.B W0, #0x4, [W15]
010058  320003     BRA Z, 0x10060
01005A  504FE6     SUB.B W0, #0x6, [W15]
01005C  3A010B     BRA NZ, 0x10274
01005E  3700C9     BRA 0x101F2
1270:                      case HCI_EVENT_PACKET:
1271:                          handled = rfcomm_multiplexer_hci_event_handler(packet, size);
1272:                          break;
1273:                      case L2CAP_DATA_PACKET:
1274:                          handled = rfcomm_multiplexer_l2cap_packet_handler(channel, packet, size);
1275:                          break;
1276:                      default:
1277:                          break;
1278:                  }
1279:                  
1280:                  if (handled) {
1281:                      rfcomm_run();
010340  0236B0     CALL rfcomm_run
010342  000001     NOP
1282:                      return;
1283:                  }
1284:                  
1285:                  // we only handle l2cap packet over open multiplexer channel now
1286:                  if (packet_type != L2CAP_DATA_PACKET) {
1287:                      (*app_packet_handler)(NULL, packet_type, channel, packet, size);
010274  97BA0F     MOV [W15-16], W4
010276  780189     MOV W9, W3
010278  97B17F     MOV [W15-18], W2
01027A  78408C     MOV.B W12, W1
01027C  370011     BRA 0x102A0
1288:                      return;
1289:                  }
1290:                  rfcomm_multiplexer_t * multiplexer = rfcomm_multiplexer_for_l2cap_cid(channel);
1291:                  if (!multiplexer || multiplexer->state != RFCOMM_MULTIPLEXER_OPEN) {
010292  9006E3     MOV [W3+12], W13
010294  568FE7     SUB W13, #0x7, [W15]
010296  320008     BRA Z, 0x102A8
1292:                      (*app_packet_handler)(NULL, packet_type, channel, packet, size);
010298  97BA0F     MOV [W15-16], W4
01029A  780189     MOV W9, W3
01029C  97B17F     MOV [W15-18], W2
01029E  B3C061     MOV #0x6, W1
0102A0  EB0000     CLR W0
0102A2  8387D5     MOV app_packet_handler, W5
0102A4  010005     CALL W5
0102A6  37004E     BRA 0x10344
1293:                      return;
1294:                  }
1295:                  
1296:                  // channel data ?
1297:                  // rfcomm: (0) addr [76543 server channel] [2 direction: initiator uses 1] [1 C/R: CMD by initiator = 1] [0 EA=1]
1298:                  const uint8_t frame_dlci = packet[0] >> 2;
0102A8  FB8019     ZE [W9], W0
0102AA  DE00C2     LSR W0, #2, W1
1299:              	
1300:                  if (frame_dlci && (packet[1] == BT_RFCOMM_UIH || packet[1] == BT_RFCOMM_UIH_PF)) {
0102AC  E00401     CP0.B W1
0102AE  320042     BRA Z, 0x10334
0102B0  E80589     INC W9, W11
0102B2  78411B     MOV.B [W11], W2
0102B4  414FF1     ADD.B W2, #0x11, [W15]
0102B6  320002     BRA Z, 0x102BC
0102B8  414FE1     ADD.B W2, #0x1, [W15]
0102BA  3A003C     BRA NZ, 0x10334
1301:                      rfcomm_channel_packet_handler_uih(multiplexer, packet, size);
1302:                      rfcomm_run();
1303:                      return;
1304:                  }
1305:                   
1306:                  rfcomm_channel_packet_handler(multiplexer, packet, size);
010334  97B90F     MOV [W15-16], W2
010336  780089     MOV W9, W1
010338  780003     MOV W3, W0
01033A  02299C     CALL rfcomm_channel_packet_handler
01033C  000001     NOP
01033E  370002     BRA 0x10344
1307:              }
1308:              
1309:              static int rfcomm_channel_ready_for_open(rfcomm_channel_t *channel){
1310:                  // log_info("rfcomm_channel_ready_for_open state %u, flags needed %04x, current %04x, rf credits %u, l2cap credits %u \n", channel->state, RFCOMM_CHANNEL_STATE_VAR_RCVD_MSC_RSP|RFCOMM_CHANNEL_STATE_VAR_SENT_MSC_RSP|RFCOMM_CHANNEL_STATE_VAR_SENT_CREDITS, channel->state_var, channel->credits_outgoing, channel->multiplexer->l2cap_credits);
1311:                  if ((channel->state_var & RFCOMM_CHANNEL_STATE_VAR_RCVD_MSC_RSP) == 0) return 0;
00FBF4  900818     MOV [W8+18], W0
00FBF6  A35800     BTST.Z W0, #5
00FBF8  32006D     BRA Z, 0xFCD4
1312:                  if ((channel->state_var & RFCOMM_CHANNEL_STATE_VAR_SENT_MSC_RSP) == 0) return 0;
00FBFA  A3E800     BTST.Z W0, #14
00FBFC  32006B     BRA Z, 0xFCD4
1313:                  if ((channel->state_var & RFCOMM_CHANNEL_STATE_VAR_SENT_CREDITS) == 0) return 0;
00FBFE  E00000     CP0 W0
00FC00  3D0069     BRA GE, 0xFCD4
1314:                  if (channel->credits_outgoing == 0) return 0;
00FC02  904838     MOV.B [W8+11], W0
00FC04  E00400     CP0.B W0
00FC06  320066     BRA Z, 0xFCD4
00FC08  370058     BRA 0xFCBA
1315:                  
1316:                  return 1;
1317:              }
1318:              
1319:              static void rfcomm_channel_state_machine(rfcomm_channel_t *channel, rfcomm_channel_event_t *event){
1320:                  
1321:                  // log_info("rfcomm_channel_state_machine: state %u, state_var %04x, event %u\n", channel->state, channel->state_var ,event->type);
1322:                  
1323:                  rfcomm_multiplexer_t *multiplexer = channel->multiplexer;
00F95E  900320     MOV [W0+4], W6
1324:                  
1325:                  // TODO: integrate in common switch
1326:                  if (event->type == CH_EVT_RCVD_DISC){
00F960  780111     MOV [W1], W2
00F962  510FE5     SUB W2, #0x5, [W15]
00F964  3A0004     BRA NZ, 0xF96E
1327:                      rfcomm_emit_channel_closed(channel);
00F966  02525A     CALL rfcomm_emit_channel_closed
00F968  000001     NOP
1328:                      channel->state = RFCOMM_CHANNEL_SEND_UA_AFTER_DISC;
00F96A  2000A0     MOV #0xA, W0
00F96C  3700C0     BRA 0xFAEE
1329:                      return;
1330:                  }
1331:                  
1332:                  // TODO: integrate in common switch
1333:                  if (event->type == CH_EVT_RCVD_DM){
00F96E  510FE6     SUB W2, #0x6, [W15]
00F970  320194     BRA Z, 0xFC9A
1334:                      log_info("Received DM message for #%u\n", channel->dlci);
1335:                      log_info("-> Closing channel locally for #%u\n", channel->dlci);
1336:                      rfcomm_emit_channel_closed(channel);
1337:                      rfcomm_channel_finalize(channel);
1338:                      return;
1339:                  }
1340:                  
1341:                  // remote port negotiation command - just accept everything for now
1342:                  //
1343:                  // "The RPN command can be used before a new DLC is opened and should be used whenever the port settings change."
1344:                  // "The RPN command is specified as optional in TS 07.10, but it is mandatory to recognize and respond to it in RFCOMM. 
1345:                  //   (Although the handling of individual settings are implementation-dependent.)"
1346:                  //
1347:                  
1348:                  // TODO: integrate in common switch
1349:                  if (event->type == CH_EVT_RCVD_RPN_CMD){
00F972  510FE9     SUB W2, #0x9, [W15]
00F974  3A0007     BRA NZ, 0xF984
1350:                      // control port parameters
1351:                      rfcomm_channel_event_rpn_t *event_rpn = (rfcomm_channel_event_rpn_t*) event;
1352:                      memcpy(&channel->rpn_data, &event_rpn->data, sizeof(rfcomm_rpn_data_t));
00F976  4000F8     ADD W0, #0x18, W1
00F978  E88003     INC2 W3, W0
00F97A  090006     REPEAT #0x6
00F97C  7858B0     MOV.B [W0++], [W1++]
00F97E  B10071     SUB #0x7, W1
00F980  B10070     SUB #0x7, W0
00F982  370016     BRA 0xF9B0
1353:                      channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_SEND_RPN_RSP;
1354:                      return;
1355:                  }
1356:                  
1357:                  // TODO: integrate in common switch
1358:                  if (event->type == CH_EVT_RCVD_RPN_REQ){
00F984  510FEA     SUB W2, #0xA, [W15]
00F986  3A0018     BRA NZ, 0xF9B8
1359:                      // default rpn rsp
1360:                      rfcomm_rpn_data_t rpn_data;
1361:                      rpn_data.baud_rate = 0xa0;        /* 9600 bps */
00F988  5780F3     SUB W15, #0x13, W1
00F98A  B3CA00     MOV #0xA0, W0
00F98C  784880     MOV.B W0, [W1]
1362:                      rpn_data.flags = 0x03;            /* 8-n-1 */
00F98E  B3C030     MOV #0x3, W0
00F990  9FEFE0     MOV.B W0, [W15-18]
1363:                      rpn_data.flow_control = 0;        /* no flow control */
00F992  EB4000     CLR.B W0
00F994  9FEFF0     MOV.B W0, [W15-17]
1364:                      rpn_data.xon  = 0xd1;             /* XON */
00F996  B3CD10     MOV #0xD1, W0
00F998  9FF780     MOV.B W0, [W15-16]
1365:                      rpn_data.xoff = 0xd3;             /* XOFF */
00F99A  E8C000     INC2.B W0, W0
00F99C  9FF790     MOV.B W0, [W15-15]
1366:                      rpn_data.parameter_mask_0 = 0x7f; /* parameter mask, all values set */
00F99E  B3C7F0     MOV #0x7F, W0
00F9A0  9FF7A0     MOV.B W0, [W15-14]
1367:                      rpn_data.parameter_mask_1 = 0x3f; /* parameter mask, all values set */
00F9A2  B3C3F0     MOV #0x3F, W0
00F9A4  9FF7B0     MOV.B W0, [W15-13]
1368:                      memcpy(&channel->rpn_data, &rpn_data, sizeof(rfcomm_rpn_data_t));
00F9A6  440078     ADD W8, #0x18, W0
00F9A8  090006     REPEAT #0x6
00F9AA  785831     MOV.B [W1++], [W0++]
00F9AC  B10070     SUB #0x7, W0
00F9AE  B10071     SUB #0x7, W1
1369:                      channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_SEND_RPN_RSP;
00F9B0  900818     MOV [W8+18], W0
00F9B2  A08000     BSET W0, #8
00F9B4  980C10     MOV W0, [W8+18]
00F9B6  37018E     BRA 0xFCD4
1370:                      return;
1371:                  }
1372:                  
1373:                  // TODO: integrate in common swich
1374:                  if (event->type == CH_EVT_READY_TO_SEND){
00F9B8  510FED     SUB W2, #0xD, [W15]
00F9BA  3A0023     BRA NZ, 0xFA02
1375:                      if (channel->state_var & RFCOMM_CHANNEL_STATE_VAR_SEND_RPN_RSP){
00F9BC  900810     MOV [W0+18], W0
00F9BE  A38800     BTST.Z W0, #8
00F9C0  320020     BRA Z, 0xFA02
1376:                          log_info("Sending Remote Port Negotiation RSP for #%u\n", channel->dlci);
1377:                          channel->state_var &= ~RFCOMM_CHANNEL_STATE_VAR_SEND_RPN_RSP;
00F9C2  A18000     BCLR W0, #8
00F9C4  980C10     MOV W0, [W8+18]
1378:                          rfcomm_send_uih_rpn_rsp(multiplexer, channel->dlci, &channel->rpn_data);
00F9C6  440178     ADD W8, #0x18, W2
00F9C8  904998     MOV.B [W8+9], W3
1379:                          return;
1380:                      }
1381:                  }
1382:                  
1383:                  rfcomm_channel_event_pn_t * event_pn = (rfcomm_channel_event_pn_t*) event;
1384:                  
1385:                  switch (channel->state) {
00FA02  900808     MOV [W8+16], W0
00FA04  200001     MOV #0x0, W1
00FA06  500061     SUB W0, #0x1, W0
00FA08  5880E0     SUBB W1, #0x0, W1
00FA0A  500FEB     SUB W0, #0xB, [W15]
00FA0C  588FE0     SUBB W1, #0x0, [W15]
00FA0E  3E0162     BRA GTU, 0xFCD4
00FA10  016000     BRA W0
00FA12  37000B     BRA 0xFA2A
00FA14  37006E     BRA 0xFAF2
00FA16  370071     BRA 0xFAFA
00FA18  37008F     BRA 0xFB38
00FA1A  370099     BRA 0xFB4E
00FA1C  3700A1     BRA 0xFB60
00FA1E  37001A     BRA 0xFA54
00FA20  3700A7     BRA 0xFB70
00FA22  3700FA     BRA 0xFC18
00FA24  37013E     BRA 0xFCA2
00FA26  370128     BRA 0xFC78
00FA28  37011E     BRA 0xFC66
1386:                      case RFCOMM_CHANNEL_CLOSED:
1387:                          switch (event->type){
00FA2A  510FE1     SUB W2, #0x1, [W15]
00FA2C  320003     BRA Z, 0xFA34
00FA2E  510FE3     SUB W2, #0x3, [W15]
00FA30  3A0151     BRA NZ, 0xFCD4
00FA32  370003     BRA 0xFA3A
1388:                              case CH_EVT_RCVD_SABM:
1389:                                  log_info("-> Inform app\n");
1390:                                  channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_RCVD_SABM;
00FA34  900818     MOV [W8+18], W0
00FA36  A03000     BSET W0, #3
00FA38  370006     BRA 0xFA46
1391:                                  channel->state = RFCOMM_CHANNEL_INCOMING_SETUP;
1392:                                  rfcomm_emit_connection_request(channel);
1393:                                  break;
1394:                              case CH_EVT_RCVD_PN:
1395:                                  rfcomm_channel_accept_pn(channel, event_pn);
00FA3A  780083     MOV W3, W1
00FA3C  780008     MOV W8, W0
00FA3E  025D54     CALL rfcomm_channel_accept_pn
00FA40  000001     NOP
1396:                                  log_info("-> Inform app\n");
1397:                                  channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_RCVD_PN;
00FA42  900818     MOV [W8+18], W0
00FA44  A01000     BSET W0, #1
00FA46  980C10     MOV W0, [W8+18]
1398:                                  channel->state = RFCOMM_CHANNEL_INCOMING_SETUP;
00FA48  200070     MOV #0x7, W0
00FA4A  980C00     MOV W0, [W8+16]
1399:                                  rfcomm_emit_connection_request(channel);
00FA4C  780008     MOV W8, W0
00FA4E  024ADC     CALL rfcomm_emit_connection_request
00FA50  000001     NOP
00FA52  370140     BRA 0xFCD4
1400:                                  break;
1401:                              default:
1402:                                  break;
1403:                          }
1404:                          break;
1405:                          
1406:                      case RFCOMM_CHANNEL_INCOMING_SETUP:
1407:                          switch (event->type){
00FA54  510FE3     SUB W2, #0x3, [W15]
00FA56  32000C     BRA Z, 0xFA70
00FA58  510FED     SUB W2, #0xD, [W15]
00FA5A  320017     BRA Z, 0xFA8A
00FA5C  510FE1     SUB W2, #0x1, [W15]
00FA5E  3A013A     BRA NZ, 0xFCD4
1408:                              case CH_EVT_RCVD_SABM:
1409:                                  channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_RCVD_SABM;
00FA60  900898     MOV [W8+18], W1
00FA62  780001     MOV W1, W0
00FA64  A03000     BSET W0, #3
00FA66  980C10     MOV W0, [W8+18]
1410:                                  if (channel->state_var & RFCOMM_CHANNEL_STATE_VAR_CLIENT_ACCEPTED) {
00FA68  A30800     BTST.Z W0, #0
00FA6A  320134     BRA Z, 0xFCD4
1411:                                      channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_SEND_UA;
00FA6C  B32081     IOR #0x208, W1
00FA6E  37000B     BRA 0xFA86
1412:                                  }
1413:                                  break;
1414:                              case CH_EVT_RCVD_PN:
1415:                                  rfcomm_channel_accept_pn(channel, event_pn);
00FA70  780083     MOV W3, W1
00FA72  780008     MOV W8, W0
00FA74  025D54     CALL rfcomm_channel_accept_pn
00FA76  000001     NOP
1416:                                  channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_RCVD_PN;
00FA78  900898     MOV [W8+18], W1
00FA7A  780001     MOV W1, W0
00FA7C  A01000     BSET W0, #1
00FA7E  980C10     MOV W0, [W8+18]
1417:                                  if (channel->state_var & RFCOMM_CHANNEL_STATE_VAR_CLIENT_ACCEPTED) {
00FA80  A30800     BTST.Z W0, #0
00FA82  320128     BRA Z, 0xFCD4
1418:                                      channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_SEND_PN_RSP;
00FA84  B30421     IOR #0x42, W1
00FA86  980C11     MOV W1, [W8+18]
00FA88  370125     BRA 0xFCD4
1419:                                  }
1420:                                  break;
1421:                              case CH_EVT_READY_TO_SEND:
1422:                                  if (channel->state_var & RFCOMM_CHANNEL_STATE_VAR_SEND_PN_RSP){
00FA8A  900818     MOV [W8+18], W0
00FA8C  A36800     BTST.Z W0, #6
00FA8E  32001E     BRA Z, 0xFACC
1423:                                      log_info("Sending UIH Parameter Negotiation Respond for #%u\n", channel->dlci);
1424:                                      channel->state_var &= ~RFCOMM_CHANNEL_STATE_VAR_SEND_PN_RSP;
00FA90  A16000     BCLR W0, #6
00FA92  980C10     MOV W0, [W8+18]
1425:                                      rfcomm_send_uih_pn_response(multiplexer, channel->dlci, channel->pn_priority, channel->max_frame_size);
00FA94  900938     MOV [W8+22], W2
00FA96  9052C8     MOV.B [W8+20], W5
00FA98  904998     MOV.B [W8+9], W3
1426:                                  }
1427:                                  else if (channel->state_var & RFCOMM_CHANNEL_STATE_VAR_SEND_UA){
00FACC  A39800     BTST.Z W0, #9
00FACE  320006     BRA Z, 0xFADC
1428:                                      log_info("Sending UA #%u\n", channel->dlci);
1429:                                      channel->state_var &= ~RFCOMM_CHANNEL_STATE_VAR_SEND_UA;
00FAD0  A19000     BCLR W0, #9
00FAD2  980C10     MOV W0, [W8+18]
1430:                                      rfcomm_send_ua(multiplexer, channel->dlci);
00FAD4  904898     MOV.B [W8+9], W1
00FAD6  780006     MOV W6, W0
00FAD8  02626A     CALL rfcomm_send_ua
00FADA  000001     NOP
1431:                                  }
1432:                                  if ((channel->state_var & RFCOMM_CHANNEL_STATE_VAR_CLIENT_ACCEPTED) && (channel->state_var & RFCOMM_CHANNEL_STATE_VAR_RCVD_SABM)) {
00FADC  900898     MOV [W8+18], W1
00FADE  A30801     BTST.Z W1, #0
00FAE0  3200F9     BRA Z, 0xFCD4
00FAE2  A33801     BTST.Z W1, #3
00FAE4  3200F7     BRA Z, 0xFCD4
1433:                                      channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_SEND_MSC_CMD;
1434:                                      channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_SEND_CREDITS;
00FAE6  214000     MOV #0x1400, W0
00FAE8  708000     IOR W1, W0, W0
00FAEA  980C10     MOV W0, [W8+18]
1435:                                      channel->state = RFCOMM_CHANNEL_DLC_SETUP;
00FAEC  200080     MOV #0x8, W0
00FAEE  980C00     MOV W0, [W8+16]
00FAF0  3700F1     BRA 0xFCD4
1436:                                  } 
1437:                                  break;
1438:                                  
1439:                              default:
1440:                                  break;
1441:                          }
1442:                          break;
1443:                          
1444:                      case RFCOMM_CHANNEL_W4_MULTIPLEXER:
1445:                          switch (event->type) {
00FAF4  510FEC     SUB W2, #0xC, [W15]
00FAF6  32FFFB     BRA Z, 0xFAEE
00FAF8  3700ED     BRA 0xFCD4
1446:                              case CH_EVT_MULTIPLEXER_READY:
1447:                                  log_info("Muliplexer opened, sending UIH PN next\n");
1448:                                  channel->state = RFCOMM_CHANNEL_SEND_UIH_PN;
00FAF2  200030     MOV #0x3, W0
1449:                                  break;
1450:                              default:
1451:                                  break;
1452:                          }
1453:                          break;
1454:                          
1455:                      case RFCOMM_CHANNEL_SEND_UIH_PN:
1456:                          switch (event->type) {
00FAFA  510FED     SUB W2, #0xD, [W15]
00FAFC  3A00EB     BRA NZ, 0xFCD4
1457:                              case CH_EVT_READY_TO_SEND:
1458:                                  log_info("Sending UIH Parameter Negotiation Command for #%u (channel 0x%p)\n", channel->dlci, channel );
1459:                                  channel->state = RFCOMM_CHANNEL_W4_PN_RSP;
00FAFE  200040     MOV #0x4, W0
00FB00  980C00     MOV W0, [W8+16]
1460:                                  rfcomm_send_uih_pn_command(multiplexer, channel->dlci, channel->max_frame_size);
00FB02  900938     MOV [W8+22], W2
00FB04  904998     MOV.B [W8+9], W3
1461:                                  break;
1462:                              default:
1463:                                  break;
1464:                          }
1465:                          break;
1466:                          
1467:                      case RFCOMM_CHANNEL_W4_PN_RSP:
1468:                          switch (event->type){
00FB38  510FE4     SUB W2, #0x4, [W15]
00FB3A  3A00CC     BRA NZ, 0xFCD4
1469:                              case CH_EVT_RCVD_PN_RSP:
1470:                                  // update max frame size
1471:                                  if (channel->max_frame_size > event_pn->max_frame_size) {
00FB3C  900093     MOV [W3+2], W1
00FB3E  900838     MOV [W8+22], W0
00FB40  500F81     SUB W0, W1, [W15]
00FB42  360001     BRA LEU, 0xFB46
1472:                                      channel->max_frame_size = event_pn->max_frame_size;
00FB44  980C31     MOV W1, [W8+22]
1473:                                  }
1474:                                  // new credits
1475:                                  channel->credits_outgoing = event_pn->credits_outgoing;
00FB46  9041D3     MOV.B [W3+5], W3
00FB48  984C33     MOV.B W3, [W8+11]
1476:                                  channel->state = RFCOMM_CHANNEL_SEND_SABM_W4_UA;
00FB4A  200050     MOV #0x5, W0
00FB4C  37FFD0     BRA 0xFAEE
1477:                                  break;
1478:                              default:
1479:                                  break;
1480:                          }
1481:                          break;
1482:              
1483:                      case RFCOMM_CHANNEL_SEND_SABM_W4_UA:
1484:                          switch (event->type) {
00FB4E  510FED     SUB W2, #0xD, [W15]
00FB50  3A00C1     BRA NZ, 0xFCD4
1485:                              case CH_EVT_READY_TO_SEND:
1486:                                  log_info("Sending SABM #%u\n", channel->dlci);
1487:                                  channel->state = RFCOMM_CHANNEL_W4_UA;
00FB52  200060     MOV #0x6, W0
00FB54  980C00     MOV W0, [W8+16]
1488:                                  rfcomm_send_sabm(multiplexer, channel->dlci);
00FB56  904898     MOV.B [W8+9], W1
00FB58  780006     MOV W6, W0
00FB5A  026320     CALL rfcomm_send_sabm
00FB5C  000001     NOP
00FB5E  3700BA     BRA 0xFCD4
1489:                                  break;
1490:                              default:
1491:                                  break;
1492:                          }
1493:                          break;
1494:                          
1495:                      case RFCOMM_CHANNEL_W4_UA:
1496:                          switch (event->type){
00FB60  510FE2     SUB W2, #0x2, [W15]
00FB62  3A00B8     BRA NZ, 0xFCD4
1497:                              case CH_EVT_RCVD_UA:
1498:                                  channel->state = RFCOMM_CHANNEL_DLC_SETUP;
00FB64  200080     MOV #0x8, W0
00FB66  980C00     MOV W0, [W8+16]
1499:                                  channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_SEND_MSC_CMD;
1500:                                  channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_SEND_CREDITS;
00FB68  900818     MOV [W8+18], W0
00FB6A  214001     MOV #0x1400, W1
00FB6C  700001     IOR W0, W1, W0
00FB6E  37FF22     BRA 0xF9B4
1501:                                  break;
1502:                              default:
1503:                                  break;
1504:                          }
1505:                          break;
1506:                          
1507:                      case RFCOMM_CHANNEL_DLC_SETUP:
1508:                          switch (event->type){
00FB70  510FE8     SUB W2, #0x8, [W15]
00FB72  320008     BRA Z, 0xFB84
00FB74  510FED     SUB W2, #0xD, [W15]
00FB76  32000A     BRA Z, 0xFB8C
00FB78  510FE7     SUB W2, #0x7, [W15]
00FB7A  3A003C     BRA NZ, 0xFBF4
1509:                              case CH_EVT_RCVD_MSC_CMD:
1510:                                  channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_RCVD_MSC_CMD;
1511:                                  channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_SEND_MSC_RSP;
00FB7C  900818     MOV [W8+18], W0
00FB7E  208101     MOV #0x810, W1
00FB80  700001     IOR W0, W1, W0
00FB82  370002     BRA 0xFB88
1512:                                  break;
1513:                              case CH_EVT_RCVD_MSC_RSP:
1514:                                  channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_RCVD_MSC_RSP;
00FB84  900818     MOV [W8+18], W0
00FB86  A05000     BSET W0, #5
00FB88  980C10     MOV W0, [W8+18]
00FB8A  370034     BRA 0xFBF4
1515:                                  break;
1516:                                  
1517:                              case CH_EVT_READY_TO_SEND:
1518:                                  if (channel->state_var & RFCOMM_CHANNEL_STATE_VAR_SEND_MSC_CMD){
00FB8C  900898     MOV [W8+18], W1
00FB8E  A3A801     BTST.Z W1, #10
00FB90  320018     BRA Z, 0xFBC2
1519:                                      log_info("Sending MSC CMD for #%u\n", channel->dlci);
1520:                                      channel->state_var &= ~RFCOMM_CHANNEL_STATE_VAR_SEND_MSC_CMD;
1521:                                      channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_SENT_MSC_CMD;
00FB92  A1A001     BCLR W1, #10
00FB94  A0D001     BSET W1, #13
00FB96  980C11     MOV W1, [W8+18]
1522:                                      rfcomm_send_uih_msc_cmd(multiplexer, channel->dlci , 0x8d);  // ea=1,fc=0,rtc=1,rtr=1,ic=0,dv=1
00FB98  904918     MOV.B [W8+9], W2
1523:                                      break;
1524:                                  }
1525:                                  if (channel->state_var & RFCOMM_CHANNEL_STATE_VAR_SEND_MSC_RSP){
00FBC2  208000     MOV #0x800, W0
00FBC4  608100     AND W1, W0, W2
00FBC6  320009     BRA Z, 0xFBDA
1526:                                      log_info("Sending MSC RSP for #%u\n", channel->dlci);
1527:                                      channel->state_var &= ~RFCOMM_CHANNEL_STATE_VAR_SEND_MSC_RSP;
1528:                                      channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_SENT_MSC_RSP;
00FBC8  A1B001     BCLR W1, #11
00FBCA  A0E001     BSET W1, #14
00FBCC  980C11     MOV W1, [W8+18]
1529:                                      rfcomm_send_uih_msc_rsp(multiplexer, channel->dlci, 0x8d);  // ea=1,fc=0,rtc=1,rtr=1,ic=0,dv=1
00FBCE  904898     MOV.B [W8+9], W1
00FBD0  B3C8D2     MOV #0x8D, W2
00FBD2  780006     MOV W6, W0
00FBD4  02590C     CALL rfcomm_send_uih_msc_rsp
00FBD6  000001     NOP
00FBD8  37000D     BRA 0xFBF4
1530:                                      break;
1531:                                  }
1532:                                  if (channel->state_var & RFCOMM_CHANNEL_STATE_VAR_SEND_CREDITS){
00FBDA  A3C801     BTST.Z W1, #12
00FBDC  32000B     BRA Z, 0xFBF4
1533:                                      log_info("Providing credits for #%u\n", channel->dlci);
1534:                                      channel->state_var &= ~RFCOMM_CHANNEL_STATE_VAR_SEND_CREDITS;
1535:                                      channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_SENT_CREDITS;
00FBDE  A1C001     BCLR W1, #12
00FBE0  280000     MOV #0x8000, W0
00FBE2  708000     IOR W1, W0, W0
00FBE4  980C10     MOV W0, [W8+18]
1536:                                      if (channel->new_credits_incoming) {
00FBE6  9048C8     MOV.B [W8+12], W1
00FBE8  E00401     CP0.B W1
00FBEA  320004     BRA Z, 0xFBF4
1537:                                          uint8_t new_credits = channel->new_credits_incoming;
1538:                                          channel->new_credits_incoming = 0;
00FBEC  984C42     MOV.B W2, [W8+12]
1539:                                          rfcomm_channel_send_credits(channel, new_credits);
00FBEE  780008     MOV W8, W0
00FBF0  025936     CALL rfcomm_channel_send_credits
00FBF2  000001     NOP
1540:                                      }
1541:                                      break;
1542:              
1543:                                  }
1544:                                  break;
1545:                              default:
1546:                                  break;
1547:                          }
1548:                          // finally done?
1549:                          if (rfcomm_channel_ready_for_open(channel)){
1550:                              channel->state = RFCOMM_CHANNEL_OPEN;
1551:                              rfcomm_channel_opened(channel);
1552:                          }
1553:                          break;
1554:                      
1555:                      case RFCOMM_CHANNEL_OPEN:
1556:                          switch (event->type){
00FC18  510FEB     SUB W2, #0xB, [W15]
00FC1A  32001B     BRA Z, 0xFC52
00FC1C  510FED     SUB W2, #0xD, [W15]
00FC1E  320005     BRA Z, 0xFC2A
00FC20  510FE7     SUB W2, #0x7, [W15]
00FC22  3A0058     BRA NZ, 0xFCD4
1557:                              case CH_EVT_RCVD_MSC_CMD:
1558:                                  channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_SEND_MSC_RSP;
00FC24  900818     MOV [W8+18], W0
00FC26  A0B000     BSET W0, #11
00FC28  37FEC5     BRA 0xF9B4
1559:                                  break;
1560:                              case CH_EVT_READY_TO_SEND:
1561:                                  if (channel->state_var & RFCOMM_CHANNEL_STATE_VAR_SEND_MSC_RSP){
00FC2A  900898     MOV [W8+18], W1
00FC2C  208000     MOV #0x800, W0
00FC2E  608000     AND W1, W0, W0
00FC30  320008     BRA Z, 0xFC42
1562:                                      log_info("Sending MSC RSP for #%u\n", channel->dlci);
1563:                                      channel->state_var &= ~RFCOMM_CHANNEL_STATE_VAR_SEND_MSC_RSP;
00FC32  A1B001     BCLR W1, #11
00FC34  980C11     MOV W1, [W8+18]
1564:                                      rfcomm_send_uih_msc_rsp(multiplexer, channel->dlci, 0x8d);  // ea=1,fc=0,rtc=1,rtr=1,ic=0,dv=1
00FC36  904898     MOV.B [W8+9], W1
00FC38  B3C8D2     MOV #0x8D, W2
00FC3A  780006     MOV W6, W0
00FC3C  02590C     CALL rfcomm_send_uih_msc_rsp
00FC3E  000001     NOP
00FC40  370049     BRA 0xFCD4
1565:                                      break;
1566:                                  }
1567:                                  if (channel->new_credits_incoming) {
00FC42  9048C8     MOV.B [W8+12], W1
00FC44  E00401     CP0.B W1
00FC46  320046     BRA Z, 0xFCD4
1568:                                      uint8_t new_credits = channel->new_credits_incoming;
1569:                                      channel->new_credits_incoming = 0;
00FC48  984C40     MOV.B W0, [W8+12]
1570:                                      rfcomm_channel_send_credits(channel, new_credits);
00FC4A  780008     MOV W8, W0
00FC4C  025936     CALL rfcomm_channel_send_credits
00FC4E  000001     NOP
00FC50  370041     BRA 0xFCD4
1571:                                      break;
1572:                                  }
1573:                                  break;
1574:                              case CH_EVT_RCVD_CREDITS: {
1575:                                  // notify daemon -> might trigger re-try of parked connections
1576:                                  uint8_t event[1] = { DAEMON_EVENT_NEW_RFCOMM_CREDITS };
00FC52  B3C530     MOV #0x53, W0
00FC54  9FEF80     MOV.B W0, [W15-24]
1577:                                  (*app_packet_handler)(channel->connection, DAEMON_EVENT_PACKET, channel->rfcomm_cid, event, sizeof(event));
00FC56  900138     MOV [W8+6], W2
00FC58  901028     MOV [W8+36], W0
00FC5A  200014     MOV #0x1, W4
00FC5C  5781F8     SUB W15, #0x18, W3
00FC5E  B3C051     MOV #0x5, W1
00FC60  8387D5     MOV app_packet_handler, W5
00FC62  010005     CALL W5
00FC64  370037     BRA 0xFCD4
1578:                                  break;
1579:                              }  
1580:                              default:
1581:                                  break;
1582:                          }
1583:                          break;
1584:                          
1585:                      case RFCOMM_CHANNEL_SEND_DM:
1586:                          switch (event->type) {
00FC66  510FED     SUB W2, #0xD, [W15]
00FC68  3A0035     BRA NZ, 0xFCD4
1587:                              case CH_EVT_READY_TO_SEND:
1588:                                  log_info("Sending DM_PF for #%u\n", channel->dlci);
1589:                                  // don't emit channel closed - channel was never open
1590:                                  channel->state = RFCOMM_CHANNEL_CLOSED;
00FC6A  200010     MOV #0x1, W0
00FC6C  980C00     MOV W0, [W8+16]
1591:                                  rfcomm_send_dm_pf(multiplexer, channel->dlci);
00FC6E  904898     MOV.B [W8+9], W1
00FC70  780006     MOV W6, W0
00FC72  026282     CALL rfcomm_send_dm_pf
00FC74  000001     NOP
00FC76  37001D     BRA 0xFCB2
1592:                                  rfcomm_channel_finalize(channel);
1593:                                  break;
1594:                              default:
1595:                                  break;
1596:                          }
1597:                          break;
1598:                          
1599:                      case RFCOMM_CHANNEL_SEND_DISC:
1600:                          switch (event->type) {
00FC78  510FED     SUB W2, #0xD, [W15]
00FC7A  3A002C     BRA NZ, 0xFCD4
1601:                              case CH_EVT_READY_TO_SEND:
1602:                                  channel->state = RFCOMM_CHANNEL_CLOSED;
00FC7C  200010     MOV #0x1, W0
00FC7E  980C00     MOV W0, [W8+16]
1603:                                  rfcomm_send_disc(multiplexer, channel->dlci);
1604:                                  rfcomm_emit_channel_closed(channel);
00FC9A  780008     MOV W8, W0
00FC9C  02525A     CALL rfcomm_emit_channel_closed
00FC9E  000001     NOP
00FCA0  370008     BRA 0xFCB2
1605:                                  rfcomm_channel_finalize(channel);
1606:                                  break;
1607:                              default:
1608:                                  break;
1609:                          }
1610:                          break;
1611:                          
1612:                      case RFCOMM_CHANNEL_SEND_UA_AFTER_DISC:
1613:                          switch (event->type) {
00FCA2  510FED     SUB W2, #0xD, [W15]
00FCA4  3A0017     BRA NZ, 0xFCD4
1614:                              case CH_EVT_READY_TO_SEND:
1615:                                  log_info("Sending UA after DISC for #%u\n", channel->dlci);
1616:                                  channel->state = RFCOMM_CHANNEL_CLOSED;
00FCA6  200010     MOV #0x1, W0
00FCA8  980C00     MOV W0, [W8+16]
1617:                                  rfcomm_send_ua(multiplexer, channel->dlci);
00FCAA  904898     MOV.B [W8+9], W1
00FCAC  780006     MOV W6, W0
00FCAE  02626A     CALL rfcomm_send_ua
00FCB0  000001     NOP
1618:                                  rfcomm_channel_finalize(channel);
00FCB2  780008     MOV W8, W0
00FCB4  02634C     CALL rfcomm_channel_finalize
00FCB6  000001     NOP
00FCB8  37000D     BRA 0xFCD4
1619:                                  break;
1620:                              default:
1621:                                  break;
1622:                          }
1623:                          break;
1624:                          
1625:                      default:
1626:                          break;
1627:                  }
1628:              }
1629:              
1630:              
1631:              // MARK: RFCOMM RUN
1632:              // process outstanding signaling tasks
1633:              static void rfcomm_run(void){
1634:                  
1635:                  linked_item_t *it;
1636:                  linked_item_t *next;
1637:                  
1638:                  for (it = (linked_item_t *) rfcomm_multiplexers; it ; it = next){
0136B4  8387C8     MOV rfcomm_multiplexers, W8
0136B6  370030     BRA 0x13718
013718  E00008     CP0 W8
01371A  3AFFCE     BRA NZ, 0x136B8
1639:              
1640:                      next = it->next;    // be prepared for removal of channel in state machine
0136B8  780498     MOV [W8], W9
1641:                      
1642:                      rfcomm_multiplexer_t * multiplexer = ((rfcomm_multiplexer_t *) it);
1643:                      
1644:                      if (!l2cap_can_send_packet_now(multiplexer->l2cap_cid)) {
0136BA  900078     MOV [W8+14], W0
0136BC  025DFE     CALL l2cap_can_send_packet_now
0136BE  000001     NOP
0136C0  E00000     CP0 W0
0136C2  320029     BRA Z, 0x13716
1645:                          // log_info("rfcomm_run cannot send l2cap packet for #%u, credits %u\n", multiplexer->l2cap_cid, multiplexer->l2cap_credits);
1646:                          continue;
1647:                      }
1648:                      // log_info("rfcomm_run: multi 0x%08x, state %u\n", (int) multiplexer, multiplexer->state);
1649:              
1650:                      rfcomm_multiplexer_state_machine(multiplexer, MULT_EV_READY_TO_SEND);
1651:                  }
1652:              
1653:                  for (it = (linked_item_t *) rfcomm_channels; it ; it = next){
01371C  8387B8     MOV rfcomm_channels, W8
01371E  37000E     BRA 0x1373C
01373C  E00008     CP0 W8
01373E  3AFFF0     BRA NZ, 0x13720
1654:              
1655:                      next = it->next;    // be prepared for removal of channel in state machine
013720  780498     MOV [W8], W9
1656:              
1657:                      rfcomm_channel_t * channel = ((rfcomm_channel_t *) it);
1658:                      rfcomm_multiplexer_t * multiplexer = channel->multiplexer;
1659:                      
1660:                      if (!l2cap_can_send_packet_now(multiplexer->l2cap_cid)) continue;
013722  900028     MOV [W8+4], W0
013724  900070     MOV [W0+14], W0
013726  025DFE     CALL l2cap_can_send_packet_now
013728  000001     NOP
01372A  E00000     CP0 W0
01372C  320006     BRA Z, 0x1373A
1661:                   
1662:                      rfcomm_channel_event_t event = { CH_EVT_READY_TO_SEND };
01372E  2000D0     MOV #0xD, W0
013730  9FBFD0     MOV W0, [W15-6]
1663:                      rfcomm_channel_state_machine(channel, &event);
013732  5780E6     SUB W15, #0x6, W1
013734  780008     MOV W8, W0
013736  02F956     CALL rfcomm_channel_state_machine
013738  000000     NOP
01373A  780409     MOV W9, W8
1664:                  }
1665:              }
1666:              
1667:              // MARK: RFCOMM BTstack API
1668:              
1669:              void rfcomm_init(void){
1670:                  rfcomm_client_cid_generator = 0;
0165B2  EB0000     CLR W0
0165B4  8B87E0     MOV W0, rfcomm_client_cid_generator
1671:                  rfcomm_multiplexers = NULL;
0165B6  8B87C0     MOV W0, rfcomm_multiplexers
1672:                  rfcomm_services     = NULL;
0165B8  8B87A0     MOV W0, rfcomm_services
1673:                  rfcomm_channels     = NULL;
0165BA  8B87B0     MOV W0, rfcomm_channels
1674:              }
1675:              
1676:              // register packet handler
1677:              void rfcomm_register_packet_handler(void (*handler)(void * connection, uint8_t packet_type,
1678:                                                                  uint16_t channel, uint8_t *packet, uint16_t size)){
1679:              	app_packet_handler = handler;
01675C  8B87D0     MOV W0, app_packet_handler
1680:              }
1681:              
1682:              int rfcomm_can_send(uint8_t rfcomm_cid) {
1683:                  rfcomm_channel_t * channel = rfcomm_channel_for_rfcomm_cid(rfcomm_cid);
015586  FB8100     ZE W0, W2
1684:                  if (!channel){
1685:                      log_error("rfcomm_send_internal cid %u doesn't exist!\n", rfcomm_cid);
1686:                      return 0;
1687:                  }
1688:              
1689:                  return channel->credits_outgoing && channel->packets_granted
01559A  904831     MOV.B [W1+11], W0
01559C  E00400     CP0.B W0
01559E  32000A     BRA Z, 0x155B4
0155A0  904821     MOV.B [W1+10], W0
0155A2  E00400     CP0.B W0
0155A4  320007     BRA Z, 0x155B4
0155A6  900021     MOV [W1+4], W0
0155A8  900070     MOV [W0+14], W0
0155AA  025DFE     CALL l2cap_can_send_packet_now
0155AC  000001     NOP
0155AE  200011     MOV #0x1, W1
0155B0  E00000     CP0 W0
0155B2  3A0001     BRA NZ, 0x155B6
0155B4  EB0080     CLR W1
1690:                         && l2cap_can_send_packet_now(channel->multiplexer->l2cap_cid);
1691:              }
1692:              
1693:              // send packet over specific channel
1694:              int rfcomm_send_internal(uint16_t rfcomm_cid, uint8_t *data, uint16_t len){
1695:              
1696:                  rfcomm_channel_t * channel = rfcomm_channel_for_rfcomm_cid(rfcomm_cid);
1697:                  if (!channel){
1698:                      log_error("rfcomm_send_internal cid 0x%02x doesn't exist!\n", rfcomm_cid);
1699:                      return 0;
1700:                  }
1701:                  
1702:                  if (!channel->credits_outgoing){
013E44  904838     MOV.B [W8+11], W0
013E46  E00400     CP0.B W0
013E48  320021     BRA Z, 0x13E8C
1703:                      log_info("rfcomm_send_internal cid 0x%02x, no rfcomm outgoing credits!\n", rfcomm_cid);
1704:                      return RFCOMM_NO_OUTGOING_CREDITS;
1705:                  }
1706:              
1707:                  if (!channel->packets_granted){
013E4A  9048A8     MOV.B [W8+10], W1
013E4C  E00401     CP0.B W1
013E4E  32001E     BRA Z, 0x13E8C
1708:                      log_info("rfcomm_send_internal cid 0x%02x, no rfcomm credits granted!\n", rfcomm_cid);
1709:                      return RFCOMM_NO_OUTGOING_CREDITS;
1710:                  }
1711:                  
1712:                  // log_info("rfcomm_send_internal: len %u... outgoing credits %u, l2cap credit %us, granted %u\n",
1713:                  //        len, channel->credits_outgoing, channel->multiplexer->l2cap_credits, channel->packets_granted);
1714:                  
1715:              
1716:                  // send might cause l2cap to emit new credits, update counters first
1717:                  channel->credits_outgoing--;
013E50  E94000     DEC.B W0, W0
013E52  984C30     MOV.B W0, [W8+11]
1718:                  int packets_granted_decreased = 0;
1719:                  if (channel->packets_granted) {
1720:                      channel->packets_granted--;
013E54  E94001     DEC.B W1, W0
013E56  984C20     MOV.B W0, [W8+10]
1721:                      packets_granted_decreased++;
1722:                  }
1723:                  
1724:                  int result = rfcomm_send_uih_data(channel->multiplexer, channel->dlci, data, len);
013E58  900028     MOV [W8+4], W0
1725:                  
1726:                  if (result != 0) {
013E74  E00000     CP0 W0
013E76  320007     BRA Z, 0x13E86
1727:                      channel->credits_outgoing++;
013E78  904838     MOV.B [W8+11], W0
013E7A  E84000     INC.B W0, W0
013E7C  984C30     MOV.B W0, [W8+11]
1728:                      channel->packets_granted += packets_granted_decreased;
013E7E  904828     MOV.B [W8+10], W0
013E80  E84000     INC.B W0, W0
013E82  984C20     MOV.B W0, [W8+10]
013E84  370004     BRA 0x13E8E
1729:                      log_info("rfcomm_send_internal: error %d\n", result);
1730:                      return result;
1731:                  }
1732:                  
1733:                  // log_info("rfcomm_send_internal: now outgoing credits %u, l2cap credit %us, granted %u\n",
1734:                  //        channel->credits_outgoing, channel->multiplexer->l2cap_credits, channel->packets_granted);
1735:              
1736:                  rfcomm_hand_out_credits();
013E86  0240A0     CALL rfcomm_hand_out_credits
013E88  000001     NOP
013E8A  370001     BRA 0x13E8E
1737:                  
1738:                  return result;
013E8C  200729     MOV #0x72, W9
1739:              }
1740:              
1741:              void rfcomm_create_channel2(void * connection, bd_addr_t *addr, uint8_t server_channel, uint8_t incoming_flow_control, uint8_t initial_credits){
1742:                  log_info("RFCOMM_CREATE_CHANNEL addr %s channel #%u flow control %u init credits %u\n",  bd_addr_to_str(*addr), server_channel,
1743:                           incoming_flow_control, initial_credits);
1744:                  
1745:                  // create new multiplexer if necessary
1746:                  rfcomm_multiplexer_t * multiplexer = rfcomm_multiplexer_for_addr(addr);
013A0C  780001     MOV W1, W0
013A0E  025B3A     CALL rfcomm_multiplexer_for_addr
013A10  000001     NOP
013A12  780400     MOV W0, W8
1747:                  if (!multiplexer) {
013A14  E00000     CP0 W0
013A16  3A000A     BRA NZ, 0x13A2C
1748:                      multiplexer = rfcomm_multiplexer_create_for_addr(addr);
013A18  78000A     MOV W10, W0
013A1A  024B26     CALL rfcomm_multiplexer_create_for_addr
013A1C  000001     NOP
013A1E  780400     MOV W0, W8
1749:                      if (!multiplexer){
013A20  E00000     CP0 W0
013A22  32000C     BRA Z, 0x13A3C
1750:                          rfcomm_emit_channel_open_failed_outgoing_memory(connection, addr, server_channel);
1751:                          return;
1752:                      }
1753:                      multiplexer->outgoing = 1;
013A24  B3C010     MOV #0x1, W0
013A26  985C20     MOV.B W0, [W8+26]
1754:                      multiplexer->state = RFCOMM_MULTIPLEXER_W4_CONNECT;
013A28  200020     MOV #0x2, W0
013A2A  980460     MOV W0, [W8+12]
1755:                  }
1756:                  
1757:                  // prepare channel
1758:                  rfcomm_channel_t * channel = rfcomm_channel_create(multiplexer, NULL, server_channel);
013A2C  784109     MOV.B W9, W2
013A2E  EB0080     CLR W1
013A30  780008     MOV W8, W0
013A32  0238EA     CALL rfcomm_channel_create
013A34  000001     NOP
013A36  780080     MOV W0, W1
1759:                  if (!channel){
013A38  E00000     CP0 W0
013A3A  3A0006     BRA NZ, 0x13A48
1760:                      rfcomm_emit_channel_open_failed_outgoing_memory(connection, addr, server_channel);
013A3C  784109     MOV.B W9, W2
013A3E  78008A     MOV W10, W1
013A40  78000B     MOV W11, W0
013A42  0243FC     CALL rfcomm_emit_channel_open_failed_outgoing_memory
013A44  000001     NOP
013A46  370016     BRA 0x13A74
1761:                      return;
1762:                  }
1763:                  channel->connection = connection;
013A48  98102B     MOV W11, [W0+36]
1764:                  channel->incoming_flow_control = incoming_flow_control;
013A4A  98486C     MOV.B W12, [W0+14]
1765:                  channel->new_credits_incoming  = initial_credits;
013A4C  98484D     MOV.B W13, [W0+12]
1766:                  
1767:                  // start multiplexer setup
1768:                  if (multiplexer->state != RFCOMM_MULTIPLEXER_OPEN) {
013A4E  900068     MOV [W8+12], W0
013A50  500FE7     SUB W0, #0x7, [W15]
013A52  32000C     BRA Z, 0x13A6C
1769:                      
1770:                      channel->state = RFCOMM_CHANNEL_W4_MULTIPLEXER;
013A54  200020     MOV #0x2, W0
013A56  980880     MOV W0, [W1+16]
1771:                      
1772:                      l2cap_create_channel_internal(connection, rfcomm_packet_handler, *addr, PSM_RFCOMM, l2cap_max_mtu());
013A58  0266B4     CALL l2cap_max_mtu
013A5A  000001     NOP
013A5C  780200     MOV W0, W4
013A5E  200033     MOV #0x3, W3
013A60  78010A     MOV W10, W2
013A62  2531C1     MOV #0x531C, W1
013A64  78000B     MOV W11, W0
013A66  023AFA     CALL l2cap_create_channel_internal
013A68  000001     NOP
013A6A  370004     BRA 0x13A74
1773:                      
1774:                      return;
1775:                  }
1776:                  
1777:                  channel->state = RFCOMM_CHANNEL_SEND_UIH_PN;
013A6C  200030     MOV #0x3, W0
013A6E  980880     MOV W0, [W1+16]
1778:                  
1779:                  // start connecting, if multiplexer is already up and running
1780:                  rfcomm_run();
013A70  0236B0     CALL rfcomm_run
013A72  000001     NOP
1781:              }
1782:              
1783:              void rfcomm_create_channel_with_initial_credits_internal(void * connection, bd_addr_t *addr, uint8_t server_channel, uint8_t initial_credits){
1784:                  rfcomm_create_channel2(connection, addr, server_channel, 1, initial_credits);
01666C  784203     MOV.B W3, W4
01666E  B3C013     MOV #0x1, W3
016670  0439FC     GOTO rfcomm_create_channel2
016672  000001     NOP
1785:              }
1786:              
1787:              void rfcomm_create_channel_internal(void * connection, bd_addr_t *addr, uint8_t server_channel){
1788:                  rfcomm_create_channel2(connection, addr, server_channel, 0, 0x30);
016664  B3C304     MOV #0x30, W4
016666  EB4180     CLR.B W3
016668  0439FC     GOTO rfcomm_create_channel2
01666A  000001     NOP
1789:              }
1790:              
1791:              void rfcomm_disconnect_internal(uint16_t rfcomm_cid){
1792:                  log_info("RFCOMM_DISCONNECT cid 0x%02x", rfcomm_cid);
1793:                  rfcomm_channel_t * channel = rfcomm_channel_for_rfcomm_cid(rfcomm_cid);
1794:                  if (channel) {
1795:                      channel->state = RFCOMM_CHANNEL_SEND_DISC;
016054  2000B0     MOV #0xB, W0
016056  980880     MOV W0, [W1+16]
1796:                  }
1797:                  
1798:                  // process
1799:                  rfcomm_run();
016058  0436B0     GOTO rfcomm_run
01605A  000001     NOP
1800:              }
1801:              
1802:              
1803:              void rfcomm_register_service2(void * connection, uint8_t channel, uint16_t max_frame_size, uint8_t incoming_flow_control, uint8_t initial_credits){
1804:                  log_info("RFCOMM_REGISTER_SERVICE channel #%u mtu %u flow_control %u credits %u",
1805:                           channel, max_frame_size, incoming_flow_control, initial_credits);
1806:                  // check if already registered
1807:                  rfcomm_service_t * service = rfcomm_service_for_channel(channel);
1808:                  if (service){
1809:                      rfcomm_emit_service_registered(connection, RFCOMM_CHANNEL_ALREADY_REGISTERED, channel);
013C10  784109     MOV.B W9, W2
013C12  B3C711     MOV #0x71, W1
013C14  370020     BRA 0x13C56
1810:                      return;
1811:                  }
1812:                  
1813:                  // alloc structure
1814:                  service = btstack_memory_rfcomm_service_get();
013C4A  0266FC     CALL btstack_memory_rfcomm_service_get
013C4C  000001     NOP
013C4E  780400     MOV W0, W8
1815:                  if (!service) {
013C50  E00000     CP0 W0
013C52  3AFFE4     BRA NZ, 0x13C1C
013C54  37FFE0     BRA 0x13C16
1816:                      rfcomm_emit_service_registered(connection, BTSTACK_MEMORY_ALLOC_FAILED, channel);
013C16  784109     MOV.B W9, W2
013C18  B3C561     MOV #0x56, W1
013C1A  37001D     BRA 0x13C56
1817:                      return;
1818:                  }
1819:                  
1820:                  // register with l2cap if not registered before, max MTU
1821:                  if (linked_list_empty(&rfcomm_services)){
013C1C  270F40     MOV #0x70F4, W0
013C1E  0265CA     CALL linked_list_empty
013C20  000001     NOP
013C22  E00000     CP0 W0
013C24  320006     BRA Z, 0x13C32
1822:                      l2cap_register_service_internal(NULL, rfcomm_packet_handler, PSM_RFCOMM, 0xffff);
013C26  EB8180     SETM W3
013C28  200032     MOV #0x3, W2
013C2A  2531C1     MOV #0x531C, W1
013C2C  EB0000     CLR W0
013C2E  024344     CALL l2cap_register_service_internal
013C30  000001     NOP
1823:                  }
1824:                  
1825:                  // fill in 
1826:                  service->connection     = connection;
013C32  98045A     MOV W10, [W8+10]
1827:                  service->server_channel = channel;
013C34  984449     MOV.B W9, [W8+4]
1828:                  service->max_frame_size = max_frame_size;
013C36  98043B     MOV W11, [W8+6]
1829:                  service->incoming_flow_control = incoming_flow_control;
013C38  984C0C     MOV.B W12, [W8+8]
1830:                  service->incoming_initial_credits = initial_credits;
013C3A  984C1D     MOV.B W13, [W8+9]
1831:                  
1832:                  // add to services list
1833:                  linked_list_add(&rfcomm_services, (linked_item_t *) service);
013C3C  780088     MOV W8, W1
013C3E  270F40     MOV #0x70F4, W0
013C40  0263E6     CALL linked_list_add
013C42  000001     NOP
1834:                  
1835:                  // done
1836:                  rfcomm_emit_service_registered(connection, 0, channel);
013C44  784109     MOV.B W9, W2
013C46  EB4080     CLR.B W1
013C48  370006     BRA 0x13C56
013C56  78000A     MOV W10, W0
013C58  025682     CALL rfcomm_emit_service_registered
013C5A  000001     NOP
1837:              }
1838:              
1839:              void rfcomm_register_service_with_initial_credits_internal(void * connection, uint8_t channel, uint16_t max_frame_size, uint8_t initial_credits){
1840:                  rfcomm_register_service2(connection, channel, max_frame_size, 1, initial_credits);
01665C  784203     MOV.B W3, W4
01665E  B3C013     MOV #0x1, W3
016660  043BEE     GOTO rfcomm_register_service2
016662  000001     NOP
1841:              }
1842:              
1843:              void rfcomm_register_service_internal(void * connection, uint8_t channel, uint16_t max_frame_size){
1844:                  rfcomm_register_service2(connection, channel, max_frame_size, 0, 0x30);
016654  B3C304     MOV #0x30, W4
016656  EB4180     CLR.B W3
016658  043BEE     GOTO rfcomm_register_service2
01665A  000001     NOP
1845:              }
1846:              
1847:              void rfcomm_unregister_service_internal(uint8_t service_channel){
1848:                  log_info("RFCOMM_UNREGISTER_SERVICE #%u", service_channel);
1849:                  rfcomm_service_t *service = rfcomm_service_for_channel(service_channel);
1850:                  if (!service) return;
1851:                  linked_list_remove(&rfcomm_services, (linked_item_t *) service);
015188  780088     MOV W8, W1
01518A  270F40     MOV #0x70F4, W0
01518C  0263FC     CALL linked_list_remove
01518E  000001     NOP
1852:                  btstack_memory_rfcomm_service_free(service);
015190  780008     MOV W8, W0
015192  026694     CALL btstack_memory_rfcomm_service_free
015194  000001     NOP
1853:                  
1854:                  // unregister if no services active
1855:                  if (linked_list_empty(&rfcomm_services)){
015196  270F40     MOV #0x70F4, W0
015198  0265CA     CALL linked_list_empty
01519A  000001     NOP
01519C  E00000     CP0 W0
01519E  320004     BRA Z, 0x151A8
1856:                      // bt_send_cmd(&l2cap_unregister_service, PSM_RFCOMM);
1857:                      l2cap_unregister_service_internal(NULL, PSM_RFCOMM);
0151A0  200031     MOV #0x3, W1
0151A2  EB0000     CLR W0
0151A4  02547E     CALL l2cap_unregister_service_internal
0151A6  000001     NOP
1858:                  }
1859:              }
1860:              
1861:              void rfcomm_accept_connection_internal(uint16_t rfcomm_cid){
1862:                  log_info("RFCOMM_ACCEPT_CONNECTION cid 0x%02x", rfcomm_cid);
1863:                  rfcomm_channel_t * channel = rfcomm_channel_for_rfcomm_cid(rfcomm_cid);
1864:                  if (!channel) return;
1865:                  switch (channel->state) {
0152A6  900801     MOV [W1+16], W0
0152A8  500FE7     SUB W0, #0x7, [W15]
0152AA  3A000D     BRA NZ, 0x152C6
1866:                      case RFCOMM_CHANNEL_INCOMING_SETUP:
1867:                          channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_CLIENT_ACCEPTED;
0152AC  900911     MOV [W1+18], W2
0152AE  780002     MOV W2, W0
0152B0  A00000     BSET W0, #0
0152B2  980890     MOV W0, [W1+18]
1868:                          if (channel->state_var & RFCOMM_CHANNEL_STATE_VAR_RCVD_PN){
0152B4  A31800     BTST.Z W0, #1
0152B6  320002     BRA Z, 0x152BC
1869:                              channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_SEND_PN_RSP;
0152B8  B30412     IOR #0x41, W2
0152BA  980892     MOV W2, [W1+18]
1870:                          }
1871:                          if (channel->state_var & RFCOMM_CHANNEL_STATE_VAR_RCVD_SABM){
0152BC  900811     MOV [W1+18], W0
0152BE  A33800     BTST.Z W0, #3
0152C0  320002     BRA Z, 0x152C6
1872:                              channel->state_var |= RFCOMM_CHANNEL_STATE_VAR_SEND_UA;
0152C2  A09000     BSET W0, #9
0152C4  980890     MOV W0, [W1+18]
1873:                          }
1874:                          break;
1875:                      default:
1876:                          break;
1877:                  }
1878:              
1879:                  // process
1880:                  rfcomm_run();
1881:              }
1882:              
1883:              void rfcomm_decline_connection_internal(uint16_t rfcomm_cid){
1884:                  log_info("RFCOMM_DECLINE_CONNECTION cid 0x%02x", rfcomm_cid);
1885:                  rfcomm_channel_t * channel = rfcomm_channel_for_rfcomm_cid(rfcomm_cid);
1886:                  if (!channel) return;
1887:                  switch (channel->state) {
015D8A  900801     MOV [W1+16], W0
015D8C  500FE7     SUB W0, #0x7, [W15]
015D8E  3A0002     BRA NZ, 0x15D94
1888:                      case RFCOMM_CHANNEL_INCOMING_SETUP:
1889:                          channel->state = RFCOMM_CHANNEL_SEND_DM;
015D90  2000C0     MOV #0xC, W0
015D92  980880     MOV W0, [W1+16]
1890:                          break;
1891:                      default:
1892:                          break;
1893:                  }
1894:              
1895:                  // process
1896:                  rfcomm_run();
1897:              }
1898:              
1899:              void rfcomm_grant_credits(uint16_t rfcomm_cid, uint8_t credits){
1900:                  log_info("RFCOMM_GRANT_CREDITS cid 0x%02x credits %u", rfcomm_cid, credits);
1901:                  rfcomm_channel_t * channel = rfcomm_channel_for_rfcomm_cid(rfcomm_cid);
1902:                  if (!channel) return;
1903:                  if (!channel->incoming_flow_control) return;
015B74  904862     MOV.B [W2+14], W0
015B76  E00400     CP0.B W0
015B78  320005     BRA Z, 0x15B84
1904:                  channel->new_credits_incoming += credits;
015B7A  904842     MOV.B [W2+12], W0
015B7C  40C000     ADD.B W1, W0, W0
015B7E  984940     MOV.B W0, [W2+12]
1905:              
1906:                  // process
1907:                  rfcomm_run();
1908:              }
1909:              
1910:              //
1911:              void rfcomm_close_connection(void *connection){
1912:                  linked_item_t *it;
1913:                  
1914:                  // close open channels
1915:                  for (it = (linked_item_t *) rfcomm_channels; it ; it = it->next){
015010  8387B1     MOV rfcomm_channels, W1
015012  2000B2     MOV #0xB, W2
015014  370005     BRA 0x15020
01501E  780091     MOV [W1], W1
015020  E00001     CP0 W1
015022  3AFFF9     BRA NZ, 0x15016
1916:                      rfcomm_channel_t * channel = (rfcomm_channel_t *)it;
1917:                      if (channel->connection != connection) continue;
015016  901021     MOV [W1+36], W0
015018  500F89     SUB W0, W9, [W15]
01501A  3A0001     BRA NZ, 0x1501E
1918:                      channel->state = RFCOMM_CHANNEL_SEND_DISC;
01501C  980882     MOV W2, [W1+16]
1919:                  }
1920:                  
1921:                  // unregister services
1922:                  it = (linked_item_t *) &rfcomm_services;
015024  270F48     MOV #0x70F4, W8
015026  370009     BRA 0x1503A
1923:                  while (it->next) {
01503A  780098     MOV [W8], W1
01503C  E00001     CP0 W1
01503E  3AFFF4     BRA NZ, 0x15028
1924:                      rfcomm_service_t * service = (rfcomm_service_t *) it->next;
1925:                      if (service->connection == connection){
015028  900051     MOV [W1+10], W0
01502A  500F89     SUB W0, W9, [W15]
01502C  320002     BRA Z, 0x15032
01502E  780401     MOV W1, W8
015030  370004     BRA 0x1503A
1926:                          it->next = it->next->next;
015032  780C11     MOV [W1], [W8]
1927:                          btstack_memory_rfcomm_service_free(service);
015034  780001     MOV W1, W0
015036  026694     CALL btstack_memory_rfcomm_service_free
015038  000001     NOP
1928:                      } else {
1929:                          it = it->next;
1930:                      }
1931:                  }
1932:              
1933:                  // process
1934:                  rfcomm_run();
015040  0236B0     CALL rfcomm_run
015042  000001     NOP
1935:              }
1936:              
1937:              
1938:              
1939:              
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libbtstack/src/remote_device_db_memory.c
01466C  BE9F88     MOV.D W8, [W15++]
01466E  781F8A     MOV W10, [W15++]
014670  780480     MOV W0, W9
014672  780501     MOV W1, W10
0146C4  BE9F88     MOV.D W8, [W15++]
0146C6  781F8A     MOV W10, [W15++]
0146C8  780500     MOV W0, W10
014910  BE9F88     MOV.D W8, [W15++]
014912  BE0400     MOV.D W0, W8
0151AC  BE9F88     MOV.D W8, [W15++]
0151AE  780100     MOV W0, W2
0151B0  780481     MOV W1, W9
0151E6  BE9F88     MOV.D W8, [W15++]
0151E8  780100     MOV W0, W2
0151EA  780481     MOV W1, W9
015C40  BE9F88     MOV.D W8, [W15++]
015C42  780481     MOV W1, W9
015C44  370009     BRA 0x15C58
015DBA  781F88     MOV W8, [W15++]
015DBC  780080     MOV W0, W1
015DDC  781F88     MOV W8, [W15++]
015DDE  780080     MOV W0, W1
1:                 /*
2:                  * Copyright (C) 2009-2012 by Matthias Ringwald
3:                  *
4:                  * Redistribution and use in source and binary forms, with or without
5:                  * modification, are permitted provided that the following conditions
6:                  * are met:
7:                  *
8:                  * 1. Redistributions of source code must retain the above copyright
9:                  *    notice, this list of conditions and the following disclaimer.
10:                 * 2. Redistributions in binary form must reproduce the above copyright
11:                 *    notice, this list of conditions and the following disclaimer in the
12:                 *    documentation and/or other materials provided with the distribution.
13:                 * 3. Neither the name of the copyright holders nor the names of
14:                 *    contributors may be used to endorse or promote products derived
15:                 *    from this software without specific prior written permission.
16:                 * 4. Any redistribution, use, or modification is done solely for
17:                 *    personal benefit and not for any commercial purpose or for
18:                 *    monetary gain.
19:                 *
20:                 * THIS SOFTWARE IS PROVIDED BY MATTHIAS RINGWALD AND CONTRIBUTORS
21:                 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
22:                 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
23:                 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MATTHIAS
24:                 * RINGWALD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
25:                 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
26:                 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
27:                 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
28:                 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
29:                 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
30:                 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
31:                 * SUCH DAMAGE.
32:                 *
33:                 * Please inquire about commercial licensing options at btstack@ringwald.ch
34:                 *
35:                 */
36:                
37:                #include <string.h>
38:                #include <stdlib.h>
39:                
40:                #include "remote_device_db.h"
41:                #include "btstack_memory.h"
42:                #include "debug.h"
43:                
44:                #include <btstack/utils.h>
45:                #include <btstack/linked_list.h>
46:                
47:                // This lists should be only accessed by tests.
48:                linked_list_t db_mem_link_keys = NULL;
49:                linked_list_t db_mem_names = NULL;
50:                static linked_list_t db_mem_services = NULL;
51:                
52:                // Device info
53:                static void db_open(void){
54:                }
55:                
56:                static void db_close(void){ 
57:                }
58:                
59:                static db_mem_device_t * get_item(linked_list_t list, bd_addr_t *bd_addr) {
60:                    linked_item_t *it;
61:                    for (it = (linked_item_t *) list; it ; it = it->next){
015C56  780018     MOV [W8], W0
015C58  E00000     CP0 W0
015C5A  3AFFF5     BRA NZ, 0x15C46
015C5C  780400     MOV W0, W8
62:                        db_mem_device_t * item = (db_mem_device_t *) it;
015C46  780400     MOV W0, W8
63:                        if (BD_ADDR_CMP(item->bd_addr, *bd_addr) == 0) {
015C48  400064     ADD W0, #0x4, W0
015C4A  200062     MOV #0x6, W2
015C4C  780089     MOV W9, W1
015C4E  0256EC     CALL memcmp
015C50  000000     NOP
015C52  E00000     CP0 W0
015C54  320004     BRA Z, 0x15C5E
64:                            return item;
65:                        }
66:                    }
67:                    return NULL;
68:                }
69:                
70:                static int get_name(bd_addr_t *bd_addr, device_name_t *device_name) {
71:                    db_mem_device_name_t * item = (db_mem_device_name_t *) get_item(db_mem_names, bd_addr);
0151B2  8388B0     MOV db_mem_names, W0
0151B4  780082     MOV W2, W1
0151B6  025C40     CALL get_item
0151B8  000001     NOP
0151BA  780400     MOV W0, W8
72:                    
73:                    if (!item) return 0;
0151BC  E00000     CP0 W0
0151BE  3A0002     BRA NZ, 0x151C4
0151C0  780080     MOV W0, W1
0151C2  37000E     BRA 0x151E0
74:                    
75:                    strncpy((char*)device_name, item->device_name, MAX_NAME_LEN);
0151C4  4000EA     ADD W0, #0xA, W1
0151C6  200202     MOV #0x20, W2
0151C8  780009     MOV W9, W0
0151CA  02575C     CALL strncpy
0151CC  000000     NOP
76:                    
77:                	linked_list_remove(&db_mem_names, (linked_item_t *) item);
0151CE  780088     MOV W8, W1
0151D0  271160     MOV #0x7116, W0
0151D2  0263FC     CALL linked_list_remove
0151D4  000001     NOP
78:                    linked_list_add(&db_mem_names, (linked_item_t *) item);
0151D6  780088     MOV W8, W1
0151D8  271160     MOV #0x7116, W0
0151DA  0263E6     CALL linked_list_add
0151DC  000001     NOP
0151DE  200011     MOV #0x1, W1
79:                	
80:                	return 1;
81:                }
82:                
83:                static int get_link_key(bd_addr_t *bd_addr, link_key_t *link_key) {
84:                    db_mem_device_link_key_t * item = (db_mem_device_link_key_t *) get_item(db_mem_link_keys, bd_addr);
0151EC  8388C0     MOV db_mem_link_keys, W0
0151EE  780082     MOV W2, W1
0151F0  025C40     CALL get_item
0151F2  000001     NOP
0151F4  780400     MOV W0, W8
85:                    
86:                    if (!item) return 0;
0151F6  E00000     CP0 W0
0151F8  3A0002     BRA NZ, 0x151FE
0151FA  780080     MOV W0, W1
0151FC  37000E     BRA 0x1521A
87:                    
88:                    memcpy(link_key, item->link_key, LINK_KEY_LEN);
0151FE  40006A     ADD W0, #0xA, W0
015200  09000F     REPEAT #0xF
015202  785CB0     MOV.B [W0++], [W9++]
015204  B10109     SUB #0x10, W9
015206  B10100     SUB #0x10, W0
89:                    
90:                	linked_list_remove(&db_mem_link_keys, (linked_item_t *) item);
015208  780088     MOV W8, W1
01520A  271180     MOV #0x7118, W0
01520C  0263FC     CALL linked_list_remove
01520E  000001     NOP
91:                    linked_list_add(&db_mem_link_keys, (linked_item_t *) item);
015210  780088     MOV W8, W1
015212  271180     MOV #0x7118, W0
015214  0263E6     CALL linked_list_add
015216  000001     NOP
015218  200011     MOV #0x1, W1
92:                
93:                	return 1;
94:                }
95:                
96:                static void delete_link_key(bd_addr_t *bd_addr){
97:                    db_mem_device_t * item = get_item(db_mem_link_keys, bd_addr);
015DBE  8388C0     MOV db_mem_link_keys, W0
015DC0  025C40     CALL get_item
015DC2  000001     NOP
015DC4  780400     MOV W0, W8
98:                    
99:                    if (!item) return;
015DC6  E00000     CP0 W0
015DC8  320007     BRA Z, 0x15DD8
100:                   
101:                   linked_list_remove(&db_mem_link_keys, (linked_item_t *) item);
015DCA  780080     MOV W0, W1
015DCC  271180     MOV #0x7118, W0
015DCE  0263FC     CALL linked_list_remove
015DD0  000001     NOP
102:                   btstack_memory_db_mem_device_link_key_free(item);
015DD2  780008     MOV W8, W0
015DD4  0266A4     CALL btstack_memory_db_mem_device_link_key_free
015DD6  000001     NOP
103:               }
104:               
105:               
106:               static void put_link_key(bd_addr_t *bd_addr, link_key_t *link_key){
107:                   db_mem_device_link_key_t * existingRecord = (db_mem_device_link_key_t *) get_item(db_mem_link_keys, bd_addr);
014914  8388C0     MOV db_mem_link_keys, W0
014916  780088     MOV W8, W1
014918  025C40     CALL get_item
01491A  000001     NOP
108:                   
109:                   if (existingRecord){
01491C  E00000     CP0 W0
01491E  320006     BRA Z, 0x1492C
110:                       memcpy(existingRecord->link_key, link_key, LINK_KEY_LEN);
014920  40006A     ADD W0, #0xA, W0
014922  09000F     REPEAT #0xF
014924  785839     MOV.B [W9++], [W0++]
014926  B10100     SUB #0x10, W0
014928  B10109     SUB #0x10, W9
01492A  370018     BRA 0x1495C
111:                       return;
112:                   }
113:                   
114:                   // Record not found, create new one for this device
115:                   db_mem_device_link_key_t * newItem = (db_mem_device_link_key_t*) btstack_memory_db_mem_device_link_key_get();
01492C  026708     CALL btstack_memory_db_mem_device_link_key_get
01492E  000001     NOP
014930  780080     MOV W0, W1
116:                   if (!newItem){
014932  E00000     CP0 W0
014934  3A0006     BRA NZ, 0x14942
117:                       newItem = (db_mem_device_link_key_t*)linked_list_get_last_item(&db_mem_link_keys);
014936  271180     MOV #0x7118, W0
014938  0264AC     CALL linked_list_get_last_item
01493A  000001     NOP
01493C  780080     MOV W0, W1
118:                   }
119:                   
120:                   if (!newItem) return;
01493E  E00000     CP0 W0
014940  32000D     BRA Z, 0x1495C
121:                   
122:                   memcpy(newItem->device.bd_addr, bd_addr, sizeof(bd_addr_t));
014942  408064     ADD W1, #0x4, W0
014944  090005     REPEAT #0x5
014946  785838     MOV.B [W8++], [W0++]
014948  B10060     SUB #0x6, W0
01494A  B10068     SUB #0x6, W8
123:                   memcpy(newItem->link_key, link_key, LINK_KEY_LEN);
01494C  40806A     ADD W1, #0xA, W0
01494E  09000F     REPEAT #0xF
014950  785839     MOV.B [W9++], [W0++]
014952  B10100     SUB #0x10, W0
014954  B10109     SUB #0x10, W9
124:                   linked_list_add(&db_mem_link_keys, (linked_item_t *) newItem);
014956  271180     MOV #0x7118, W0
014958  0263E6     CALL linked_list_add
01495A  000001     NOP
125:               }
126:               
127:               static void delete_name(bd_addr_t *bd_addr){
128:                   db_mem_device_t * item = get_item(db_mem_names, bd_addr);
015DE0  8388B0     MOV db_mem_names, W0
015DE2  025C40     CALL get_item
015DE4  000001     NOP
015DE6  780400     MOV W0, W8
129:                   
130:                   if (!item) return;
015DE8  E00000     CP0 W0
015DEA  320007     BRA Z, 0x15DFA
131:                   
132:                   linked_list_remove(&db_mem_names, (linked_item_t *) item);
015DEC  780080     MOV W0, W1
015DEE  271160     MOV #0x7116, W0
015DF0  0263FC     CALL linked_list_remove
015DF2  000001     NOP
133:                   btstack_memory_db_mem_device_name_free(item);    
015DF4  780008     MOV W8, W0
015DF6  026784     CALL btstack_memory_db_mem_device_name_free
015DF8  000001     NOP
134:               }
135:               
136:               static void put_name(bd_addr_t *bd_addr, device_name_t *device_name){
137:                   db_mem_device_name_t * existingRecord = (db_mem_device_name_t *) get_item(db_mem_names, bd_addr);
014674  8388B0     MOV db_mem_names, W0
014676  780089     MOV W9, W1
014678  025C40     CALL get_item
01467A  000001     NOP
138:                   
139:                   if (existingRecord){
01467C  E00000     CP0 W0
01467E  320006     BRA Z, 0x1468C
140:                       strncpy(existingRecord->device_name, (const char*) device_name, MAX_NAME_LEN);
014680  40006A     ADD W0, #0xA, W0
014682  200202     MOV #0x20, W2
014684  78008A     MOV W10, W1
014686  02575C     CALL strncpy
014688  000000     NOP
01468A  370019     BRA 0x146BE
141:                       return;
142:                   }
143:                   
144:                   // Record not found, create a new one for this device
145:                   db_mem_device_name_t * newItem = (db_mem_device_name_t *) btstack_memory_db_mem_device_name_get();
01468C  026782     CALL btstack_memory_db_mem_device_name_get
01468E  000001     NOP
014690  780400     MOV W0, W8
146:                   if (!newItem) {
014692  E00000     CP0 W0
014694  3A0006     BRA NZ, 0x146A2
147:                       newItem = (db_mem_device_name_t*)linked_list_get_last_item(&db_mem_names);
014696  271160     MOV #0x7116, W0
014698  0264AC     CALL linked_list_get_last_item
01469A  000001     NOP
01469C  780400     MOV W0, W8
148:                   };
149:               
150:                   if (!newItem) return;
01469E  E00000     CP0 W0
0146A0  32000E     BRA Z, 0x146BE
151:                   
152:                   memcpy(newItem->device.bd_addr, bd_addr, sizeof(bd_addr_t));
0146A2  440064     ADD W8, #0x4, W0
0146A4  090005     REPEAT #0x5
0146A6  785839     MOV.B [W9++], [W0++]
0146A8  B10060     SUB #0x6, W0
0146AA  B10069     SUB #0x6, W9
153:                   strncpy(newItem->device_name, (const char*) device_name, MAX_NAME_LEN);
0146AC  44006A     ADD W8, #0xA, W0
0146AE  200202     MOV #0x20, W2
0146B0  78008A     MOV W10, W1
0146B2  02575C     CALL strncpy
0146B4  000000     NOP
154:                   linked_list_add(&db_mem_names, (linked_item_t *) newItem);
0146B6  780088     MOV W8, W1
0146B8  271160     MOV #0x7116, W0
0146BA  0263E6     CALL linked_list_add
0146BC  000001     NOP
155:               }
156:               
157:               
158:               // MARK: PERSISTENT RFCOMM CHANNEL ALLOCATION
159:               
160:               static uint8_t persistent_rfcomm_channel(char *serviceName){
161:                   linked_item_t *it;
162:                   db_mem_service_t * item;
163:                   uint8_t max_channel = 1;
164:               
165:                   for (it = (linked_item_t *) db_mem_services; it ; it = it->next){
0146CA  80FFE8     MOV db_mem_services, W8
0146CC  B3C019     MOV #0x1, W9
0146CE  37000C     BRA 0x146E8
0146E6  780418     MOV [W8], W8
0146E8  E00008     CP0 W8
0146EA  3AFFF2     BRA NZ, 0x146D0
166:                       item = (db_mem_service_t *) it;
167:                       if (strncmp(item->service_name, serviceName, MAX_NAME_LEN) == 0) {
0146D0  440064     ADD W8, #0x4, W0
0146D2  200202     MOV #0x20, W2
0146D4  78008A     MOV W10, W1
0146D6  025930     CALL strncmp
0146D8  000000     NOP
0146DA  9060C8     MOV.B [W8+36], W1
0146DC  E00000     CP0 W0
0146DE  32000D     BRA Z, 0x146FA
168:                           // Match found
169:                           return item->channel;
0146FA  FB8081     ZE W1, W1
0146FC  37000B     BRA 0x14714
170:                       }
171:               
172:                       // TODO prevent overflow
173:                       if (item->channel >= max_channel) max_channel = item->channel + 1;
0146E0  50CF89     SUB.B W1, W9, [W15]
0146E2  390001     BRA NC, 0x146E6
0146E4  E84481     INC.B W1, W9
174:                   }
175:               
176:                   // Allocate new persistant channel
177:                   db_mem_service_t * newItem = (db_mem_service_t *) btstack_memory_db_mem_service_get();
0146EC  026786     CALL btstack_memory_db_mem_service_get
0146EE  000001     NOP
0146F0  780400     MOV W0, W8
178:               
179:                   if (!newItem) return 0;
0146F2  E00000     CP0 W0
0146F4  3A0004     BRA NZ, 0x146FE
0146F6  780080     MOV W0, W1
0146F8  37000D     BRA 0x14714
180:                   
181:                   strncpy(newItem->service_name, serviceName, MAX_NAME_LEN);
0146FE  400064     ADD W0, #0x4, W0
014700  200202     MOV #0x20, W2
014702  78008A     MOV W10, W1
014704  02575C     CALL strncpy
014706  000000     NOP
182:                   newItem->channel = max_channel;
014708  986449     MOV.B W9, [W8+36]
183:                   linked_list_add(&db_mem_services, (linked_item_t *) newItem);
01470A  780088     MOV W8, W1
01470C  21FFC0     MOV #0x1FFC, W0
01470E  0263E6     CALL linked_list_add
014710  000001     NOP
184:                   return max_channel;
014712  FB8089     ZE W9, W1
185:               }
186:               
187:               
188:               const remote_device_db_t remote_device_db_memory = {
189:                   db_open,
190:                   db_close,
191:                   get_link_key,
192:                   put_link_key,
193:                   delete_link_key,
194:                   get_name,
195:                   put_name,
196:                   delete_name,
197:                   persistent_rfcomm_channel
198:               };
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libbtstack/src/memory_pool.c
0165D6  780080     MOV W0, W1
1:                 /*
2:                  * Copyright (C) 2009-2012 by Matthias Ringwald
3:                  *
4:                  * Redistribution and use in source and binary forms, with or without
5:                  * modification, are permitted provided that the following conditions
6:                  * are met:
7:                  *
8:                  * 1. Redistributions of source code must retain the above copyright
9:                  *    notice, this list of conditions and the following disclaimer.
10:                 * 2. Redistributions in binary form must reproduce the above copyright
11:                 *    notice, this list of conditions and the following disclaimer in the
12:                 *    documentation and/or other materials provided with the distribution.
13:                 * 3. Neither the name of the copyright holders nor the names of
14:                 *    contributors may be used to endorse or promote products derived
15:                 *    from this software without specific prior written permission.
16:                 * 4. Any redistribution, use, or modification is done solely for
17:                 *    personal benefit and not for any commercial purpose or for
18:                 *    monetary gain.
19:                 *
20:                 * THIS SOFTWARE IS PROVIDED BY MATTHIAS RINGWALD AND CONTRIBUTORS
21:                 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
22:                 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
23:                 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MATTHIAS
24:                 * RINGWALD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
25:                 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
26:                 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
27:                 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
28:                 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
29:                 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
30:                 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
31:                 * SUCH DAMAGE.
32:                 *
33:                 * Please inquire about commercial licensing options at btstack@ringwald.ch
34:                 *
35:                 */
36:                
37:                /*
38:                 *  memory_pool.c
39:                 *
40:                 *  Fixed-size block allocation
41:                 *
42:                 *  Free blocks are kept in singly linked list
43:                 *
44:                 */
45:                
46:                #include <btstack/memory_pool.h>
47:                #include <stddef.h>
48:                
49:                typedef struct node {
50:                    struct node * next;
51:                } node_t;
52:                
53:                void memory_pool_create(memory_pool_t *pool, void * storage, int count, int block_size){
54:                    node_t *free_blocks = (node_t*) pool;
55:                    char   *mem_ptr = (char *) storage;
56:                    int i;
57:                    
58:                    // create singly linked list of all available blocks
59:                    free_blocks->next = NULL;
016450  EB0800     CLR [W0]
016452  EB0200     CLR W4
016454  370004     BRA 0x1645E
60:                    for (i = 0 ; i < count ; i++){
01645C  E80204     INC W4, W4
01645E  520F82     SUB W4, W2, [W15]
016460  35FFFA     BRA LT, 0x16456
61:                        memory_pool_free(pool, mem_ptr);
62:                        mem_ptr += block_size;
01645A  408083     ADD W1, W3, W1
63:                    }
64:                }
65:                
66:                void * memory_pool_get(memory_pool_t *pool){
67:                    node_t *free_blocks = (node_t*) pool;
68:                    
69:                    if (!free_blocks->next) return NULL;
0165D8  780010     MOV [W0], W0
0165DA  E00000     CP0 W0
0165DC  320001     BRA Z, 0x165E0
70:                    
71:                    // remove first
72:                    node_t *node      = free_blocks->next;
73:                    free_blocks->next = node->next;
0165DE  780890     MOV [W0], [W1]
74:                    
75:                    return (void*) node;
76:                }
77:                
78:                void memory_pool_free(memory_pool_t *pool, void * block){
79:                    node_t *free_blocks = (node_t*) pool;
80:                    node_t *node        = (node_t*) block;
81:                    // add block as node to list
82:                    node->next          = free_blocks->next;
016456  780890     MOV [W0], [W1]
016732  780890     MOV [W0], [W1]
83:                    free_blocks->next   = node;
016458  780801     MOV W1, [W0]
016734  780801     MOV W1, [W0]
84:                }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libbtstack/src/linked_list.c
0163FC  370006     BRA 0x1640A
01643C  370003     BRA 0x16444
0165CA  780080     MOV W0, W1
1:                 /*
2:                  * Copyright (C) 2009-2012 by Matthias Ringwald
3:                  *
4:                  * Redistribution and use in source and binary forms, with or without
5:                  * modification, are permitted provided that the following conditions
6:                  * are met:
7:                  *
8:                  * 1. Redistributions of source code must retain the above copyright
9:                  *    notice, this list of conditions and the following disclaimer.
10:                 * 2. Redistributions in binary form must reproduce the above copyright
11:                 *    notice, this list of conditions and the following disclaimer in the
12:                 *    documentation and/or other materials provided with the distribution.
13:                 * 3. Neither the name of the copyright holders nor the names of
14:                 *    contributors may be used to endorse or promote products derived
15:                 *    from this software without specific prior written permission.
16:                 * 4. Any redistribution, use, or modification is done solely for
17:                 *    personal benefit and not for any commercial purpose or for
18:                 *    monetary gain.
19:                 *
20:                 * THIS SOFTWARE IS PROVIDED BY MATTHIAS RINGWALD AND CONTRIBUTORS
21:                 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
22:                 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
23:                 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MATTHIAS
24:                 * RINGWALD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
25:                 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
26:                 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
27:                 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
28:                 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
29:                 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
30:                 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
31:                 * SUCH DAMAGE.
32:                 *
33:                 * Please inquire about commercial licensing options at btstack@ringwald.ch
34:                 *
35:                 */
36:                
37:                /*
38:                 *  linked_list.c
39:                 *
40:                 *  Created by Matthias Ringwald on 7/13/09.
41:                 */
42:                
43:                #include <btstack/linked_list.h>
44:                #include <stdlib.h>
45:                /**
46:                 * tests if list is empty
47:                 */
48:                int  linked_list_empty(linked_list_t * list){
0165CC  EA0010     NEG [W0], W0
0165CE  700011     IOR W0, [W1], W0
0165D0  DE004F     LSR W0, #15, W0
0165D2  100061     SUBR W0, #0x1, W0
49:                    return *list == (void *) 0;
50:                }
51:                
52:                /**
53:                 * linked_list_get_last_item
54:                 */
55:                linked_item_t * linked_list_get_last_item(linked_list_t * list){        // <-- find the last item in the list
56:                    linked_item_t *lastItem = NULL;
57:                    linked_item_t *it;
58:                    for (it = *list; it ; it = it->next){
0164AC  780010     MOV [W0], W0
0164AE  EB0080     CLR W1
0164B0  370002     BRA 0x164B6
0164B2  780080     MOV W0, W1
0164B4  780010     MOV [W0], W0
0164B6  E00000     CP0 W0
0164B8  3AFFFC     BRA NZ, 0x164B2
59:                        if (it) {
60:                            lastItem = it;
61:                        }
62:                    }
63:                    return lastItem;
64:                }
65:                
66:                
67:                /**
68:                 * linked_list_add
69:                 */
70:                void linked_list_add(linked_list_t * list, linked_item_t *item){        // <-- add item to list
71:                    // check if already in list
72:                    linked_item_t *it;
73:                    for (it = *list; it ; it = it->next){
0163E6  780190     MOV [W0], W3
0163E8  780103     MOV W3, W2
0163EA  370003     BRA 0x163F2
0163F0  780112     MOV [W2], W2
0163F2  E00002     CP0 W2
0163F4  3AFFFB     BRA NZ, 0x163EC
74:                        if (it == item) {
0163EC  510F81     SUB W2, W1, [W15]
0163EE  320005     BRA Z, 0x163FA
75:                            return;
76:                        }
77:                    }
78:                    // add first
79:                    item->next = *list;
0163F6  780883     MOV W3, [W1]
80:                    *list = item;
81:                }
82:                
83:                void linked_list_add_tail(linked_list_t * list, linked_item_t *item){   // <-- add item to list as last element
84:                    // check if already in list
85:                    linked_item_t *it;
86:                    for (it = (linked_item_t *) list; it->next ; it = it->next){
016444  780110     MOV [W0], W2
016446  E00002     CP0 W2
016448  3AFFFA     BRA NZ, 0x1643E
87:                        if (it->next == item) {
01643E  510F81     SUB W2, W1, [W15]
016440  320006     BRA Z, 0x1644E
88:                            return;
016442  780002     MOV W2, W0
89:                        }
90:                    }
91:                    item->next = (linked_item_t*) 0;
01644A  780882     MOV W2, [W1]
92:                    it->next = item;
93:                }
94:                
95:                /**
96:                 * Remove data_source from run loop
97:                 *
98:                 * @note: assumes that data_source_t.next is first element in data_source
99:                 */
100:               int  linked_list_remove(linked_list_t * list, linked_item_t *item){    // <-- remove item from list
101:                   linked_item_t *it;
102:                   for (it = (linked_item_t *) list; it ; it = it->next){
01640A  E00000     CP0 W0
01640C  3AFFF8     BRA NZ, 0x163FE
01640E  EB8000     SETM W0
103:                       if (it->next == item){
0163FE  780110     MOV [W0], W2
016400  510F81     SUB W2, W1, [W15]
016402  3A0002     BRA NZ, 0x16408
104:                           it->next =  item->next;
016404  780812     MOV [W2], [W0]
016406  050000     RETLW #0x0, W0
105:                           return 0;
016408  780002     MOV W2, W0
106:                       }
107:                   }
108:                   return -1;
109:               }
110:               
111:               void linked_item_set_user(linked_item_t *item, void *user_data){
112:                   item->next = (linked_item_t *) 0;
016726  EB0800     CLR [W0]
113:                   item->user_data = user_data;
016728  980011     MOV W1, [W0+2]
114:               }
115:               
116:               void * linked_item_get_user(linked_item_t *item) {
01676C  900010     MOV [W0+2], W0
117:                   return item->user_data;
118:               }
119:               
120:               #if 0
121:               #include <stdio.h>
122:               void test_linked_list(){
123:                   linked_list_t testList = 0;
124:                   linked_item_t itemA;
125:                   linked_item_t itemB;
126:                   linked_item_t itemC;
127:                   linked_item_set_user(&itemA, (void *) 0);
128:                   linked_item_set_user(&itemB, (void *) 0);
129:                   linked_list_add(&testList, &itemA);
130:                   linked_list_add(&testList, &itemB);
131:                   linked_list_add_tail(&testList, &itemC);
132:                   // linked_list_remove(&testList, &itemB);
133:                   linked_item_t *it;
134:                   for (it = (linked_item_t *) &testList; it ; it = it->next){
135:                       if (it->next == &itemA) printf("Item A\n");
136:                       if (it->next == &itemB) printf("Item B\n");
137:                       if (it->next == &itemC) printf("Item C\n");
138:                       /* if (it->next == &itemB){
139:                           it->next =  it->next;
140:                           printf(" remove\n");
141:                       } else {
142:                           printf(" keep\n");
143:                       
144:                        */
145:                   }
146:               }
147:               #endif
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libbtstack/src/l2cap_signaling.c
0134D8  BE9F88     MOV.D W8, [W15++]
0134DA  BE9F8A     MOV.D W10, [W15++]
0134DC  781F8C     MOV W12, [W15++]
0134DE  780500     MOV W0, W10
0134E0  780001     MOV W1, W0
0134E2  780482     MOV W2, W9
0134E4  784403     MOV.B W3, W8
0134E6  780604     MOV W4, W12
1:                 /*
2:                  * Copyright (C) 2009-2012 by Matthias Ringwald
3:                  *
4:                  * Redistribution and use in source and binary forms, with or without
5:                  * modification, are permitted provided that the following conditions
6:                  * are met:
7:                  *
8:                  * 1. Redistributions of source code must retain the above copyright
9:                  *    notice, this list of conditions and the following disclaimer.
10:                 * 2. Redistributions in binary form must reproduce the above copyright
11:                 *    notice, this list of conditions and the following disclaimer in the
12:                 *    documentation and/or other materials provided with the distribution.
13:                 * 3. Neither the name of the copyright holders nor the names of
14:                 *    contributors may be used to endorse or promote products derived
15:                 *    from this software without specific prior written permission.
16:                 * 4. Any redistribution, use, or modification is done solely for
17:                 *    personal benefit and not for any commercial purpose or for
18:                 *    monetary gain.
19:                 *
20:                 * THIS SOFTWARE IS PROVIDED BY MATTHIAS RINGWALD AND CONTRIBUTORS
21:                 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
22:                 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
23:                 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MATTHIAS
24:                 * RINGWALD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
25:                 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
26:                 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
27:                 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
28:                 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
29:                 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
30:                 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
31:                 * SUCH DAMAGE.
32:                 *
33:                 * Please inquire about commercial licensing options at btstack@ringwald.ch
34:                 *
35:                 */
36:                
37:                /*
38:                 *  l2cap_signaling.h
39:                 *
40:                 *  Created by Matthias Ringwald on 7/23/09.
41:                 */
42:                
43:                #include "l2cap_signaling.h"
44:                
45:                #include <string.h>
46:                
47:                static char *l2cap_signaling_commands_format[] = {
48:                "D",    // 0x01 command reject: reason {cmd not understood (0), sig MTU exceeded (2:max sig MTU), invalid CID (4:req CID)}, data len, data
49:                "22",   // 0x02 connection request: PSM, Source CID
50:                "2222", // 0x03 connection response: Dest CID, Source CID, Result, Status
51:                "22D",  // 0x04 config request: Dest CID, Flags, Configuration options
52:                "222D", // 0x05 config response: Source CID, Flags, Result, Configuration options
53:                "22",   // 0x06 disconection request: Dest CID, Source CID
54:                "22",   // 0x07 disconection response: Dest CID, Source CID
55:                "D",    // 0x08 echo request: Data
56:                "D",    // 0x09 echo response: Data
57:                "2",    // 0x0a information request: InfoType {1=Connectionless MTU, 2=Extended features supported}
58:                "22D",  // 0x0b information response: InfoType, Result, Data
59:                };
60:                
61:                uint8_t   sig_seq_nr  = 0xff;
62:                uint16_t  source_cid  = 0x40;
63:                
64:                uint8_t l2cap_next_sig_id(void){
65:                    if (sig_seq_nr == 0xff) {
016412  26E7E1     MOV #0x6E7E, W1
016414  784011     MOV.B [W1], W0
016416  404FE1     ADD.B W0, #0x1, [W15]
016418  3A0003     BRA NZ, 0x16420
66:                        sig_seq_nr = 1;
01641A  B3C010     MOV #0x1, W0
01641C  784880     MOV.B W0, [W1]
01641E  370001     BRA 0x16422
67:                    } else {
68:                        sig_seq_nr++;
016420  E84880     INC.B W0, [W1]
016422  26E7E0     MOV #0x6E7E, W0
016424  FB8010     ZE [W0], W0
69:                    }
70:                    return sig_seq_nr;
71:                }
72:                
73:                uint16_t l2cap_next_local_cid(void){
74:                    return source_cid++;
0166C4  8373E0     MOV source_cid, W0
0166C6  E80080     INC W0, W1
0166C8  8B73E1     MOV W1, source_cid
75:                }
76:                
77:                uint16_t l2cap_create_signaling_internal(uint8_t * acl_buffer, hci_con_handle_t handle, L2CAP_SIGNALING_COMMANDS cmd, uint8_t identifier, va_list argptr){
78:                    
79:                    // 0 - Connection handle : PB=10 : BC=00 
80:                    bt_store_16(acl_buffer, 0, handle | (2 << 12) | (0 << 14));
0134E8  A0D000     BSET W0, #13
0134EA  780100     MOV W0, W2
0134EC  EB0080     CLR W1
0134EE  78000A     MOV W10, W0
0134F0  026614     CALL bt_store_16
0134F2  000001     NOP
81:                    // 6 - L2CAP channel = 1
82:                    bt_store_16(acl_buffer, 6, 1);
0134F4  200012     MOV #0x1, W2
0134F6  200061     MOV #0x6, W1
0134F8  78000A     MOV W10, W0
0134FA  026614     CALL bt_store_16
0134FC  000001     NOP
83:                    // 8 - Code
84:                    acl_buffer[8] = cmd;
0134FE  984D09     MOV.B W9, [W10+8]
85:                    // 9 - id (!= 0 sequentially)
86:                    acl_buffer[9] = identifier;
013500  984D18     MOV.B W8, [W10+9]
87:                    
88:                    // 12 - L2CAP signaling parameters
89:                    uint16_t pos = 12;
90:                    const char *format = l2cap_signaling_commands_format[cmd-1];
013502  448009     ADD W9, W9, W0
013504  E98080     DEC2 W0, W1
013506  26E800     MOV #0x6E80, W0
013508  7885E0     MOV [W0+W1], W11
01350A  2000C9     MOV #0xC, W9
01350C  37001F     BRA 0x1354C
91:                    uint16_t word;
92:                    uint8_t * ptr;
93:                    while (*format) {
01354C  78409B     MOV.B [W11], W1
01354E  E00401     CP0.B W1
013550  3AFFDE     BRA NZ, 0x1350E
94:                        switch(*format) {
01350E  B3C310     MOV #0x31, W0
013510  50CF80     SUB.B W1, W0, [W15]
013512  35001B     BRA LT, 0x1354A
013514  B3C322     MOV #0x32, W2
013516  50CF82     SUB.B W1, W2, [W15]
013518  340004     BRA LE, 0x13522
01351A  404073     ADD.B W0, #0x13, W0
01351C  50CF80     SUB.B W1, W0, [W15]
01351E  3A0015     BRA NZ, 0x1354A
013520  37000B     BRA 0x13538
95:                            case '1': //  8 bit value
96:                            case '2': // 16 bit value
97:                                word = va_arg(argptr, int);
013522  78004C     MOV [--W12], W0
98:                                // minimal va_arg is int: 2 bytes on 8+16 bit CPUs
99:                                acl_buffer[pos++] = word & 0xff;
013524  7CF500     MOV.B W0, [W10+W9]
013526  E80089     INC W9, W1
100:                               if (*format == '2') {
013528  114F9B     SUBR.B W2, [W11], [W15]
01352A  320002     BRA Z, 0x13530
01352C  780481     MOV W1, W9
01352E  37000D     BRA 0x1354A
101:                                   acl_buffer[pos++] = word >> 8;
013530  DE0048     LSR W0, #8, W0
013532  78F500     MOV.B W0, [W10+W1]
013534  E88489     INC2 W9, W9
013536  370009     BRA 0x1354A
102:                               }
103:                               break;
104:                           case 'D': // variable data. passed: len, ptr
105:                               word = va_arg(argptr, int);
013538  E9800C     DEC2 W12, W0
01353A  780420     MOV [W0--], W8
106:                               ptr  = va_arg(argptr, uint8_t *);
01353C  780600     MOV W0, W12
107:                               memcpy(&acl_buffer[pos], ptr, word);
01353E  450009     ADD W10, W9, W0
013540  78009C     MOV [W12], W1
013542  780108     MOV W8, W2
013544  0256DE     CALL memcpy
013546  000000     NOP
108:                               pos += word;
013548  448488     ADD W9, W8, W9
109:                               break;
110:                           default:
111:                               break;
112:                       }
113:                       format++;
01354A  E8058B     INC W11, W11
114:                   };
115:                   va_end(argptr);
116:                   
117:                   // Fill in various length fields: it's the number of bytes following for ACL lenght and l2cap parameter length
118:                   // - the l2cap payload length is counted after the following channel id (only payload) 
119:                   
120:                   // 2 - ACL length
121:                   bt_store_16(acl_buffer, 2,  pos - 4);
013552  548164     SUB W9, #0x4, W2
013554  200021     MOV #0x2, W1
013556  78000A     MOV W10, W0
013558  026614     CALL bt_store_16
01355A  000001     NOP
122:                   // 4 - L2CAP packet length
123:                   bt_store_16(acl_buffer, 4,  pos - 6 - 2);
01355C  548168     SUB W9, #0x8, W2
01355E  200041     MOV #0x4, W1
013560  78000A     MOV W10, W0
013562  026614     CALL bt_store_16
013564  000001     NOP
124:                   // 10 - L2CAP signaling parameter length
125:                   bt_store_16(acl_buffer, 10, pos - 12);
013566  54816C     SUB W9, #0xC, W2
013568  2000A1     MOV #0xA, W1
01356A  78000A     MOV W10, W0
01356C  026614     CALL bt_store_16
01356E  000001     NOP
126:                   
127:                   return pos;
128:               }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libbtstack/src/l2cap.c  --
011204  FA0008     LNK #0x8
011206  BE9F88     MOV.D W8, [W15++]
011208  781F8A     MOV W10, [W15++]
01120A  370049     BRA 0x1129E
011F74  FA0006     LNK #0x6
011F76  BE9F88     MOV.D W8, [W15++]
011F78  BE9F8A     MOV.D W10, [W15++]
011F7A  781F8C     MOV W12, [W15++]
011F7C  780480     MOV W0, W9
011F7E  780601     MOV W1, W12
012270  4787F4     ADD W15, #0x14, W15
012272  BE9F88     MOV.D W8, [W15++]
012274  BE9F8A     MOV.D W10, [W15++]
012276  BE9F8C     MOV.D W12, [W15++]
012278  781F8E     MOV W14, [W15++]
01227A  780580     MOV W0, W11
01227C  780181     MOV W1, W3
01305C  BE9F88     MOV.D W8, [W15++]
01305E  780400     MOV W0, W8
013060  780101     MOV W1, W2
013616  BE9F88     MOV.D W8, [W15++]
013618  BE9F8A     MOV.D W10, [W15++]
01361A  781F8C     MOV W12, [W15++]
01361C  780480     MOV W0, W9
01361E  780601     MOV W1, W12
013AFA  FA0022     LNK #0x22
013AFC  BE9F88     MOV.D W8, [W15++]
013AFE  BE9F8A     MOV.D W10, [W15++]
013B00  BE9F8C     MOV.D W12, [W15++]
013B02  BE0600     MOV.D W0, W12
013B04  BE0502     MOV.D W2, W10
013B06  780484     MOV W4, W9
013B76  BE9F88     MOV.D W8, [W15++]
013B78  BE9F8A     MOV.D W10, [W15++]
013B7A  780580     MOV W0, W11
013B7C  780501     MOV W1, W10
013CDA  FA0016     LNK #0x16
013CDC  781F88     MOV W8, [W15++]
013CDE  780400     MOV W0, W8
014344  BE9F88     MOV.D W8, [W15++]
014346  BE9F8A     MOV.D W10, [W15++]
014348  780480     MOV W0, W9
01434A  780581     MOV W1, W11
01434C  780402     MOV W2, W8
01434E  780503     MOV W3, W10
01450A  BE9F88     MOV.D W8, [W15++]
01450C  BE9F8A     MOV.D W10, [W15++]
01450E  780480     MOV W0, W9
014510  780581     MOV W1, W11
014512  780502     MOV W2, W10
014D1A  BE9F88     MOV.D W8, [W15++]
014D1C  BE9F8A     MOV.D W10, [W15++]
014D1E  780580     MOV W0, W11
014D20  784501     MOV.B W1, W10
014D5E  780280     MOV W0, W5
014D60  780181     MOV W1, W3
014E20  FA0006     LNK #0x6
014E22  BE9F88     MOV.D W8, [W15++]
014E24  780400     MOV W0, W8
014E26  784481     MOV.B W1, W9
015048  781F88     MOV W8, [W15++]
015084  FA0000     LNK #0x0
015086  BE9F88     MOV.D W8, [W15++]
015088  781F8A     MOV W10, [W15++]
01508A  780500     MOV W0, W10
01508C  780481     MOV W1, W9
0150C0  BE9F88     MOV.D W8, [W15++]
0150C2  780480     MOV W0, W9
015220  BE9F88     MOV.D W8, [W15++]
015222  BE9F8A     MOV.D W10, [W15++]
015224  780580     MOV W0, W11
015226  780501     MOV W1, W10
015228  780482     MOV W2, W9
01522A  780403     MOV W3, W8
0152CA  FA0006     LNK #0x6
0152CC  781F88     MOV W8, [W15++]
0152CE  780400     MOV W0, W8
015448  FA0004     LNK #0x4
01544A  781F88     MOV W8, [W15++]
01544C  780400     MOV W0, W8
01547E  781F88     MOV W8, [W15++]
0154B4  BE9F88     MOV.D W8, [W15++]
0154B6  781F8A     MOV W10, [W15++]
0154B8  780500     MOV W0, W10
0154BA  780481     MOV W1, W9
0154BC  780402     MOV W2, W8
015800  781F88     MOV W8, [W15++]
015802  780280     MOV W0, W5
015804  784301     MOV.B W1, W6
015806  784382     MOV.B W2, W7
015808  780403     MOV W3, W8
015DFE  780100     MOV W0, W2
015EA2  781F88     MOV W8, [W15++]
015EC2  781F88     MOV W8, [W15++]
015EC4  780400     MOV W0, W8
015F5A  900B10     MOV [W0+18], W6
015F5C  784381     MOV.B W1, W7
015F78  780180     MOV W0, W3
01605C  780100     MOV W0, W2
016078  780100     MOV W0, W2
0161B8  780100     MOV W0, W2
0161D2  780100     MOV W0, W2
0161EC  780181     MOV W1, W3
0161EE  780082     MOV W2, W1
1:                 /*
2:                  * Copyright (C) 2009-2012 by Matthias Ringwald
3:                  *
4:                  * Redistribution and use in source and binary forms, with or without
5:                  * modification, are permitted provided that the following conditions
6:                  * are met:
7:                  *
8:                  * 1. Redistributions of source code must retain the above copyright
9:                  *    notice, this list of conditions and the following disclaimer.
10:                 * 2. Redistributions in binary form must reproduce the above copyright
11:                 *    notice, this list of conditions and the following disclaimer in the
12:                 *    documentation and/or other materials provided with the distribution.
13:                 * 3. Neither the name of the copyright holders nor the names of
14:                 *    contributors may be used to endorse or promote products derived
15:                 *    from this software without specific prior written permission.
16:                 * 4. Any redistribution, use, or modification is done solely for
17:                 *    personal benefit and not for any commercial purpose or for
18:                 *    monetary gain.
19:                 *
20:                 * THIS SOFTWARE IS PROVIDED BY MATTHIAS RINGWALD AND CONTRIBUTORS
21:                 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
22:                 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
23:                 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MATTHIAS
24:                 * RINGWALD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
25:                 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
26:                 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
27:                 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
28:                 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
29:                 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
30:                 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
31:                 * SUCH DAMAGE.
32:                 *
33:                 * Please inquire about commercial licensing options at btstack@ringwald.ch
34:                 *
35:                 */
36:                
37:                /*
38:                 *  l2cap.c
39:                 *
40:                 *  Logical Link Control and Adaption Protocl (L2CAP)
41:                 *
42:                 *  Created by Matthias Ringwald on 5/16/09.
43:                 */
44:                
45:                #include "l2cap.h"
46:                #include "hci.h"
47:                #include "hci_dump.h"
48:                #include "debug.h"
49:                #include "btstack_memory.h"
50:                
51:                #include <stdarg.h>
52:                #include <string.h>
53:                
54:                #include <stdio.h>
55:                
56:                // nr of buffered acl packets in outgoing queue to get max performance 
57:                #define NR_BUFFERED_ACL_PACKETS 3
58:                
59:                // used to cache l2cap rejects, echo, and informational requests
60:                #define NR_PENDING_SIGNALING_RESPONSES 3
61:                
62:                // offsets for L2CAP SIGNALING COMMANDS
63:                #define L2CAP_SIGNALING_COMMAND_CODE_OFFSET   0
64:                #define L2CAP_SIGNALING_COMMAND_SIGID_OFFSET  1
65:                #define L2CAP_SIGNALING_COMMAND_LENGTH_OFFSET 2
66:                #define L2CAP_SIGNALING_COMMAND_DATA_OFFSET   4
67:                
68:                static void null_packet_handler(void * connection, uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size);
69:                static void l2cap_packet_handler(uint8_t packet_type, uint8_t *packet, uint16_t size);
70:                
71:                // used to cache l2cap rejects, echo, and informational requests
72:                static l2cap_signaling_response_t signaling_responses[NR_PENDING_SIGNALING_RESPONSES];
73:                static int signaling_responses_pending;
74:                
75:                static linked_list_t l2cap_channels = NULL;
76:                static linked_list_t l2cap_services = NULL;
77:                static void (*packet_handler) (void * connection, uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size) = null_packet_handler;
78:                static int new_credits_blocked = 0;
79:                
80:                static btstack_packet_handler_t attribute_protocol_packet_handler = NULL;
81:                static btstack_packet_handler_t security_protocol_packet_handler = NULL;
82:                
83:                // prototypes
84:                static void l2cap_finialize_channel_close(l2cap_channel_t *channel);
85:                static l2cap_service_t * l2cap_get_service(uint16_t psm);
86:                static void l2cap_emit_channel_opened(l2cap_channel_t *channel, uint8_t status);
87:                static void l2cap_emit_channel_closed(l2cap_channel_t *channel);
88:                static void l2cap_emit_connection_request(l2cap_channel_t *channel);
89:                static int l2cap_channel_ready_for_open(l2cap_channel_t *channel);
90:                
91:                
92:                void l2cap_init(){
93:                    new_credits_blocked = 0;
015EA4  EB0400     CLR W8
015EA6  8B7338     MOV W8, new_credits_blocked
94:                    signaling_responses_pending = 0;
015EA8  8B7348     MOV W8, signaling_responses_pending
95:                    
96:                    l2cap_channels = NULL;
015EAA  8B7328     MOV W8, l2cap_channels
97:                    l2cap_services = NULL;
015EAC  8B7318     MOV W8, l2cap_services
98:                
99:                    packet_handler = null_packet_handler;
015EAE  2535C0     MOV #0x535C, W0
015EB0  8B88F0     MOV W0, packet_handler
100:                   
101:                   // 
102:                   // register callback with HCI
103:                   //
104:                   hci_register_packet_handler(&l2cap_packet_handler);
015EB2  253600     MOV #0x5360, W0
015EB4  026758     CALL hci_register_packet_handler
015EB6  000001     NOP
105:                   hci_connectable_control(0); // no services yet
015EB8  784008     MOV.B W8, W0
015EBA  026428     CALL hci_connectable_control
015EBC  000001     NOP
106:               }
107:               
108:               
109:               /** Register L2CAP packet handlers */
110:               static void null_packet_handler(void * connection, uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size){
111:               }
112:               void l2cap_register_packet_handler(void (*handler)(void * connection, uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size)){
113:                   packet_handler = handler;
016768  8B88F0     MOV W0, packet_handler
114:               }
115:               
116:               //  notify client/protocol handler
117:               void l2cap_dispatch(l2cap_channel_t *channel, uint8_t type, uint8_t * data, uint16_t size){
118:                   if (channel->packet_handler) {
015F5E  901280     MOV [W0+32], W5
015F60  E00005     CP0 W5
015F62  320003     BRA Z, 0x15F6A
119:                       (* (channel->packet_handler))(type, channel->local_cid, data, size);
015F64  780086     MOV W6, W1
015F66  784007     MOV.B W7, W0
015F68  014005     GOTO W5
120:                   } else {
121:                       (*packet_handler)(channel->connection, type, channel->local_cid, data, size);
122:                   }
123:               }
124:               
125:               void l2cap_emit_channel_opened(l2cap_channel_t *channel, uint8_t status) {
126:                   log_info("L2CAP_EVENT_CHANNEL_OPENED status 0x%x addr %s handle 0x%x psm 0x%x local_cid 0x%x remote_cid 0x%x local_mtu %u, remote_mtu %u",
127:                            status, bd_addr_to_str(channel->address), channel->handle, channel->psm,
128:                            channel->local_cid, channel->remote_cid, channel->local_mtu, channel->remote_mtu);
129:                   uint8_t event[21];
130:                   event[0] = L2CAP_EVENT_CHANNEL_OPENED;
013CE0  B3C700     MOV #0x70, W0
013CE2  9FEF80     MOV.B W0, [W15-24]
131:                   event[1] = sizeof(event) - 2;
013CE4  B3C130     MOV #0x13, W0
013CE6  9FEF90     MOV.B W0, [W15-23]
132:                   event[2] = status;
013CE8  9FEFA1     MOV.B W1, [W15-22]
133:                   bt_flip_addr(&event[3], channel->address);
013CEA  4400E8     ADD W8, #0x8, W1
013CEC  578075     SUB W15, #0x15, W0
013CEE  02616A     CALL bt_flip_addr
013CF0  000001     NOP
134:                   bt_store_16(event,  9, channel->handle);
013CF2  900178     MOV [W8+14], W2
013CF4  200091     MOV #0x9, W1
013CF6  578078     SUB W15, #0x18, W0
013CF8  026614     CALL bt_store_16
013CFA  000001     NOP
135:                   bt_store_16(event, 11, channel->psm);
013CFC  900958     MOV [W8+26], W2
013CFE  2000B1     MOV #0xB, W1
013D00  578078     SUB W15, #0x18, W0
013D02  026614     CALL bt_store_16
013D04  000001     NOP
136:                   bt_store_16(event, 13, channel->local_cid);
013D06  900918     MOV [W8+18], W2
013D08  2000D1     MOV #0xD, W1
013D0A  578078     SUB W15, #0x18, W0
013D0C  026614     CALL bt_store_16
013D0E  000001     NOP
137:                   bt_store_16(event, 15, channel->remote_cid);
013D10  900928     MOV [W8+20], W2
013D12  2000F1     MOV #0xF, W1
013D14  578078     SUB W15, #0x18, W0
013D16  026614     CALL bt_store_16
013D18  000001     NOP
138:                   bt_store_16(event, 17, channel->local_mtu);
013D1A  900938     MOV [W8+22], W2
013D1C  200111     MOV #0x11, W1
013D1E  578078     SUB W15, #0x18, W0
013D20  026614     CALL bt_store_16
013D22  000001     NOP
139:                   bt_store_16(event, 19, channel->remote_mtu); 
013D24  900948     MOV [W8+24], W2
013D26  200131     MOV #0x13, W1
013D28  578078     SUB W15, #0x18, W0
013D2A  026614     CALL bt_store_16
013D2C  000001     NOP
140:                   hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
013D2E  200153     MOV #0x15, W3
013D30  578178     SUB W15, #0x18, W2
013D32  EB4080     CLR.B W1
013D34  B3C040     MOV #0x4, W0
013D36  026798     CALL hci_dump_packet
013D38  000001     NOP
141:                   l2cap_dispatch(channel, HCI_EVENT_PACKET, event, sizeof(event));
013D3A  200153     MOV #0x15, W3
013D3C  578178     SUB W15, #0x18, W2
013D3E  B3C041     MOV #0x4, W1
013D40  780008     MOV W8, W0
013D42  025F5A     CALL l2cap_dispatch
013D44  000001     NOP
142:               }
143:               
144:               void l2cap_emit_channel_closed(l2cap_channel_t *channel) {
145:                   log_info("L2CAP_EVENT_CHANNEL_CLOSED local_cid 0x%x", channel->local_cid);
146:                   uint8_t event[4];
147:                   event[0] = L2CAP_EVENT_CHANNEL_CLOSED;
01544E  B3C710     MOV #0x71, W0
015450  9FFFA0     MOV.B W0, [W15-6]
148:                   event[1] = sizeof(event) - 2;
015452  B3C020     MOV #0x2, W0
015454  9FFFB0     MOV.B W0, [W15-5]
149:                   bt_store_16(event, 2, channel->local_cid);
015456  900918     MOV [W8+18], W2
015458  200021     MOV #0x2, W1
01545A  578066     SUB W15, #0x6, W0
01545C  026614     CALL bt_store_16
01545E  000001     NOP
150:                   hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
015460  200043     MOV #0x4, W3
015462  578166     SUB W15, #0x6, W2
015464  EB4080     CLR.B W1
015466  784003     MOV.B W3, W0
015468  026798     CALL hci_dump_packet
01546A  000001     NOP
151:                   l2cap_dispatch(channel, HCI_EVENT_PACKET, event, sizeof(event));
01546C  200043     MOV #0x4, W3
01546E  578166     SUB W15, #0x6, W2
015470  784083     MOV.B W3, W1
015472  780008     MOV W8, W0
015474  025F5A     CALL l2cap_dispatch
015476  000001     NOP
152:               }
153:               
154:               void l2cap_emit_connection_request(l2cap_channel_t *channel) {
155:                   log_info("L2CAP_EVENT_INCOMING_CONNECTION addr %s handle 0x%x psm 0x%x local_cid 0x%x remote_cid 0x%x",
156:                            bd_addr_to_str(channel->address), channel->handle,  channel->psm, channel->local_cid, channel->remote_cid);
157:                   uint8_t event[16];
158:                   event[0] = L2CAP_EVENT_INCOMING_CONNECTION;
012330  B3C720     MOV #0x72, W0
012332  9FE780     MOV.B W0, [W15-32]
159:                   event[1] = sizeof(event) - 2;
012334  B3C0E0     MOV #0xE, W0
012336  9FE790     MOV.B W0, [W15-31]
160:                   bt_flip_addr(&event[2], channel->address);
012338  78008E     MOV W14, W1
01233A  57807E     SUB W15, #0x1E, W0
01233C  02616A     CALL bt_flip_addr
01233E  000001     NOP
161:                   bt_store_16(event,  8, channel->handle);
012340  90017A     MOV [W10+14], W2
012342  200081     MOV #0x8, W1
012344  2FFE00     MOV #0xFFE0, W0
012346  40000F     ADD W0, W15, W0
012348  026614     CALL bt_store_16
01234A  000001     NOP
162:                   bt_store_16(event, 10, channel->psm);
01234C  90095A     MOV [W10+26], W2
01234E  2000A1     MOV #0xA, W1
012350  2FFE00     MOV #0xFFE0, W0
012352  40000F     ADD W0, W15, W0
012354  026614     CALL bt_store_16
012356  000001     NOP
163:                   bt_store_16(event, 12, channel->local_cid);
012358  90091A     MOV [W10+18], W2
01235A  2000C1     MOV #0xC, W1
01235C  2FFE00     MOV #0xFFE0, W0
01235E  40000F     ADD W0, W15, W0
012360  026614     CALL bt_store_16
012362  000001     NOP
164:                   bt_store_16(event, 14, channel->remote_cid);
012364  90092A     MOV [W10+20], W2
012366  2000E1     MOV #0xE, W1
012368  2FFE00     MOV #0xFFE0, W0
01236A  40000F     ADD W0, W15, W0
01236C  026614     CALL bt_store_16
01236E  000001     NOP
165:                   hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
012370  200103     MOV #0x10, W3
012372  2FFE02     MOV #0xFFE0, W2
012374  41010F     ADD W2, W15, W2
012376  784089     MOV.B W9, W1
012378  784008     MOV.B W8, W0
01237A  026798     CALL hci_dump_packet
01237C  000001     NOP
166:                   l2cap_dispatch(channel, HCI_EVENT_PACKET, event, sizeof(event));
01237E  200103     MOV #0x10, W3
012380  2FFE02     MOV #0xFFE0, W2
012382  41010F     ADD W2, W15, W2
012384  784088     MOV.B W8, W1
012386  78000A     MOV W10, W0
012388  025F5A     CALL l2cap_dispatch
01238A  000001     NOP
01238C  370028     BRA 0x123DE
167:               }
168:               
169:               static void l2cap_emit_service_registered(void *connection, uint8_t status, uint16_t psm){
170:                   log_info("L2CAP_EVENT_SERVICE_REGISTERED status 0x%x psm 0x%x", status, psm);
171:                   uint8_t event[5];
172:                   event[0] = L2CAP_EVENT_SERVICE_REGISTERED;
0152D0  B3C750     MOV #0x75, W0
0152D2  9FFF80     MOV.B W0, [W15-8]
173:                   event[1] = sizeof(event) - 2;
0152D4  B3C030     MOV #0x3, W0
0152D6  9FFF90     MOV.B W0, [W15-7]
174:                   event[2] = status;
0152D8  9FFFA1     MOV.B W1, [W15-6]
175:                   bt_store_16(event, 3, psm);
0152DA  200031     MOV #0x3, W1
0152DC  578068     SUB W15, #0x8, W0
0152DE  026614     CALL bt_store_16
0152E0  000001     NOP
176:                   hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
0152E2  200053     MOV #0x5, W3
0152E4  578168     SUB W15, #0x8, W2
0152E6  EB4080     CLR.B W1
0152E8  B3C040     MOV #0x4, W0
0152EA  026798     CALL hci_dump_packet
0152EC  000001     NOP
177:                   (*packet_handler)(connection, HCI_EVENT_PACKET, 0, event, sizeof(event));
0152EE  200054     MOV #0x5, W4
0152F0  5781E8     SUB W15, #0x8, W3
0152F2  EB0100     CLR W2
0152F4  B3C041     MOV #0x4, W1
0152F6  780008     MOV W8, W0
0152F8  8388F5     MOV packet_handler, W5
0152FA  010005     CALL W5
178:               }
179:               
180:               void l2cap_emit_credits(l2cap_channel_t *channel, uint8_t credits) {
181:                   
182:                   log_info("L2CAP_EVENT_CREDITS local_cid 0x%x credits %u", channel->local_cid, credits);
183:                   // track credits
184:                   channel->packets_granted += credits;
014E28  905840     MOV.B [W0+28], W0
014E2A  40C000     ADD.B W1, W0, W0
014E2C  985C40     MOV.B W0, [W8+28]
185:                   
186:                   uint8_t event[5];
187:                   event[0] = L2CAP_EVENT_CREDITS;
014E2E  B3C740     MOV #0x74, W0
014E30  9FF7E0     MOV.B W0, [W15-10]
188:                   event[1] = sizeof(event) - 2;
014E32  B3C030     MOV #0x3, W0
014E34  9FF7F0     MOV.B W0, [W15-9]
189:                   bt_store_16(event, 2, channel->local_cid);
014E36  900918     MOV [W8+18], W2
014E38  200021     MOV #0x2, W1
014E3A  57806A     SUB W15, #0xA, W0
014E3C  026614     CALL bt_store_16
014E3E  000001     NOP
190:                   event[4] = credits;
014E40  9FFFA9     MOV.B W9, [W15-6]
191:                   hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
014E42  200053     MOV #0x5, W3
014E44  57816A     SUB W15, #0xA, W2
014E46  EB4080     CLR.B W1
014E48  B3C040     MOV #0x4, W0
014E4A  026798     CALL hci_dump_packet
014E4C  000001     NOP
192:                   l2cap_dispatch(channel, HCI_EVENT_PACKET, event, sizeof(event));
014E4E  200053     MOV #0x5, W3
014E50  57816A     SUB W15, #0xA, W2
014E52  B3C041     MOV #0x4, W1
014E54  780008     MOV W8, W0
014E56  025F5A     CALL l2cap_dispatch
014E58  000001     NOP
193:               }
194:               
195:               void l2cap_block_new_credits(uint8_t blocked){
196:                   new_credits_blocked = blocked;
01670E  FB8000     ZE W0, W0
016710  8B7330     MOV W0, new_credits_blocked
197:               }
198:               
199:               void l2cap_hand_out_credits(void){
200:               
201:                   if (new_credits_blocked) return;    // we're told not to. used by daemon
01504A  837330     MOV new_credits_blocked, W0
01504C  E00000     CP0 W0
01504E  3A0018     BRA NZ, 0x15080
202:                   
203:                   linked_item_t *it;
204:                   for (it = (linked_item_t *) l2cap_channels; it ; it = it->next){
015050  837328     MOV l2cap_channels, W8
015052  370014     BRA 0x1507C
01507A  780418     MOV [W8], W8
01507C  E00008     CP0 W8
01507E  3AFFEA     BRA NZ, 0x15054
205:                       if (!hci_number_free_acl_slots()) return;
015054  026008     CALL hci_number_free_acl_slots
015056  000001     NOP
015058  E00400     CP0.B W0
01505A  320012     BRA Z, 0x15080
206:                       l2cap_channel_t * channel = (l2cap_channel_t *) it;
207:                       if (channel->state != L2CAP_STATE_OPEN) continue;
01505C  900028     MOV [W8+4], W0
01505E  500FE7     SUB W0, #0x7, [W15]
015060  3A000C     BRA NZ, 0x1507A
208:                       if (hci_number_outgoing_packets(channel->handle) < NR_BUFFERED_ACL_PACKETS && channel->packets_granted == 0) {
015062  900078     MOV [W8+14], W0
015064  026024     CALL hci_number_outgoing_packets
015066  000001     NOP
015068  504FE2     SUB.B W0, #0x2, [W15]
01506A  3E0007     BRA GTU, 0x1507A
01506C  905848     MOV.B [W8+28], W0
01506E  E00400     CP0.B W0
015070  3A0004     BRA NZ, 0x1507A
209:                           l2cap_emit_credits(channel, 1);
015072  B3C011     MOV #0x1, W1
015074  780008     MOV W8, W0
015076  024E20     CALL l2cap_emit_credits
015078  000001     NOP
210:                       }
211:                   }
212:               }
213:               
214:               l2cap_channel_t * l2cap_get_channel_for_local_cid(uint16_t local_cid){
215:                   linked_item_t *it;
216:                   for (it = (linked_item_t *) l2cap_channels; it ; it = it->next){
013686  837324     MOV l2cap_channels, W4
013688  370004     BRA 0x13692
013690  780214     MOV [W4], W4
013692  E00004     CP0 W4
013694  3AFFFA     BRA NZ, 0x1368A
013696  370006     BRA 0x136A4
013B8A  837329     MOV l2cap_channels, W9
013B8C  370004     BRA 0x13B96
013B94  780499     MOV [W9], W9
013B96  E00009     CP0 W9
013B98  3AFFFA     BRA NZ, 0x13B8E
013B9A  370024     BRA 0x13BE4
015E00  837321     MOV l2cap_channels, W1
015E02  370004     BRA 0x15E0C
015E0A  780091     MOV [W1], W1
015E0C  E00001     CP0 W1
015E0E  3AFFFA     BRA NZ, 0x15E04
015E10  370006     BRA 0x15E1E
015F7A  837322     MOV l2cap_channels, W2
015F7C  370004     BRA 0x15F86
015F84  780112     MOV [W2], W2
015F86  E00002     CP0 W2
015F88  3AFFFA     BRA NZ, 0x15F7E
015F8A  060000     RETURN
01605E  837321     MOV l2cap_channels, W1
016060  370004     BRA 0x1606A
016068  780091     MOV [W1], W1
01606A  E00001     CP0 W1
01606C  3AFFFA     BRA NZ, 0x16062
01606E  060000     RETURN
01607A  837321     MOV l2cap_channels, W1
01607C  370004     BRA 0x16086
016084  780091     MOV [W1], W1
016086  E00001     CP0 W1
016088  3AFFFA     BRA NZ, 0x1607E
01608A  370002     BRA 0x16090
0161BA  837320     MOV l2cap_channels, W0
0161BC  370005     BRA 0x161C8
0161C6  780011     MOV [W1], W0
0161C8  E00000     CP0 W0
0161CA  3AFFF9     BRA NZ, 0x161BE
0161CC  780080     MOV W0, W1
0161D4  837321     MOV l2cap_channels, W1
0161D6  370004     BRA 0x161E0
0161DE  780091     MOV [W1], W1
0161E0  E00001     CP0 W1
0161E2  3AFFFA     BRA NZ, 0x161D8
0161E4  780001     MOV W1, W0
0161E6  060000     RETURN
217:                       l2cap_channel_t * channel = (l2cap_channel_t *) it;
0161BE  780080     MOV W0, W1
218:                       if ( channel->local_cid == local_cid) {
01368A  900814     MOV [W4+18], W0
01368C  500F82     SUB W0, W2, [W15]
01368E  320004     BRA Z, 0x13698
013B8E  900819     MOV [W9+18], W0
013B90  500F8B     SUB W0, W11, [W15]
013B92  320004     BRA Z, 0x13B9C
015E04  900811     MOV [W1+18], W0
015E06  500F82     SUB W0, W2, [W15]
015E08  320004     BRA Z, 0x15E12
015F7E  900812     MOV [W2+18], W0
015F80  500F83     SUB W0, W3, [W15]
015F82  320004     BRA Z, 0x15F8C
016062  900811     MOV [W1+18], W0
016064  500F82     SUB W0, W2, [W15]
016066  320004     BRA Z, 0x16070
01607E  900811     MOV [W1+18], W0
016080  500F82     SUB W0, W2, [W15]
016082  320004     BRA Z, 0x1608C
0161C0  900810     MOV [W0+18], W0
0161C2  500F82     SUB W0, W2, [W15]
0161C4  320004     BRA Z, 0x161CE
0161D8  900811     MOV [W1+18], W0
0161DA  500F82     SUB W0, W2, [W15]
0161DC  320005     BRA Z, 0x161E8
219:                           return channel;
220:                       }
221:                   }
222:                   return NULL;
223:               }
224:               
225:               int  l2cap_can_send_packet_now(uint16_t local_cid){
226:                   l2cap_channel_t *channel = l2cap_get_channel_for_local_cid(local_cid);
227:                   if (!channel) return 0;
228:                   if (!channel->packets_granted) return 0;
015E12  905841     MOV.B [W1+28], W0
015E14  E00400     CP0.B W0
015E16  320003     BRA Z, 0x15E1E
229:                   return hci_can_send_packet_now(HCI_ACL_DATA_PACKET);
230:               }
231:               
232:               uint16_t l2cap_get_remote_mtu_for_local_cid(uint16_t local_cid){
233:                   l2cap_channel_t * channel = l2cap_get_channel_for_local_cid(local_cid);
234:                   if (channel) {
235:                       return channel->remote_mtu;
0161E8  900841     MOV [W1+24], W0
236:                   } 
237:                   return 0;
238:               }
239:               
240:               int l2cap_send_signaling_packet(hci_con_handle_t handle, L2CAP_SIGNALING_COMMANDS cmd, uint8_t identifier, ...){
241:               
242:                   if (!hci_can_send_packet_now(HCI_ACL_DATA_PACKET)){
01508E  B3C020     MOV #0x2, W0
015090  025714     CALL hci_can_send_packet_now
015092  000001     NOP
015094  200571     MOV #0x57, W1
015096  E00000     CP0 W0
015098  32000E     BRA Z, 0x150B6
243:                       log_info("l2cap_send_signaling_packet, cannot send\n");
244:                       return BTSTACK_ACL_BUFFERS_FULL;
245:                   }
246:                   
247:                   // log_info("l2cap_send_signaling_packet type %u\n", cmd);
248:                   uint8_t *acl_buffer = hci_get_outgoing_acl_packet_buffer();
01509A  026750     CALL hci_get_outgoing_acl_packet_buffer
01509C  000001     NOP
01509E  780400     MOV W0, W8
249:                   va_list argptr;
250:                   va_start(argptr, identifier);
251:                   uint16_t len = l2cap_create_signaling_internal(acl_buffer, handle, cmd, identifier, argptr);
0150A0  57826E     SUB W15, #0xE, W4
0150A2  97F1AF     MOV.B [W15-14], W3
0150A4  780109     MOV W9, W2
0150A6  78008A     MOV W10, W1
0150A8  0234D8     CALL l2cap_create_signaling_internal
0150AA  000001     NOP
0150AC  780080     MOV W0, W1
252:                   va_end(argptr);
253:                   // log_info("l2cap_send_signaling_packet con %u!\n", handle);
254:                   return hci_send_acl_packet(acl_buffer, len);
0150AE  780008     MOV W8, W0
0150B0  024C90     CALL hci_send_acl_packet
0150B2  000001     NOP
0150B4  780080     MOV W0, W1
255:               }
256:               
257:               uint8_t *l2cap_get_outgoing_buffer(void){
258:                   return hci_get_outgoing_acl_packet_buffer() + COMPLETE_L2CAP_HEADER; // 8 bytes
0166AC  026750     CALL hci_get_outgoing_acl_packet_buffer
0166AE  000001     NOP
0166B0  400068     ADD W0, #0x8, W0
259:               }
260:               
261:               int l2cap_send_prepared(uint16_t local_cid, uint16_t len){
262:                   
263:                   if (!hci_can_send_packet_now(HCI_ACL_DATA_PACKET)){
013B7E  B3C020     MOV #0x2, W0
013B80  025714     CALL hci_can_send_packet_now
013B82  000001     NOP
013B84  200578     MOV #0x57, W8
013B86  E00000     CP0 W0
013B88  32002E     BRA Z, 0x13BE6
264:                       log_info("l2cap_send_internal cid 0x%02x, cannot send\n", local_cid);
265:                       return BTSTACK_ACL_BUFFERS_FULL;
266:                   }
267:                   
268:                   l2cap_channel_t * channel = l2cap_get_channel_for_local_cid(local_cid);
269:                   if (!channel) {
270:                       log_error("l2cap_send_internal no channel for cid 0x%02x\n", local_cid);
271:                       return -1;   // TODO: define error
272:                   }
273:               
274:                   if (channel->packets_granted == 0){
013B9C  905849     MOV.B [W9+28], W0
013B9E  E00400     CP0.B W0
013BA0  320021     BRA Z, 0x13BE4
275:                       log_error("l2cap_send_internal cid 0x%02x, no credits!\n", local_cid);
276:                       return -1;  // TODO: define error
277:                   }
278:                   
279:                   --channel->packets_granted;
013BA2  E94000     DEC.B W0, W0
013BA4  985CC0     MOV.B W0, [W9+28]
280:               
281:                   log_debug("l2cap_send_internal cid 0x%02x, handle %u, 1 credit used, credits left %u;\n",
282:                                 local_cid, channel->handle, channel->packets_granted);
283:                   
284:                   uint8_t *acl_buffer = hci_get_outgoing_acl_packet_buffer();
013BA6  026750     CALL hci_get_outgoing_acl_packet_buffer
013BA8  000001     NOP
013BAA  780400     MOV W0, W8
285:               
286:                   // 0 - Connection handle : PB=10 : BC=00 
287:                   bt_store_16(acl_buffer, 0, channel->handle | (2 << 12) | (0 << 14));
013BAC  900179     MOV [W9+14], W2
013BAE  A0D002     BSET W2, #13
013BB0  EB0080     CLR W1
013BB2  026614     CALL bt_store_16
013BB4  000001     NOP
288:                   // 2 - ACL length
289:                   bt_store_16(acl_buffer, 2,  len + 4);
013BB6  450164     ADD W10, #0x4, W2
013BB8  200021     MOV #0x2, W1
013BBA  780008     MOV W8, W0
013BBC  026614     CALL bt_store_16
013BBE  000001     NOP
290:                   // 4 - L2CAP packet length
291:                   bt_store_16(acl_buffer, 4,  len + 0);
013BC0  78010A     MOV W10, W2
013BC2  200041     MOV #0x4, W1
013BC4  780008     MOV W8, W0
013BC6  026614     CALL bt_store_16
013BC8  000001     NOP
292:                   // 6 - L2CAP channel DEST
293:                   bt_store_16(acl_buffer, 6, channel->remote_cid);    
013BCA  900929     MOV [W9+20], W2
013BCC  200061     MOV #0x6, W1
013BCE  780008     MOV W8, W0
013BD0  026614     CALL bt_store_16
013BD2  000001     NOP
294:                   // send
295:                   int err = hci_send_acl_packet(acl_buffer, len+8);
013BD4  4500E8     ADD W10, #0x8, W1
013BD6  780008     MOV W8, W0
013BD8  024C90     CALL hci_send_acl_packet
013BDA  000001     NOP
013BDC  780400     MOV W0, W8
296:                   
297:                   l2cap_hand_out_credits();
013BDE  025048     CALL l2cap_hand_out_credits
013BE0  000001     NOP
013BE2  370001     BRA 0x13BE6
298:                   
299:                   return err;
013BE4  EB8400     SETM W8
300:               }
301:               
302:               int l2cap_send_prepared_connectionless(uint16_t handle, uint16_t cid, uint16_t len){
303:                   
304:                   if (!hci_can_send_packet_now(HCI_ACL_DATA_PACKET)){
014514  B3C020     MOV #0x2, W0
014516  025714     CALL hci_can_send_packet_now
014518  000001     NOP
01451A  200578     MOV #0x57, W8
01451C  E00000     CP0 W0
01451E  32001E     BRA Z, 0x1455C
305:                       log_info("l2cap_send_prepared_to_handle cid 0x%02x, cannot send\n", cid);
306:                       return BTSTACK_ACL_BUFFERS_FULL;
307:                   }
308:                   
309:                   log_debug("l2cap_send_prepared_to_handle cid 0x%02x, handle %u\n", cid, handle);
310:                   
311:                   uint8_t *acl_buffer = hci_get_outgoing_acl_packet_buffer();
014520  026750     CALL hci_get_outgoing_acl_packet_buffer
014522  000001     NOP
014524  780400     MOV W0, W8
312:                   
313:                   // 0 - Connection handle : PB=10 : BC=00 
314:                   bt_store_16(acl_buffer, 0, handle | (2 << 12) | (0 << 14));
014526  A0D009     BSET W9, #13
014528  780109     MOV W9, W2
01452A  EB0080     CLR W1
01452C  026614     CALL bt_store_16
01452E  000001     NOP
315:                   // 2 - ACL length
316:                   bt_store_16(acl_buffer, 2,  len + 4);
014530  450164     ADD W10, #0x4, W2
014532  200021     MOV #0x2, W1
014534  780008     MOV W8, W0
014536  026614     CALL bt_store_16
014538  000001     NOP
317:                   // 4 - L2CAP packet length
318:                   bt_store_16(acl_buffer, 4,  len + 0);
01453A  78010A     MOV W10, W2
01453C  200041     MOV #0x4, W1
01453E  780008     MOV W8, W0
014540  026614     CALL bt_store_16
014542  000001     NOP
319:                   // 6 - L2CAP channel DEST
320:                   bt_store_16(acl_buffer, 6, cid);    
014544  78010B     MOV W11, W2
014546  200061     MOV #0x6, W1
014548  780008     MOV W8, W0
01454A  026614     CALL bt_store_16
01454C  000001     NOP
321:                   // send
322:                   int err = hci_send_acl_packet(acl_buffer, len+8);
01454E  4500E8     ADD W10, #0x8, W1
014550  780008     MOV W8, W0
014552  024C90     CALL hci_send_acl_packet
014554  000001     NOP
014556  780400     MOV W0, W8
323:                   
324:                   l2cap_hand_out_credits();
014558  025048     CALL l2cap_hand_out_credits
01455A  000001     NOP
325:               
326:                   return err;
327:               }
328:               
329:               int l2cap_send_internal(uint16_t local_cid, uint8_t *data, uint16_t len){
330:               
331:                   if (!hci_can_send_packet_now(HCI_ACL_DATA_PACKET)){
0154BE  B3C020     MOV #0x2, W0
0154C0  025714     CALL hci_can_send_packet_now
0154C2  000001     NOP
0154C4  200571     MOV #0x57, W1
0154C6  E00000     CP0 W0
0154C8  32000C     BRA Z, 0x154E2
332:                       log_info("l2cap_send_internal cid 0x%02x, cannot send\n", local_cid);
333:                       return BTSTACK_ACL_BUFFERS_FULL;
334:                   }
335:               
336:                   uint8_t *acl_buffer = hci_get_outgoing_acl_packet_buffer();
0154CA  026750     CALL hci_get_outgoing_acl_packet_buffer
0154CC  000001     NOP
337:               
338:                   memcpy(&acl_buffer[8], data, len);
0154CE  400068     ADD W0, #0x8, W0
0154D0  780108     MOV W8, W2
0154D2  780089     MOV W9, W1
0154D4  0256DE     CALL memcpy
0154D6  000000     NOP
339:               
340:                   return l2cap_send_prepared(local_cid, len);
0154D8  780088     MOV W8, W1
0154DA  78000A     MOV W10, W0
0154DC  023B76     CALL l2cap_send_prepared
0154DE  000001     NOP
0154E0  780080     MOV W0, W1
341:               }
342:               
343:               int l2cap_send_connectionless(uint16_t handle, uint16_t cid, uint8_t *data, uint16_t len){
344:                   
345:                   if (!hci_can_send_packet_now(HCI_ACL_DATA_PACKET)){
01522C  B3C020     MOV #0x2, W0
01522E  025714     CALL hci_can_send_packet_now
015230  000001     NOP
015232  200571     MOV #0x57, W1
015234  E00000     CP0 W0
015236  32000D     BRA Z, 0x15252
346:                       log_info("l2cap_send_internal cid 0x%02x, cannot send\n", cid);
347:                       return BTSTACK_ACL_BUFFERS_FULL;
348:                   }
349:                   
350:                   uint8_t *acl_buffer = hci_get_outgoing_acl_packet_buffer();
015238  026750     CALL hci_get_outgoing_acl_packet_buffer
01523A  000001     NOP
351:                   
352:                   memcpy(&acl_buffer[8], data, len);
01523C  400068     ADD W0, #0x8, W0
01523E  780108     MOV W8, W2
015240  780089     MOV W9, W1
015242  0256DE     CALL memcpy
015244  000000     NOP
353:                   
354:                   return l2cap_send_prepared_connectionless(handle, cid, len);
015246  780108     MOV W8, W2
015248  78008A     MOV W10, W1
01524A  78000B     MOV W11, W0
01524C  02450A     CALL l2cap_send_prepared_connectionless
01524E  000001     NOP
015250  780080     MOV W0, W1
355:               }
356:               
357:               static inline void channelStateVarSetFlag(l2cap_channel_t *channel, L2CAP_CHANNEL_STATE_VAR flag){
358:                   channel->state_var = (L2CAP_CHANNEL_STATE_VAR) (channel->state_var | flag);
011330  900038     MOV [W8+6], W0
011332  A02000     BSET W0, #2
011334  980430     MOV W0, [W8+6]
01137A  A05000     BSET W0, #5
01137C  980430     MOV W0, [W8+6]
0113A2  A04000     BSET W0, #4
0113A4  980430     MOV W0, [W8+6]
0130B8  900038     MOV [W8+6], W0
0130BA  A02000     BSET W0, #2
0130BC  980430     MOV W0, [W8+6]
0130BE  370039     BRA 0x13132
0130F2  900038     MOV [W8+6], W0
0130F4  B30090     IOR #0x9, W0
0130F6  980430     MOV W0, [W8+6]
013102  900038     MOV [W8+6], W0
013104  A01000     BSET W0, #1
013106  980430     MOV W0, [W8+6]
359:               }
360:               
361:               static inline void channelStateVarClearFlag(l2cap_channel_t *channel, L2CAP_CHANNEL_STATE_VAR flag){
362:                   channel->state_var = (L2CAP_CHANNEL_STATE_VAR) (channel->state_var & ~flag);
011378  A13000     BCLR W0, #3
0113A0  A12000     BCLR W0, #2
363:               }
364:               
365:               
366:               
367:               // MARK: L2CAP_RUN
368:               // process outstanding signaling tasks
369:               void l2cap_run(void){
370:                   
371:                   // check pending signaling responses
372:                   while (signaling_responses_pending){
01129E  837340     MOV signaling_responses_pending, W0
0112A0  E00000     CP0 W0
0112A2  3AFFB4     BRA NZ, 0x1120C
373:                       
374:                       if (!hci_can_send_packet_now(HCI_ACL_DATA_PACKET)) break;
01120C  B3C020     MOV #0x2, W0
01120E  025714     CALL hci_can_send_packet_now
011210  000001     NOP
011212  E00000     CP0 W0
011214  320047     BRA Z, 0x112A4
375:                       
376:                       hci_con_handle_t handle = signaling_responses[0].handle;
011216  837354     MOV signaling_responses, W4
377:                       uint8_t sig_id = signaling_responses[0].sig_id;
011218  26E6C0     MOV #0x6E6C, W0
01121A  784190     MOV.B [W0], W3
378:                       uint16_t infoType = signaling_responses[0].data;    // INFORMATION_REQUEST
01121C  837372     MOV 0x6E6E, W2
379:                       uint16_t result   = signaling_responses[0].data;    // CONNECTION_REQUEST
380:                       
381:                       switch (signaling_responses[0].code){
01121E  26E6D0     MOV #0x6E6D, W0
011220  784010     MOV.B [W0], W0
011222  504FE8     SUB.B W0, #0x8, [W15]
011224  32000C     BRA Z, 0x1123E
011226  504FEA     SUB.B W0, #0xA, [W15]
011228  320014     BRA Z, 0x11252
01122A  504FE2     SUB.B W0, #0x2, [W15]
01122C  3A0028     BRA NZ, 0x1127E
382:                           case CONNECTION_REQUEST:
383:                               l2cap_send_signaling_packet(handle, CONNECTION_RESPONSE, sig_id, 0, 0, result, 0);
01122E  EB1F80     CLR [W15++]
011230  781F82     MOV W2, [W15++]
011232  EB1F80     CLR [W15++]
011234  EB1F80     CLR [W15++]
011236  E8878F     INC2 W15, W15
011238  9FFFE3     MOV.B W3, [W15-2]
01123A  200031     MOV #0x3, W1
01123C  37001C     BRA 0x11276
384:                               break;
385:                           case ECHO_REQUEST:
386:                               l2cap_send_signaling_packet(handle, ECHO_RESPONSE, sig_id, 0, NULL);
01123E  EB1F80     CLR [W15++]
011240  EB1F80     CLR [W15++]
011242  E8878F     INC2 W15, W15
011244  9FFFE3     MOV.B W3, [W15-2]
011246  200091     MOV #0x9, W1
011248  780004     MOV W4, W0
01124A  025084     CALL l2cap_send_signaling_packet
01124C  000001     NOP
387:                               break;
01124E  5787E6     SUB W15, #0x6, W15
011250  370016     BRA 0x1127E
388:                           case INFORMATION_REQUEST:
389:                               if (infoType == 2) {
011252  510FE2     SUB W2, #0x2, [W15]
011254  3A0008     BRA NZ, 0x11266
390:                                   uint32_t features = 0;
011256  B80060     MUL.UU W0, #0, W0
011258  980720     MOV W0, [W14+4]
01125A  980731     MOV W1, [W14+6]
391:                                   // extended features request supported, however no features present
392:                                   l2cap_send_signaling_packet(handle, INFORMATION_RESPONSE, sig_id, infoType, 0, 4, &features);
01125C  471FE4     ADD W14, #0x4, [W15++]
01125E  200040     MOV #0x4, W0
011260  781F80     MOV W0, [W15++]
011262  EB1F80     CLR [W15++]
011264  370004     BRA 0x1126E
393:                               } else {
394:                                   // all other types are not supported
395:                                   l2cap_send_signaling_packet(handle, INFORMATION_RESPONSE, sig_id, infoType, 1, 0, NULL);
011266  EB1F80     CLR [W15++]
011268  EB1F80     CLR [W15++]
01126A  200011     MOV #0x1, W1
01126C  781F81     MOV W1, [W15++]
01126E  781F82     MOV W2, [W15++]
011270  E8878F     INC2 W15, W15
011272  9FFFE3     MOV.B W3, [W15-2]
011274  2000B1     MOV #0xB, W1
011276  780004     MOV W4, W0
011278  025084     CALL l2cap_send_signaling_packet
01127A  000001     NOP
01127C  5787EA     SUB W15, #0xA, W15
396:                               }
397:                               break;
398:                           default:
399:                               // should not happen
400:                               break;
401:                       }
402:                       
403:                       // remove first item
404:                       signaling_responses_pending--;
01127E  837340     MOV signaling_responses_pending, W0
011280  E90000     DEC W0, W0
011282  8B7340     MOV W0, signaling_responses_pending
011284  EB0100     CLR W2
011286  26E6A1     MOV #0x6E6A, W1
011288  780180     MOV W0, W3
01128A  370006     BRA 0x11298
405:                       int i;
406:                       for (i=0; i < signaling_responses_pending; i++){
011296  E80102     INC W2, W2
011298  4080E6     ADD W1, #0x6, W1
01129A  510F83     SUB W2, W3, [W15]
01129C  35FFF7     BRA LT, 0x1128C
407:                           memcpy(&signaling_responses[i], &signaling_responses[i+1], sizeof(l2cap_signaling_response_t));
01128C  508066     SUB W1, #0x6, W0
01128E  BE0211     MOV.D [W1], W4
011290  BE8804     MOV.D W4, [W0]
011292  9002A1     MOV [W1+4], W5
011294  980025     MOV W5, [W0+4]
408:                       }
409:                   }
410:                   
411:                   uint8_t  config_options[4];
412:                   linked_item_t *it;
413:                   linked_item_t *next;
414:                   for (it = (linked_item_t *) l2cap_channels; it ; it = next){
0112A4  837328     MOV l2cap_channels, W8
0112A6  3700C9     BRA 0x1143A
01143A  E00008     CP0 W8
01143C  3AFF35     BRA NZ, 0x112A8
415:                       next = it->next;    // cache next item as current item might get freed
0112A8  780518     MOV [W8], W10
416:               
417:                       if (!hci_can_send_packet_now(HCI_COMMAND_DATA_PACKET)) break;
0112AA  B3C010     MOV #0x1, W0
0112AC  025714     CALL hci_can_send_packet_now
0112AE  000001     NOP
0112B0  E00000     CP0 W0
0112B2  3200C5     BRA Z, 0x1143E
418:                       if (!hci_can_send_packet_now(HCI_ACL_DATA_PACKET)) break;
0112B4  B3C020     MOV #0x2, W0
0112B6  025714     CALL hci_can_send_packet_now
0112B8  000001     NOP
0112BA  E00000     CP0 W0
0112BC  3200C0     BRA Z, 0x1143E
419:                       
420:                       l2cap_channel_t * channel = (l2cap_channel_t *) it;
421:                       
422:                       // log_info("l2cap_run: state %u, var 0x%02x\n", channel->state, channel->state_var);
423:                       
424:                       
425:                       switch (channel->state){
0112BE  900028     MOV [W8+4], W0
0112C0  500FEA     SUB W0, #0xA, [W15]
0112C2  32001F     BRA Z, 0x11302
0112C4  3E0007     BRA GTU, 0x112D4
0112C6  500FE6     SUB W0, #0x6, [W15]
0112C8  320054     BRA Z, 0x11372
0112CA  500FE9     SUB W0, #0x9, [W15]
0112CC  320043     BRA Z, 0x11354
0112CE  500FE2     SUB W0, #0x2, [W15]
0112D0  3A00B3     BRA NZ, 0x11438
0112D2  370006     BRA 0x112E0
0112D4  500FEC     SUB W0, #0xC, [W15]
0112D6  32009F     BRA Z, 0x11416
0112D8  390029     BRA NC, 0x1132C
0112DA  500FED     SUB W0, #0xD, [W15]
0112DC  3A00AD     BRA NZ, 0x11438
0112DE  37008C     BRA 0x113F8
426:               
427:                           case L2CAP_STATE_WILL_SEND_CREATE_CONNECTION:
428:                               // send connection request - set state first
429:                               channel->state = L2CAP_STATE_WAIT_CONNECTION_COMPLETE;
0112E0  200030     MOV #0x3, W0
0112E2  980420     MOV W0, [W8+4]
430:                               // BD_ADDR, Packet_Type, Page_Scan_Repetition_Mode, Reserved, Clock_Offset, Allow_Role_Switch
431:                               hci_send_cmd(&hci_create_connection, channel->address, hci_usable_acl_packet_types(), 0, 0, 0, 1); 
0112E4  02674C     CALL hci_usable_acl_packet_types
0112E6  000001     NOP
0112E8  200011     MOV #0x1, W1
0112EA  781F81     MOV W1, [W15++]
0112EC  EB1F80     CLR [W15++]
0112EE  EB1F80     CLR [W15++]
0112F0  EB1F80     CLR [W15++]
0112F2  781F80     MOV W0, [W15++]
0112F4  441FE8     ADD W8, #0x8, [W15++]
0112F6  2EAFC4     MOV #0xEAFC, W4
0112F8  781F84     MOV W4, [W15++]
0112FA  026252     CALL hci_send_cmd
0112FC  000001     NOP
432:                               break;
0112FE  5787EE     SUB W15, #0xE, W15
011300  37009B     BRA 0x11438
433:                               
434:                           case L2CAP_STATE_WILL_SEND_CONNECTION_RESPONSE_DECLINE:
435:                               l2cap_send_signaling_packet(channel->handle, CONNECTION_RESPONSE, channel->remote_sig_id, 0, 0, channel->reason, 0);
011302  900078     MOV [W8+14], W0
011304  EB1F80     CLR [W15++]
011306  9058D8     MOV.B [W8+29], W1
011308  FB8081     ZE W1, W1
01130A  781F81     MOV W1, [W15++]
01130C  EB1F80     CLR [W15++]
01130E  EB1F80     CLR [W15++]
011310  E8878F     INC2 W15, W15
011312  905288     MOV.B [W8+16], W5
011314  9FFFE5     MOV.B W5, [W15-2]
011316  200031     MOV #0x3, W1
011318  025084     CALL l2cap_send_signaling_packet
01131A  000001     NOP
436:                               // discard channel - l2cap_finialize_channel_close without sending l2cap close event
437:                               linked_list_remove(&l2cap_channels, (linked_item_t *) channel); // -- remove from list
01131C  780088     MOV W8, W1
01131E  26E640     MOV #0x6E64, W0
011320  0263FC     CALL linked_list_remove
011322  000001     NOP
438:                               btstack_memory_l2cap_channel_free(channel); 
011324  780008     MOV W8, W0
011326  026684     CALL btstack_memory_l2cap_channel_free
011328  000001     NOP
01132A  370012     BRA 0x11350
439:                               break;
440:                               
441:                           case L2CAP_STATE_WILL_SEND_CONNECTION_RESPONSE_ACCEPT:
442:                               channel->state = L2CAP_STATE_CONFIG;
01132C  200060     MOV #0x6, W0
01132E  980420     MOV W0, [W8+4]
443:                               channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_REQ);
444:                               l2cap_send_signaling_packet(channel->handle, CONNECTION_RESPONSE, channel->remote_sig_id, channel->local_cid, channel->remote_cid, 0, 0);
011336  900078     MOV [W8+14], W0
011338  EB1F80     CLR [W15++]
01133A  EB1F80     CLR [W15++]
01133C  9008A8     MOV [W8+20], W1
01133E  781F81     MOV W1, [W15++]
011340  900A18     MOV [W8+18], W4
011342  781F84     MOV W4, [W15++]
011344  E8878F     INC2 W15, W15
011346  905408     MOV.B [W8+16], W8
011348  9FFFE8     MOV.B W8, [W15-2]
01134A  200031     MOV #0x3, W1
01134C  025084     CALL l2cap_send_signaling_packet
01134E  000001     NOP
445:                               break;
011350  5787EA     SUB W15, #0xA, W15
011352  370072     BRA 0x11438
446:                               
447:                           case L2CAP_STATE_WILL_SEND_CONNECTION_REQUEST:
448:                               // success, start l2cap handshake
449:                               channel->local_sig_id = l2cap_next_sig_id();
011354  026412     CALL l2cap_next_sig_id
011356  000001     NOP
011358  985410     MOV.B W0, [W8+17]
450:                               channel->state = L2CAP_STATE_WAIT_CONNECT_RSP;
01135A  200050     MOV #0x5, W0
01135C  980420     MOV W0, [W8+4]
451:                               l2cap_send_signaling_packet( channel->handle, CONNECTION_REQUEST, channel->local_sig_id, channel->psm, channel->local_cid);                   
01135E  900078     MOV [W8+14], W0
011360  900A98     MOV [W8+18], W5
011362  781F85     MOV W5, [W15++]
011364  9008D8     MOV [W8+26], W1
011366  781F81     MOV W1, [W15++]
011368  E8878F     INC2 W15, W15
01136A  905418     MOV.B [W8+17], W8
01136C  9FFFE8     MOV.B W8, [W15-2]
01136E  200021     MOV #0x2, W1
011370  370060     BRA 0x11432
452:                               break;
453:                           
454:                           case L2CAP_STATE_CONFIG:
455:                               if (channel->state_var & L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP){
011372  900038     MOV [W8+6], W0
011374  6004E8     AND W0, #0x8, W9
011376  320012     BRA Z, 0x1139C
456:                                   channelStateVarClearFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP);
457:                                   channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SENT_CONF_RSP);
458:                                   l2cap_send_signaling_packet(channel->handle, CONFIGURE_RESPONSE, channel->remote_sig_id, channel->remote_cid, 0, 0, 0, NULL);
01137E  900078     MOV [W8+14], W0
011380  EB1F80     CLR [W15++]
011382  EB1F80     CLR [W15++]
011384  EB1F80     CLR [W15++]
011386  EB1F80     CLR [W15++]
011388  900A28     MOV [W8+20], W4
01138A  781F84     MOV W4, [W15++]
01138C  E8878F     INC2 W15, W15
01138E  905288     MOV.B [W8+16], W5
011390  9FFFE5     MOV.B W5, [W15-2]
011392  200051     MOV #0x5, W1
011394  025084     CALL l2cap_send_signaling_packet
011396  000001     NOP
011398  5787EC     SUB W15, #0xC, W15
01139A  37001E     BRA 0x113D8
459:                               }
460:                               else if (channel->state_var & L2CAP_CHANNEL_STATE_VAR_SEND_CONF_REQ){
01139C  A32800     BTST.Z W0, #2
01139E  32001C     BRA Z, 0x113D8
461:                                   channelStateVarClearFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_REQ);
462:                                   channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SENT_CONF_REQ);
463:                                   channel->local_sig_id = l2cap_next_sig_id();
0113A6  026412     CALL l2cap_next_sig_id
0113A8  000001     NOP
0113AA  985410     MOV.B W0, [W8+17]
464:                                   config_options[0] = 1; // MTU
0113AC  B3C010     MOV #0x1, W0
0113AE  784F00     MOV.B W0, [W14]
465:                                   config_options[1] = 2; // len param
0113B0  B3C020     MOV #0x2, W0
0113B2  984710     MOV.B W0, [W14+1]
466:                                   bt_store_16( (uint8_t*)&config_options, 2, channel->local_mtu);
0113B4  900938     MOV [W8+22], W2
0113B6  200021     MOV #0x2, W1
0113B8  78000E     MOV W14, W0
0113BA  026614     CALL bt_store_16
0113BC  000001     NOP
467:                                   l2cap_send_signaling_packet(channel->handle, CONFIGURE_REQUEST, channel->local_sig_id, channel->remote_cid, 0, 4, &config_options);
0113BE  900078     MOV [W8+14], W0
0113C0  781F8E     MOV W14, [W15++]
0113C2  200041     MOV #0x4, W1
0113C4  781F81     MOV W1, [W15++]
0113C6  781F89     MOV W9, [W15++]
0113C8  900A28     MOV [W8+20], W4
0113CA  781F84     MOV W4, [W15++]
0113CC  E8878F     INC2 W15, W15
0113CE  905298     MOV.B [W8+17], W5
0113D0  9FFFE5     MOV.B W5, [W15-2]
0113D2  025084     CALL l2cap_send_signaling_packet
0113D4  000001     NOP
0113D6  5787EA     SUB W15, #0xA, W15
468:                               }
469:                               if (l2cap_channel_ready_for_open(channel)){
0113D8  780008     MOV W8, W0
0113DA  0264DE     CALL l2cap_channel_ready_for_open
0113DC  000001     NOP
0113DE  E00000     CP0 W0
0113E0  32002B     BRA Z, 0x11438
470:                                   channel->state = L2CAP_STATE_OPEN;
0113E2  200070     MOV #0x7, W0
0113E4  980420     MOV W0, [W8+4]
471:                                   l2cap_emit_channel_opened(channel, 0);  // success
0113E6  EB4080     CLR.B W1
0113E8  780008     MOV W8, W0
0113EA  023CDA     CALL l2cap_emit_channel_opened
0113EC  000001     NOP
472:                                   l2cap_emit_credits(channel, 1);
0113EE  B3C011     MOV #0x1, W1
0113F0  780008     MOV W8, W0
0113F2  024E20     CALL l2cap_emit_credits
0113F4  000001     NOP
0113F6  370020     BRA 0x11438
473:                               }
474:                               break;
475:               
476:                           case L2CAP_STATE_WILL_SEND_DISCONNECT_RESPONSE:
477:                               l2cap_send_signaling_packet( channel->handle, DISCONNECTION_RESPONSE, channel->remote_sig_id, channel->local_cid, channel->remote_cid);   
0113F8  900078     MOV [W8+14], W0
0113FA  9008A8     MOV [W8+20], W1
0113FC  781F81     MOV W1, [W15++]
0113FE  900A18     MOV [W8+18], W4
011400  781F84     MOV W4, [W15++]
011402  E8878F     INC2 W15, W15
011404  905288     MOV.B [W8+16], W5
011406  9FFFE5     MOV.B W5, [W15-2]
011408  200071     MOV #0x7, W1
01140A  025084     CALL l2cap_send_signaling_packet
01140C  000001     NOP
478:                               l2cap_finialize_channel_close(channel);  // -- remove from list
01140E  780008     MOV W8, W0
011410  025EC2     CALL l2cap_finialize_channel_close
011412  000001     NOP
011414  370010     BRA 0x11436
479:                               break;
480:                               
481:                           case L2CAP_STATE_WILL_SEND_DISCONNECT_REQUEST:
482:                               channel->local_sig_id = l2cap_next_sig_id();
011416  026412     CALL l2cap_next_sig_id
011418  000001     NOP
01141A  985410     MOV.B W0, [W8+17]
483:                               channel->state = L2CAP_STATE_WAIT_DISCONNECT;
01141C  200080     MOV #0x8, W0
01141E  980420     MOV W0, [W8+4]
484:                               l2cap_send_signaling_packet( channel->handle, DISCONNECTION_REQUEST, channel->local_sig_id, channel->remote_cid, channel->local_cid);   
011420  900078     MOV [W8+14], W0
011422  900898     MOV [W8+18], W1
011424  781F81     MOV W1, [W15++]
011426  900A28     MOV [W8+20], W4
011428  781F84     MOV W4, [W15++]
01142A  E8878F     INC2 W15, W15
01142C  905418     MOV.B [W8+17], W8
01142E  9FFFE8     MOV.B W8, [W15-2]
011430  200061     MOV #0x6, W1
011432  025084     CALL l2cap_send_signaling_packet
011434  000001     NOP
011436  5787E6     SUB W15, #0x6, W15
011438  78040A     MOV W10, W8
485:                               break;
486:                           default:
487:                               break;
488:                       }
489:                   }
490:               }
491:               
492:               uint16_t l2cap_max_mtu(void){
493:                   return hci_max_acl_data_packet_length() - L2CAP_HEADER_SIZE;
0166B4  026754     CALL hci_max_acl_data_packet_length
0166B6  000001     NOP
0166B8  500064     SUB W0, #0x4, W0
494:               }
495:               
496:               // open outgoing L2CAP channel
497:               void l2cap_create_channel_internal(void * connection, btstack_packet_handler_t packet_handler,
498:                                                  bd_addr_t address, uint16_t psm, uint16_t mtu){
499:                   
500:                   log_info("L2CAP_CREATE_CHANNEL_MTU addr %s psm 0x%x mtu %u", bd_addr_to_str(address), psm, mtu);
501:                   
502:                   // alloc structure
503:                   l2cap_channel_t * chan = (l2cap_channel_t*) btstack_memory_l2cap_channel_get();
013B08  0266F0     CALL btstack_memory_l2cap_channel_get
013B0A  000001     NOP
013B0C  780400     MOV W0, W8
504:                   if (!chan) {
013B0E  E00000     CP0 W0
013B10  3A000D     BRA NZ, 0x13B2C
505:                       // emit error event
506:                       l2cap_channel_t dummy_channel;
507:                       BD_ADDR_COPY(dummy_channel.address, address);
013B12  2FFDA1     MOV #0xFFDA, W1
013B14  478001     ADD W15, W1, W0
013B16  090005     REPEAT #0x5
013B18  78583A     MOV.B [W10++], [W0++]
013B1A  B10060     SUB #0x6, W0
013B1C  B1006A     SUB #0x6, W10
508:                       dummy_channel.psm = psm;
013B1E  9FB7EB     MOV W11, [W15-20]
509:                       l2cap_emit_channel_opened(&dummy_channel, BTSTACK_MEMORY_ALLOC_FAILED);
013B20  B3C561     MOV #0x56, W1
013B22  2FFD20     MOV #0xFFD2, W0
013B24  40000F     ADD W0, W15, W0
013B26  023CDA     CALL l2cap_emit_channel_opened
013B28  000001     NOP
013B2A  370020     BRA 0x13B6C
510:                       return;
511:                   }
512:                   // limit local mtu to max acl packet length
513:                   if (mtu > l2cap_max_mtu()) {
013B2C  0266B4     CALL l2cap_max_mtu
013B2E  000001     NOP
013B30  548F80     SUB W9, W0, [W15]
013B32  360003     BRA LEU, 0x13B3A
514:                       mtu = l2cap_max_mtu();
013B34  0266B4     CALL l2cap_max_mtu
013B36  000001     NOP
013B38  780480     MOV W0, W9
515:                   }
516:                       
517:                   // fill in 
518:                   BD_ADDR_COPY(chan->address, address);
013B3A  440068     ADD W8, #0x8, W0
013B3C  090005     REPEAT #0x5
013B3E  78583A     MOV.B [W10++], [W0++]
013B40  B10060     SUB #0x6, W0
013B42  B1006A     SUB #0x6, W10
519:                   chan->psm = psm;
013B44  980C5B     MOV W11, [W8+26]
520:                   chan->handle = 0;
013B46  EB0080     CLR W1
013B48  980471     MOV W1, [W8+14]
521:                   chan->connection = connection;
013B4A  980C7C     MOV W12, [W8+30]
522:                   chan->packet_handler = packet_handler;
013B4C  98140D     MOV W13, [W8+32]
523:                   chan->remote_mtu = L2CAP_MINIMAL_MTU;
013B4E  200300     MOV #0x30, W0
013B50  980C40     MOV W0, [W8+24]
524:                   chan->local_mtu = mtu;
013B52  980C39     MOV W9, [W8+22]
525:                   chan->packets_granted = 0;
013B54  985C41     MOV.B W1, [W8+28]
526:                   
527:                   // set initial state
528:                   chan->state = L2CAP_STATE_WILL_SEND_CREATE_CONNECTION;
013B56  200020     MOV #0x2, W0
013B58  980420     MOV W0, [W8+4]
529:                   chan->state_var = L2CAP_CHANNEL_STATE_VAR_NONE;
013B5A  980431     MOV W1, [W8+6]
530:                   chan->remote_sig_id = L2CAP_SIG_ID_INVALID;
013B5C  985401     MOV.B W1, [W8+16]
531:                   chan->local_sig_id = L2CAP_SIG_ID_INVALID;
013B5E  985411     MOV.B W1, [W8+17]
532:                   
533:                   // add to connections list
534:                   linked_list_add(&l2cap_channels, (linked_item_t *) chan);
013B60  780088     MOV W8, W1
013B62  26E640     MOV #0x6E64, W0
013B64  0263E6     CALL linked_list_add
013B66  000001     NOP
535:                   
536:                   l2cap_run();
013B68  021204     CALL l2cap_run
013B6A  000001     NOP
537:               }
538:               
539:               void l2cap_disconnect_internal(uint16_t local_cid, uint8_t reason){
540:                   log_info("L2CAP_DISCONNECT local_cid 0x%x reason 0x%x", local_cid, reason);
541:                   // find channel for local_cid
542:                   l2cap_channel_t * channel = l2cap_get_channel_for_local_cid(local_cid);
543:                   if (channel) {
544:                       channel->state = L2CAP_STATE_WILL_SEND_DISCONNECT_REQUEST;
01608C  2000C0     MOV #0xC, W0
01608E  9800A0     MOV W0, [W1+4]
545:                   }
546:                   // process
547:                   l2cap_run();
016090  041204     GOTO l2cap_run
016092  000001     NOP
548:               }
549:               
550:               static void l2cap_handle_connection_failed_for_addr(bd_addr_t address, uint8_t status){
551:                   linked_item_t *it = (linked_item_t *) &l2cap_channels;
014D22  26E649     MOV #0x6E64, W9
014D24  370016     BRA 0x14D52
552:                   while (it->next){
014D52  780419     MOV [W9], W8
014D54  E00008     CP0 W8
014D56  3AFFE7     BRA NZ, 0x14D26
553:                       l2cap_channel_t * channel = (l2cap_channel_t *) it->next;
554:                       if ( ! BD_ADDR_CMP( channel->address, address) ){
014D26  440068     ADD W8, #0x8, W0
014D28  200062     MOV #0x6, W2
014D2A  78008B     MOV W11, W1
014D2C  0256EC     CALL memcmp
014D2E  000000     NOP
014D30  E00000     CP0 W0
014D32  320002     BRA Z, 0x14D38
014D34  780488     MOV W8, W9
014D36  37000D     BRA 0x14D52
555:                           if (channel->state == L2CAP_STATE_WAIT_CONNECTION_COMPLETE || channel->state == L2CAP_STATE_WILL_SEND_CREATE_CONNECTION) {
014D38  900028     MOV [W8+4], W0
014D3A  E98000     DEC2 W0, W0
014D3C  500FE1     SUB W0, #0x1, [W15]
014D3E  3E0009     BRA GTU, 0x14D52
556:                               // failure, forward error code
557:                               l2cap_emit_channel_opened(channel, status);
014D40  78408A     MOV.B W10, W1
014D42  780008     MOV W8, W0
014D44  023CDA     CALL l2cap_emit_channel_opened
014D46  000001     NOP
558:                               // discard channel
559:                               it->next = it->next->next;
014D48  780019     MOV [W9], W0
014D4A  780C90     MOV [W0], [W9]
560:                               btstack_memory_l2cap_channel_free(channel);
014D4C  780008     MOV W8, W0
014D4E  026684     CALL btstack_memory_l2cap_channel_free
014D50  000001     NOP
561:                           }
562:                       } else {
563:                           it = it->next;
564:                       }
565:                   }
566:               }
567:               
568:               static void l2cap_handle_connection_success_for_addr(bd_addr_t address, hci_con_handle_t handle){
569:                   linked_item_t *it;
570:                   for (it = (linked_item_t *) l2cap_channels; it ; it = it->next){
011FC0  837328     MOV l2cap_channels, W8
011FC2  370012     BRA 0x11FE8
011FE6  780418     MOV [W8], W8
011FE8  E00008     CP0 W8
011FEA  3AFFEC     BRA NZ, 0x11FC4
011FEC  370017     BRA 0x1201C
571:                       l2cap_channel_t * channel = (l2cap_channel_t *) it;
572:                       if ( ! BD_ADDR_CMP( channel->address, address) ){
011FC4  440068     ADD W8, #0x8, W0
011FC6  200062     MOV #0x6, W2
011FC8  5780F0     SUB W15, #0x10, W1
011FCA  0256EC     CALL memcmp
011FCC  000000     NOP
011FCE  E00000     CP0 W0
011FD0  3A000A     BRA NZ, 0x11FE6
573:                           if (channel->state == L2CAP_STATE_WAIT_CONNECTION_COMPLETE || channel->state == L2CAP_STATE_WILL_SEND_CREATE_CONNECTION) {
011FD2  900028     MOV [W8+4], W0
011FD4  E98000     DEC2 W0, W0
011FD6  500FE1     SUB W0, #0x1, [W15]
011FD8  3E0006     BRA GTU, 0x11FE6
574:                               // success, start l2cap handshake
575:                               channel->state = L2CAP_STATE_WILL_SEND_CONNECTION_REQUEST;
011FDA  200090     MOV #0x9, W0
011FDC  980420     MOV W0, [W8+4]
576:                               channel->handle = handle;
011FDE  98047A     MOV W10, [W8+14]
577:                               channel->local_cid = l2cap_next_local_cid();
011FE0  0266C4     CALL l2cap_next_local_cid
011FE2  000001     NOP
011FE4  980C10     MOV W0, [W8+18]
578:                           }
579:                       }
580:                   }
581:                   // process
582:                   l2cap_run();
583:               }
584:               
585:               void l2cap_event_handler( uint8_t *packet, uint16_t size ){
586:                   
587:                   bd_addr_t address;
588:                   hci_con_handle_t handle;
589:                   l2cap_channel_t * channel;
590:                   linked_item_t *it;
591:                   int hci_con_used;
592:                   
593:                   switch(packet[0]){
011F80  784090     MOV.B [W0], W1
011F82  50CFEF     SUB.B W1, #0xF, [W15]
011F84  32004B     BRA Z, 0x1201C
011F86  3E0007     BRA GTU, 0x11F96
011F88  50CFE5     SUB.B W1, #0x5, [W15]
011F8A  32004B     BRA Z, 0x12022
011F8C  50CFEE     SUB.B W1, #0xE, [W15]
011F8E  320033     BRA Z, 0x11FF6
011F90  50CFE3     SUB.B W1, #0x3, [W15]
011F92  3A00A4     BRA NZ, 0x120DC
011F94  370009     BRA 0x11FA8
011F96  B3C540     MOV #0x54, W0
011F98  50CF80     SUB.B W1, W0, [W15]
011F9A  320083     BRA Z, 0x120A2
011F9C  40407F     ADD.B W0, #0x1F, W0
011F9E  50CF80     SUB.B W1, W0, [W15]
011FA0  32005C     BRA Z, 0x1205A
011FA2  50CFF3     SUB.B W1, #0x13, [W15]
011FA4  3A009B     BRA NZ, 0x120DC
011FA6  370054     BRA 0x12050
594:                           
595:                       // handle connection complete events
596:                       case HCI_EVENT_CONNECTION_COMPLETE:
597:                           bt_flip_addr(address, &packet[5]);
011FA8  4000E5     ADD W0, #0x5, W1
011FAA  578070     SUB W15, #0x10, W0
011FAC  02616A     CALL bt_flip_addr
011FAE  000001     NOP
598:                           if (packet[2] == 0){
011FB0  9040A9     MOV.B [W9+2], W1
011FB2  E00401     CP0.B W1
011FB4  3A001C     BRA NZ, 0x11FEE
599:                               handle = READ_BT_16(packet, 3);
011FB6  9040B9     MOV.B [W9+3], W1
011FB8  FB8081     ZE W1, W1
011FBA  904049     MOV.B [W9+4], W0
011FBC  DD0048     SL W0, #8, W0
011FBE  708500     IOR W1, W0, W10
600:                               l2cap_handle_connection_success_for_addr(address, handle);
601:                           } else {
602:                               l2cap_handle_connection_failed_for_addr(address, packet[2]);
011FEE  578070     SUB W15, #0x10, W0
011FF0  024D1A     CALL l2cap_handle_connection_failed_for_addr
011FF2  000001     NOP
011FF4  370073     BRA 0x120DC
603:                           }
604:                           break;
605:                           
606:                       // handle successful create connection cancel command
607:                       case HCI_EVENT_COMMAND_COMPLETE:
608:                           if ( COMMAND_COMPLETE_EVENT(packet, hci_create_connection_cancel) ) {
011FF6  904030     MOV.B [W0+3], W0
011FF8  FB8000     ZE W0, W0
011FFA  9040C9     MOV.B [W9+4], W1
011FFC  DD08C8     SL W1, #8, W1
011FFE  700001     IOR W0, W1, W0
012000  2EAEC1     MOV #0xEAEC, W1
012002  500F91     SUB W0, [W1], [W15]
012004  3A000B     BRA NZ, 0x1201C
609:                               if (packet[5] == 0){
012006  904059     MOV.B [W9+5], W0
012008  E00400     CP0.B W0
01200A  3A0008     BRA NZ, 0x1201C
610:                                   bt_flip_addr(address, &packet[6]);
01200C  4480E6     ADD W9, #0x6, W1
01200E  578070     SUB W15, #0x10, W0
012010  02616A     CALL bt_flip_addr
012012  000001     NOP
611:                                   // CONNECTION TERMINATED BY LOCAL HOST (0X16)
612:                                   l2cap_handle_connection_failed_for_addr(address, 0x16);
012014  B3C161     MOV #0x16, W1
012016  578070     SUB W15, #0x10, W0
012018  024D1A     CALL l2cap_handle_connection_failed_for_addr
01201A  000001     NOP
613:                               }
614:                           }
615:                           l2cap_run();    // try sending signaling packets first
616:                           break;
617:                           
618:                       case HCI_EVENT_COMMAND_STATUS:
619:                           l2cap_run();    // try sending signaling packets first
01201C  021204     CALL l2cap_run
01201E  000001     NOP
012020  37005D     BRA 0x120DC
620:                           break;
621:                           
622:                       // handle disconnection complete events
623:                       case HCI_EVENT_DISCONNECTION_COMPLETE:
624:                           // send l2cap disconnect events for all channels on this handle
625:                           handle = READ_BT_16(packet, 3);
012022  9040B0     MOV.B [W0+3], W1
012024  FB8081     ZE W1, W1
012026  904040     MOV.B [W0+4], W0
012028  DD0048     SL W0, #8, W0
01202A  708580     IOR W1, W0, W11
626:                           it = (linked_item_t *) &l2cap_channels;
01202C  26E64A     MOV #0x6E64, W10
01202E  37000C     BRA 0x12048
627:                           while (it->next){
012048  78041A     MOV [W10], W8
01204A  E00008     CP0 W8
01204C  3AFFF1     BRA NZ, 0x12030
01204E  370046     BRA 0x120DC
628:                               l2cap_channel_t * channel = (l2cap_channel_t *) it->next;
629:                               if ( channel->handle == handle ){
012030  900078     MOV [W8+14], W0
012032  500F8B     SUB W0, W11, [W15]
012034  320002     BRA Z, 0x1203A
012036  780508     MOV W8, W10
012038  370007     BRA 0x12048
630:                                   // update prev item before free'ing next element - don't call l2cap_finalize_channel_close
631:                                   it->next = it->next->next;
01203A  780D18     MOV [W8], [W10]
632:                                   l2cap_emit_channel_closed(channel);
01203C  780008     MOV W8, W0
01203E  025448     CALL l2cap_emit_channel_closed
012040  000001     NOP
633:                                   btstack_memory_l2cap_channel_free(channel);
012042  780008     MOV W8, W0
012044  026684     CALL btstack_memory_l2cap_channel_free
012046  000001     NOP
634:                               } else {
635:                                   it = it->next;
636:                               }
637:                           }
638:                           break;
639:                           
640:                       case HCI_EVENT_NUMBER_OF_COMPLETED_PACKETS:
641:                           l2cap_run();    // try sending signaling packets first
012050  021204     CALL l2cap_run
012052  000001     NOP
642:                           l2cap_hand_out_credits();
012054  025048     CALL l2cap_hand_out_credits
012056  000001     NOP
012058  370041     BRA 0x120DC
643:                           break;
644:                           
645:                       // HCI Connection Timeouts
646:                       case L2CAP_EVENT_TIMEOUT_CHECK:
647:                           handle = READ_BT_16(packet, 2);
01205A  9040A9     MOV.B [W9+2], W1
01205C  FB8081     ZE W1, W1
01205E  904039     MOV.B [W9+3], W0
012060  DD0048     SL W0, #8, W0
012062  708400     IOR W1, W0, W8
648:                           if (hci_authentication_active_for_handle(handle)) break;
012064  780008     MOV W8, W0
012066  025A2C     CALL hci_authentication_active_for_handle
012068  000001     NOP
01206A  E00000     CP0 W0
01206C  3A0037     BRA NZ, 0x120DC
649:                           hci_con_used = 0;
650:                           for (it = (linked_item_t *) l2cap_channels; it ; it = it->next){
01206E  837321     MOV l2cap_channels, W1
012070  780100     MOV W0, W2
012072  370005     BRA 0x1207E
01207C  780091     MOV [W1], W1
01207E  E00001     CP0 W1
012080  3AFFF9     BRA NZ, 0x12074
651:                               channel = (l2cap_channel_t *) it;
652:                               if (channel->handle == handle) {
012074  900071     MOV [W1+14], W0
012076  500F88     SUB W0, W8, [W15]
012078  3A0001     BRA NZ, 0x1207C
01207A  200012     MOV #0x1, W2
653:                                   hci_con_used = 1;
654:                               }
655:                           }
656:                           if (hci_con_used) break;
012082  E00002     CP0 W2
012084  3A002B     BRA NZ, 0x120DC
657:                           if (!hci_can_send_packet_now(HCI_COMMAND_DATA_PACKET)) break;
012086  B3C010     MOV #0x1, W0
012088  025714     CALL hci_can_send_packet_now
01208A  000001     NOP
01208C  E00000     CP0 W0
01208E  320026     BRA Z, 0x120DC
658:                           hci_send_cmd(&hci_disconnect, handle, 0x13); // remote closed connection             
012090  200130     MOV #0x13, W0
012092  781F80     MOV W0, [W15++]
012094  781F88     MOV W8, [W15++]
012096  2EAF00     MOV #0xEAF0, W0
012098  781F80     MOV W0, [W15++]
01209A  026252     CALL hci_send_cmd
01209C  000001     NOP
659:                           break;
01209E  5787E6     SUB W15, #0x6, W15
0120A0  37001D     BRA 0x120DC
660:               
661:                       case DAEMON_EVENT_HCI_PACKET_SENT:
662:                           for (it = (linked_item_t *) l2cap_channels; it ; it = it->next){
0120A2  837328     MOV l2cap_channels, W8
0120A4  370009     BRA 0x120B8
0120B6  780418     MOV [W8], W8
0120B8  E00008     CP0 W8
0120BA  3AFFF5     BRA NZ, 0x120A6
663:                               channel = (l2cap_channel_t *) it;
664:                               if (channel->packet_handler) {
0120A6  901208     MOV [W8+32], W4
0120A8  E00004     CP0 W4
0120AA  320005     BRA Z, 0x120B6
665:                                   (* (channel->packet_handler))(HCI_EVENT_PACKET, channel->local_cid, packet, size);
0120AC  900898     MOV [W8+18], W1
0120AE  78018C     MOV W12, W3
0120B0  780109     MOV W9, W2
0120B2  B3C040     MOV #0x4, W0
0120B4  010004     CALL W4
666:                               } 
667:                           }
668:                           if (attribute_protocol_packet_handler) {
0120BC  837304     MOV attribute_protocol_packet_handler, W4
0120BE  E00004     CP0 W4
0120C0  320005     BRA Z, 0x120CC
669:                               (*attribute_protocol_packet_handler)(HCI_EVENT_PACKET, 0, packet, size);
0120C2  78018C     MOV W12, W3
0120C4  780109     MOV W9, W2
0120C6  780088     MOV W8, W1
0120C8  B3C040     MOV #0x4, W0
0120CA  010004     CALL W4
670:                           }
671:                           if (security_protocol_packet_handler) {
0120CC  8372F4     MOV security_protocol_packet_handler, W4
0120CE  E00004     CP0 W4
0120D0  320005     BRA Z, 0x120DC
672:                               (*security_protocol_packet_handler)(HCI_EVENT_PACKET, 0, packet, size);
0120D2  78018C     MOV W12, W3
0120D4  780109     MOV W9, W2
0120D6  780088     MOV W8, W1
0120D8  B3C040     MOV #0x4, W0
0120DA  010004     CALL W4
673:                           }
674:                           break;
675:                           
676:                       default:
677:                           break;
678:                   }
679:                   
680:                   // pass on
681:                   (*packet_handler)(NULL, HCI_EVENT_PACKET, 0, packet, size);
0120DC  78020C     MOV W12, W4
0120DE  780189     MOV W9, W3
0120E0  EB0100     CLR W2
0120E2  B3C041     MOV #0x4, W1
0120E4  EB0000     CLR W0
0120E6  8388F5     MOV packet_handler, W5
0120E8  010005     CALL W5
682:               }
683:               
684:               static void l2cap_handle_disconnect_request(l2cap_channel_t *channel, uint16_t identifier){
685:                   channel->remote_sig_id = identifier;
01307A  985403     MOV.B W3, [W8+16]
686:                   channel->state = L2CAP_STATE_WILL_SEND_DISCONNECT_RESPONSE;
01307C  2000D0     MOV #0xD, W0
01307E  980420     MOV W0, [W8+4]
687:                   l2cap_run();
013080  021204     CALL l2cap_run
013082  000001     NOP
013084  370056     BRA 0x13132
688:               }
689:               
690:               static void l2cap_register_signaling_response(hci_con_handle_t handle, uint8_t code, uint8_t sig_id, uint16_t data){
691:                   // Vol 3, Part A, 4.3: "The DCID and SCID fields shall be ignored when the result field indi- cates the connection was refused."
692:                   if (signaling_responses_pending < NR_PENDING_SIGNALING_RESPONSES) {
01580A  837344     MOV signaling_responses_pending, W4
01580C  520FE2     SUB W4, #0x2, [W15]
01580E  3C000D     BRA GT, 0x1582A
693:                       signaling_responses[signaling_responses_pending].handle = handle;
015810  B92066     MUL.SU W4, #6, W0
015812  26E6A3     MOV #0x6E6A, W3
015814  783185     MOV W5, [W3+W0]
694:                       signaling_responses[signaling_responses_pending].code = code;
015816  E88100     INC2 W0, W2
015818  410103     ADD W2, W3, W2
01581A  984116     MOV.B W6, [W2+1]
695:                       signaling_responses[signaling_responses_pending].sig_id = sig_id;
01581C  784907     MOV.B W7, [W2]
696:                       signaling_responses[signaling_responses_pending].data = data;
01581E  400064     ADD W0, #0x4, W0
015820  783188     MOV W8, [W3+W0]
697:                       signaling_responses_pending++;
015822  E80004     INC W4, W0
015824  8B7340     MOV W0, signaling_responses_pending
698:                       l2cap_run();
015826  021204     CALL l2cap_run
015828  000001     NOP
699:                   }
700:               }
701:               
702:               static void l2cap_handle_connection_request(hci_con_handle_t handle, uint8_t sig_id, uint16_t psm, uint16_t source_cid){
703:                   
704:                   // log_info("l2cap_handle_connection_request for handle %u, psm %u cid 0x%02x\n", handle, psm, source_cid);
705:                   l2cap_service_t *service = l2cap_get_service(psm);
706:                   if (!service) {
707:                       // 0x0002 PSM not supported
708:                       l2cap_register_signaling_response(handle, CONNECTION_REQUEST, sig_id, 0x0002);
0123D2  200023     MOV #0x2, W3
0123D4  78410C     MOV.B W12, W2
0123D6  784083     MOV.B W3, W1
0123D8  78000B     MOV W11, W0
0123DA  025800     CALL l2cap_register_signaling_response
0123DC  000001     NOP
709:                       return;
710:                   }
711:                   
712:                   hci_connection_t * hci_connection = connection_for_handle( handle );
0122C4  78000B     MOV W11, W0
0122C6  026184     CALL connection_for_handle
0122C8  000001     NOP
0122CA  780480     MOV W0, W9
713:                   if (!hci_connection) {
0122CC  E00000     CP0 W0
0122CE  320087     BRA Z, 0x123DE
714:                       // 
715:                       log_error("no hci_connection for handle %u\n", handle);
716:                       return;
717:                   }
718:                   // alloc structure
719:                   // log_info("l2cap_handle_connection_request register channel\n");
720:                   l2cap_channel_t * channel = (l2cap_channel_t*) btstack_memory_l2cap_channel_get();
0122D0  0266F0     CALL btstack_memory_l2cap_channel_get
0122D2  000001     NOP
0122D4  780500     MOV W0, W10
721:                   if (!channel){
0122D6  E00000     CP0 W0
0122D8  3A0004     BRA NZ, 0x122E2
722:                       // 0x0004 No resources available
723:                       l2cap_register_signaling_response(handle, CONNECTION_REQUEST, sig_id, 0x0004);
0122DA  200043     MOV #0x4, W3
0122DC  78410C     MOV.B W12, W2
0122DE  B3C021     MOV #0x2, W1
0122E0  37007B     BRA 0x123D8
724:                       return;
725:                   }
726:                   
727:                   // fill in 
728:                   BD_ADDR_COPY(channel->address, hci_connection->address);
0122E2  400768     ADD W0, #0x8, W14
0122E4  448064     ADD W9, #0x4, W0
0122E6  090005     REPEAT #0x5
0122E8  785F30     MOV.B [W0++], [W14++]
0122EA  B1006E     SUB #0x6, W14
0122EC  B10060     SUB #0x6, W0
729:                   channel->psm = psm;
0122EE  980D5D     MOV W13, [W10+26]
730:                   channel->handle = handle;
0122F0  98057B     MOV W11, [W10+14]
731:                   channel->connection = service->connection;
0122F2  900048     MOV [W8+8], W0
0122F4  980D70     MOV W0, [W10+30]
732:                   channel->packet_handler = service->packet_handler;
0122F6  900058     MOV [W8+10], W0
0122F8  981500     MOV W0, [W10+32]
733:                   channel->local_cid  = l2cap_next_local_cid();
0122FA  0266C4     CALL l2cap_next_local_cid
0122FC  000001     NOP
0122FE  980D10     MOV W0, [W10+18]
734:                   channel->remote_cid = source_cid;
012300  97B80F     MOV [W15-16], W0
012302  980D20     MOV W0, [W10+20]
735:                   channel->local_mtu  = service->mtu;
012304  900438     MOV [W8+6], W8
012306  980D38     MOV W8, [W10+22]
736:                   channel->remote_mtu = L2CAP_DEFAULT_MTU;
012308  202A00     MOV #0x2A0, W0
01230A  980D40     MOV W0, [W10+24]
737:                   channel->packets_granted = 0;
01230C  EB4000     CLR.B W0
01230E  985D40     MOV.B W0, [W10+28]
738:                   channel->remote_sig_id = sig_id; 
012310  98550C     MOV.B W12, [W10+16]
739:               
740:                   // limit local mtu to max acl packet length
741:                   if (channel->local_mtu > l2cap_max_mtu()) {
012312  0266B4     CALL l2cap_max_mtu
012314  000001     NOP
012316  540F80     SUB W8, W0, [W15]
012318  360003     BRA LEU, 0x12320
742:                       channel->local_mtu = l2cap_max_mtu();
01231A  0266B4     CALL l2cap_max_mtu
01231C  000001     NOP
01231E  980D30     MOV W0, [W10+22]
743:                   }
744:                   
745:                   // set initial state
746:                   channel->state = L2CAP_STATE_WAIT_CLIENT_ACCEPT_OR_REJECT;
012320  200048     MOV #0x4, W8
012322  980528     MOV W8, [W10+4]
747:                   channel->state_var = L2CAP_CHANNEL_STATE_VAR_NONE;
012324  EB0480     CLR W9
012326  980539     MOV W9, [W10+6]
748:                   
749:                   // add to connections list
750:                   linked_list_add(&l2cap_channels, (linked_item_t *) channel);
012328  78008A     MOV W10, W1
01232A  26E640     MOV #0x6E64, W0
01232C  0263E6     CALL linked_list_add
01232E  000001     NOP
751:                   
752:                   // emit incoming connection request
753:                   l2cap_emit_connection_request(channel);
754:               }
755:               
756:               void l2cap_accept_connection_internal(uint16_t local_cid){
757:                   log_info("L2CAP_ACCEPT_CONNECTION local_cid 0x%x", local_cid);
758:                   l2cap_channel_t * channel = l2cap_get_channel_for_local_cid(local_cid);
759:                   if (!channel) {
760:                       log_error("l2cap_accept_connection_internal called but local_cid 0x%x not found", local_cid);
761:                       return;
762:                   }
763:               
764:                   channel->state = L2CAP_STATE_WILL_SEND_CONNECTION_RESPONSE_ACCEPT;
016070  2000B0     MOV #0xB, W0
016072  9800A0     MOV W0, [W1+4]
765:               
766:                   // process
767:                   l2cap_run();
768:               }
769:               
770:               void l2cap_decline_connection_internal(uint16_t local_cid, uint8_t reason){
771:                   log_info("L2CAP_DECLINE_CONNECTION local_cid 0x%x, reason %x", local_cid, reason);
772:                   l2cap_channel_t * channel = l2cap_get_channel_for_local_cid( local_cid);
773:                   if (!channel) {
774:                       log_error( "l2cap_decline_connection_internal called but local_cid 0x%x not found", local_cid);
775:                       return;
776:                   }
777:                   channel->state  = L2CAP_STATE_WILL_SEND_CONNECTION_RESPONSE_DECLINE;
015F8C  2000A0     MOV #0xA, W0
015F8E  980120     MOV W0, [W2+4]
778:                   channel->reason = reason;
015F90  985951     MOV.B W1, [W2+29]
779:                   l2cap_run();
780:               }
781:               
782:               void l2cap_signaling_handle_configure_request(l2cap_channel_t *channel, uint8_t *command){
783:               
784:                   channel->remote_sig_id = command[L2CAP_SIGNALING_COMMAND_SIGID_OFFSET];
014D62  904011     MOV.B [W1+1], W0
014D64  985280     MOV.B W0, [W5+16]
785:               
786:                   // accept the other's configuration options
787:                   uint16_t end_pos = 4 + READ_BT_16(command, L2CAP_SIGNALING_COMMAND_LENGTH_OFFSET);
014D66  9040A1     MOV.B [W1+2], W1
014D68  FB8081     ZE W1, W1
014D6A  904033     MOV.B [W3+3], W0
014D6C  DD0048     SL W0, #8, W0
014D6E  708080     IOR W1, W0, W1
014D70  408364     ADD W1, #0x4, W6
014D72  200081     MOV #0x8, W1
014D74  370012     BRA 0x14D9A
788:                   uint16_t pos     = 8;
789:                   while (pos < end_pos){
014D9A  508F86     SUB W1, W6, [W15]
014D9C  39FFEC     BRA NC, 0x14D76
790:                       uint8_t type   = command[pos++];
791:                       uint8_t length = command[pos++];
014D76  408003     ADD W1, W3, W0
014D78  904210     MOV.B [W0+1], W4
014D7A  E88101     INC2 W1, W2
792:                       // MTU { type(8): 1, len(8):2, MTU(16) }
793:                       if ((type & 0x7f) == 1 && length == 2){
014D7C  FB8010     ZE [W0], W0
014D7E  B207F0     AND #0x7F, W0
014D80  500FE1     SUB W0, #0x1, [W15]
014D82  3A0009     BRA NZ, 0x14D96
014D84  524FE2     SUB.B W4, #0x2, [W15]
014D86  3A0007     BRA NZ, 0x14D96
794:                           channel->remote_mtu = READ_BT_16(command, pos);
014D88  794063     MOV.B [W3+W2], W0
014D8A  FB8000     ZE W0, W0
014D8C  418082     ADD W3, W2, W1
014D8E  904091     MOV.B [W1+1], W1
014D90  DD08C8     SL W1, #8, W1
014D92  700001     IOR W0, W1, W0
014D94  980AC0     MOV W0, [W5+24]
795:                           // log_info("l2cap cid 0x%02x, remote mtu %u\n", channel->local_cid, channel->remote_mtu);
796:                       }
797:                       pos += length;
014D96  FB8004     ZE W4, W0
014D98  410080     ADD W2, W0, W1
798:                   }
799:               }
800:               
801:               static int l2cap_channel_ready_for_open(l2cap_channel_t *channel){
802:                   // log_info("l2cap_channel_ready_for_open 0x%02x\n", channel->state_var);
803:                   if ((channel->state_var & L2CAP_CHANNEL_STATE_VAR_RCVD_CONF_RSP) == 0) return 0;
0164DE  9000B0     MOV [W0+6], W1
0164E0  A31801     BTST.Z W1, #1
0164E2  320003     BRA Z, 0x164EA
804:                   if ((channel->state_var & L2CAP_CHANNEL_STATE_VAR_SENT_CONF_RSP) == 0) return 0;
0164E4  200010     MOV #0x1, W0
0164E6  A35801     BTST.Z W1, #5
0164E8  3A0001     BRA NZ, 0x164EC
0164EA  EB0000     CLR W0
805:                   return 1;
806:               }
807:               
808:               
809:               void l2cap_signaling_handler_channel(l2cap_channel_t *channel, uint8_t *command){
810:               
811:                   uint8_t  code       = command[L2CAP_SIGNALING_COMMAND_CODE_OFFSET];
013062  784011     MOV.B [W1], W0
812:                   uint8_t  identifier = command[L2CAP_SIGNALING_COMMAND_SIGID_OFFSET];
013064  904191     MOV.B [W1+1], W3
013066  9000A8     MOV [W8+4], W1
813:                   uint16_t result = 0;
814:                   
815:                   log_info("L2CAP signaling handler code %u, state %u\n", code, channel->state);
816:                   
817:                   // handle DISCONNECT REQUESTS seperately
818:                   if (code == DISCONNECTION_REQUEST){
013068  504FE6     SUB.B W0, #0x6, [W15]
01306A  3A000D     BRA NZ, 0x13086
819:                       switch (channel->state){
01306C  508FEC     SUB W1, #0xC, [W15]
01306E  3E0061     BRA GTU, 0x13132
013070  200010     MOV #0x1, W0
013072  DD0001     SL W0, W1, W0
013074  211C01     MOV #0x11C0, W1
013076  600001     AND W0, W1, W0
013078  32005C     BRA Z, 0x13132
820:                           case L2CAP_STATE_CONFIG:
821:                           case L2CAP_STATE_OPEN:
822:                           case L2CAP_STATE_WILL_SEND_DISCONNECT_REQUEST:
823:                           case L2CAP_STATE_WAIT_DISCONNECT:
824:                               l2cap_handle_disconnect_request(channel, identifier);
825:                               break;
826:               
827:                           default:
828:                               // ignore in other states
829:                               break;
830:                       }
831:                       return;
832:                   }
833:                   
834:                   // @STATEMACHINE(l2cap)
835:                   switch (channel->state) {
013086  508FE6     SUB W1, #0x6, [W15]
013088  32002F     BRA Z, 0x130E8
01308A  508FE8     SUB W1, #0x8, [W15]
01308C  32004D     BRA Z, 0x13128
01308E  508FE5     SUB W1, #0x5, [W15]
013090  3A0050     BRA NZ, 0x13132
836:                           
837:                       case L2CAP_STATE_WAIT_CONNECT_RSP:
838:                           switch (code){
013092  504FE3     SUB.B W0, #0x3, [W15]
013094  3A004E     BRA NZ, 0x13132
839:                               case CONNECTION_RESPONSE:
840:                                   result = READ_BT_16 (command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET+4);
013096  904882     MOV.B [W2+8], W1
013098  FB8081     ZE W1, W1
01309A  904812     MOV.B [W2+9], W0
01309C  DD0048     SL W0, #8, W0
01309E  708480     IOR W1, W0, W9
841:                                   switch (result) {
0130A0  320003     BRA Z, 0x130A8
0130A2  548FE1     SUB W9, #0x1, [W15]
0130A4  3A000D     BRA NZ, 0x130C0
0130A6  370045     BRA 0x13132
842:                                       case 0:
843:                                           // successful connection
844:                                           channel->remote_cid = READ_BT_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET);
0130A8  9040C2     MOV.B [W2+4], W1
0130AA  FB8081     ZE W1, W1
0130AC  904052     MOV.B [W2+5], W0
0130AE  DD0048     SL W0, #8, W0
0130B0  708080     IOR W1, W0, W1
0130B2  980C21     MOV W1, [W8+20]
845:                                           channel->state = L2CAP_STATE_CONFIG;
0130B4  200060     MOV #0x6, W0
0130B6  980420     MOV W0, [W8+4]
846:                                           channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_REQ);
847:                                           break;
848:                                       case 1:
849:                                           // connection pending. get some coffee
850:                                           break;
851:                                       default:
852:                                           // channel closed
853:                                           channel->state = L2CAP_STATE_CLOSED;
0130C0  200010     MOV #0x1, W0
0130C2  980420     MOV W0, [W8+4]
854:               
855:                                           // map l2cap connection response result to BTstack status enumeration
856:                                           l2cap_emit_channel_opened(channel, L2CAP_CONNECTION_RESPONSE_RESULT_SUCCESSFUL + result);
0130C4  B3C630     MOV #0x63, W0
0130C6  44C080     ADD.B W9, W0, W1
0130C8  780008     MOV W8, W0
0130CA  023CDA     CALL l2cap_emit_channel_opened
0130CC  000001     NOP
857:                                           
858:                                           // drop link key if security block
859:                                           if (L2CAP_CONNECTION_RESPONSE_RESULT_SUCCESSFUL + result == L2CAP_CONNECTION_RESPONSE_RESULT_REFUSED_SECURITY){
0130CE  548FE3     SUB W9, #0x3, [W15]
0130D0  3A0003     BRA NZ, 0x130D8
860:                                               hci_drop_link_key_for_bd_addr(&channel->address);
0130D2  440068     ADD W8, #0x8, W0
0130D4  0265A6     CALL hci_drop_link_key_for_bd_addr
0130D6  000001     NOP
861:                                           }
862:                                           
863:                                           // discard channel
864:                                           linked_list_remove(&l2cap_channels, (linked_item_t *) channel);
0130D8  780088     MOV W8, W1
0130DA  26E640     MOV #0x6E64, W0
0130DC  0263FC     CALL linked_list_remove
0130DE  000001     NOP
865:                                           btstack_memory_l2cap_channel_free(channel);
0130E0  780008     MOV W8, W0
0130E2  026684     CALL btstack_memory_l2cap_channel_free
0130E4  000001     NOP
0130E6  370025     BRA 0x13132
866:                                           break;
867:                                   }
868:                                   break;
869:                                   
870:                               default:
871:                                   //@TODO: implement other signaling packets
872:                                   break;
873:                           }
874:                           break;
875:               
876:                       case L2CAP_STATE_CONFIG:
877:                           switch (code) {
0130E8  504FE4     SUB.B W0, #0x4, [W15]
0130EA  320003     BRA Z, 0x130F2
0130EC  504FE5     SUB.B W0, #0x5, [W15]
0130EE  3A000C     BRA NZ, 0x13108
0130F0  370008     BRA 0x13102
878:                               case CONFIGURE_REQUEST:
879:                                   channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_RCVD_CONF_REQ);
880:                                   channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP);
881:                                   l2cap_signaling_handle_configure_request(channel, command);
0130F8  780082     MOV W2, W1
0130FA  780008     MOV W8, W0
0130FC  024D5E     CALL l2cap_signaling_handle_configure_request
0130FE  000001     NOP
013100  370003     BRA 0x13108
882:                                   break;
883:                               case CONFIGURE_RESPONSE:
884:                                   channelStateVarSetFlag(channel, L2CAP_CHANNEL_STATE_VAR_RCVD_CONF_RSP);
885:                                   break;
886:                               default:
887:                                   break;
888:                           }
889:                           if (l2cap_channel_ready_for_open(channel)){
013108  780008     MOV W8, W0
01310A  0264DE     CALL l2cap_channel_ready_for_open
01310C  000001     NOP
01310E  E00000     CP0 W0
013110  320010     BRA Z, 0x13132
890:                               // for open:
891:                               channel->state = L2CAP_STATE_OPEN;
013112  200070     MOV #0x7, W0
013114  980420     MOV W0, [W8+4]
892:                               l2cap_emit_channel_opened(channel, 0);
013116  EB4080     CLR.B W1
013118  780008     MOV W8, W0
01311A  023CDA     CALL l2cap_emit_channel_opened
01311C  000001     NOP
893:                               l2cap_emit_credits(channel, 1);
01311E  B3C011     MOV #0x1, W1
013120  780008     MOV W8, W0
013122  024E20     CALL l2cap_emit_credits
013124  000001     NOP
013126  370005     BRA 0x13132
894:                           }
895:                           break;
896:                           
897:                       case L2CAP_STATE_WAIT_DISCONNECT:
898:                           switch (code) {
013128  504FE7     SUB.B W0, #0x7, [W15]
01312A  3A0003     BRA NZ, 0x13132
899:                               case DISCONNECTION_RESPONSE:
900:                                   l2cap_finialize_channel_close(channel);
01312C  780008     MOV W8, W0
01312E  025EC2     CALL l2cap_finialize_channel_close
013130  000001     NOP
901:                                   break;
902:                               default:
903:                                   //@TODO: implement other signaling packets
904:                                   break;
905:                           }
906:                           break;
907:                           
908:                       case L2CAP_STATE_CLOSED:
909:                           // @TODO handle incoming requests
910:                           break;
911:                           
912:                       case L2CAP_STATE_OPEN:
913:                           //@TODO: implement other signaling packets, e.g. re-configure
914:                           break;
915:                       default:
916:                           break;
917:                   }
918:                   // log_info("new state %u\n", channel->state);
919:               }
920:               
921:               
922:               void l2cap_signaling_handler_dispatch( hci_con_handle_t handle, uint8_t * command){
923:                   
924:                   // get code, signalind identifier and command len
925:                   uint8_t code   = command[L2CAP_SIGNALING_COMMAND_CODE_OFFSET];
01227E  784091     MOV.B [W1], W1
926:                   uint8_t sig_id = command[L2CAP_SIGNALING_COMMAND_SIGID_OFFSET];
012280  904613     MOV.B [W3+1], W12
927:                   
928:                   // not for a particular channel, and not CONNECTION_REQUEST, ECHO_[REQUEST|RESPONSE], INFORMATION_REQUEST 
929:                   if (code < 1 || code == ECHO_RESPONSE || code > INFORMATION_REQUEST){
012282  E00401     CP0.B W1
012284  3200AC     BRA Z, 0x123DE
012286  50CFE9     SUB.B W1, #0x9, [W15]
012288  3200AA     BRA Z, 0x123DE
01228A  50CFEA     SUB.B W1, #0xA, [W15]
01228C  3E00A8     BRA GTU, 0x123DE
930:                       return;
931:                   }
932:               
933:                   // general commands without an assigned channel
934:                   switch(code) {
01228E  FB8201     ZE W1, W4
012290  50CFE8     SUB.B W1, #0x8, [W15]
012292  32007D     BRA Z, 0x1238E
012294  50CFEA     SUB.B W1, #0xA, [W15]
012296  32007D     BRA Z, 0x12392
012298  904143     MOV.B [W3+4], W2
01229A  904053     MOV.B [W3+5], W0
01229C  50CFE2     SUB.B W1, #0x2, [W15]
01229E  3A0080     BRA NZ, 0x123A0
935:                           
936:                       case CONNECTION_REQUEST: {
937:                           uint16_t psm =        READ_BT_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET);
0122A0  FB8082     ZE W2, W1
0122A2  DD0048     SL W0, #8, W0
0122A4  708680     IOR W1, W0, W13
938:                           uint16_t source_cid = READ_BT_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET+2);
0122A6  9040E3     MOV.B [W3+6], W1
0122A8  FB8081     ZE W1, W1
0122AA  904073     MOV.B [W3+7], W0
0122AC  DD0048     SL W0, #8, W0
0122AE  708080     IOR W1, W0, W1
0122B0  9FBF81     MOV W1, [W15-16]
939:                           l2cap_handle_connection_request(handle, sig_id, psm, source_cid);
940:                           return;
941:                       }
942:                           
943:                       case ECHO_REQUEST:
944:                           l2cap_register_signaling_response(handle, code, sig_id, 0);
01238E  EB0180     CLR W3
012390  370005     BRA 0x1239C
945:                           return;
946:                           
947:                       case INFORMATION_REQUEST: {
948:                           uint16_t infoType = READ_BT_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET);
949:                           l2cap_register_signaling_response(handle, code, sig_id, infoType);
012392  904043     MOV.B [W3+4], W0
012394  FB8000     ZE W0, W0
012396  9041D3     MOV.B [W3+5], W3
012398  DD19C8     SL W3, #8, W3
01239A  700183     IOR W0, W3, W3
01239C  78410C     MOV.B W12, W2
01239E  37001C     BRA 0x123D8
950:                           return;
951:                       }
952:                           
953:                       default:
954:                           break;
955:                   }
956:                   
957:                   
958:                   // Get potential destination CID
959:                   uint16_t dest_cid = READ_BT_16(command, L2CAP_SIGNALING_COMMAND_DATA_OFFSET);
0123A0  FB8082     ZE W2, W1
0123A2  DD0048     SL W0, #8, W0
0123A4  708080     IOR W1, W0, W1
960:                   
961:                   // Find channel for this sig_id and connection handle
962:                   linked_item_t *it;
963:                   for (it = (linked_item_t *) l2cap_channels; it ; it = it->next){
0123A6  837322     MOV l2cap_channels, W2
0123A8  37000D     BRA 0x123C4
0123C2  780112     MOV [W2], W2
0123C4  E00002     CP0 W2
0123C6  3AFFF1     BRA NZ, 0x123AA
0123C8  37000A     BRA 0x123DE
964:                       l2cap_channel_t * channel = (l2cap_channel_t *) it;
965:                       if (channel->handle == handle) {
0123AA  900072     MOV [W2+14], W0
0123AC  500F8B     SUB W0, W11, [W15]
0123AE  3A0009     BRA NZ, 0x123C2
966:                           if (code & 1) {
0123B0  A30804     BTST.Z W4, #0
0123B2  320004     BRA Z, 0x123BC
967:                               // match odd commands (responses) by previous signaling identifier 
968:                               if (channel->local_sig_id == sig_id) {
0123B4  905012     MOV.B [W2+17], W0
0123B6  504F8C     SUB.B W0, W12, [W15]
0123B8  3A0004     BRA NZ, 0x123C2
0123BA  370007     BRA 0x123CA
969:                                   l2cap_signaling_handler_channel(channel, command);
970:                                   break;
971:                               }
972:                           } else {
973:                               // match even commands (requests) by local channel id
974:                               if (channel->local_cid == dest_cid) {
0123BC  900812     MOV [W2+18], W0
0123BE  500F81     SUB W0, W1, [W15]
0123C0  320004     BRA Z, 0x123CA
975:                                   l2cap_signaling_handler_channel(channel, command);
0123CA  BE0002     MOV.D W2, W0
0123CC  02305C     CALL l2cap_signaling_handler_channel
0123CE  000001     NOP
0123D0  370006     BRA 0x123DE
976:                                   break;
977:                               }
978:                           }
979:                       }
980:                   }
981:               }
982:               
983:               void l2cap_acl_handler( uint8_t *packet, uint16_t size ){
984:                       
985:                   // Get Channel ID
986:                   uint16_t channel_id = READ_L2CAP_CHANNEL_ID(packet); 
013620  9040E0     MOV.B [W0+6], W1
013622  FB8081     ZE W1, W1
013624  904070     MOV.B [W0+7], W0
013626  DD0048     SL W0, #8, W0
013628  708100     IOR W1, W0, W2
987:                   hci_con_handle_t handle = READ_ACL_CONNECTION_HANDLE(packet);
01362A  FB8099     ZE [W9], W1
01362C  904019     MOV.B [W9+1], W0
01362E  DD0048     SL W0, #8, W0
013630  708080     IOR W1, W0, W1
013632  20FFF0     MOV #0xFFF, W0
013634  608580     AND W1, W0, W11
988:                   
989:                   switch (channel_id) {
013636  510FE4     SUB W2, #0x4, [W15]
013638  320015     BRA Z, 0x13664
01363A  510FE6     SUB W2, #0x6, [W15]
01363C  32001B     BRA Z, 0x13674
01363E  20008A     MOV #0x8, W10
013640  510FE1     SUB W2, #0x1, [W15]
013642  32000D     BRA Z, 0x1365E
013644  370020     BRA 0x13686
990:                           
991:                       case L2CAP_CID_SIGNALING: {
992:                           
993:                           uint16_t command_offset = 8;
994:                           while (command_offset < size) {                
01365E  550F8C     SUB W10, W12, [W15]
013660  39FFF2     BRA NC, 0x13646
013662  370020     BRA 0x136A4
995:                               
996:                               // handle signaling commands
997:                               l2cap_signaling_handler_dispatch(handle, &packet[command_offset]);
013646  44840A     ADD W9, W10, W8
013648  780088     MOV W8, W1
01364A  78000B     MOV W11, W0
01364C  022270     CALL l2cap_signaling_handler_dispatch
01364E  000001     NOP
998:                               
999:                               // increment command_offset
1000:                              command_offset += L2CAP_SIGNALING_COMMAND_DATA_OFFSET + READ_BT_16(packet, command_offset + L2CAP_SIGNALING_COMMAND_LENGTH_OFFSET);
013650  904028     MOV.B [W8+2], W0
013652  FB8000     ZE W0, W0
013654  9040B8     MOV.B [W8+3], W1
013656  DD08C8     SL W1, #8, W1
013658  700001     IOR W0, W1, W0
01365A  450000     ADD W10, W0, W0
01365C  400564     ADD W0, #0x4, W10
1001:                          }
1002:                          break;
1003:                      }
1004:                          
1005:                      case L2CAP_CID_ATTRIBUTE_PROTOCOL:
1006:                          if (attribute_protocol_packet_handler) {
013664  837304     MOV attribute_protocol_packet_handler, W4
013666  E00004     CP0 W4
013668  32001D     BRA Z, 0x136A4
1007:                              (*attribute_protocol_packet_handler)(ATT_DATA_PACKET, handle, &packet[COMPLETE_L2CAP_HEADER], size-COMPLETE_L2CAP_HEADER);
01366A  448168     ADD W9, #0x8, W2
01366C  5601E8     SUB W12, #0x8, W3
01366E  78008B     MOV W11, W1
013670  B3C080     MOV #0x8, W0
013672  370007     BRA 0x13682
1008:                          }
1009:                          break;
1010:              
1011:                      case L2CAP_CID_SECURITY_MANAGER_PROTOCOL:
1012:                          if (security_protocol_packet_handler) {
013674  8372F4     MOV security_protocol_packet_handler, W4
013676  E00004     CP0 W4
013678  320015     BRA Z, 0x136A4
1013:                              (*security_protocol_packet_handler)(SM_DATA_PACKET, handle, &packet[COMPLETE_L2CAP_HEADER], size-COMPLETE_L2CAP_HEADER);
01367A  448168     ADD W9, #0x8, W2
01367C  5601E8     SUB W12, #0x8, W3
01367E  78008B     MOV W11, W1
013680  B3C090     MOV #0x9, W0
013682  010004     CALL W4
013684  37000F     BRA 0x136A4
1014:                          }
1015:                          break;
1016:                          
1017:                      default: {
1018:                          // Find channel for this channel_id and connection handle
1019:                          l2cap_channel_t * channel = l2cap_get_channel_for_local_cid(channel_id);
1020:                          if (channel) {
1021:                              l2cap_dispatch(channel, L2CAP_DATA_PACKET, &packet[COMPLETE_L2CAP_HEADER], size-COMPLETE_L2CAP_HEADER);
013698  448168     ADD W9, #0x8, W2
01369A  5601E8     SUB W12, #0x8, W3
01369C  B3C061     MOV #0x6, W1
01369E  780004     MOV W4, W0
0136A0  025F5A     CALL l2cap_dispatch
0136A2  000001     NOP
1022:                          }
1023:                          break;
1024:                      }
1025:                  }
1026:                  
1027:                  l2cap_run();
0136A4  021204     CALL l2cap_run
0136A6  000001     NOP
1028:              }
1029:              
1030:              static void l2cap_packet_handler(uint8_t packet_type, uint8_t *packet, uint16_t size){
1031:                  switch (packet_type) {
0161F0  504FE2     SUB.B W0, #0x2, [W15]
0161F2  320005     BRA Z, 0x161FE
0161F4  504FE4     SUB.B W0, #0x4, [W15]
0161F6  3A0006     BRA NZ, 0x16204
1032:                      case HCI_EVENT_PACKET:
1033:                          l2cap_event_handler(packet, size);
0161F8  780003     MOV W3, W0
0161FA  041F74     GOTO l2cap_event_handler
0161FC  000001     NOP
1034:                          break;
1035:                      case HCI_ACL_DATA_PACKET:
1036:                          l2cap_acl_handler(packet, size);
1037:                          break;
1038:                      default:
1039:                          break;
1040:                  }
1041:              }
1042:              
1043:              // finalize closed channel - l2cap_handle_disconnect_request & DISCONNECTION_RESPONSE
1044:              void l2cap_finialize_channel_close(l2cap_channel_t *channel){
1045:                  channel->state = L2CAP_STATE_CLOSED;
015EC6  200010     MOV #0x1, W0
015EC8  980420     MOV W0, [W8+4]
1046:                  l2cap_emit_channel_closed(channel);
015ECA  780008     MOV W8, W0
015ECC  025448     CALL l2cap_emit_channel_closed
015ECE  000001     NOP
1047:                  // discard channel
1048:                  linked_list_remove(&l2cap_channels, (linked_item_t *) channel);
015ED0  780088     MOV W8, W1
015ED2  26E640     MOV #0x6E64, W0
015ED4  0263FC     CALL linked_list_remove
015ED6  000001     NOP
1049:                  btstack_memory_l2cap_channel_free(channel);
015ED8  780008     MOV W8, W0
015EDA  026684     CALL btstack_memory_l2cap_channel_free
015EDC  000001     NOP
1050:              }
1051:              
1052:              l2cap_service_t * l2cap_get_service(uint16_t psm){
1053:                  linked_item_t *it;
1054:                  
1055:                  // close open channels
1056:                  for (it = (linked_item_t *) l2cap_services; it ; it = it->next){
0122B2  837318     MOV l2cap_services, W8
0122B4  370004     BRA 0x122BE
0122BC  780418     MOV [W8], W8
0122BE  E00008     CP0 W8
0122C0  3AFFFA     BRA NZ, 0x122B6
0122C2  370087     BRA 0x123D2
014350  837311     MOV l2cap_services, W1
014352  370004     BRA 0x1435C
01435A  780091     MOV [W1], W1
01435C  E00001     CP0 W1
01435E  3AFFFA     BRA NZ, 0x14354
014360  370013     BRA 0x14388
015480  837318     MOV l2cap_services, W8
015482  370004     BRA 0x1548C
01548A  780418     MOV [W8], W8
01548C  E00008     CP0 W8
01548E  3AFFFA     BRA NZ, 0x15484
015490  37000F     BRA 0x154B0
1057:                      l2cap_service_t * service = ((l2cap_service_t *) it);
1058:                      if ( service->psm == psm){
0122B6  900028     MOV [W8+4], W0
0122B8  500F8D     SUB W0, W13, [W15]
0122BA  320004     BRA Z, 0x122C4
014354  900021     MOV [W1+4], W0
014356  500F88     SUB W0, W8, [W15]
014358  320004     BRA Z, 0x14362
015484  900028     MOV [W8+4], W0
015486  500F81     SUB W0, W1, [W15]
015488  320004     BRA Z, 0x15492
1059:                          return service;
1060:                      };
1061:                  }
1062:                  return NULL;
1063:              }
1064:              
1065:              void l2cap_register_service_internal(void *connection, btstack_packet_handler_t packet_handler, uint16_t psm, uint16_t mtu){
1066:                  
1067:                  log_info("L2CAP_REGISTER_SERVICE psm 0x%x mtu %u", psm, mtu);
1068:                  
1069:                  // check for alread registered psm 
1070:                  // TODO: emit error event
1071:                  l2cap_service_t *service = l2cap_get_service(psm);
1072:                  if (service) {
1073:                      log_error("l2cap_register_service_internal: PSM %u already registered\n", psm);
1074:                      l2cap_emit_service_registered(connection, L2CAP_SERVICE_ALREADY_REGISTERED, psm);
014362  780108     MOV W8, W2
014364  B3C6A1     MOV #0x6A, W1
014366  370016     BRA 0x14394
1075:                      return;
1076:                  }
1077:                  
1078:                  // alloc structure
1079:                  // TODO: emit error event
1080:                  service = (l2cap_service_t *) btstack_memory_l2cap_service_get();
014388  0266EA     CALL btstack_memory_l2cap_service_get
01438A  000001     NOP
01438C  780080     MOV W0, W1
1081:                  if (!service) {
01438E  E00000     CP0 W0
014390  3AFFEE     BRA NZ, 0x1436E
014392  37FFEA     BRA 0x14368
1082:                      log_error("l2cap_register_service_internal: no memory for l2cap_service_t\n");
1083:                      l2cap_emit_service_registered(connection, BTSTACK_MEMORY_ALLOC_FAILED, psm);
014368  780108     MOV W8, W2
01436A  B3C561     MOV #0x56, W1
01436C  370013     BRA 0x14394
1084:                      return;
1085:                  }
1086:                  
1087:                  // fill in 
1088:                  service->psm = psm;
01436E  9800A8     MOV W8, [W1+4]
1089:                  service->mtu = mtu;
014370  9800BA     MOV W10, [W1+6]
1090:                  service->connection = connection;
014372  9800C9     MOV W9, [W1+8]
1091:                  service->packet_handler = packet_handler;
014374  9800DB     MOV W11, [W1+10]
1092:              
1093:                  // add to services list
1094:                  linked_list_add(&l2cap_services, (linked_item_t *) service);
014376  26E620     MOV #0x6E62, W0
014378  0263E6     CALL linked_list_add
01437A  000001     NOP
1095:                  
1096:                  // enable page scan
1097:                  hci_connectable_control(1);
01437C  B3C010     MOV #0x1, W0
01437E  026428     CALL hci_connectable_control
014380  000001     NOP
1098:              
1099:                  // done
1100:                  l2cap_emit_service_registered(connection, 0, psm);
014382  780108     MOV W8, W2
014384  EB4080     CLR.B W1
014386  370006     BRA 0x14394
014394  780009     MOV W9, W0
014396  0252CA     CALL l2cap_emit_service_registered
014398  000001     NOP
1101:              }
1102:              
1103:              void l2cap_unregister_service_internal(void *connection, uint16_t psm){
1104:                  
1105:                  log_info("L2CAP_UNREGISTER_SERVICE psm 0x%x", psm);
1106:              
1107:                  l2cap_service_t *service = l2cap_get_service(psm);
1108:                  if (!service) return;
1109:                  linked_list_remove(&l2cap_services, (linked_item_t *) service);
015492  780088     MOV W8, W1
015494  26E620     MOV #0x6E62, W0
015496  0263FC     CALL linked_list_remove
015498  000001     NOP
1110:                  btstack_memory_l2cap_service_free(service);
01549A  780008     MOV W8, W0
01549C  02667C     CALL btstack_memory_l2cap_service_free
01549E  000001     NOP
1111:                  
1112:                  // disable page scan when no services registered
1113:                  if (!linked_list_empty(&l2cap_services)) return;
0154A0  26E620     MOV #0x6E62, W0
0154A2  0265CA     CALL linked_list_empty
0154A4  000001     NOP
0154A6  E00000     CP0 W0
0154A8  320003     BRA Z, 0x154B0
1114:                  hci_connectable_control(0);
0154AA  EB4000     CLR.B W0
0154AC  026428     CALL hci_connectable_control
0154AE  000001     NOP
1115:              }
1116:              
1117:              //
1118:              void l2cap_close_connection(void *connection){
1119:                  linked_item_t *it;
1120:                  
1121:                  // close open channels - note to myself: no channel is freed, so no new for fancy iterator tricks
1122:                  l2cap_channel_t * channel;
1123:                  for (it = (linked_item_t *) l2cap_channels; it ; it = it->next){
0150C4  837321     MOV l2cap_channels, W1
0150C6  2000C2     MOV #0xC, W2
0150C8  370005     BRA 0x150D4
0150D2  780091     MOV [W1], W1
0150D4  E00001     CP0 W1
0150D6  3AFFF9     BRA NZ, 0x150CA
1124:                      channel = (l2cap_channel_t *) it;
1125:                      if (channel->connection == connection) {
0150CA  900871     MOV [W1+30], W0
0150CC  500F89     SUB W0, W9, [W15]
0150CE  3A0001     BRA NZ, 0x150D2
1126:                          channel->state = L2CAP_STATE_WILL_SEND_DISCONNECT_REQUEST;
0150D0  9800A2     MOV W2, [W1+4]
1127:                      }
1128:                  }   
1129:                  
1130:                  // unregister services
1131:                  it = (linked_item_t *) &l2cap_services;
0150D8  26E628     MOV #0x6E62, W8
0150DA  370009     BRA 0x150EE
1132:                  while (it->next) {
0150EE  780098     MOV [W8], W1
0150F0  E00001     CP0 W1
0150F2  3AFFF4     BRA NZ, 0x150DC
1133:                      l2cap_service_t * service = (l2cap_service_t *) it->next;
1134:                      if (service->connection == connection){
0150DC  900041     MOV [W1+8], W0
0150DE  500F89     SUB W0, W9, [W15]
0150E0  320002     BRA Z, 0x150E6
0150E2  780401     MOV W1, W8
0150E4  370004     BRA 0x150EE
1135:                          it->next = it->next->next;
0150E6  780C11     MOV [W1], [W8]
1136:                          btstack_memory_l2cap_service_free(service);
0150E8  780001     MOV W1, W0
0150EA  02667C     CALL btstack_memory_l2cap_service_free
0150EC  000001     NOP
1137:                      } else {
1138:                          it = it->next;
1139:                      }
1140:                  }
1141:                  
1142:                  // process
1143:                  l2cap_run();
0150F4  021204     CALL l2cap_run
0150F6  000001     NOP
1144:              }
1145:              
1146:              // Bluetooth 4.0 - allows to register handler for Attribute Protocol and Security Manager Protocol
1147:              void l2cap_register_fixed_channel(btstack_packet_handler_t packet_handler, uint16_t channel_id) {
1148:                  switch(channel_id){
01649A  508FE4     SUB W1, #0x4, [W15]
01649C  320003     BRA Z, 0x164A4
01649E  508FE6     SUB W1, #0x6, [W15]
0164A0  3A0004     BRA NZ, 0x164AA
0164A2  370002     BRA 0x164A8
1149:                      case L2CAP_CID_ATTRIBUTE_PROTOCOL:
1150:                          attribute_protocol_packet_handler = packet_handler;
0164A4  8B7300     MOV W0, attribute_protocol_packet_handler
0164A6  060000     RETURN
1151:                          break;
1152:                      case L2CAP_CID_SECURITY_MANAGER_PROTOCOL:
1153:                          security_protocol_packet_handler = packet_handler;
1154:                          break;
1155:                  }
1156:              }
1157:              
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libbtstack/src/hci_transport_mchpusb.c
0144B0  FA0002     LNK #0x2
0144B2  780300     MOV W0, W6
0144B4  780002     MOV W2, W0
0144B6  BE0104     MOV.D W4, W2
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                // Implementation of btstack hci transport layer over IOIO's bluetooth dongle
31:                // driver within the MCHPUSB host framework.
32:                
33:                #include <assert.h>
34:                #include "config.h"
35:                
36:                #include "usb_host_bluetooth.h"
37:                #include "logging.h"
38:                
39:                #include "debug.h"
40:                #include "hci.h"
41:                #include "hci_transport.h"
42:                #include "hci_dump.h"
43:                
44:                static uint8_t *bulk_in;
45:                static int bulk_in_size;
46:                static uint8_t *int_in;
47:                #define INT_IN_SIZE 64
48:                
49:                void hci_transport_mchpusb_tasks() {
50:                  if (!USBHostBlueToothIntInBusy()) {
015D98  26E4E0     MOV #0x6E4E, W0
015D9A  E00010     CP0 [W0]
015D9C  3A0005     BRA NZ, 0x15DA8
51:                    USBHostBluetoothReadInt(int_in, INT_IN_SIZE);
015D9E  837530     MOV int_in, W0
015DA0  200402     MOV #0x40, W2
015DA2  200003     MOV #0x0, W3
015DA4  026576     CALL USBHostBluetoothReadInt
015DA6  000001     NOP
52:                  }
53:                  if (!USBHostBlueToothBulkInBusy()) {
015DA8  26E480     MOV #0x6E48, W0
015DAA  E00010     CP0 [W0]
015DAC  3A0005     BRA NZ, 0x15DB8
54:                    USBHostBluetoothReadBulk(bulk_in, bulk_in_size);
55:                  }
56:                }
57:                
58:                // single instance
59:                static hci_transport_t hci_transport_mchpusb;
60:                static void (*packet_handler)(uint8_t packet_type, uint8_t *packet, uint16_t size) = NULL;
61:                
62:                static int usb_open(void *transport_config) {
63:                  return 0;
64:                }
65:                
66:                static int usb_close() {
67:                  return 0;
68:                }
69:                
70:                static int usb_send_cmd_packet(uint8_t *packet, int size) {
71:                  return USB_SUCCESS == USBHostBluetoothWriteControl(packet, size) ? 0 : -1;
015B90  DE91CF     ASR W2, #15, W3
015B92  780001     MOV W1, W0
015B94  02658E     CALL USBHostBluetoothWriteControl
015B96  000001     NOP
015B98  370004     BRA 0x15BA2
72:                }
73:                
74:                static int usb_send_acl_packet(uint8_t *packet, int size) {
75:                  return USB_SUCCESS == USBHostBluetoothWriteBulk(packet, size) ? 0 : -1;
76:                }
77:                
78:                static int usb_send_packet(uint8_t packet_type, uint8_t * packet, int size) {
79:                  switch (packet_type) {
015B86  504FE1     SUB.B W0, #0x1, [W15]
015B88  320003     BRA Z, 0x15B90
015B8A  504FE2     SUB.B W0, #0x2, [W15]
015B8C  3A000C     BRA NZ, 0x15BA6
015B8E  370005     BRA 0x15B9A
80:                    case HCI_COMMAND_DATA_PACKET:
81:                      return usb_send_cmd_packet(packet, size);
82:                    case HCI_ACL_DATA_PACKET:
83:                      return usb_send_acl_packet(packet, size);
84:                    default:
85:                      return -1;
86:                  }
87:                }
88:                
89:                static int usb_can_send_packet(uint8_t packet_type) {
90:                  switch (packet_type) {
015E82  504FE1     SUB.B W0, #0x1, [W15]
015E84  320004     BRA Z, 0x15E8E
015E86  EB8080     SETM W1
015E88  504FE2     SUB.B W0, #0x2, [W15]
015E8A  3A0009     BRA NZ, 0x15E9E
015E8C  370003     BRA 0x15E94
91:                    case HCI_COMMAND_DATA_PACKET:
92:                      return !USBHostBlueToothControlOutBusy();
015E8E  EB0080     CLR W1
015E90  26E5A0     MOV #0x6E5A, W0
015E92  370002     BRA 0x15E98
93:                    case HCI_ACL_DATA_PACKET:
94:                      return !USBHostBlueToothBulkOutBusy();
015E94  EB0080     CLR W1
015E96  26E540     MOV #0x6E54, W0
015E98  E00010     CP0 [W0]
015E9A  3A0001     BRA NZ, 0x15E9E
015E9C  200011     MOV #0x1, W1
95:                    default:
96:                      return -1;
97:                  }
98:                }
99:                
100:               static void usb_register_packet_handler(void (*handler)(uint8_t packet_type, uint8_t *packet, uint16_t size)) {
101:                 log_info("registering packet handler\n");
102:                 packet_handler = handler;
016760  8B74B0     MOV W0, packet_handler
103:               }
104:               
105:               static const char * usb_get_transport_name() {
106:                 return "USB";
107:               }
108:               
109:               // get usb singleton
110:               
111:               hci_transport_t * hci_transport_mchpusb_instance(void *buf, int size) {
112:                 assert(size > INT_IN_SIZE + 256);
113:                 int_in = buf;
015960  8B7530     MOV W0, int_in
114:                 bulk_in = int_in + INT_IN_SIZE;
015962  B00400     ADD #0x40, W0
015964  8B7550     MOV W0, bulk_in
115:                 bulk_in_size = size - INT_IN_SIZE;
015966  B10401     SUB #0x40, W1
015968  8B7541     MOV W1, bulk_in_size
116:                 hci_transport_mchpusb.open = usb_open;
01596A  26E980     MOV #0x6E98, W0
01596C  253201     MOV #0x5320, W1
01596E  780801     MOV W1, [W0]
117:                 hci_transport_mchpusb.close = usb_close;
015970  253241     MOV #0x5324, W1
015972  8B74D1     MOV W1, 0x6E9A
118:                 hci_transport_mchpusb.send_packet = usb_send_packet;
015974  253281     MOV #0x5328, W1
015976  8B74E1     MOV W1, 0x6E9C
119:                 hci_transport_mchpusb.register_packet_handler = usb_register_packet_handler;
015978  2532C1     MOV #0x532C, W1
01597A  8B74F1     MOV W1, 0x6E9E
120:                 hci_transport_mchpusb.get_transport_name = usb_get_transport_name;
01597C  253301     MOV #0x5330, W1
01597E  8B7501     MOV W1, 0x6EA0
121:                 hci_transport_mchpusb.set_baudrate = NULL;
015980  EB0080     CLR W1
015982  8B7511     MOV W1, 0x6EA2
122:                 hci_transport_mchpusb.can_send_packet_now = usb_can_send_packet;
015984  253341     MOV #0x5334, W1
015986  8B7521     MOV W1, 0x6EA4
123:                 return &hci_transport_mchpusb;
124:               }
125:               
126:               BOOL USBHostBluetoothCallback(BLUETOOTH_EVENT event,
127:                       USB_EVENT status,
128:                       void *data,
129:                       DWORD size) {
130:                 uint8_t e;
131:                 switch (event) {
0144B8  530FE2     SUB W6, #0x2, [W15]
0144BA  32000E     BRA Z, 0x144D8
0144BC  390023     BRA NC, 0x14504
0144BE  530FE3     SUB W6, #0x3, [W15]
0144C0  320016     BRA Z, 0x144EE
0144C2  EB0000     CLR W0
0144C4  530FE5     SUB W6, #0x5, [W15]
0144C6  3E001F     BRA GTU, 0x14506
132:                   case BLUETOOTH_EVENT_WRITE_BULK_DONE:
133:                   case BLUETOOTH_EVENT_WRITE_CONTROL_DONE:
134:                     e = DAEMON_EVENT_HCI_PACKET_SENT;
0144C8  B3C540     MOV #0x54, W0
0144CA  9FFFE0     MOV.B W0, [W15-2]
135:                     packet_handler(HCI_EVENT_PACKET, &e, 1);
0144CC  200012     MOV #0x1, W2
0144CE  E9808F     DEC2 W15, W1
0144D0  B3C040     MOV #0x4, W0
0144D2  8374B3     MOV packet_handler, W3
0144D4  010003     CALL W3
0144D6  370016     BRA 0x14504
136:                     return TRUE;
137:               
138:                   case BLUETOOTH_EVENT_ATTACHED:
139:                   case BLUETOOTH_EVENT_DETACHED:
140:                     return TRUE;
141:               
142:                   case BLUETOOTH_EVENT_READ_BULK_DONE:
143:                     if (status == USB_SUCCESS) {
0144D8  E00001     CP0 W1
0144DA  3A0014     BRA NZ, 0x14504
144:                       if (size) {
0144DC  520FE0     SUB W4, #0x0, [W15]
0144DE  5A8FE0     SUBB W5, #0x0, [W15]
0144E0  320011     BRA Z, 0x14504
145:                         if (packet_handler) {
0144E2  8374B4     MOV packet_handler, W4
0144E4  E00004     CP0 W4
0144E6  32000E     BRA Z, 0x14504
146:                           packet_handler(HCI_ACL_DATA_PACKET, data, size);
0144E8  780080     MOV W0, W1
0144EA  784006     MOV.B W6, W0
0144EC  37000A     BRA 0x14502
147:                         }
148:                       }
149:                     } else {
150:                       log_printf("Read bulk failure");
151:                     }
152:                     return TRUE;
153:               
154:                   case BLUETOOTH_EVENT_READ_INTERRUPT_DONE:
155:                     if (status == USB_SUCCESS) {
0144EE  E00001     CP0 W1
0144F0  3A0009     BRA NZ, 0x14504
156:                       if (size) {
0144F2  520FE0     SUB W4, #0x0, [W15]
0144F4  5A8FE0     SUBB W5, #0x0, [W15]
0144F6  320006     BRA Z, 0x14504
157:                         if (packet_handler) {
0144F8  8374B4     MOV packet_handler, W4
0144FA  E00004     CP0 W4
0144FC  320003     BRA Z, 0x14504
158:                           packet_handler(HCI_EVENT_PACKET, data, size);
0144FE  780080     MOV W0, W1
014500  B3C040     MOV #0x4, W0
014502  010004     CALL W4
014504  200010     MOV #0x1, W0
159:                         }
160:                       }
161:                     } else {
162:                       log_printf("Read bulk failure");
163:                     }
164:                     return TRUE;
165:               
166:                   default:
167:                     return FALSE;
168:                 }
169:               }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libbtstack/src/hci_dump.c  
01672C  FA0000     LNK #0x0
1:                 /*
2:                  * Copyright (C) 2009-2012 by Matthias Ringwald
3:                  *
4:                  * Redistribution and use in source and binary forms, with or without
5:                  * modification, are permitted provided that the following conditions
6:                  * are met:
7:                  *
8:                  * 1. Redistributions of source code must retain the above copyright
9:                  *    notice, this list of conditions and the following disclaimer.
10:                 * 2. Redistributions in binary form must reproduce the above copyright
11:                 *    notice, this list of conditions and the following disclaimer in the
12:                 *    documentation and/or other materials provided with the distribution.
13:                 * 3. Neither the name of the copyright holders nor the names of
14:                 *    contributors may be used to endorse or promote products derived
15:                 *    from this software without specific prior written permission.
16:                 * 4. Any redistribution, use, or modification is done solely for
17:                 *    personal benefit and not for any commercial purpose or for
18:                 *    monetary gain.
19:                 *
20:                 * THIS SOFTWARE IS PROVIDED BY MATTHIAS RINGWALD AND CONTRIBUTORS
21:                 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
22:                 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
23:                 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MATTHIAS
24:                 * RINGWALD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
25:                 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
26:                 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
27:                 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
28:                 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
29:                 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
30:                 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
31:                 * SUCH DAMAGE.
32:                 *
33:                 * Please inquire about commercial licensing options at btstack@ringwald.ch
34:                 *
35:                 */
36:                
37:                /*
38:                 *  hci_dump.c
39:                 *
40:                 *  Dump HCI trace in various formats:
41:                 *
42:                 *  - BlueZ's hcidump format
43:                 *  - Apple's PacketLogger
44:                 *  - stdout hexdump
45:                 *
46:                 *  Created by Matthias Ringwald on 5/26/09.
47:                 */
48:                
49:                #include "config.h"
50:                
51:                #include "hci_dump.h"
52:                #include "hci.h"
53:                #include "hci_transport.h"
54:                #include <btstack/hci_cmds.h>
55:                
56:                #ifndef EMBEDDED
57:                #include <fcntl.h>        // open
58:                #include <arpa/inet.h>    // hton..
59:                #include <unistd.h>       // write 
60:                #include <stdio.h>
61:                #include <time.h>
62:                #include <sys/time.h>     // for timestamps
63:                #include <sys/stat.h>     // for mode flags
64:                #include <stdarg.h>       // for va_list
65:                #endif
66:                
67:                // BLUEZ hcidump
68:                typedef struct {
69:                	uint16_t	len;
70:                	uint8_t		in;
71:                	uint8_t		pad;
72:                	uint32_t	ts_sec;
73:                	uint32_t	ts_usec;
74:                    uint8_t     packet_type;
75:                }
76:                #ifdef __GNUC__
77:                __attribute__ ((packed))
78:                #endif 
79:                hcidump_hdr;
80:                
81:                // APPLE PacketLogger
82:                typedef struct {
83:                	uint32_t	len;
84:                	uint32_t	ts_sec;
85:                	uint32_t	ts_usec;
86:                	uint8_t		type;   // 0xfc for note
87:                }
88:                #ifdef __GNUC__
89:                __attribute__ ((packed))
90:                #endif
91:                pktlog_hdr;
92:                
93:                #ifndef EMBEDDED
94:                static int dump_file = -1;
95:                static int dump_format;
96:                static hcidump_hdr header_bluez;
97:                static pktlog_hdr  header_packetlogger;
98:                static char time_string[40];
99:                static int  max_nr_packets = -1;
100:               static int  nr_packets = 0;
101:               static char log_message_buffer[256];
102:               #endif
103:               
104:               void hci_dump_open(char *filename, hci_dump_format_t format){
105:               #ifndef EMBEDDED
106:                   dump_format = format;
107:                   if (dump_format == HCI_DUMP_STDOUT) {
108:                       dump_file = fileno(stdout);
109:                   } else {
110:                       dump_file = open(filename, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
111:                   }
112:               #endif
113:               }
114:               
115:               #ifndef EMBEDDED
116:               void hci_dump_set_max_packets(int packets){
117:                   max_nr_packets = packets;
118:               }
119:               #endif
120:               
121:               void hci_dump_packet(uint8_t packet_type, uint8_t in, uint8_t *packet, uint16_t len) {
122:               #ifndef EMBEDDED
123:               
124:                   if (dump_file < 0) return; // not activated yet
125:               
126:                   // don't grow bigger than max_nr_packets
127:                   if (dump_format != HCI_DUMP_STDOUT && max_nr_packets > 0){
128:                       if (nr_packets >= max_nr_packets){
129:                           lseek(dump_file, 0, SEEK_SET);
130:                           ftruncate(dump_file, 0);
131:                           nr_packets = 0;
132:                       }
133:                       nr_packets++;
134:                   }
135:                   
136:                   // get time
137:                   struct timeval curr_time;
138:                   struct tm* ptm;
139:                   gettimeofday(&curr_time, NULL);
140:                   
141:                   switch (dump_format){
142:                       case HCI_DUMP_STDOUT: {
143:                           /* Obtain the time of day, and convert it to a tm struct. */
144:                           ptm = localtime (&curr_time.tv_sec);
145:                           /* Format the date and time, down to a single second. */
146:                           strftime (time_string, sizeof (time_string), "[%Y-%m-%d %H:%M:%S", ptm);
147:                           /* Compute milliseconds from microseconds. */
148:                           uint16_t milliseconds = curr_time.tv_usec / 1000;
149:                           /* Print the formatted time, in seconds, followed by a decimal point
150:                            and the milliseconds. */
151:                           printf ("%s.%03u] ", time_string, milliseconds);
152:                           switch (packet_type){
153:                               case HCI_COMMAND_DATA_PACKET:
154:                                   printf("CMD => ");
155:                                   break;
156:                               case HCI_EVENT_PACKET:
157:                                   printf("EVT <= ");
158:                                   break;
159:                               case HCI_ACL_DATA_PACKET:
160:                                   if (in) {
161:                                       printf("ACL <= ");
162:                                   } else {
163:                                       printf("ACL => ");
164:                                   }
165:                                   break;
166:                               case LOG_MESSAGE_PACKET:
167:                                   // assume buffer is big enough
168:                                   packet[len] = 0;
169:                                   printf("LOG -- %s\n", (char*) packet);
170:                                   return;
171:                               default:
172:                                   return;
173:                           }
174:                           hexdump(packet, len);
175:                           break;
176:                       }
177:                           
178:                       case HCI_DUMP_BLUEZ:
179:                           bt_store_16( (uint8_t *) &header_bluez.len, 0, 1 + len);
180:                           header_bluez.in  = in;
181:                           header_bluez.pad = 0;
182:                           bt_store_32( (uint8_t *) &header_bluez.ts_sec,  0, curr_time.tv_sec);
183:                           bt_store_32( (uint8_t *) &header_bluez.ts_usec, 0, curr_time.tv_usec);
184:                           header_bluez.packet_type = packet_type;
185:                           write (dump_file, &header_bluez, sizeof(hcidump_hdr) );
186:                           write (dump_file, packet, len );
187:                           break;
188:                           
189:                       case HCI_DUMP_PACKETLOGGER:
190:                           header_packetlogger.len = htonl( sizeof(pktlog_hdr) - 4 + len);
191:                           header_packetlogger.ts_sec =  htonl(curr_time.tv_sec);
192:                           header_packetlogger.ts_usec = htonl(curr_time.tv_usec);
193:                           switch (packet_type){
194:                               case HCI_COMMAND_DATA_PACKET:
195:                                   header_packetlogger.type = 0x00;
196:                                   break;
197:                               case HCI_ACL_DATA_PACKET:
198:                                   if (in) {
199:                                       header_packetlogger.type = 0x03;
200:                                   } else {
201:                                       header_packetlogger.type = 0x02;
202:                                   }
203:                                   break;
204:                               case HCI_EVENT_PACKET:
205:                                   header_packetlogger.type = 0x01;
206:                                   break;
207:                               case LOG_MESSAGE_PACKET:
208:                                   header_packetlogger.type = 0xfc;
209:                                   break;
210:                               default:
211:                                   return;
212:                           }
213:                           write (dump_file, &header_packetlogger, sizeof(pktlog_hdr) );
214:                           write (dump_file, packet, len );
215:                           break;
216:                           
217:                       default:
218:                           break;
219:                   }
220:               #endif
221:               }
222:               
223:               void hci_dump_log(const char * format, ...){
224:               #ifndef EMBEDDED
225:                   va_list argptr;
226:                   va_start(argptr, format);
227:                   int len = vsnprintf(log_message_buffer, sizeof(log_message_buffer), format, argptr);
228:                   hci_dump_packet(LOG_MESSAGE_PACKET, 0, (uint8_t*) log_message_buffer, len);
229:                   va_end(argptr);
230:               #endif    
231:               }
232:               
233:               void hci_dump_close(){
234:               #ifndef EMBEDDED
235:                   close(dump_file);
236:                   dump_file = -1;
237:               #endif
238:               }
239:               
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libbtstack/src/hci_cmds.c  
012526  BE9F88     MOV.D W8, [W15++]
012528  BE9F8A     MOV.D W10, [W15++]
01252A  BE9F8C     MOV.D W12, [W15++]
01252C  781F8E     MOV W14, [W15++]
01252E  780480     MOV W0, W9
012530  780602     MOV W2, W12
016526  FA0000     LNK #0x0
016528  97B8CF     MOV [W15-8], W1
1:                 /*
2:                  * Copyright (C) 2009-2012 by Matthias Ringwald
3:                  *
4:                  * Redistribution and use in source and binary forms, with or without
5:                  * modification, are permitted provided that the following conditions
6:                  * are met:
7:                  *
8:                  * 1. Redistributions of source code must retain the above copyright
9:                  *    notice, this list of conditions and the following disclaimer.
10:                 * 2. Redistributions in binary form must reproduce the above copyright
11:                 *    notice, this list of conditions and the following disclaimer in the
12:                 *    documentation and/or other materials provided with the distribution.
13:                 * 3. Neither the name of the copyright holders nor the names of
14:                 *    contributors may be used to endorse or promote products derived
15:                 *    from this software without specific prior written permission.
16:                 * 4. Any redistribution, use, or modification is done solely for
17:                 *    personal benefit and not for any commercial purpose or for
18:                 *    monetary gain.
19:                 *
20:                 * THIS SOFTWARE IS PROVIDED BY MATTHIAS RINGWALD AND CONTRIBUTORS
21:                 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
22:                 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
23:                 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MATTHIAS
24:                 * RINGWALD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
25:                 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
26:                 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
27:                 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
28:                 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
29:                 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
30:                 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
31:                 * SUCH DAMAGE.
32:                 *
33:                 * Please inquire about commercial licensing options at btstack@ringwald.ch
34:                 *
35:                 */
36:                
37:                /*
38:                 *  hci_cmds.c
39:                 *
40:                 *  Created by Matthias Ringwald on 7/23/09.
41:                 */
42:                
43:                #include <btstack/hci_cmds.h>
44:                
45:                #include <string.h>
46:                
47:                #include <btstack/sdp_util.h>
48:                #include "config.h"
49:                #include "hci.h"
50:                
51:                // calculate combined ogf/ocf value
52:                #define OPCODE(ogf, ocf) (ocf | ogf << 10)
53:                
54:                /**
55:                 * construct HCI Command based on template
56:                 *
57:                 * Format:
58:                 *   1,2,3,4: one to four byte value
59:                 *   H: HCI connection handle
60:                 *   B: Bluetooth Baseband Address (BD_ADDR)
61:                 *   E: Extended Inquiry Result
62:                 *   N: Name up to 248 chars, \0 terminated
63:                 *   P: 16 byte Pairing code
64:                 *   S: Service Record (Data Element Sequence)
65:                 */
66:                uint16_t hci_create_cmd_internal(uint8_t *hci_cmd_buffer, const hci_cmd_t *cmd, va_list argptr){
67:                    
68:                    hci_cmd_buffer[0] = cmd->opcode & 0xff;
012532  784811     MOV.B [W1], [W0]
69:                    hci_cmd_buffer[1] = cmd->opcode >> 8;
012534  904011     MOV.B [W1+1], W0
012536  984490     MOV.B W0, [W9+1]
70:                    int pos = 3;
71:                    
72:                    const char *format = cmd->format;
012538  900711     MOV [W1+2], W14
01253A  20003A     MOV #0x3, W10
01253C  37007A     BRA 0x12632
73:                    uint16_t word;
74:                    uint32_t longword;
75:                    uint8_t * ptr;
76:                    while (*format) {
012632  78409E     MOV.B [W14], W1
012634  E00401     CP0.B W1
012636  3AFF83     BRA NZ, 0x1253E
77:                        switch(*format) {
01253E  B3C420     MOV #0x42, W0
012540  50CF80     SUB.B W1, W0, [W15]
012542  32003E     BRA Z, 0x125C0
012544  3C000A     BRA GT, 0x1255A
012546  504071     SUB.B W0, #0x11, W0
012548  50CF80     SUB.B W1, W0, [W15]
01254A  350072     BRA LT, 0x12630
01254C  E84000     INC.B W0, W0
01254E  50CF80     SUB.B W1, W0, [W15]
012550  340013     BRA LE, 0x12578
012552  E8C000     INC2.B W0, W0
012554  50CF80     SUB.B W1, W0, [W15]
012556  3C006C     BRA GT, 0x12630
012558  37001D     BRA 0x12594
01255A  B3C480     MOV #0x48, W0
01255C  50CF80     SUB.B W1, W0, [W15]
01255E  32000C     BRA Z, 0x12578
012560  3C0004     BRA GT, 0x1256A
012562  504063     SUB.B W0, #0x3, W0
012564  50CF80     SUB.B W1, W0, [W15]
012566  3A0064     BRA NZ, 0x12630
012568  37003B     BRA 0x125E0
01256A  B3C4E0     MOV #0x4E, W0
01256C  50CF80     SUB.B W1, W0, [W15]
01256E  320040     BRA Z, 0x125F0
012570  E8C000     INC2.B W0, W0
012572  50CF80     SUB.B W1, W0, [W15]
012574  3A005D     BRA NZ, 0x12630
012576  370055     BRA 0x12622
78:                            case '1': //  8 bit value
79:                            case '2': // 16 bit value
80:                            case 'H': // hci_handle
81:                                word = va_arg(argptr, int);  // minimal va_arg is int: 2 bytes on 8+16 bit CPUs
012578  7800CC     MOV [--W12], W1
82:                                hci_cmd_buffer[pos++] = word & 0xff;
01257A  7D7481     MOV.B W1, [W9+W10]
01257C  E8010A     INC W10, W2
83:                                if (*format == '2') {
01257E  78419E     MOV.B [W14], W3
012580  B3C320     MOV #0x32, W0
012582  51CF80     SUB.B W3, W0, [W15]
012584  320003     BRA Z, 0x1258C
84:                                    hci_cmd_buffer[pos++] = word >> 8;
85:                                } else if (*format == 'H') {
012586  B3C480     MOV #0x48, W0
012588  51CF80     SUB.B W3, W0, [W15]
01258A  3A0013     BRA NZ, 0x125B2
86:                                    // TODO implement opaque client connection handles
87:                                    //      pass module handle for now
88:                                    hci_cmd_buffer[pos++] = word >> 8;
01258C  DE0848     LSR W1, #8, W0
01258E  797480     MOV.B W0, [W9+W2]
012590  E8850A     INC2 W10, W10
012592  37004E     BRA 0x12630
89:                                } 
90:                                break;
91:                            case '3':
92:                            case '4':
93:                                longword = va_arg(argptr, uint32_t);
012594  BE024C     MOV.D [--W12], W4
94:                                // longword = va_arg(argptr, int);
95:                                hci_cmd_buffer[pos++] = longword;
012596  7D7484     MOV.B W4, [W9+W10]
96:                                hci_cmd_buffer[pos++] = longword >> 8;
012598  450109     ADD W10, W9, W2
01259A  DD29C8     SL W5, #8, W3
01259C  DE2048     LSR W4, #8, W0
01259E  718000     IOR W3, W0, W0
0125A0  DE28C8     LSR W5, #8, W1
0125A2  984110     MOV.B W0, [W2+1]
97:                                hci_cmd_buffer[pos++] = longword >> 16;
0125A4  DE2840     LSR W5, #0, W0
0125A6  200001     MOV #0x0, W1
0125A8  984120     MOV.B W0, [W2+2]
0125AA  450163     ADD W10, #0x3, W2
98:                                if (*format == '4'){
0125AC  B3C340     MOV #0x34, W0
0125AE  104F9E     SUBR.B W0, [W14], [W15]
0125B0  320002     BRA Z, 0x125B6
0125B2  780502     MOV W2, W10
0125B4  37003D     BRA 0x12630
99:                                    hci_cmd_buffer[pos++] = longword >> 24;
0125B6  DE2848     LSR W5, #8, W0
0125B8  200001     MOV #0x0, W1
0125BA  797480     MOV.B W0, [W9+W2]
0125BC  450564     ADD W10, #0x4, W10
0125BE  370038     BRA 0x12630
100:                               }
101:                               break;
102:                           case 'B': // bt-addr
103:                               ptr = va_arg(argptr, uint8_t *);
0125C0  7800CC     MOV [--W12], W1
104:                               hci_cmd_buffer[pos++] = ptr[5];
0125C2  904051     MOV.B [W1+5], W0
0125C4  7D7480     MOV.B W0, [W9+W10]
105:                               hci_cmd_buffer[pos++] = ptr[4];
0125C6  450009     ADD W10, W9, W0
0125C8  904141     MOV.B [W1+4], W2
0125CA  984012     MOV.B W2, [W0+1]
106:                               hci_cmd_buffer[pos++] = ptr[3];
0125CC  9041B1     MOV.B [W1+3], W3
0125CE  984023     MOV.B W3, [W0+2]
107:                               hci_cmd_buffer[pos++] = ptr[2];
0125D0  904121     MOV.B [W1+2], W2
0125D2  984032     MOV.B W2, [W0+3]
108:                               hci_cmd_buffer[pos++] = ptr[1];
0125D4  904191     MOV.B [W1+1], W3
0125D6  984043     MOV.B W3, [W0+4]
109:                               hci_cmd_buffer[pos++] = ptr[0];
0125D8  784091     MOV.B [W1], W1
0125DA  984051     MOV.B W1, [W0+5]
0125DC  450566     ADD W10, #0x6, W10
0125DE  370028     BRA 0x12630
110:                               break;
111:                           case 'E': // Extended Inquiry Information 240 octets
112:                               ptr = va_arg(argptr, uint8_t *);
113:                               memcpy(&hci_cmd_buffer[pos], ptr, 240);
0125E0  44808A     ADD W9, W10, W1
0125E2  78004C     MOV [--W12], W0
0125E4  0900EF     REPEAT #0xEF
0125E6  7858B0     MOV.B [W0++], [W1++]
0125E8  B10F01     SUB #0xF0, W1
0125EA  B10F00     SUB #0xF0, W0
114:                               pos += 240;
0125EC  B00F0A     ADD #0xF0, W10
0125EE  370020     BRA 0x12630
115:                               break;
116:                           case 'N': { // UTF-8 string, null terminated
117:                               ptr = va_arg(argptr, uint8_t *);
0125F0  7806CC     MOV [--W12], W13
118:                               uint16_t len = strlen((const char*) ptr);
0125F2  78000D     MOV W13, W0
0125F4  02578A     CALL strlen
0125F6  000000     NOP
0125F8  780400     MOV W0, W8
119:                               if (len > 248) {
0125FA  200F8B     MOV #0xF8, W11
0125FC  500F8B     SUB W0, W11, [W15]
0125FE  360001     BRA LEU, 0x12602
012600  78040B     MOV W11, W8
120:                                   len = 248;
121:                               }
122:                               memcpy(&hci_cmd_buffer[pos], ptr, len);
012602  44800A     ADD W9, W10, W0
012604  780108     MOV W8, W2
012606  78008D     MOV W13, W1
012608  0256DE     CALL memcpy
01260A  000000     NOP
123:                               if (len < 248) {
01260C  200F70     MOV #0xF7, W0
01260E  540F80     SUB W8, W0, [W15]
012610  3E0006     BRA GTU, 0x1261E
124:                                   // fill remaining space with zeroes
125:                                   memset(&hci_cmd_buffer[pos+len], 0, 248-len);
012612  558108     SUB W11, W8, W2
012614  450008     ADD W10, W8, W0
012616  448000     ADD W9, W0, W0
012618  EB0080     CLR W1
01261A  025720     CALL memset
01261C  000000     NOP
126:                               }
127:                               pos += 248;
01261E  B00F8A     ADD #0xF8, W10
012620  370007     BRA 0x12630
128:                               break;
129:                           }
130:                           case 'P': // 16 byte PIN code or link key
131:                               ptr = va_arg(argptr, uint8_t *);
132:                               memcpy(&hci_cmd_buffer[pos], ptr, 16);
012622  44808A     ADD W9, W10, W1
012624  78004C     MOV [--W12], W0
012626  09000F     REPEAT #0xF
012628  7858B0     MOV.B [W0++], [W1++]
01262A  B10101     SUB #0x10, W1
01262C  B10100     SUB #0x10, W0
133:                               pos += 16;
01262E  450570     ADD W10, #0x10, W10
134:                               break;
135:               #ifdef HAVE_BLE
136:                           case 'A': // 31 bytes advertising data
137:                               ptr = va_arg(argptr, uint8_t *);
138:                               memcpy(&hci_cmd_buffer[pos], ptr, 31);
139:                               pos += 31;
140:                               break;
141:               #endif
142:               #ifdef HAVE_SDP
143:                           case 'S': { // Service Record (Data Element Sequence)
144:                               ptr = va_arg(argptr, uint8_t *);
145:                               uint16_t len = de_get_len(ptr);
146:                               memcpy(&hci_cmd_buffer[pos], ptr, len);
147:                               pos += len;
148:                               break;
149:                           }
150:               #endif
151:                           default:
152:                               break;
153:                       }
154:                       format++;
012630  E8070E     INC W14, W14
155:                   };
156:                   hci_cmd_buffer[2] = pos - 3;
012638  554063     SUB.B W10, #0x3, W0
01263A  9844A0     MOV.B W0, [W9+2]
157:                   return pos;
158:               }
159:               
160:               /**
161:                * construct HCI Command based on template
162:                *
163:                * mainly calls hci_create_cmd_internal
164:                */
165:               uint16_t hci_create_cmd(uint8_t *hci_cmd_buffer, hci_cmd_t *cmd, ...){
166:                   va_list argptr;
167:                   va_start(argptr, cmd);
168:                   uint16_t len = hci_create_cmd_internal(hci_cmd_buffer, cmd, argptr);
01652A  578168     SUB W15, #0x8, W2
01652C  022526     CALL hci_create_cmd_internal
01652E  000001     NOP
169:                   va_end(argptr);
170:                   return len;
171:               }
172:               
173:               
174:               /**
175:                *  Link Control Commands 
176:                */
177:               const hci_cmd_t hci_inquiry = {
178:               OPCODE(OGF_LINK_CONTROL, 0x01), "311"
179:               // LAP, Inquiry length, Num_responses
180:               };
181:               const hci_cmd_t hci_inquiry_cancel = {
182:               OPCODE(OGF_LINK_CONTROL, 0x02), ""
183:               // no params
184:               };
185:               const hci_cmd_t hci_create_connection = {
186:               OPCODE(OGF_LINK_CONTROL, 0x05), "B21121"
187:               // BD_ADDR, Packet_Type, Page_Scan_Repetition_Mode, Reserved, Clock_Offset, Allow_Role_Switch
188:               };
189:               const hci_cmd_t hci_disconnect = {
190:               OPCODE(OGF_LINK_CONTROL, 0x06), "H1"
191:               // Handle, Reason: 0x05, 0x13-0x15, 0x1a, 0x29
192:               // see Errors Codes in BT Spec Part D
193:               };
194:               const hci_cmd_t hci_create_connection_cancel = {
195:               OPCODE(OGF_LINK_CONTROL, 0x08), "B"
196:               // BD_ADDR
197:               };
198:               const hci_cmd_t hci_accept_connection_request = {
199:               OPCODE(OGF_LINK_CONTROL, 0x09), "B1"
200:               // BD_ADDR, Role: become master, stay slave
201:               };
202:               const hci_cmd_t hci_reject_connection_request = {
203:               OPCODE(OGF_LINK_CONTROL, 0x0a), "B1"
204:               // BD_ADDR, reason e.g. CONNECTION REJECTED DUE TO LIMITED RESOURCES (0x0d)
205:               };
206:               const hci_cmd_t hci_link_key_request_reply = {
207:               OPCODE(OGF_LINK_CONTROL, 0x0b), "BP"
208:               // BD_ADDR, LINK_KEY
209:               };
210:               const hci_cmd_t hci_link_key_request_negative_reply = {
211:               OPCODE(OGF_LINK_CONTROL, 0x0c), "B"
212:               // BD_ADDR
213:               };
214:               const hci_cmd_t hci_pin_code_request_reply = {
215:               OPCODE(OGF_LINK_CONTROL, 0x0d), "B1P"
216:               // BD_ADDR, pin length, PIN: c-string
217:               };
218:               const hci_cmd_t hci_pin_code_request_negative_reply = {
219:               OPCODE(OGF_LINK_CONTROL, 0x0e), "B"
220:               // BD_ADDR
221:               };
222:               const hci_cmd_t hci_authentication_requested = {
223:               OPCODE(OGF_LINK_CONTROL, 0x11), "H"
224:               // Handle
225:               };
226:               const hci_cmd_t hci_set_connection_encryption = {
227:               OPCODE(OGF_LINK_CONTROL, 0x13), "H1"
228:               // Handle, Encryption_Enable
229:               };
230:               const hci_cmd_t hci_change_connection_link_key = {
231:               OPCODE(OGF_LINK_CONTROL, 0x15), "H"
232:               // Handle
233:               };
234:               const hci_cmd_t hci_remote_name_request = {
235:               OPCODE(OGF_LINK_CONTROL, 0x19), "B112"
236:               // BD_ADDR, Page_Scan_Repetition_Mode, Reserved, Clock_Offset
237:               };
238:               const hci_cmd_t hci_remote_name_request_cancel = {
239:               OPCODE(OGF_LINK_CONTROL, 0x1A), "B"
240:               // BD_ADDR
241:               };
242:               
243:               /**
244:                *  Link Policy Commands 
245:                */
246:               const hci_cmd_t hci_sniff_mode = {
247:               OPCODE(OGF_LINK_POLICY, 0x03), "H2222"
248:               // handle, Sniff_Max_Interval, Sniff_Min_Interval, Sniff_Attempt, Sniff_Timeout:
249:               };
250:               const hci_cmd_t hci_qos_setup = {
251:               OPCODE(OGF_LINK_POLICY, 0x07), "H114444"
252:               // handle, flags, service_type, token rate (bytes/s), peak bandwith (bytes/s),
253:               // latency (us), delay_variation (us)
254:               };
255:               const hci_cmd_t hci_role_discovery = {
256:               OPCODE(OGF_LINK_POLICY, 0x09), "H"
257:               // handle
258:               };
259:               const hci_cmd_t hci_switch_role_command= {
260:               OPCODE(OGF_LINK_POLICY, 0x0b), "B1"
261:               // BD_ADDR, role: {0=master,1=slave}
262:               };
263:               const hci_cmd_t hci_read_link_policy_settings = {
264:               OPCODE(OGF_LINK_POLICY, 0x0c), "H"
265:               // handle 
266:               };
267:               const hci_cmd_t hci_write_link_policy_settings = {
268:               OPCODE(OGF_LINK_POLICY, 0x0d), "H2"
269:               // handle, settings
270:               };
271:               
272:               /**
273:                *  Controller & Baseband Commands 
274:                */
275:               const hci_cmd_t hci_set_event_mask = {
276:               OPCODE(OGF_CONTROLLER_BASEBAND, 0x01), "44"
277:               // event_mask lower 4 octets, higher 4 bytes
278:               };
279:               const hci_cmd_t hci_reset = {
280:               OPCODE(OGF_CONTROLLER_BASEBAND, 0x03), ""
281:               // no params
282:               };
283:               const hci_cmd_t hci_delete_stored_link_key = {
284:               OPCODE(OGF_CONTROLLER_BASEBAND, 0x12), "B1"
285:               // BD_ADDR, Delete_All_Flag
286:               };
287:               const hci_cmd_t hci_write_local_name = {
288:               OPCODE(OGF_CONTROLLER_BASEBAND, 0x13), "N"
289:               // Local name (UTF-8, Null Terminated, max 248 octets)
290:               };
291:               const hci_cmd_t hci_write_page_timeout = {
292:               OPCODE(OGF_CONTROLLER_BASEBAND, 0x18), "2"
293:               // Page_Timeout * 0.625 ms
294:               };
295:               const hci_cmd_t hci_write_scan_enable = {
296:               OPCODE(OGF_CONTROLLER_BASEBAND, 0x1A), "1"
297:               // Scan_enable: no, inq, page, inq+page
298:               };
299:               const hci_cmd_t hci_write_authentication_enable = {
300:               OPCODE(OGF_CONTROLLER_BASEBAND, 0x20), "1"
301:               // Authentication_Enable
302:               };
303:               const hci_cmd_t hci_write_class_of_device = {
304:               OPCODE(OGF_CONTROLLER_BASEBAND, 0x24), "3"
305:               // Class of Device
306:               };
307:               const hci_cmd_t hci_read_num_broadcast_retransmissions = {
308:               OPCODE(OGF_CONTROLLER_BASEBAND, 0x29), ""
309:               };
310:               const hci_cmd_t hci_write_num_broadcast_retransmissions = {
311:               OPCODE(OGF_CONTROLLER_BASEBAND, 0x2a), "1"
312:               // Num broadcast retransmissions (e.g. 0 for a single broadcast)
313:               };
314:               const hci_cmd_t hci_host_buffer_size = {
315:               OPCODE(OGF_CONTROLLER_BASEBAND, 0x33), "2122"
316:               // Host_ACL_Data_Packet_Length:, Host_Synchronous_Data_Packet_Length:, Host_Total_Num_ACL_Data_Packets:, Host_Total_Num_Synchronous_Data_Packets:
317:               };
318:               const hci_cmd_t hci_read_link_supervision_timeout = {
319:               OPCODE(OGF_CONTROLLER_BASEBAND, 0x36), "H"
320:               // handle
321:               };
322:               const hci_cmd_t hci_write_link_supervision_timeout = {
323:               OPCODE(OGF_CONTROLLER_BASEBAND, 0x37), "H2"
324:               // handle, Range for N: 0x0001 ? 0xFFFF Time (Range: 0.625ms ? 40.9 sec)
325:               };
326:               const hci_cmd_t hci_write_inquiry_mode = {
327:               OPCODE(OGF_CONTROLLER_BASEBAND, 0x45), "1"
328:               // Inquiry mode: 0x00 = standard, 0x01 = with RSSI, 0x02 = extended
329:               };
330:               const hci_cmd_t hci_write_extended_inquiry_response = {
331:               OPCODE(OGF_CONTROLLER_BASEBAND, 0x52), "1E"
332:               // FEC_Required, Exstended Inquiry Response
333:               };
334:               const hci_cmd_t hci_write_simple_pairing_mode = {
335:               OPCODE(OGF_CONTROLLER_BASEBAND, 0x56), "1"
336:               // mode: 0 = off, 1 = on
337:               };
338:               const hci_cmd_t hci_read_le_host_supported = {
339:               OPCODE(OGF_CONTROLLER_BASEBAND, 0x6c), ""
340:               // params: none
341:               // return: status, le supported host, simultaneous le host
342:               };
343:               const hci_cmd_t hci_write_le_host_supported = {
344:               OPCODE(OGF_CONTROLLER_BASEBAND, 0x6d), "11"
345:               // param: le supported host, simultaneous le host
346:               // return: status
347:               };
348:               
349:               /**
350:                * Informational Parameters
351:                */
352:               const hci_cmd_t hci_read_local_supported_features = {
353:               OPCODE(OGF_INFORMATIONAL_PARAMETERS, 0x03), ""
354:               // no params
355:               };
356:               const hci_cmd_t hci_read_buffer_size = {
357:               OPCODE(OGF_INFORMATIONAL_PARAMETERS, 0x05), ""
358:               // no params
359:               };
360:               const hci_cmd_t hci_read_bd_addr = {
361:               OPCODE(OGF_INFORMATIONAL_PARAMETERS, 0x09), ""
362:               // no params
363:               };
364:               
365:               #ifdef HAVE_BLE
366:               /**
367:                * Low Energy Commands
368:                */
369:               const hci_cmd_t hci_le_set_event_mask = {
370:               OPCODE(OGF_LE_CONTROLLER, 0x01), "44"
371:               // params: event_mask lower 4 octets, higher 4 bytes
372:               // return: status
373:               };
374:               const hci_cmd_t hci_le_read_buffer_size = {
375:               OPCODE(OGF_LE_CONTROLLER, 0x02), ""
376:               // params: none
377:               // return: status, le acl data packet len (16), total num le acl data packets(8)
378:               };
379:               const hci_cmd_t hci_le_read_supported_features = {
380:               OPCODE(OGF_LE_CONTROLLER, 0x03), ""
381:               // params: none
382:               // return: LE_Features See [Vol 6] Part B, Section 4.6
383:               };
384:               const hci_cmd_t hci_le_set_random_address = {
385:               OPCODE(OGF_LE_CONTROLLER, 0x05), "B"
386:               // params: random device address
387:               // return: status
388:               };
389:               const hci_cmd_t hci_le_set_advertising_parameters = {
390:               OPCODE(OGF_LE_CONTROLLER, 0x06), "22111B11"
391:               // param: min advertising interval, [0x0020,0x4000], default: 0x0800, unit: 0.625 msec
392:               // param: max advertising interval, [0x0020,0x4000], default: 0x0800, unit: 0.625 msec
393:               // param: advertising type (enum from 0): ADV_IND, ADC_DIRECT_IND, ADV_SCAN_IND, ADV_NONCONN_IND
394:               // param: own address type (enum from 0): public device address, random device address
395:               // param: direct address type (enum from 0): public device address, random device address
396:               // param: direct address - public or random address of device to be connecteed
397:               // param: advertising channel map (flags): chan_37(1), chan_38(2), chan_39(4)
398:               // param: advertising filter policy (enum from 0): scan any conn any, scan whitelist, con any, scan any conn whitelist, scan whitelist, con whitelist
399:               // return: status
400:               };
401:               const hci_cmd_t hci_le_read_advertising_channel_tx_power = {
402:               OPCODE(OGF_LE_CONTROLLER, 0x07), ""
403:               // params: none
404:               // return: status, level [-20,10] signed int (8), units dBm
405:               };
406:               const hci_cmd_t hci_le_set_advertising_data= {
407:               OPCODE(OGF_LE_CONTROLLER, 0x08), "1A"
408:               // param: advertising data len
409:               // param: advertising data (31 bytes)
410:               // return: status
411:               };
412:               const hci_cmd_t hci_le_set_scan_response_data= {
413:               OPCODE(OGF_LE_CONTROLLER, 0x09), "1A"
414:               // param: scan response data len
415:               // param: scan response data (31 bytes)
416:               // return: status
417:               };
418:               const hci_cmd_t hci_le_set_advertise_enable = {
419:               OPCODE(OGF_LE_CONTROLLER, 0x0a), "1"
420:               // params: avertise enable: off (0), on (1)
421:               // return: status
422:               };
423:               const hci_cmd_t hci_le_set_scan_parameters = {
424:               OPCODE(OGF_LE_CONTROLLER, 0x0b), "12211"
425:               // param: le scan type: passive (0), active (1)
426:               // param: le scan interval [0x0004,0x4000], unit: 0.625 msec
427:               // param: le scan window   [0x0004,0x4000], unit: 0.625 msec
428:               // param: own address type: public (0), random (1)
429:               // param: scanning filter policy: any (0), only whitelist (1)
430:               // return: status
431:               };
432:               const hci_cmd_t hci_le_set_scan_enable = {
433:               OPCODE(OGF_LE_CONTROLLER, 0x0c), "11"
434:               // param: le scan enable:  disabled (0), enabled (1)
435:               // param: filter duplices: disabled (0), enabled (1)
436:               // return: status
437:               };
438:               const hci_cmd_t hci_le_create_connection= {
439:               OPCODE(OGF_LE_CONTROLLER, 0x0d), "2211B1222222"
440:               // param: le scan interval, [0x0004, 0x4000], unit: 0.625 msec
441:               // param: le scan window, [0x0004, 0x4000], unit: 0.625 msec
442:               // param: initiator filter policy: peer address type + peer address (0), whitelist (1)
443:               // param: peer address type: public (0), random (1)
444:               // param: peer address
445:               // param: own address type: public (0), random (1)
446:               // param: conn interval min, [0x0006, 0x0c80], unit: 1.25 msec
447:               // param: conn interval max, [0x0006, 0x0c80], unit: 1.25 msec
448:               // param: conn latency, number of connection events [0x0000, 0x01f4]
449:               // param: supervision timeout, [0x000a, 0x0c80], unit: 10 msec
450:               // param: minimum CE length, [0x0000, 0xffff], unit: 0.625 msec
451:               // return: none -> le create connection complete event
452:               };
453:               const hci_cmd_t hci_le_create_connection_cancel = {
454:               OPCODE(OGF_LE_CONTROLLER, 0x0e), ""
455:               // params: none
456:               // return: status
457:               };
458:               const hci_cmd_t hci_le_read_white_list_size = {
459:               OPCODE(OGF_LE_CONTROLLER, 0x0f), ""
460:               // params: none
461:               // return: status, number of entries in controller whitelist
462:               };
463:               const hci_cmd_t hci_le_clear_white_list = {
464:               OPCODE(OGF_LE_CONTROLLER, 0x10), ""
465:               // params: none
466:               // return: status
467:               };
468:               const hci_cmd_t hci_le_add_device_to_whitelist = {
469:               OPCODE(OGF_LE_CONTROLLER, 0x11), "1B"
470:               // param: address type: public (0), random (1)
471:               // param: address
472:               // return: status
473:               };
474:               const hci_cmd_t hci_le_remove_device_from_whitelist = {
475:               OPCODE(OGF_LE_CONTROLLER, 0x12), "1B"
476:               // param: address type: public (0), random (1)
477:               // param: address
478:               // return: status
479:               };
480:               const hci_cmd_t hci_le_connection_update = {
481:               OPCODE(OGF_LE_CONTROLLER, 0x13), "H222222"
482:               // param: conn handle
483:               // param: conn interval min, [0x0006,0x0c80], unit: 1.25 msec
484:               // param: conn interval max, [0x0006,0x0c80], unit: 1.25 msec
485:               // param: conn latency, [0x0000,0x03e8], number of connection events
486:               // param: supervision timeout, [0x000a,0x0c80], unit: 10 msec
487:               // param: minimum CE length, [0x0000,0xffff], unit: 0.625 msec
488:               // param: maximum CE length, [0x0000,0xffff], unit: 0.625 msec
489:               // return: none -> le connection update complete event
490:               };
491:               const hci_cmd_t hci_le_set_host_channel_classification = {
492:               OPCODE(OGF_LE_CONTROLLER, 0x14), "41"
493:               // param: channel map 37 bit, split into first 32 and higher 5 bits
494:               // return: status
495:               };
496:               const hci_cmd_t hci_le_read_channel_map = {
497:               OPCODE(OGF_LE_CONTROLLER, 0x15), "H"
498:               // params: connection handle
499:               // return: status, connection handle, channel map (5 bytes, 37 used)
500:               };
501:               const hci_cmd_t hci_le_read_remote_used_features = {
502:               OPCODE(OGF_LE_CONTROLLER, 0x16), "H"
503:               // params: connection handle
504:               // return: none -> le read remote used features complete event
505:               };
506:               const hci_cmd_t hci_le_encrypt = {
507:               OPCODE(OGF_LE_CONTROLLER, 0x17), "PP"
508:               // param: key (128) for AES-128
509:               // param: plain text (128) 
510:               // return: status, encrypted data (128)
511:               };
512:               const hci_cmd_t hci_le_rand = {
513:               OPCODE(OGF_LE_CONTROLLER, 0x18), ""
514:               // params: none
515:               // return: status, random number (64)
516:               };
517:               const hci_cmd_t hci_le_start_encryption = {
518:               OPCODE(OGF_LE_CONTROLLER, 0x19), "H442P"
519:               // param: connection handle
520:               // param: 64 bit random number lower  32 bit
521:               // param: 64 bit random number higher 32 bit
522:               // param: encryption diversifier (16)
523:               // param: long term key (128)
524:               // return: none -> encryption changed or encryption key refresh complete event
525:               };
526:               const hci_cmd_t hci_le_long_term_key_request_reply = {
527:               OPCODE(OGF_LE_CONTROLLER, 0x1a), "HP"
528:               // param: connection handle
529:               // param: long term key (128)
530:               // return: status, connection handle
531:               };
532:               const hci_cmd_t hci_le_long_term_key_negative_reply = {
533:               OPCODE(OGF_LE_CONTROLLER, 0x1b), "H"
534:               // param: connection handle
535:               // return: status, connection handle
536:               };
537:               const hci_cmd_t hci_le_read_supported_states = {
538:               OPCODE(OGF_LE_CONTROLLER, 0x1c), "H"
539:               // param: none
540:               // return: status, LE states (64)
541:               };
542:               const hci_cmd_t hci_le_receiver_test = {
543:               OPCODE(OGF_LE_CONTROLLER, 0x1d), "1"
544:               // param: rx frequency, [0x00 0x27], frequency (MHz): 2420 + N*2
545:               // return: status
546:               };
547:               const hci_cmd_t hci_le_transmitter_test = {
548:                   OPCODE(OGF_LE_CONTROLLER, 0x1e), "111"
549:                   // param: tx frequency, [0x00 0x27], frequency (MHz): 2420 + N*2
550:                   // param: lengh of test payload [0x00,0x25]
551:                   // param: packet payload [0,7] different patterns
552:                   // return: status
553:               };
554:               const hci_cmd_t hci_le_test_end = {
555:                   OPCODE(OGF_LE_CONTROLLER, 0x1f), "1"
556:                   // params: none
557:                   // return: status, number of packets (8)
558:               };
559:               #endif
560:               
561:               // BTstack commands
562:               const hci_cmd_t btstack_get_state = {
563:               OPCODE(OGF_BTSTACK, BTSTACK_GET_STATE), ""
564:               // no params -> 
565:               };
566:               
567:               const hci_cmd_t btstack_set_power_mode = {
568:               OPCODE(OGF_BTSTACK, BTSTACK_SET_POWER_MODE), "1"
569:               // mode: 0 = off, 1 = on
570:               };
571:               
572:               const hci_cmd_t btstack_set_acl_capture_mode = {
573:               OPCODE(OGF_BTSTACK, BTSTACK_SET_ACL_CAPTURE_MODE), "1"
574:               // mode: 0 = off, 1 = on
575:               };
576:               
577:               const hci_cmd_t btstack_get_version = {
578:               OPCODE(OGF_BTSTACK, BTSTACK_GET_VERSION), ""
579:               };
580:               
581:               const hci_cmd_t btstack_get_system_bluetooth_enabled = {
582:               OPCODE(OGF_BTSTACK, BTSTACK_GET_SYSTEM_BLUETOOTH_ENABLED), ""
583:               };
584:               
585:               const hci_cmd_t btstack_set_system_bluetooth_enabled = {
586:               OPCODE(OGF_BTSTACK, BTSTACK_SET_SYSTEM_BLUETOOTH_ENABLED), "1"
587:               };
588:               
589:               const hci_cmd_t btstack_set_discoverable = {
590:               OPCODE(OGF_BTSTACK, BTSTACK_SET_DISCOVERABLE), "1"
591:               };
592:               
593:               const hci_cmd_t btstack_set_bluetooth_enabled = {
594:               // only used by btstack config
595:               OPCODE(OGF_BTSTACK, BTSTACK_SET_BLUETOOTH_ENABLED), "1"
596:               };
597:               
598:               const hci_cmd_t l2cap_create_channel = {
599:               OPCODE(OGF_BTSTACK, L2CAP_CREATE_CHANNEL), "B2"
600:               // @param bd_addr(48), psm (16)
601:               };
602:               const hci_cmd_t l2cap_create_channel_mtu = {
603:               OPCODE(OGF_BTSTACK, L2CAP_CREATE_CHANNEL_MTU), "B22"
604:               // @param bd_addr(48), psm (16), mtu (16)
605:               };
606:               const hci_cmd_t l2cap_disconnect = {
607:               OPCODE(OGF_BTSTACK, L2CAP_DISCONNECT), "21"
608:               // @param channel(16), reason(8)
609:               };
610:               const hci_cmd_t l2cap_register_service = {
611:               OPCODE(OGF_BTSTACK, L2CAP_REGISTER_SERVICE), "22"
612:               // @param psm (16), mtu (16)
613:               };
614:               const hci_cmd_t l2cap_unregister_service = {
615:               OPCODE(OGF_BTSTACK, L2CAP_UNREGISTER_SERVICE), "2"
616:               // @param psm (16)
617:               };
618:               const hci_cmd_t l2cap_accept_connection = {
619:               OPCODE(OGF_BTSTACK, L2CAP_ACCEPT_CONNECTION), "2"
620:               // @param source cid (16)
621:               };
622:               const hci_cmd_t l2cap_decline_connection = {
623:               OPCODE(OGF_BTSTACK, L2CAP_DECLINE_CONNECTION), "21"
624:               // @param source cid (16), reason(8)
625:               };
626:               const hci_cmd_t sdp_register_service_record = {
627:               OPCODE(OGF_BTSTACK, SDP_REGISTER_SERVICE_RECORD), "S"
628:               // @param service record handle (DES)
629:               };
630:               const hci_cmd_t sdp_unregister_service_record = {
631:               OPCODE(OGF_BTSTACK, SDP_UNREGISTER_SERVICE_RECORD), "4"
632:               // @param service record handle (32)
633:               };
634:               
635:               // create rfcomm channel: @param bd_addr(48), channel (8)
636:               const hci_cmd_t rfcomm_create_channel = {
637:               	OPCODE(OGF_BTSTACK, RFCOMM_CREATE_CHANNEL), "B1"
638:               };
639:               // create rfcomm channel: @param bd_addr(48), channel (8), mtu (16), credits (8)
640:               const hci_cmd_t rfcomm_create_channel_with_initial_credits = {
641:               	OPCODE(OGF_BTSTACK, RFCOMM_CREATE_CHANNEL_WITH_CREDITS), "B121"
642:               };
643:               // grant credits: @param rfcomm_cid(16), credits (8)
644:               const hci_cmd_t rfcomm_grants_credits= {
645:               	OPCODE(OGF_BTSTACK, RFCOMM_GRANT_CREDITS), "21"
646:               };
647:               // disconnect rfcomm disconnect, @param rfcomm_cid(16), reason(8)
648:               const  hci_cmd_t rfcomm_disconnect = {
649:               	OPCODE(OGF_BTSTACK, RFCOMM_DISCONNECT), "21"
650:               };
651:               
652:               // register rfcomm service: @param channel(8), mtu (16)
653:               const hci_cmd_t rfcomm_register_service = {
654:                   OPCODE(OGF_BTSTACK, RFCOMM_REGISTER_SERVICE), "12"
655:               };
656:               // register rfcomm service: @param channel(8), mtu (16), initial credits (8)
657:               const hci_cmd_t rfcomm_register_service_with_initial_credits = {
658:                   OPCODE(OGF_BTSTACK, RFCOMM_REGISTER_SERVICE_WITH_CREDITS), "121"
659:               };
660:               
661:               // unregister rfcomm service, @param service_channel(16)
662:               const hci_cmd_t rfcomm_unregister_service = {
663:                   OPCODE(OGF_BTSTACK, RFCOMM_UNREGISTER_SERVICE), "2"
664:               };
665:               // accept connection @param source cid (16)
666:               const hci_cmd_t rfcomm_accept_connection = {
667:                   OPCODE(OGF_BTSTACK, RFCOMM_ACCEPT_CONNECTION), "2"
668:               };
669:               // decline connection @param source cid (16)
670:               const hci_cmd_t rfcomm_decline_connection = {
671:                   OPCODE(OGF_BTSTACK, RFCOMM_DECLINE_CONNECTION), "21"
672:               };
673:               // request persisten rfcomm channel number for named service
674:               const hci_cmd_t rfcomm_persistent_channel_for_service = {
675:                   OPCODE(OGF_BTSTACK, RFCOMM_PERSISTENT_CHANNEL), "N"
676:               };
677:               
678:               // register rfcomm service: @param channel(8), mtu (16), initial credits (8)
679:               extern const hci_cmd_t rfcomm_register_service_with_initial_credits;
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libbtstack/src/hci.c  ----
00FCDA  FA000C     LNK #0xC
00FCDC  BE9F88     MOV.D W8, [W15++]
00FCDE  BE9F8A     MOV.D W10, [W15++]
00FCE0  BE9F8C     MOV.D W12, [W15++]
00FCE2  780581     MOV W1, W11
00FCE4  780502     MOV W2, W10
0118A0  FA0010     LNK #0x10
0118A2  BE9F88     MOV.D W8, [W15++]
012DA8  FA0006     LNK #0x6
012DAA  BE9F88     MOV.D W8, [W15++]
012DAC  BE9F8A     MOV.D W10, [W15++]
012DAE  780480     MOV W0, W9
012DB0  780581     MOV W1, W11
012E9A  781F88     MOV W8, [W15++]
012E9C  780080     MOV W0, W1
0149AC  FA0102     LNK #0x102
0149AE  BE9F88     MOV.D W8, [W15++]
0149B0  780100     MOV W0, W2
0149B2  780481     MOV W1, W9
014C90  BE9F88     MOV.D W8, [W15++]
014C92  BE0400     MOV.D W0, W8
014CD6  FA000E     LNK #0xE
014CD8  781F88     MOV W8, [W15++]
014CDA  780400     MOV W0, W8
014DE0  BE9F88     MOV.D W8, [W15++]
014DE2  780400     MOV W0, W8
014EDE  FA0006     LNK #0x6
014EE0  BE9F88     MOV.D W8, [W15++]
014EE2  781F8A     MOV W10, [W15++]
014EE4  780100     MOV W0, W2
014EE6  784501     MOV.B W1, W10
014FD0  BE9F88     MOV.D W8, [W15++]
014FD2  780480     MOV W0, W9
015552  FA0004     LNK #0x4
015714  781F88     MOV W8, [W15++]
015716  784400     MOV.B W0, W8
0157D2  FA0004     LNK #0x4
015A04  FA0004     LNK #0x4
015A2C  780100     MOV W0, W2
015AA2  BE9F88     MOV.D W8, [W15++]
015AA4  780480     MOV W0, W9
015AC8  FA0004     LNK #0x4
015AEE  FA0004     LNK #0x4
015B14  FA0006     LNK #0x6
015B16  781F88     MOV W8, [W15++]
015B18  780401     MOV W1, W8
015D10  FA0002     LNK #0x2
015D32  781F88     MOV W8, [W15++]
015D34  780400     MOV W0, W8
016024  780100     MOV W0, W2
016184  780100     MOV W0, W2
016252  FA0000     LNK #0x0
016254  97B8CF     MOV [W15-8], W1
1:                 /*
2:                  * Copyright (C) 2009-2012 by Matthias Ringwald
3:                  *
4:                  * Redistribution and use in source and binary forms, with or without
5:                  * modification, are permitted provided that the following conditions
6:                  * are met:
7:                  *
8:                  * 1. Redistributions of source code must retain the above copyright
9:                  *    notice, this list of conditions and the following disclaimer.
10:                 * 2. Redistributions in binary form must reproduce the above copyright
11:                 *    notice, this list of conditions and the following disclaimer in the
12:                 *    documentation and/or other materials provided with the distribution.
13:                 * 3. Neither the name of the copyright holders nor the names of
14:                 *    contributors may be used to endorse or promote products derived
15:                 *    from this software without specific prior written permission.
16:                 * 4. Any redistribution, use, or modification is done solely for
17:                 *    personal benefit and not for any commercial purpose or for
18:                 *    monetary gain.
19:                 *
20:                 * THIS SOFTWARE IS PROVIDED BY MATTHIAS RINGWALD AND CONTRIBUTORS
21:                 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
22:                 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
23:                 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MATTHIAS
24:                 * RINGWALD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
25:                 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
26:                 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
27:                 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
28:                 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
29:                 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
30:                 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
31:                 * SUCH DAMAGE.
32:                 *
33:                 * Please inquire about commercial licensing options at btstack@ringwald.ch
34:                 *
35:                 */
36:                
37:                /*
38:                 *  hci.c
39:                 *
40:                 *  Created by Matthias Ringwald on 4/29/09.
41:                 *
42:                 */
43:                
44:                #include "config.h"
45:                
46:                #include "hci.h"
47:                
48:                #include <stdarg.h>
49:                #include <string.h>
50:                #include <stdio.h>
51:                
52:                #ifndef EMBEDDED
53:                #include <unistd.h> // gethostbyname
54:                #include <btstack/version.h>
55:                #endif
56:                
57:                #include "btstack_memory.h"
58:                #include "debug.h"
59:                #include "hci_dump.h"
60:                
61:                #include <btstack/hci_cmds.h>
62:                
63:                #define HCI_CONNECTION_TIMEOUT_MS 10000
64:                
65:                #ifdef USE_BLUETOOL
66:                #include "bt_control_iphone.h"
67:                #endif
68:                
69:                static void hci_update_scan_enable(void);
70:                
71:                // the STACK is here
72:                static hci_stack_t       hci_stack;
73:                
74:                /**
75:                 * get connection for a given handle
76:                 *
77:                 * @return connection OR NULL, if not found
78:                 */
79:                hci_connection_t * connection_for_handle(hci_con_handle_t con_handle){
80:                    linked_item_t *it;
81:                    for (it = (linked_item_t *) hci_stack.connections; it ; it = it->next){
00FDF4  80F232     MOV 0x1E46, W2
00FDF6  370004     BRA 0xFE00
00FDFE  780112     MOV [W2], W2
00FE00  E00002     CP0 W2
00FE02  3AFFFA     BRA NZ, 0xFDF8
00FE04  370003     BRA 0xFE0C
00FF1C  80F232     MOV 0x1E46, W2
00FF1E  370004     BRA 0xFF28
00FF26  780112     MOV [W2], W2
00FF28  E00002     CP0 W2
00FF2A  3AFFFA     BRA NZ, 0xFF20
00FF2C  370009     BRA 0xFF40
00FF96  80F230     MOV 0x1E46, W0
00FF98  370005     BRA 0xFFA4
00FFA2  780019     MOV [W9], W0
00FFA4  E00000     CP0 W0
00FFA6  3AFFF9     BRA NZ, 0xFF9A
00FFA8  780480     MOV W0, W9
014CAA  80F231     MOV 0x1E46, W1
014CAC  370004     BRA 0x14CB6
014CB4  780091     MOV [W1], W1
014CB6  E00001     CP0 W1
014CB8  3AFFFA     BRA NZ, 0x14CAE
014CBA  37000A     BRA 0x14CD0
015A2E  80F231     MOV 0x1E46, W1
015A30  370004     BRA 0x15A3A
015A38  780091     MOV [W1], W1
015A3A  E00001     CP0 W1
015A3C  3AFFFA     BRA NZ, 0x15A32
015A3E  370008     BRA 0x15A50
016026  80F231     MOV 0x1E46, W1
016028  370004     BRA 0x16032
016030  780091     MOV [W1], W1
016032  E00001     CP0 W1
016034  3AFFFA     BRA NZ, 0x1602A
016036  780001     MOV W1, W0
016038  060000     RETURN
016186  80F230     MOV 0x1E46, W0
016188  370005     BRA 0x16194
016192  780011     MOV [W1], W0
016194  E00000     CP0 W0
016196  3AFFF9     BRA NZ, 0x1618A
016198  780080     MOV W0, W1
82:                        if ( ((hci_connection_t *) it)->con_handle == con_handle){
00FDF8  900052     MOV [W2+10], W0
00FDFA  500F85     SUB W0, W5, [W15]
00FDFC  320004     BRA Z, 0xFE06
00FF20  900052     MOV [W2+10], W0
00FF22  500F81     SUB W0, W1, [W15]
00FF24  320004     BRA Z, 0xFF2E
00FF9A  780480     MOV W0, W9
00FF9C  900050     MOV [W0+10], W0
00FF9E  500F81     SUB W0, W1, [W15]
00FFA0  320004     BRA Z, 0xFFAA
014CAE  900051     MOV [W1+10], W0
014CB0  500F82     SUB W0, W2, [W15]
014CB2  320004     BRA Z, 0x14CBC
015A32  900051     MOV [W1+10], W0
015A34  500F82     SUB W0, W2, [W15]
015A36  320004     BRA Z, 0x15A40
01602A  900051     MOV [W1+10], W0
01602C  500F82     SUB W0, W2, [W15]
01602E  320005     BRA Z, 0x1603A
01618A  780080     MOV W0, W1
01618C  900050     MOV [W0+10], W0
01618E  500F82     SUB W0, W2, [W15]
016190  320004     BRA Z, 0x1619A
83:                            return (hci_connection_t *) it;
84:                        }
85:                    }
86:                    return NULL;
87:                }
88:                
89:                static void hci_connection_timeout_handler(timer_source_t *timer){
90:                #if defined(HAVE_TIME) || defined(HAVE_TICK)
91:                    hci_connection_t * connection = (hci_connection_t *) linked_item_get_user(&timer->item);
92:                #endif
93:                #ifdef HAVE_TIME
94:                    struct timeval tv;
95:                    gettimeofday(&tv, NULL);
96:                    if (tv.tv_sec >= connection->timestamp.tv_sec + HCI_CONNECTION_TIMEOUT_MS/1000) {
97:                        // connections might be timed out
98:                        hci_emit_l2cap_check_timeout(connection);
99:                    }
100:               #endif
101:               #ifdef HAVE_TICK
102:                   if (embedded_get_ticks() > connection->timestamp + embedded_ticks_for_ms(HCI_CONNECTION_TIMEOUT_MS)){
103:                       // connections might be timed out
104:                       hci_emit_l2cap_check_timeout(connection);
105:                   }
106:                   run_loop_set_timer(timer, HCI_CONNECTION_TIMEOUT_MS);
107:                   run_loop_add_timer(timer);
108:               #endif
109:               }
110:               
111:               static void hci_connection_timestamp(hci_connection_t *connection){
112:               #ifdef HAVE_TIME
113:                   gettimeofday(&connection->timestamp, NULL);
114:               #endif
115:               #ifdef HAVE_TICK
116:                   connection->timestamp = embedded_get_ticks();
117:               #endif
118:               }
119:               
120:               /**
121:                * create connection for given address
122:                *
123:                * @return connection OR NULL, if no memory left
124:                */
125:               static hci_connection_t * create_connection_for_addr(bd_addr_t addr){
126:                   hci_connection_t * conn = (hci_connection_t *) btstack_memory_hci_connection_get();
014DE4  0266E4     CALL btstack_memory_hci_connection_get
014DE6  000001     NOP
014DE8  780480     MOV W0, W9
127:                   if (!conn) return NULL;
014DEA  E00000     CP0 W0
014DEC  320016     BRA Z, 0x14E1A
128:                   BD_ADDR_COPY(conn->address, addr);
014DEE  400064     ADD W0, #0x4, W0
014DF0  090005     REPEAT #0x5
014DF2  785838     MOV.B [W8++], [W0++]
014DF4  B10060     SUB #0x6, W0
014DF6  B10068     SUB #0x6, W8
129:                   conn->con_handle = 0xffff;
014DF8  EB8000     SETM W0
014DFA  9804D0     MOV W0, [W9+10]
130:                   conn->authentication_flags = AUTH_FLAGS_NONE;
014DFC  EB0400     CLR W8
014DFE  9804F8     MOV W8, [W9+14]
131:                   linked_item_set_user(&conn->timeout.item, conn);
014E00  448070     ADD W9, #0x10, W0
014E02  780089     MOV W9, W1
014E04  026726     CALL linked_item_set_user
014E06  000001     NOP
132:                   conn->timeout.process = hci_connection_timeout_handler;
014E08  253100     MOV #0x5310, W0
014E0A  980CA0     MOV W0, [W9+20]
133:                   hci_connection_timestamp(conn);
134:                   conn->acl_recombination_length = 0;
014E0C  990CE8     MOV W8, [W9+284]
135:                   conn->acl_recombination_pos = 0;
014E0E  990CD8     MOV W8, [W9+282]
136:                   conn->num_acl_packets_sent = 0;
014E10  9A5CE8     MOV.B W8, [W9+286]
137:                   linked_list_add(&hci_stack.connections, (linked_item_t *) conn);
014E12  780089     MOV W9, W1
014E14  21E460     MOV #0x1E46, W0
014E16  0263E6     CALL linked_list_add
014E18  000001     NOP
138:                   return conn;
139:               }
140:               
141:               /**
142:                * get connection for given address
143:                *
144:                * @return connection OR NULL, if not found
145:                */
146:               static hci_connection_t * connection_for_address(bd_addr_t address){
147:                   linked_item_t *it;
148:                   for (it = (linked_item_t *) hci_stack.connections; it ; it = it->next){
015AA6  80F230     MOV 0x1E46, W0
015AA8  370009     BRA 0x15ABC
015ABA  780018     MOV [W8], W0
015ABC  E00000     CP0 W0
015ABE  3AFFF5     BRA NZ, 0x15AAA
015AC0  780400     MOV W0, W8
149:                       if ( ! BD_ADDR_CMP( ((hci_connection_t *) it)->address, address) ){
015AAA  780400     MOV W0, W8
015AAC  400064     ADD W0, #0x4, W0
015AAE  200062     MOV #0x6, W2
015AB0  780089     MOV W9, W1
015AB2  0256EC     CALL memcmp
015AB4  000000     NOP
015AB6  E00000     CP0 W0
015AB8  320004     BRA Z, 0x15AC2
150:                           return (hci_connection_t *) it;
151:                       }
152:                   }
153:                   return NULL;
154:               }
155:               
156:               inline static void connectionSetAuthenticationFlags(hci_connection_t * conn, hci_authentication_flags_t flags){
157:                   conn->authentication_flags = (hci_authentication_flags_t)(conn->authentication_flags | flags);
015B2E  900070     MOV [W0+14], W0
015B30  740000     IOR W8, W0, W0
015B32  980170     MOV W0, [W2+14]
158:               }
159:               
160:               inline static void connectionClearAuthenticationFlags(hci_connection_t * conn, hci_authentication_flags_t flags){
161:                   conn->authentication_flags = (hci_authentication_flags_t)(conn->authentication_flags & ~flags);
011950  900079     MOV [W9+14], W0
011952  A11000     BCLR W0, #1
011954  9804F0     MOV W0, [W9+14]
162:               }
163:               
164:               
165:               /**
166:                * add authentication flags and reset timer
167:                */
168:               static void hci_add_connection_flags_for_flipped_bd_addr(uint8_t *bd_addr, hci_authentication_flags_t flags){
169:                   bd_addr_t addr;
170:                   bt_flip_addr(addr, *(bd_addr_t *) bd_addr);
015B1A  780080     MOV W0, W1
015B1C  578068     SUB W15, #0x8, W0
015B1E  02616A     CALL bt_flip_addr
015B20  000001     NOP
171:                   hci_connection_t * conn = connection_for_address(addr);
015B22  578068     SUB W15, #0x8, W0
015B24  025AA2     CALL connection_for_address
015B26  000001     NOP
015B28  780100     MOV W0, W2
172:                   if (conn) {
015B2A  E00000     CP0 W0
015B2C  320003     BRA Z, 0x15B34
173:                       connectionSetAuthenticationFlags(conn, flags);
174:                       hci_connection_timestamp(conn);
175:                   }
176:               }
177:               
178:               int  hci_authentication_active_for_handle(hci_con_handle_t handle){
179:                   hci_connection_t * conn = connection_for_handle(handle);
180:                   if (!conn) return 0;
181:                   if (!conn->authentication_flags) return 0;
015A40  9000F1     MOV [W1+14], W1
015A42  E00001     CP0 W1
015A44  320005     BRA Z, 0x15A50
182:                   if (conn->authentication_flags & SENT_LINK_KEY_REPLY) return 0;
015A46  A32801     BTST.Z W1, #2
015A48  3A0003     BRA NZ, 0x15A50
183:                   if (conn->authentication_flags & RECV_LINK_KEY_NOTIFICATION) return 0;
015A4A  200010     MOV #0x1, W0
015A4C  A34801     BTST.Z W1, #4
015A4E  320001     BRA Z, 0x15A52
015A50  EB0000     CLR W0
184:                   return 1;
185:               }
186:               
187:               void hci_drop_link_key_for_bd_addr(bd_addr_t *addr){
188:                   if (hci_stack.remote_device_db) {
0165A6  80FA91     MOV DUMPSYS_ERROR, W1
0165A8  E00001     CP0 W1
0165AA  320002     BRA Z, 0x165B0
189:                       hci_stack.remote_device_db->delete_link_key(addr);
190:                   }
191:               }
192:               
193:               
194:               /**
195:                * count connections
196:                */
197:               static int nr_hci_connections(void){
198:                   int count = 0;
199:                   linked_item_t *it;
200:                   for (it = (linked_item_t *) hci_stack.connections; it ; it = it->next, count++);
01555C  80F230     MOV 0x1E46, W0
01555E  EB0080     CLR W1
015560  370002     BRA 0x15566
015562  780010     MOV [W0], W0
015564  E80081     INC W1, W1
015566  E00000     CP0 W0
015568  3AFFFC     BRA NZ, 0x15562
201:                   return count;
202:               }
203:               
204:               /** 
205:                * Dummy handler called by HCI
206:                */
207:               static void dummy_handler(uint8_t packet_type, uint8_t *packet, uint16_t size){
208:               }
209:               
210:               uint8_t hci_number_outgoing_packets(hci_con_handle_t handle){
211:                   hci_connection_t * connection = connection_for_handle(handle);
212:                   if (!connection) {
213:                       log_error("hci_number_outgoing_packets connectino for handle %u does not exist!\n", handle);
214:                       return 0;
215:                   }
216:                   return connection->num_acl_packets_sent;
01603A  925861     MOV.B [W1+286], W0
01603C  FB8000     ZE W0, W0
217:               }
218:               
219:               uint8_t hci_number_free_acl_slots(){
220:                   uint8_t free_slots = hci_stack.total_num_acl_packets;
016008  21F4B0     MOV #0x1F4B, W0
01600A  784010     MOV.B [W0], W0
221:                   linked_item_t *it;
222:                   for (it = (linked_item_t *) hci_stack.connections; it ; it = it->next){
01600C  80F231     MOV 0x1E46, W1
01600E  370006     BRA 0x1601C
01601A  780091     MOV [W1], W1
01601C  E00001     CP0 W1
01601E  3AFFF8     BRA NZ, 0x16010
223:                       hci_connection_t * connection = (hci_connection_t *) it;
224:                       if (free_slots < connection->num_acl_packets_sent) {
016010  925961     MOV.B [W1+286], W2
016012  504F82     SUB.B W0, W2, [W15]
016014  310001     BRA C, 0x16018
016016  050000     RETLW #0x0, W0
225:                           log_error("hci_number_free_acl_slots: sum of outgoing packets > total acl packets!\n");
226:                           return 0;
227:                       }
228:                       free_slots -= connection->num_acl_packets_sent;
016018  504002     SUB.B W0, W2, W0
229:                   }
230:                   return free_slots;
016020  FB8000     ZE W0, W0
231:               }
232:               
233:               int hci_can_send_packet_now(uint8_t packet_type){
234:               
235:                   // check for async hci transport implementations
236:                   if (hci_stack.hci_transport->can_send_packet_now){
015718  80F200     MOV hci_stack, W0
01571A  9000E0     MOV [W0+12], W1
01571C  E00001     CP0 W1
01571E  320004     BRA Z, 0x15728
237:                       if (!hci_stack.hci_transport->can_send_packet_now(packet_type)){
015720  784008     MOV.B W8, W0
015722  010001     CALL W1
015724  E00000     CP0 W0
015726  32000B     BRA Z, 0x1573E
238:                           return 0;
239:                       }
240:                   }
241:                   
242:                   // check regular Bluetooth flow control
243:                   switch (packet_type) {
015728  544FE1     SUB.B W8, #0x1, [W15]
01572A  320006     BRA Z, 0x15738
01572C  544FE2     SUB.B W8, #0x2, [W15]
01572E  3A0007     BRA NZ, 0x1573E
244:                       case HCI_ACL_DATA_PACKET:
245:                           return hci_number_free_acl_slots();
015730  026008     CALL hci_number_free_acl_slots
015732  000001     NOP
015734  FB8000     ZE W0, W0
015736  370004     BRA 0x15740
246:                       case HCI_COMMAND_DATA_PACKET:
247:                           return hci_stack.num_cmd_packets;
015738  21F4A0     MOV #0x1F4A, W0
01573A  FB8010     ZE [W0], W0
01573C  370001     BRA 0x15740
01573E  EB0000     CLR W0
248:                       default:
249:                           return 0;
250:                   }
251:               }
252:               
253:               int hci_send_acl_packet(uint8_t *packet, int size){
254:               
255:                   // check for free places on BT module
256:                   if (!hci_number_free_acl_slots()) return BTSTACK_ACL_BUFFERS_FULL;
014C94  026008     CALL hci_number_free_acl_slots
014C96  000001     NOP
014C98  200571     MOV #0x57, W1
014C9A  E00400     CP0.B W0
014C9C  320019     BRA Z, 0x14CD0
257:                   
258:                   hci_con_handle_t con_handle = READ_ACL_CONNECTION_HANDLE(packet);
014C9E  FB8018     ZE [W8], W0
014CA0  904098     MOV.B [W8+1], W1
014CA2  DD08C8     SL W1, #8, W1
014CA4  700001     IOR W0, W1, W0
014CA6  20FFF1     MOV #0xFFF, W1
014CA8  600101     AND W0, W1, W2
259:                   hci_connection_t *connection = connection_for_handle( con_handle);
260:                   if (!connection) return 0;
261:                   hci_connection_timestamp(connection);
262:                   
263:                   // count packet
264:                   connection->num_acl_packets_sent++;
014CBC  925861     MOV.B [W1+286], W0
014CBE  E84000     INC.B W0, W0
014CC0  9A58E0     MOV.B W0, [W1+286]
265:                   // log_info("hci_send_acl_packet - handle %u, sent %u\n", connection->con_handle, connection->num_acl_packets_sent);
266:               
267:                   // send packet 
268:                   int err = hci_stack.hci_transport->send_packet(HCI_ACL_DATA_PACKET, packet, size);
014CC2  80F200     MOV hci_stack, W0
014CC4  9001A0     MOV [W0+4], W3
014CC6  780109     MOV W9, W2
014CC8  780088     MOV W8, W1
014CCA  B3C020     MOV #0x2, W0
014CCC  010003     CALL W3
014CCE  780080     MOV W0, W1
269:                   
270:                   return err;
271:               }
272:               
273:               static void acl_handler(uint8_t *packet, int size){
274:               
275:                   // get info
276:                   hci_con_handle_t con_handle = READ_ACL_CONNECTION_HANDLE(packet);
00FF8A  904111     MOV.B [W1+1], W2
00FF8C  FB8011     ZE [W1], W0
00FF8E  DD10C8     SL W2, #8, W1
00FF90  700001     IOR W0, W1, W0
00FF92  20FFF1     MOV #0xFFF, W1
00FF94  600081     AND W0, W1, W1
277:                   hci_connection_t *conn      = connection_for_handle(con_handle);
278:                   uint8_t  acl_flags          = READ_ACL_FLAGS(packet);
00FFAA  FB8002     ZE W2, W0
00FFAC  DE0144     LSR W0, #4, W2
279:                   uint16_t acl_length         = READ_ACL_LENGTH(packet);
00FFAE  9040AB     MOV.B [W11+2], W1
00FFB0  FB8081     ZE W1, W1
00FFB2  90403B     MOV.B [W11+3], W0
00FFB4  DD0048     SL W0, #8, W0
00FFB6  708400     IOR W1, W0, W8
280:               
281:                   // ignore non-registered handle
282:                   if (!conn){
00FFB8  E00009     CP0 W9
00FFBA  32003F     BRA Z, 0x1003A
283:                       log_error( "hci.c: acl_handler called with non-registered handle %u!\n" , con_handle);
284:                       return;
285:                   }
286:                   
287:                   // update idle timestamp
288:                   hci_connection_timestamp(conn);
289:                   
290:                   // handle different packet types
291:                   switch (acl_flags & 0x03) {
00FFBC  610063     AND W2, #0x3, W0
00FFBE  500FE1     SUB W0, #0x1, [W15]
00FFC0  320003     BRA Z, 0xFFC8
00FFC2  500FE2     SUB W0, #0x2, [W15]
00FFC4  3A003A     BRA NZ, 0x1003A
00FFC6  370018     BRA 0xFFF8
292:                           
293:                       case 0x01: // continuation fragment
294:                           
295:                           // sanity check
296:                           if (conn->acl_recombination_pos == 0) {
00FFC8  910859     MOV [W9+282], W0
00FFCA  E00000     CP0 W0
00FFCC  320036     BRA Z, 0x1003A
297:                               log_error( "ACL Cont Fragment but no first fragment for handle 0x%02x\n", con_handle);
298:                               return;
299:                           }
300:                           
301:                           // append fragment payload (header already stored)
302:                           memcpy(&conn->acl_recombination_buffer[conn->acl_recombination_pos], &packet[4], acl_length );
00FFCE  448576     ADD W9, #0x16, W10
00FFD0  450000     ADD W10, W0, W0
00FFD2  4580E4     ADD W11, #0x4, W1
00FFD4  780108     MOV W8, W2
00FFD6  0256DE     CALL memcpy
00FFD8  000000     NOP
303:                           conn->acl_recombination_pos += acl_length;
00FFDA  910859     MOV [W9+282], W0
00FFDC  440100     ADD W8, W0, W2
00FFDE  990CD2     MOV W2, [W9+282]
304:                           
305:                           // log_error( "ACL Cont Fragment: acl_len %u, combined_len %u, l2cap_len %u\n", acl_length,
306:                           //        conn->acl_recombination_pos, conn->acl_recombination_length);  
307:                           
308:                           // forward complete L2CAP packet if complete. 
309:                           if (conn->acl_recombination_pos >= conn->acl_recombination_length + 4 + 4){ // pos already incl. ACL header
00FFE0  910869     MOV [W9+284], W0
00FFE2  400068     ADD W0, #0x8, W0
00FFE4  510F80     SUB W2, W0, [W15]
00FFE6  390027     BRA NC, 0x10036
310:                               
311:                               hci_stack.packet_handler(HCI_ACL_DATA_PACKET, conn->acl_recombination_buffer, conn->acl_recombination_pos);
00FFE8  78008A     MOV W10, W1
00FFEA  B3C020     MOV #0x2, W0
00FFEC  80FA83     MOV pCurrentConfigurationDescriptor, W3
00FFEE  010003     CALL W3
312:                               // reset recombination buffer
313:                               conn->acl_recombination_length = 0;
00FFF0  EB0000     CLR W0
00FFF2  990CE0     MOV W0, [W9+284]
314:                               conn->acl_recombination_pos = 0;
00FFF4  990CD0     MOV W0, [W9+282]
00FFF6  37001F     BRA 0x10036
315:                           }
316:                           break;
317:                           
318:                       case 0x02: { // first fragment
319:                           
320:                           // sanity check
321:                           if (conn->acl_recombination_pos) {
00FFF8  910859     MOV [W9+282], W0
00FFFA  E00000     CP0 W0
00FFFC  3A001E     BRA NZ, 0x1003A
322:                               log_error( "ACL First Fragment but data in buffer for handle 0x%02x\n", con_handle);
323:                               return;
324:                           }
325:               
326:                           // peek into L2CAP packet!
327:                           uint16_t l2cap_length = READ_L2CAP_LENGTH( packet );
00FFFE  9040CB     MOV.B [W11+4], W1
010000  FB8081     ZE W1, W1
010002  90405B     MOV.B [W11+5], W0
010004  DD0048     SL W0, #8, W0
010006  708600     IOR W1, W0, W12
328:               
329:                           // log_error( "ACL First Fragment: acl_len %u, l2cap_len %u\n", acl_length, l2cap_length);
330:               
331:                           // compare fragment size to L2CAP packet size
332:                           if (acl_length >= l2cap_length + 4){
010008  4606E4     ADD W12, #0x4, W13
01000A  440564     ADD W8, #0x4, W10
01000C  540F8D     SUB W8, W13, [W15]
01000E  390006     BRA NC, 0x1001C
333:                               
334:                               // forward fragment as L2CAP packet
335:                               hci_stack.packet_handler(HCI_ACL_DATA_PACKET, packet, acl_length + 4);
010010  78010A     MOV W10, W2
010012  78008B     MOV W11, W1
010014  B3C020     MOV #0x2, W0
010016  80FA83     MOV pCurrentConfigurationDescriptor, W3
010018  010003     CALL W3
01001A  37000D     BRA 0x10036
336:                           
337:                           } else {
338:                               // store first fragment and tweak acl length for complete package
339:                               memcpy(conn->acl_recombination_buffer, packet, acl_length + 4);
01001C  448476     ADD W9, #0x16, W8
01001E  78010A     MOV W10, W2
010020  78008B     MOV W11, W1
010022  780008     MOV W8, W0
010024  0256DE     CALL memcpy
010026  000000     NOP
340:                               conn->acl_recombination_pos    = acl_length + 4;
010028  990CDA     MOV W10, [W9+282]
341:                               conn->acl_recombination_length = l2cap_length;
01002A  990CEC     MOV W12, [W9+284]
342:                               bt_store_16(conn->acl_recombination_buffer, 2, l2cap_length +4);
01002C  78010D     MOV W13, W2
01002E  200021     MOV #0x2, W1
010030  780008     MOV W8, W0
010032  026614     CALL bt_store_16
010034  000001     NOP
343:                           }
344:                           break;
345:                           
346:                       } 
347:                       default:
348:                           log_error( "hci.c: acl_handler called with invalid packet boundary flags %u\n", acl_flags & 0x03);
349:                           return;
350:                   }
351:                   
352:                   // execute main loop
353:                   hci_run();
010036  0218A0     CALL hci_run
010038  000001     NOP
354:               }
355:               
356:               static void hci_shutdown_connection(hci_connection_t *conn){
357:                   log_info("Connection closed: handle %u, %s\n", conn->con_handle, bd_addr_to_str(conn->address));
358:               
359:                   // cancel all l2cap connections
360:                   hci_emit_disconnection_complete(conn->con_handle, 0x16);    // terminated by local host
015D36  900050     MOV [W0+10], W0
015D38  B3C161     MOV #0x16, W1
015D3A  024EDE     CALL hci_emit_disconnection_complete
015D3C  000001     NOP
361:               
362:                   run_loop_remove_timer(&conn->timeout);
363:                   
364:                   linked_list_remove(&hci_stack.connections, (linked_item_t *) conn);
015D3E  780088     MOV W8, W1
015D40  21E460     MOV #0x1E46, W0
015D42  0263FC     CALL linked_list_remove
015D44  000001     NOP
365:                   btstack_memory_hci_connection_free( conn );
015D46  780008     MOV W8, W0
015D48  026674     CALL btstack_memory_hci_connection_free
015D4A  000001     NOP
366:                   
367:                   // now it's gone
368:                   hci_emit_nr_connections_changed();
015D4C  025552     CALL hci_emit_nr_connections_changed
015D4E  000001     NOP
369:               }
370:               
371:               static const uint16_t packet_type_sizes[] = {
372:                   0, HCI_ACL_2DH1_SIZE, HCI_ACL_3DH1_SIZE, HCI_ACL_DM1_SIZE,
373:                   HCI_ACL_DH1_SIZE, 0, 0, 0,
374:                   HCI_ACL_2DH3_SIZE, HCI_ACL_3DH3_SIZE, HCI_ACL_DM3_SIZE, HCI_ACL_DH3_SIZE,
375:                   HCI_ACL_2DH5_SIZE, HCI_ACL_3DH5_SIZE, HCI_ACL_DM5_SIZE, HCI_ACL_DH5_SIZE
376:               };
377:               
378:               static uint16_t hci_acl_packet_types_for_buffer_size(uint16_t buffer_size){
379:                   uint16_t packet_types = 0;
380:                   int i;
381:                   for (i=0;i<16;i++){
00FD8C  E80081     INC W1, W1
00FD8E  E88102     INC2 W2, W2
00FD90  508FF0     SUB W1, #0x10, [W15]
00FD92  3AFFF5     BRA NZ, 0xFD7E
382:                       if (packet_type_sizes[i] == 0) continue;
00FD7E  780012     MOV [W2], W0
00FD80  E00000     CP0 W0
00FD82  320004     BRA Z, 0xFD8C
383:                       if (packet_type_sizes[i] <= buffer_size){
00FD84  500F84     SUB W0, W4, [W15]
00FD86  3E0002     BRA GTU, 0xFD8C
384:                           packet_types |= 1 << i;
00FD88  DD2801     SL W5, W1, W0
00FD8A  718180     IOR W3, W0, W3
385:                       }
386:                   }
387:                   // flip bits for "may not be used"
388:                   packet_types ^= 0x3306;
389:                   return packet_types;
390:               }
391:               
392:               uint16_t hci_usable_acl_packet_types(void){
01674C  80FA70     MOV pDeviceDescriptor, W0
393:                   return hci_stack.packet_types;
394:               }
395:               
396:               uint8_t* hci_get_outgoing_acl_packet_buffer(void){
397:                   // hci packet buffer is >= acl data packet length
398:                   return hci_stack.hci_packet_buffer;
399:               }
400:               
401:               uint16_t hci_max_acl_data_packet_length(){
016754  80FA60     MOV adb_state, W0
402:                   return hci_stack.acl_data_packet_length;
403:               }
404:               
405:               // avoid huge local variables
406:               #ifndef EMBEDDED
407:               static device_name_t device_name;
408:               #endif
409:               static void event_handler(uint8_t *packet, int size){
410:                   bd_addr_t addr;
411:                   uint8_t link_type;
412:                   hci_con_handle_t handle;
413:                   hci_connection_t * conn;
414:                   int i;
415:                       
416:                   // printf("HCI:EVENT:%02x\n", packet[0]);
417:                   
418:                   switch (packet[0]) {
00FCEE  784011     MOV.B [W1], W0
00FCF0  FB8000     ZE W0, W0
00FCF2  200001     MOV #0x0, W1
00FCF4  500063     SUB W0, #0x3, W0
00FCF6  5880E0     SUBB W1, #0x0, W1
00FCF8  500FF5     SUB W0, #0x15, [W15]
00FCFA  588FE0     SUBB W1, #0x0, [W15]
00FCFC  3E0121     BRA GTU, 0xFF40
00FCFE  016000     BRA W0
00FD00  3700AF     BRA 0xFE60
00FD02  37008B     BRA 0xFE1A
00FD04  370103     BRA 0xFF0C
00FD06  37011C     BRA 0xFF40
00FD08  37011B     BRA 0xFF40
00FD0A  37011A     BRA 0xFF40
00FD0C  370119     BRA 0xFF40
00FD0E  370118     BRA 0xFF40
00FD10  370117     BRA 0xFF40
00FD12  370116     BRA 0xFF40
00FD14  370115     BRA 0xFF40
00FD16  37000D     BRA 0xFD32
00FD18  37005D     BRA 0xFDD4
00FD1A  37010D     BRA 0xFF36
00FD1C  370111     BRA 0xFF40
00FD1E  370110     BRA 0xFF40
00FD20  370005     BRA 0xFD2C
00FD22  37010E     BRA 0xFF40
00FD24  37010D     BRA 0xFF40
00FD26  3700E1     BRA 0xFEEA
00FD28  3700C1     BRA 0xFEAC
00FD2A  3700CD     BRA 0xFEC6
00FD2C  4581E3     ADD W11, #0x3, W3
00FD2E  EB0200     CLR W4
00FD30  37006F     BRA 0xFE10
419:                                       
420:                       case HCI_EVENT_COMMAND_COMPLETE:
421:                           // get num cmd packets
422:                           // log_info("HCI_EVENT_COMMAND_COMPLETE cmds old %u - new %u\n", hci_stack.num_cmd_packets, packet[2]);
423:                           hci_stack.num_cmd_packets = packet[2];
00FD32  21F4A0     MOV #0x1F4A, W0
00FD34  9040AB     MOV.B [W11+2], W1
00FD36  784801     MOV.B W1, [W0]
424:                           
425:                           if (COMMAND_COMPLETE_EVENT(packet, hci_read_buffer_size)){
00FD38  B3C0E2     MOV #0xE, W2
00FD3A  114F9B     SUBR.B W2, [W11], [W15]
00FD3C  3A0101     BRA NZ, 0xFF40
00FD3E  458463     ADD W11, #0x3, W8
00FD40  4584E4     ADD W11, #0x4, W9
00FD42  FB8018     ZE [W8], W0
00FD44  FB8099     ZE [W9], W1
00FD46  DD08C8     SL W1, #8, W1
00FD48  700001     IOR W0, W1, W0
00FD4A  2EA1C1     MOV #0xEA1C, W1
00FD4C  500F91     SUB W0, [W1], [W15]
00FD4E  3A0025     BRA NZ, 0xFD9A
426:                               // from offset 5
427:                               // status 
428:                               // "The HC_ACL_Data_Packet_Length return parameter will be used to determine the size of the L2CAP segments contained in ACL Data Packets"
429:                               hci_stack.acl_data_packet_length = READ_BT_16(packet, 6);
00FD50  9040EB     MOV.B [W11+6], W1
00FD52  FB8081     ZE W1, W1
00FD54  90407B     MOV.B [W11+7], W0
00FD56  DD0048     SL W0, #8, W0
00FD58  708080     IOR W1, W0, W1
00FD5A  88FA61     MOV W1, adb_state
430:                               // ignore: SCO data packet len (8)
431:                               hci_stack.total_num_acl_packets  = packet[9];
00FD5C  21F4B0     MOV #0x1F4B, W0
00FD5E  90489B     MOV.B [W11+9], W1
00FD60  784801     MOV.B W1, [W0]
432:                               // ignore: total num SCO packets
433:                               if (hci_stack.state == HCI_STATE_INITIALIZING){
00FD62  21F540     MOV #0x1F54, W0
00FD64  200012     MOV #0x1, W2
00FD66  110F90     SUBR W2, [W0], [W15]
00FD68  3A0018     BRA NZ, 0xFD9A
434:                                   // determine usable ACL payload size
435:                                   if (HCI_ACL_PAYLOAD_SIZE < hci_stack.acl_data_packet_length){
00FD6A  200FC1     MOV #0xFC, W1
00FD6C  21F4C0     MOV #0x1F4C, W0
00FD6E  108F90     SUBR W1, [W0], [W15]
00FD70  360001     BRA LEU, 0xFD74
436:                                       hci_stack.acl_data_packet_length = HCI_ACL_PAYLOAD_SIZE;
00FD72  88FA61     MOV W1, adb_state
437:                                   }
438:                                   // determine usable ACL packet types
439:                                   hci_stack.packet_types = hci_acl_packet_types_for_buffer_size(hci_stack.acl_data_packet_length);
00FD74  80FA64     MOV adb_state, W4
00FD76  EB0180     CLR W3
00FD78  780083     MOV W3, W1
00FD7A  2EDDA2     MOV #0xEDDA, W2
00FD7C  200015     MOV #0x1, W5
00FD94  233060     MOV #0x3306, W0
00FD96  698000     XOR W3, W0, W0
00FD98  88FA70     MOV W0, pDeviceDescriptor
440:                                   
441:                                   log_info("hci_read_buffer_size: used size %u, count %u, packet types %04x\n",
442:                                            hci_stack.acl_data_packet_length, hci_stack.total_num_acl_packets, hci_stack.packet_types); 
443:                               }
444:                           }
445:                           // Dump local address
446:                           if (COMMAND_COMPLETE_EVENT(packet, hci_read_bd_addr)) {
00FD9A  B3C0E0     MOV #0xE, W0
00FD9C  104F9B     SUBR.B W0, [W11], [W15]
00FD9E  3A00D0     BRA NZ, 0xFF40
00FDA0  FB8018     ZE [W8], W0
00FDA2  FB8099     ZE [W9], W1
00FDA4  DD08C8     SL W1, #8, W1
00FDA6  700001     IOR W0, W1, W0
00FDA8  2EA181     MOV #0xEA18, W1
00FDAA  500F91     SUB W0, [W1], [W15]
00FDAC  3A0004     BRA NZ, 0xFDB6
447:                               bd_addr_t addr;
448:                               bt_flip_addr(addr, &packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE + 1]);
00FDAE  4580E6     ADD W11, #0x6, W1
00FDB0  578072     SUB W15, #0x12, W0
00FDB2  02616A     CALL bt_flip_addr
00FDB4  000001     NOP
449:                               log_info("Local Address, Status: 0x%02x: Addr: %s\n",
450:                                   packet[OFFSET_OF_DATA_IN_COMMAND_COMPLETE], bd_addr_to_str(addr));
451:                           }
452:                           if (COMMAND_COMPLETE_EVENT(packet, hci_write_scan_enable)){
00FDB6  B3C0E1     MOV #0xE, W1
00FDB8  10CF9B     SUBR.B W1, [W11], [W15]
00FDBA  3A00C2     BRA NZ, 0xFF40
00FDBC  FB8018     ZE [W8], W0
00FDBE  FB8099     ZE [W9], W1
00FDC0  DD08C8     SL W1, #8, W1
00FDC2  700001     IOR W0, W1, W0
00FDC4  2EA6A1     MOV #0xEA6A, W1
00FDC6  500F91     SUB W0, [W1], [W15]
00FDC8  3A00BB     BRA NZ, 0xFF40
453:                               hci_emit_discoverable_enabled(hci_stack.discoverable);
00FDCA  21F580     MOV #0x1F58, W0
00FDCC  784010     MOV.B [W0], W0
00FDCE  025AC8     CALL hci_emit_discoverable_enabled
00FDD0  000001     NOP
00FDD2  3700B6     BRA 0xFF40
454:                           }
455:                           break;
456:                           
457:                       case HCI_EVENT_COMMAND_STATUS:
458:                           // get num cmd packets
459:                           // log_info("HCI_EVENT_COMMAND_STATUS cmds - old %u - new %u\n", hci_stack.num_cmd_packets, packet[3]);
460:                           hci_stack.num_cmd_packets = packet[3];
00FDD4  21F4A0     MOV #0x1F4A, W0
00FDD6  90413B     MOV.B [W11+3], W2
00FDD8  784802     MOV.B W2, [W0]
00FDDA  3700B2     BRA 0xFF40
461:                           break;
462:                           
463:                       case HCI_EVENT_NUMBER_OF_COMPLETED_PACKETS:
464:                           for (i=0; i<packet[2];i++){
00FE0C  E80204     INC W4, W4
00FE0E  E88183     INC2 W3, W3
00FE10  90402B     MOV.B [W11+2], W0
00FE12  FB8100     ZE W0, W2
00FE14  520F82     SUB W4, W2, [W15]
00FE16  35FFE2     BRA LT, 0xFDDC
00FE18  370093     BRA 0xFF40
465:                               handle = READ_BT_16(packet, 3 + 2*i);
00FDDC  FB8093     ZE [W3], W1
00FDDE  904013     MOV.B [W3+1], W0
00FDE0  DD0048     SL W0, #8, W0
00FDE2  708280     IOR W1, W0, W5
466:                               uint16_t num_packets = READ_BT_16(packet, 3 + packet[2]*2 + 2*i);
00FDE4  410004     ADD W2, W4, W0
00FDE6  400000     ADD W0, W0, W0
00FDE8  458000     ADD W11, W0, W0
00FDEA  9040B0     MOV.B [W0+3], W1
00FDEC  FB8081     ZE W1, W1
00FDEE  904040     MOV.B [W0+4], W0
00FDF0  DD0048     SL W0, #8, W0
00FDF2  708080     IOR W1, W0, W1
467:                               conn = connection_for_handle(handle);
468:                               if (!conn){
469:                                   log_error("hci_number_completed_packet lists unused con handle %u\n", handle);
470:                                   continue;
471:                               }
472:                               conn->num_acl_packets_sent -= num_packets;
00FE06  925862     MOV.B [W2+286], W0
00FE08  504001     SUB.B W0, W1, W0
00FE0A  9A5960     MOV.B W0, [W2+286]
473:                               // log_info("hci_number_completed_packet %u processed for handle %u, outstanding %u\n", num_packets, handle, conn->num_acl_packets_sent);
474:                           }
475:                           break;
476:                           
477:                       case HCI_EVENT_CONNECTION_REQUEST:
478:                           bt_flip_addr(addr, &packet[2]);
00FE1A  E8808B     INC2 W11, W1
00FE1C  578078     SUB W15, #0x18, W0
00FE1E  02616A     CALL bt_flip_addr
00FE20  000001     NOP
479:                           // TODO: eval COD 8-10
480:                           link_type = packet[11];
481:                           log_info("Connection_incoming: %s, type %u\n", bd_addr_to_str(addr), link_type);
482:                           if (link_type == 1) { // ACL
00FE22  90483B     MOV.B [W11+11], W0
00FE26  504FE1     SUB.B W0, #0x1, [W15]
00FE28  3A0013     BRA NZ, 0xFE50
483:                               conn = connection_for_address(addr);
00FE2A  578078     SUB W15, #0x18, W0
00FE2C  025AA2     CALL connection_for_address
00FE2E  000001     NOP
00FE30  780080     MOV W0, W1
484:                               if (!conn) {
00FE32  E00000     CP0 W0
00FE34  3A0008     BRA NZ, 0xFE46
485:                                   conn = create_connection_for_addr(addr);
00FE36  578078     SUB W15, #0x18, W0
00FE38  024DE0     CALL create_connection_for_addr
00FE3A  000001     NOP
00FE3C  780080     MOV W0, W1
486:                               }
487:                               if (!conn) {
00FE3E  E00000     CP0 W0
00FE40  3A0002     BRA NZ, 0xFE46
488:                                   // CONNECTION REJECTED DUE TO LIMITED RESOURCES (0X0D)
489:                                   hci_stack.decline_reason = 0x0d;
00FE42  B3C0D1     MOV #0xD, W1
00FE44  370005     BRA 0xFE50
490:                                   BD_ADDR_COPY(hci_stack.decline_addr, addr);
491:                                   break;
492:                               }
493:                               conn->state = RECEIVED_CONNECTION_REQUEST;
00FE46  200020     MOV #0x2, W0
00FE48  9800E0     MOV W0, [W1+12]
494:                               hci_run();
00FE4A  0218A0     CALL hci_run
00FE4C  000001     NOP
00FE4E  370078     BRA 0xFF40
495:                           } else {
496:                               // SYNCHRONOUS CONNECTION LIMIT TO A DEVICE EXCEEDED (0X0A)
497:                               hci_stack.decline_reason = 0x0a;
00FE24  B3C0A1     MOV #0xA, W1
00FE50  21F5B0     MOV #0x1F5B, W0
00FE52  784801     MOV.B W1, [W0]
498:                               BD_ADDR_COPY(hci_stack.decline_addr, addr);
00FE54  578078     SUB W15, #0x18, W0
00FE56  21F5C1     MOV #0x1F5C, W1
00FE58  090005     REPEAT #0x5
00FE5A  7858B0     MOV.B [W0++], [W1++]
00FE5C  B10060     SUB #0x6, W0
00FE5E  370070     BRA 0xFF40
499:                           }
500:                           break;
501:                           
502:                       case HCI_EVENT_CONNECTION_COMPLETE:
503:                           // Connection management
504:                           bt_flip_addr(addr, &packet[5]);
00FE60  4580E5     ADD W11, #0x5, W1
00FE62  578078     SUB W15, #0x18, W0
00FE64  02616A     CALL bt_flip_addr
00FE66  000001     NOP
505:                           log_info("Connection_complete (status=%u) %s\n", packet[2], bd_addr_to_str(addr));
506:                           conn = connection_for_address(addr);
00FE68  578078     SUB W15, #0x18, W0
00FE6A  025AA2     CALL connection_for_address
00FE6C  000001     NOP
00FE6E  780400     MOV W0, W8
507:                           if (conn) {
00FE70  E00000     CP0 W0
00FE72  320066     BRA Z, 0xFF40
508:                               if (!packet[2]){
00FE74  E8848B     INC2 W11, W9
00FE76  E00419     CP0.B [W9]
00FE78  3A000B     BRA NZ, 0xFE90
509:                                   conn->state = OPEN;
00FE7A  200050     MOV #0x5, W0
00FE7C  980460     MOV W0, [W8+12]
510:                                   conn->con_handle = READ_BT_16(packet, 3);
00FE7E  9040BB     MOV.B [W11+3], W1
00FE80  FB8081     ZE W1, W1
00FE82  90404B     MOV.B [W11+4], W0
00FE84  DD0048     SL W0, #8, W0
00FE86  708080     IOR W1, W0, W1
00FE88  980451     MOV W1, [W8+10]
511:                                   
512:               #ifdef HAVE_TICK
513:                                   // restart timer
514:                                   run_loop_set_timer(&conn->timeout, HCI_CONNECTION_TIMEOUT_MS);
515:                                   run_loop_add_timer(&conn->timeout);
516:               #endif
517:                                   
518:                                   log_info("New connection: handle %u, %s\n", conn->con_handle, bd_addr_to_str(conn->address));
519:                                   
520:                                   hci_emit_nr_connections_changed();
00FE8A  025552     CALL hci_emit_nr_connections_changed
00FE8C  000001     NOP
00FE8E  370058     BRA 0xFF40
521:                               } else {
522:                                   // connection failed, remove entry
523:                                   linked_list_remove(&hci_stack.connections, (linked_item_t *) conn);
00FE90  780080     MOV W0, W1
00FE92  21E460     MOV #0x1E46, W0
00FE94  0263FC     CALL linked_list_remove
00FE96  000001     NOP
524:                                   btstack_memory_hci_connection_free( conn );
00FE98  780008     MOV W8, W0
00FE9A  026674     CALL btstack_memory_hci_connection_free
00FE9C  000001     NOP
525:                                   
526:                                   // if authentication error, also delete link key
527:                                   if (packet[2] == 0x05) {
00FE9E  B3C050     MOV #0x5, W0
00FEA0  104F99     SUBR.B W0, [W9], [W15]
00FEA2  3A004E     BRA NZ, 0xFF40
528:                                       hci_drop_link_key_for_bd_addr(&addr);
00FEA4  578078     SUB W15, #0x18, W0
00FEA6  0265A6     CALL hci_drop_link_key_for_bd_addr
00FEA8  000001     NOP
00FEAA  37004A     BRA 0xFF40
529:                                   }
530:                               }
531:                           }
532:                           break;
533:               
534:                       case HCI_EVENT_LINK_KEY_REQUEST:
535:                           log_info("HCI_EVENT_LINK_KEY_REQUEST\n");
536:                           hci_add_connection_flags_for_flipped_bd_addr(&packet[2], RECV_LINK_KEY_REQUEST);
00FEAC  E8840B     INC2 W11, W8
00FEAE  200011     MOV #0x1, W1
00FEB0  780008     MOV W8, W0
00FEB2  025B14     CALL hci_add_connection_flags_for_flipped_bd_addr
00FEB4  000001     NOP
537:                           if (!hci_stack.remote_device_db) break;
00FEB6  21F520     MOV #0x1F52, W0
00FEB8  E00010     CP0 [W0]
00FEBA  320042     BRA Z, 0xFF40
538:                           hci_add_connection_flags_for_flipped_bd_addr(&packet[2], HANDLE_LINK_KEY_REQUEST);
00FEBC  200021     MOV #0x2, W1
00FEBE  780008     MOV W8, W0
00FEC0  025B14     CALL hci_add_connection_flags_for_flipped_bd_addr
00FEC2  000001     NOP
00FEC4  3700B8     BRA 0x10036
539:                           hci_run();
540:                           // request handled by hci_run() as HANDLE_LINK_KEY_REQUEST gets set
541:                           return;
542:                           
543:                       case HCI_EVENT_LINK_KEY_NOTIFICATION:
544:                           hci_add_connection_flags_for_flipped_bd_addr(&packet[2], RECV_LINK_KEY_NOTIFICATION);
00FEC6  E8840B     INC2 W11, W8
00FEC8  200101     MOV #0x10, W1
00FECA  780008     MOV W8, W0
00FECC  025B14     CALL hci_add_connection_flags_for_flipped_bd_addr
00FECE  000001     NOP
545:                           if (!hci_stack.remote_device_db) break;
00FED0  21F520     MOV #0x1F52, W0
00FED2  E00010     CP0 [W0]
00FED4  320035     BRA Z, 0xFF40
546:                           bt_flip_addr(addr, &packet[2]);
00FED6  780088     MOV W8, W1
00FED8  578078     SUB W15, #0x18, W0
00FEDA  02616A     CALL bt_flip_addr
00FEDC  000001     NOP
547:                           hci_stack.remote_device_db->put_link_key(&addr, (link_key_t *) &packet[8]);
00FEDE  4580E8     ADD W11, #0x8, W1
00FEE0  80FA90     MOV DUMPSYS_ERROR, W0
00FEE2  900130     MOV [W0+6], W2
00FEE4  578078     SUB W15, #0x18, W0
00FEE6  010002     CALL W2
00FEE8  37002B     BRA 0xFF40
548:                           // still forward event to allow dismiss of pairing dialog
549:                           break;
550:                           
551:                       case HCI_EVENT_PIN_CODE_REQUEST:
552:                           hci_add_connection_flags_for_flipped_bd_addr(&packet[2], RECV_PIN_CODE_REQUEST);
00FEEA  E8840B     INC2 W11, W8
00FEEC  200201     MOV #0x20, W1
00FEEE  780008     MOV W8, W0
00FEF0  025B14     CALL hci_add_connection_flags_for_flipped_bd_addr
00FEF2  000001     NOP
553:                           // PIN CODE REQUEST means the link key request didn't succee -> delete stored link key
554:                           if (!hci_stack.remote_device_db) break;
00FEF4  21F520     MOV #0x1F52, W0
00FEF6  E00010     CP0 [W0]
00FEF8  320023     BRA Z, 0xFF40
555:                           bt_flip_addr(addr, &packet[2]);
00FEFA  780088     MOV W8, W1
00FEFC  578078     SUB W15, #0x18, W0
00FEFE  02616A     CALL bt_flip_addr
00FF00  000001     NOP
556:                           hci_stack.remote_device_db->delete_link_key(&addr);
00FF02  80FA90     MOV DUMPSYS_ERROR, W0
00FF04  9000C0     MOV [W0+8], W1
00FF06  578078     SUB W15, #0x18, W0
00FF08  010001     CALL W1
00FF0A  37001A     BRA 0xFF40
557:                           break;
558:                           
559:               #ifndef EMBEDDED
560:                       case HCI_EVENT_REMOTE_NAME_REQUEST_COMPLETE:
561:                           if (!hci_stack.remote_device_db) break;
562:                           if (packet[2]) break; // status not ok
563:                           bt_flip_addr(addr, &packet[3]);
564:                           // fix for invalid remote names - terminate on 0xff
565:                           for (i=0; i<248;i++){
566:                               if (packet[9+i] == 0xff){
567:                                   packet[9+i] = 0;
568:                                   break;
569:                               }
570:                           }
571:                           memset(&device_name, 0, sizeof(device_name_t));
572:                           strncpy((char*) device_name, (char*) &packet[9], 248);
573:                           hci_stack.remote_device_db->put_name(&addr, &device_name);
574:                           break;
575:                           
576:                       case HCI_EVENT_INQUIRY_RESULT:
577:                       case HCI_EVENT_INQUIRY_RESULT_WITH_RSSI:
578:                           if (!hci_stack.remote_device_db) break;
579:                           // first send inq result packet
580:                           hci_stack.packet_handler(HCI_EVENT_PACKET, packet, size);
581:                           // then send cached remote names
582:                           for (i=0; i<packet[2];i++){
583:                               bt_flip_addr(addr, &packet[3+i*6]);
584:                               if (hci_stack.remote_device_db->get_name(&addr, &device_name)){
585:                                   hci_emit_remote_name_cached(&addr, &device_name);
586:                               }
587:                           }
588:                           return;
589:               #endif
590:                           
591:                       case HCI_EVENT_DISCONNECTION_COMPLETE:
592:                           if (!packet[2]){
00FF0C  90402B     MOV.B [W11+2], W0
00FF0E  E00400     CP0.B W0
00FF10  3A0017     BRA NZ, 0xFF40
593:                               handle = READ_BT_16(packet, 3);
00FF12  9040BB     MOV.B [W11+3], W1
00FF14  FB8081     ZE W1, W1
00FF16  90404B     MOV.B [W11+4], W0
00FF18  DD0048     SL W0, #8, W0
00FF1A  708080     IOR W1, W0, W1
594:                               hci_connection_t * conn = connection_for_handle(handle);
595:                               if (conn) {
596:                                   hci_shutdown_connection(conn);
00FF2E  780002     MOV W2, W0
00FF30  025D32     CALL hci_shutdown_connection
00FF32  000001     NOP
00FF34  370005     BRA 0xFF40
597:                               }
598:                           }
599:                           break;
600:                           
601:                       case HCI_EVENT_HARDWARE_ERROR:
602:                           if(hci_stack.control->hw_error){
00FF36  80F220     MOV 0x1E44, W0
00FF38  900810     MOV [W0+18], W0
00FF3A  E00000     CP0 W0
00FF3C  320001     BRA Z, 0xFF40
603:                               (*hci_stack.control->hw_error)();
00FF3E  010000     CALL W0
604:                           }
605:                           break;
606:               
607:               #ifdef HAVE_BLE
608:                       case HCI_EVENT_LE_META:
609:                           switch (packet[2]) {
610:                               case HCI_SUBEVENT_LE_CONNECTION_COMPLETE:
611:                                   // Connection management
612:                                   bt_flip_addr(addr, &packet[8]);
613:                                   log_info("LE Connection_complete (status=%u) %s\n", packet[3], bd_addr_to_str(addr));
614:                                   // LE connections are auto-accepted, so just create a connection if there isn't one already
615:                                   conn = connection_for_address(addr);
616:                                   if (packet[3]){
617:                                       if (conn){
618:                                           // outgoing connection failed, remove entry
619:                                           linked_list_remove(&hci_stack.connections, (linked_item_t *) conn);
620:                                           btstack_memory_hci_connection_free( conn );
621:                                           
622:                                       }
623:                                       // if authentication error, also delete link key
624:                                       if (packet[3] == 0x05) {
625:                                           hci_drop_link_key_for_bd_addr(&addr);
626:                                       }
627:                                       break;
628:                                   }
629:                                   if (!conn){
630:                                       conn = create_connection_for_addr(addr);
631:                                   }
632:                                   if (!conn){
633:                                       // no memory
634:                                       break;
635:                                   }
636:                                   
637:                                   conn->state = OPEN;
638:                                   conn->con_handle = READ_BT_16(packet, 4);
639:                                   
640:                                   // TODO: store - role, peer address type, conn_interval, conn_latency, supervision timeout, master clock
641:               
642:                                   // restart timer
643:                                   // run_loop_set_timer(&conn->timeout, HCI_CONNECTION_TIMEOUT_MS);
644:                                   // run_loop_add_timer(&conn->timeout);
645:                                   
646:                                   log_info("New connection: handle %u, %s\n", conn->con_handle, bd_addr_to_str(conn->address));
647:                                   
648:                                   hci_emit_nr_connections_changed();
649:                                   break;
650:                                   
651:                               default:
652:                                   break;
653:                           }
654:                           break;
655:               #endif            
656:                           
657:                       default:
658:                           break;
659:                   }
660:               
661:                   // handle BT initialization
662:                   if (hci_stack.state == HCI_STATE_INITIALIZING){
00FF40  21F540     MOV #0x1F54, W0
00FF42  200011     MOV #0x1, W1
00FF44  108F90     SUBR W1, [W0], [W15]
00FF46  3A0008     BRA NZ, 0xFF58
663:                       // handle H4 synchronization loss on restart
664:                       // if (hci_stack.substate == 1 && packet[0] == HCI_EVENT_HARDWARE_ERROR){
665:                       //    hci_stack.substate = 0;
666:                       // }
667:                       // handle normal init sequence
668:                       if (hci_stack.substate % 2){
00FF48  21F561     MOV #0x1F56, W1
00FF4A  784011     MOV.B [W1], W0
00FF4C  A30800     BTST.Z W0, #0
00FF4E  320004     BRA Z, 0xFF58
669:                           // odd: waiting for event
670:                           if (packet[0] == HCI_EVENT_COMMAND_COMPLETE){
00FF50  B3C0E2     MOV #0xE, W2
00FF52  114F9B     SUBR.B W2, [W11], [W15]
00FF54  3A0001     BRA NZ, 0xFF58
671:                               hci_stack.substate++;
00FF56  E84880     INC.B W0, [W1]
672:                           }
673:                       }
674:                   }
675:                   
676:                   // help with BT sleep
677:                   if (hci_stack.state == HCI_STATE_FALLING_ASLEEP
00FF58  21F540     MOV #0x1F54, W0
00FF5A  200051     MOV #0x5, W1
00FF5C  108F90     SUBR W1, [W0], [W15]
00FF5E  3A0011     BRA NZ, 0xFF82
00FF60  21F562     MOV #0x1F56, W2
00FF62  B3C010     MOV #0x1, W0
00FF64  104F92     SUBR.B W0, [W2], [W15]
00FF66  3A000D     BRA NZ, 0xFF82
00FF68  B3C0E1     MOV #0xE, W1
00FF6A  10CF9B     SUBR.B W1, [W11], [W15]
00FF6C  3A000A     BRA NZ, 0xFF82
00FF6E  90403B     MOV.B [W11+3], W0
00FF70  FB8000     ZE W0, W0
00FF72  9040CB     MOV.B [W11+4], W1
00FF74  DD08C8     SL W1, #8, W1
00FF76  700001     IOR W0, W1, W0
00FF78  2EA6A1     MOV #0xEA6A, W1
00FF7A  500F91     SUB W0, [W1], [W15]
00FF7C  3A0002     BRA NZ, 0xFF82
678:                       && hci_stack.substate == 1
679:                       && COMMAND_COMPLETE_EVENT(packet, hci_write_scan_enable)){
680:                       hci_stack.substate++;
00FF7E  B3C020     MOV #0x2, W0
00FF80  784900     MOV.B W0, [W2]
681:                   }
682:                   
683:                   hci_stack.packet_handler(HCI_EVENT_PACKET, packet, size);
00FF82  78010A     MOV W10, W2
00FF84  78008B     MOV W11, W1
00FF86  B3C040     MOV #0x4, W0
00FF88  370046     BRA 0x10016
684:               	
685:               	// execute main loop
686:               	hci_run();
687:               }
688:               
689:               void packet_handler(uint8_t packet_type, uint8_t *packet, uint16_t size){
690:                   switch (packet_type) {
00FCE6  504FE2     SUB.B W0, #0x2, [W15]
00FCE8  320150     BRA Z, 0xFF8A
00FCEA  504FE4     SUB.B W0, #0x4, [W15]
00FCEC  3A01A6     BRA NZ, 0x1003A
691:                       case HCI_EVENT_PACKET:
692:                           event_handler(packet, size);
693:                           break;
694:                       case HCI_ACL_DATA_PACKET:
695:                           acl_handler(packet, size);
696:                           break;
697:                       default:
698:                           break;
699:                   }
700:               }
701:               
702:               /** Register HCI packet handlers */
703:               void hci_register_packet_handler(void (*handler)(uint8_t packet_type, uint8_t *packet, uint16_t size)){
704:                   hci_stack.packet_handler = handler;
016758  88FA80     MOV W0, pCurrentConfigurationDescriptor
705:               }
706:               
707:               void hci_init(hci_transport_t *transport, void *config, bt_control_t *control, remote_device_db_t const* remote_device_db){
708:                   
709:                   // reference to use transport layer implementation
710:                   hci_stack.hci_transport = transport;
014FD4  88F200     MOV W0, hci_stack
711:                   
712:                   // references to used control implementation
713:                   hci_stack.control = control;
014FD6  88F222     MOV W2, 0x1E44
714:                   
715:                   // reference to used config
716:                   hci_stack.config = config;
014FD8  88F211     MOV W1, 0x1E42
717:                   
718:                   // no connections yet
719:                   hci_stack.connections = NULL;
014FDA  EB0400     CLR W8
014FDC  88F238     MOV W8, 0x1E46
720:                   hci_stack.discoverable = 0;
014FDE  21F580     MOV #0x1F58, W0
014FE0  784808     MOV.B W8, [W0]
721:                   hci_stack.connectable = 0;
014FE2  21F590     MOV #0x1F59, W0
014FE4  784808     MOV.B W8, [W0]
722:                   
723:                   // no pending cmds
724:                   hci_stack.decline_reason = 0;
014FE6  21F5B0     MOV #0x1F5B, W0
014FE8  784808     MOV.B W8, [W0]
725:                   hci_stack.new_scan_enable_value = 0xff;
014FEA  21F5A0     MOV #0x1F5A, W0
014FEC  EBC800     SETM.B [W0]
726:                   
727:                   // higher level handler
728:                   hci_stack.packet_handler = dummy_handler;
014FEE  253140     MOV #0x5314, W0
014FF0  88FA80     MOV W0, pCurrentConfigurationDescriptor
729:               
730:                   // store and open remote device db
731:                   hci_stack.remote_device_db = remote_device_db;
014FF2  88FA93     MOV W3, DUMPSYS_ERROR
732:                   if (hci_stack.remote_device_db) {
014FF4  E00003     CP0 W3
014FF6  320002     BRA Z, 0x14FFC
733:                       hci_stack.remote_device_db->open();
014FF8  780013     MOV [W3], W0
014FFA  010000     CALL W0
734:                   }
735:                   
736:                   // max acl payload size defined in config.h
737:                   hci_stack.acl_data_packet_length = HCI_ACL_PAYLOAD_SIZE;
014FFC  200FC0     MOV #0xFC, W0
014FFE  88FA60     MOV W0, adb_state
738:                   
739:                   // register packet handlers with transport
740:                   transport->register_packet_handler(&packet_handler);
015000  9000B9     MOV [W9+6], W1
015002  2FCDA0     MOV #0xFCDA, W0
015004  010001     CALL W1
741:               
742:                   hci_stack.state = HCI_STATE_OFF;
015006  88FAA8     MOV W8, DUMPSYS_ERROR
743:               }
744:               
745:               void hci_close(){
746:                   // close remote device db
747:                   if (hci_stack.remote_device_db) {
01619E  80FA90     MOV DUMPSYS_ERROR, W0
0161A0  E00000     CP0 W0
0161A2  320005     BRA Z, 0x161AE
748:                       hci_stack.remote_device_db->close();
0161A4  900010     MOV [W0+2], W0
0161A6  010000     CALL W0
0161A8  370002     BRA 0x161AE
749:                   }
750:                   while (hci_stack.connections) {
0161AE  80F230     MOV 0x1E46, W0
0161B0  E00000     CP0 W0
0161B2  3AFFFB     BRA NZ, 0x161AA
751:                       hci_shutdown_connection((hci_connection_t *) hci_stack.connections);
0161AA  025D32     CALL hci_shutdown_connection
0161AC  000001     NOP
752:               }
753:                   hci_power_control(HCI_POWER_OFF);
0161B4  042E9A     GOTO hci_power_control
0161B6  000001     NOP
754:               }
755:               
756:               // State-Module-Driver overview
757:               // state                    module  low-level 
758:               // HCI_STATE_OFF             off      close
759:               // HCI_STATE_INITIALIZING,   on       open
760:               // HCI_STATE_WORKING,        on       open
761:               // HCI_STATE_HALTING,        on       open
762:               // HCI_STATE_SLEEPING,    off/sleep   close
763:               // HCI_STATE_FALLING_ASLEEP  on       open
764:               
765:               static int hci_power_control_on(void){
766:                   
767:                   // power on
768:                   int err = 0;
769:                   if (hci_stack.control && hci_stack.control->on){
012EC0  80F220     MOV 0x1E44, W0
012EC2  E00000     CP0 W0
012EC4  320008     BRA Z, 0x12ED6
012EC6  780090     MOV [W0], W1
012EC8  E00001     CP0 W1
012ECA  320005     BRA Z, 0x12ED6
770:                       err = (*hci_stack.control->on)(hci_stack.config);
012ECC  80F210     MOV 0x1E42, W0
012ECE  010001     CALL W1
012ED0  780400     MOV W0, W8
771:                   }
772:                   if (err){
012ED2  E00000     CP0 W0
012ED4  3A000F     BRA NZ, 0x12EF4
773:                       log_error( "POWER_ON failed\n");
774:                       hci_emit_hci_open_failed();
775:                       return err;
776:                   }
777:                   
778:                   // open low-level device
779:                   err = hci_stack.hci_transport->open(hci_stack.config);
012ED6  80F200     MOV hci_stack, W0
012ED8  780090     MOV [W0], W1
012EDA  80F210     MOV 0x1E42, W0
012EDC  010001     CALL W1
012EDE  780400     MOV W0, W8
780:                   if (err){
012EE0  E00000     CP0 W0
012EE2  320043     BRA Z, 0x12F6A
781:                       log_error( "HCI_INIT failed, turning Bluetooth off again\n");
782:                       if (hci_stack.control && hci_stack.control->off){
012EE4  80F220     MOV 0x1E44, W0
012EE6  E00000     CP0 W0
012EE8  320005     BRA Z, 0x12EF4
012EEA  900090     MOV [W0+2], W1
012EEC  E00001     CP0 W1
012EEE  320002     BRA Z, 0x12EF4
783:                           (*hci_stack.control->off)(hci_stack.config);
012EF0  80F210     MOV 0x1E42, W0
012EF2  010001     CALL W1
784:                       }
785:                       hci_emit_hci_open_failed();
012EF4  025D10     CALL hci_emit_hci_open_failed
012EF6  000001     NOP
012EF8  370040     BRA 0x12F7A
786:                       return err;
787:                   }
788:                   return 0;
789:               }
790:               
791:               static void hci_power_control_off(void){
792:                   
793:                   log_info("hci_power_control_off\n");
794:               
795:                   // close low-level device
796:                   hci_stack.hci_transport->close(hci_stack.config);
015F3C  80F200     MOV hci_stack, W0
015F3E  900090     MOV [W0+2], W1
015F40  80F210     MOV 0x1E42, W0
015F42  010001     CALL W1
797:               
798:                   log_info("hci_power_control_off - hci_transport closed\n");
799:                   
800:                   // power off
801:                   if (hci_stack.control && hci_stack.control->off){
015F44  80F220     MOV 0x1E44, W0
015F46  E00000     CP0 W0
015F48  320005     BRA Z, 0x15F54
015F4A  900090     MOV [W0+2], W1
015F4C  E00001     CP0 W1
015F4E  320002     BRA Z, 0x15F54
802:                       (*hci_stack.control->off)(hci_stack.config);
015F50  80F210     MOV 0x1E42, W0
015F52  010001     CALL W1
803:                   }
804:                   
805:                   log_info("hci_power_control_off - control closed\n");
806:               
807:                   hci_stack.state = HCI_STATE_OFF;
015F54  21F540     MOV #0x1F54, W0
015F56  EB0800     CLR [W0]
808:               }
809:               
810:               static void hci_power_control_sleep(void){
811:                   
812:                   log_info("hci_power_control_sleep\n");
813:                   
814:               #if 0
815:                   // don't close serial port during sleep
816:                   
817:                   // close low-level device
818:                   hci_stack.hci_transport->close(hci_stack.config);
819:               #endif
820:                   
821:                   // sleep mode
822:                   if (hci_stack.control && hci_stack.control->sleep){
0162F4  80F220     MOV 0x1E44, W0
0162F6  E00000     CP0 W0
0162F8  320005     BRA Z, 0x16304
0162FA  9000A0     MOV [W0+4], W1
0162FC  E00001     CP0 W1
0162FE  320002     BRA Z, 0x16304
823:                       (*hci_stack.control->sleep)(hci_stack.config);
016300  80F210     MOV 0x1E42, W0
016302  010001     CALL W1
824:                   }
825:                   
826:                   hci_stack.state = HCI_STATE_SLEEPING;
016304  200040     MOV #0x4, W0
016306  88FAA0     MOV W0, DUMPSYS_ERROR
827:               }
828:               
829:               static int hci_power_control_wake(void){
830:                   
831:                   log_info("hci_power_control_wake\n");
832:               
833:                   // wake on
834:                   if (hci_stack.control && hci_stack.control->wake){
012F3A  80F220     MOV 0x1E44, W0
012F3C  E00000     CP0 W0
012F3E  320005     BRA Z, 0x12F4A
012F40  9000B0     MOV [W0+6], W1
012F42  E00001     CP0 W1
012F44  320002     BRA Z, 0x12F4A
835:                       (*hci_stack.control->wake)(hci_stack.config);
012F46  80F210     MOV 0x1E42, W0
012F48  010001     CALL W1
836:                   }
837:                   
838:               #if 0
839:                   // open low-level device
840:                   int err = hci_stack.hci_transport->open(hci_stack.config);
841:                   if (err){
842:                       log_error( "HCI_INIT failed, turning Bluetooth off again\n");
843:                       if (hci_stack.control && hci_stack.control->off){
844:                           (*hci_stack.control->off)(hci_stack.config);
845:                       }
846:                       hci_emit_hci_open_failed();
847:                       return err;
848:                   }
849:               #endif
850:                   
851:                   return 0;
852:               }
853:               
854:               
855:               int hci_power_control(HCI_POWER_MODE power_mode){
856:                   
857:                   log_info("hci_power_control: %u, current mode %u\n", power_mode, hci_stack.state);
858:                   
859:                   int err = 0;
860:                   switch (hci_stack.state){
012E9E  80FAA0     MOV DUMPSYS_ERROR, W0
012EA0  500FE2     SUB W0, #0x2, [W15]
012EA2  320036     BRA Z, 0x12F10
012EA4  3E0005     BRA GTU, 0x12EB0
012EA6  E00000     CP0 W0
012EA8  320009     BRA Z, 0x12EBC
012EAA  500FE1     SUB W0, #0x1, [W15]
012EAC  3A0058     BRA NZ, 0x12F5E
012EAE  370025     BRA 0x12EFA
012EB0  500FE4     SUB W0, #0x4, [W15]
012EB2  32003F     BRA Z, 0x12F32
012EB4  390030     BRA NC, 0x12F16
012EB6  500FE5     SUB W0, #0x5, [W15]
012EB8  3A0052     BRA NZ, 0x12F5E
012EBA  370033     BRA 0x12F22
861:                           
862:                       case HCI_STATE_OFF:
863:                           switch (power_mode){
012EBC  508FE1     SUB W1, #0x1, [W15]
012EBE  3A004F     BRA NZ, 0x12F5E
864:                               case HCI_POWER_ON:
865:                                   err = hci_power_control_on();
866:                                   if (err) return err;
867:                                   // set up state machine
868:                                   hci_stack.num_cmd_packets = 1; // assume that one cmd can be sent
012F6A  B3C011     MOV #0x1, W1
012F6C  21F4A0     MOV #0x1F4A, W0
012F6E  784801     MOV.B W1, [W0]
869:                                   hci_stack.state = HCI_STATE_INITIALIZING;
012F70  200010     MOV #0x1, W0
012F72  88FAA0     MOV W0, DUMPSYS_ERROR
870:                                   hci_stack.substate = 0;
012F74  21F560     MOV #0x1F56, W0
012F76  784808     MOV.B W8, [W0]
012F78  37FFF2     BRA 0x12F5E
871:                                   break;
872:                               case HCI_POWER_OFF:
873:                                   // do nothing
874:                                   break;  
875:                               case HCI_POWER_SLEEP:
876:                                   // do nothing (with SLEEP == OFF)
877:                                   break;
878:                           }
879:                           break;
880:                           
881:                       case HCI_STATE_INITIALIZING:
882:                           switch (power_mode){
012EFA  E00001     CP0 W1
012EFC  320003     BRA Z, 0x12F04
012EFE  508FE2     SUB W1, #0x2, [W15]
012F00  3A002E     BRA NZ, 0x12F5E
012F02  370003     BRA 0x12F0A
883:                               case HCI_POWER_ON:
884:                                   // do nothing
885:                                   break;
886:                               case HCI_POWER_OFF:
887:                                   // no connections yet, just turn it off
888:                                   hci_power_control_off();
012F04  025F3C     CALL hci_power_control_off
012F06  000001     NOP
012F08  37002A     BRA 0x12F5E
889:                                   break;  
890:                               case HCI_POWER_SLEEP:
891:                                   // no connections yet, just turn it off
892:                                   hci_power_control_sleep();
012F0A  0262F4     CALL hci_power_control_sleep
012F0C  000001     NOP
012F0E  370027     BRA 0x12F5E
893:                                   break;
894:                           }
895:                           break;
896:                           
897:                       case HCI_STATE_WORKING:
898:                           switch (power_mode){
012F10  E00001     CP0 W1
012F12  320023     BRA Z, 0x12F5A
012F14  370002     BRA 0x12F1A
899:                               case HCI_POWER_ON:
900:                                   // do nothing
901:                                   break;
902:                               case HCI_POWER_OFF:
903:                                   // see hci_run
904:                                   hci_stack.state = HCI_STATE_HALTING;
905:                                   break;  
906:                               case HCI_POWER_SLEEP:
907:                                   // see hci_run
908:                                   hci_stack.state = HCI_STATE_FALLING_ASLEEP;
909:                                   hci_stack.substate = 0;
910:                                   break;
911:                           }
912:                           break;
913:                           
914:                       case HCI_STATE_HALTING:
915:                           switch (power_mode){
012F16  508FE1     SUB W1, #0x1, [W15]
012F18  32000A     BRA Z, 0x12F2E
012F1C  508FE2     SUB W1, #0x2, [W15]
012F1E  320019     BRA Z, 0x12F52
012F20  37001E     BRA 0x12F5E
916:                               case HCI_POWER_ON:
917:                                   // set up state machine
918:                                   hci_stack.state = HCI_STATE_INITIALIZING;
919:                                   hci_stack.substate = 0;
920:                                   break;
921:                               case HCI_POWER_OFF:
922:                                   // do nothing
923:                                   break;  
924:                               case HCI_POWER_SLEEP:
925:                                   // see hci_run
926:                                   hci_stack.state = HCI_STATE_FALLING_ASLEEP;
012F1A  200050     MOV #0x5, W0
927:                                   hci_stack.substate = 0;
928:                                   break;
929:                           }
930:                           break;
931:                           
932:                       case HCI_STATE_FALLING_ASLEEP:
933:                           switch (power_mode){
012F22  E00001     CP0 W1
012F24  32001A     BRA Z, 0x12F5A
012F26  508FE1     SUB W1, #0x1, [W15]
012F28  3A001A     BRA NZ, 0x12F5E
934:                               case HCI_POWER_ON:
935:               
936:               #if defined(USE_POWERMANAGEMENT) && defined(USE_BLUETOOL)
937:                                   // nothing to do, if H4 supports power management
938:                                   if (bt_control_iphone_power_management_enabled()){
939:                                       hci_stack.state = HCI_STATE_INITIALIZING;
940:                                       hci_stack.substate = 6;
941:                                       break;
942:                                   }
943:               #endif
944:                                   // set up state machine
945:                                   hci_stack.num_cmd_packets = 1; // assume that one cmd can be sent
012F2A  21F4A0     MOV #0x1F4A, W0
012F2C  784801     MOV.B W1, [W0]
946:                                   hci_stack.state = HCI_STATE_INITIALIZING;
012F2E  88FAA1     MOV W1, DUMPSYS_ERROR
012F30  370011     BRA 0x12F54
947:                                   hci_stack.substate = 0;
948:                                   break;
949:                               case HCI_POWER_OFF:
950:                                   // see hci_run
951:                                   hci_stack.state = HCI_STATE_HALTING;
952:                                   break;  
953:                               case HCI_POWER_SLEEP:
954:                                   // do nothing
955:                                   break;
956:                           }
957:                           break;
958:                           
959:                       case HCI_STATE_SLEEPING:
960:                           switch (power_mode){
012F32  E00001     CP0 W1
012F34  320012     BRA Z, 0x12F5A
012F36  508FE1     SUB W1, #0x1, [W15]
012F38  3A0012     BRA NZ, 0x12F5E
961:                               case HCI_POWER_ON:
962:                                   
963:               #if defined(USE_POWERMANAGEMENT) && defined(USE_BLUETOOL)
964:                                   // nothing to do, if H4 supports power management
965:                                   if (bt_control_iphone_power_management_enabled()){
966:                                       hci_stack.state = HCI_STATE_INITIALIZING;
967:                                       hci_stack.substate = 6;
968:                                       hci_update_scan_enable();
969:                                       break;
970:                                   }
971:               #endif
972:                                   err = hci_power_control_wake();
973:                                   if (err) return err;
974:                                   // set up state machine
975:                                   hci_stack.num_cmd_packets = 1; // assume that one cmd can be sent
012F4A  B3C011     MOV #0x1, W1
012F4C  21F4A0     MOV #0x1F4A, W0
012F4E  784801     MOV.B W1, [W0]
976:                                   hci_stack.state = HCI_STATE_INITIALIZING;
012F50  200010     MOV #0x1, W0
012F52  88FAA0     MOV W0, DUMPSYS_ERROR
977:                                   hci_stack.substate = 0;
012F54  21F560     MOV #0x1F56, W0
012F56  EB4800     CLR.B [W0]
012F58  370002     BRA 0x12F5E
978:                                   break;
979:                               case HCI_POWER_OFF:
980:                                   hci_stack.state = HCI_STATE_HALTING;
012F5A  200030     MOV #0x3, W0
012F5C  88FAA0     MOV W0, DUMPSYS_ERROR
981:                                   break;  
982:                               case HCI_POWER_SLEEP:
983:                                   // do nothing
984:                                   break;
985:                           }
986:                           break;
987:                   }
988:               
989:                   // create internal event
990:               	hci_emit_state();
012F5E  025A04     CALL hci_emit_state
012F60  000001     NOP
991:                   
992:               	// trigger next/first action
993:               	hci_run();
012F62  0218A0     CALL hci_run
012F64  000001     NOP
012F66  EB0400     CLR W8
012F68  370008     BRA 0x12F7A
994:               	
995:                   return 0;
996:               }
997:               
998:               static void hci_update_scan_enable(void){
999:                   // 2 = page scan, 1 = inq scan
1000:                  hci_stack.new_scan_enable_value  = hci_stack.connectable << 1 | hci_stack.discoverable;
016534  21F590     MOV #0x1F59, W0
016536  D04110     SL.B [W0], W2
016538  21F581     MOV #0x1F58, W1
01653A  21F5A0     MOV #0x1F5A, W0
01653C  714811     IOR.B W2, [W1], [W0]
1001:                  hci_run();
01653E  0418A0     GOTO hci_run
016540  000001     NOP
1002:              }
1003:              
1004:              void hci_discoverable_control(uint8_t enable){
01630A  E00400     CP0.B W0
01630C  320001     BRA Z, 0x16310
01630E  B3C010     MOV #0x1, W0
1005:                  if (enable) enable = 1; // normalize argument
1006:                  
1007:                  if (hci_stack.discoverable == enable){
016310  21F581     MOV #0x1F58, W1
016312  104F91     SUBR.B W0, [W1], [W15]
016314  3A0002     BRA NZ, 0x1631A
1008:                      hci_emit_discoverable_enabled(hci_stack.discoverable);
016316  045AC8     GOTO hci_emit_discoverable_enabled
016318  000001     NOP
1009:                      return;
1010:                  }
1011:              
1012:                  hci_stack.discoverable = enable;
01631A  784880     MOV.B W0, [W1]
1013:                  hci_update_scan_enable();
1014:              }
1015:              
1016:              void hci_connectable_control(uint8_t enable){
016428  E00400     CP0.B W0
01642A  320001     BRA Z, 0x1642E
01642C  B3C010     MOV #0x1, W0
1017:                  if (enable) enable = 1; // normalize argument
1018:                  
1019:                  // don't emit event
1020:                  if (hci_stack.connectable == enable) return;
01642E  21F591     MOV #0x1F59, W1
016430  104F91     SUBR.B W0, [W1], [W15]
016432  320003     BRA Z, 0x1643A
1021:              
1022:                  hci_stack.connectable = enable;
016434  784880     MOV.B W0, [W1]
1023:                  hci_update_scan_enable();
1024:              }
1025:              
1026:              void hci_run(){
1027:                      
1028:                  hci_connection_t * connection;
1029:                  linked_item_t * it;
1030:                  
1031:                  if (!hci_can_send_packet_now(HCI_COMMAND_DATA_PACKET)) return;
0118A4  B3C010     MOV #0x1, W0
0118A6  025714     CALL hci_can_send_packet_now
0118A8  000001     NOP
0118AA  E00000     CP0 W0
0118AC  320105     BRA Z, 0x11AB8
1032:              
1033:                  // global/non-connection oriented commands
1034:                  
1035:                  // decline incoming connections
1036:                  if (hci_stack.decline_reason){
0118AE  21F5B1     MOV #0x1F5B, W1
0118B0  784011     MOV.B [W1], W0
0118B2  E00400     CP0.B W0
0118B4  32000A     BRA Z, 0x118CA
1037:                      uint8_t reason = hci_stack.decline_reason;
1038:                      hci_stack.decline_reason = 0;
0118B6  EB4880     CLR.B [W1]
1039:                      hci_send_cmd(&hci_reject_connection_request, hci_stack.decline_addr, reason);
0118B8  FB8000     ZE W0, W0
0118BA  781F80     MOV W0, [W15++]
0118BC  21F5C0     MOV #0x1F5C, W0
0118BE  781F80     MOV W0, [W15++]
0118C0  2EAE40     MOV #0xEAE4, W0
0118C2  781F80     MOV W0, [W15++]
0118C4  026252     CALL hci_send_cmd
0118C6  000001     NOP
0118C8  5787E6     SUB W15, #0x6, W15
1040:                  }
1041:              
1042:                  if (!hci_can_send_packet_now(HCI_COMMAND_DATA_PACKET)) return;
0118CA  B3C010     MOV #0x1, W0
0118CC  025714     CALL hci_can_send_packet_now
0118CE  000001     NOP
0118D0  E00000     CP0 W0
0118D2  3200F2     BRA Z, 0x11AB8
1043:              
1044:                  // send scan enable
1045:                  if (hci_stack.new_scan_enable_value != 0xff){
0118D4  21F5A8     MOV #0x1F5A, W8
0118D6  784018     MOV.B [W8], W0
0118D8  404FE1     ADD.B W0, #0x1, [W15]
0118DA  320008     BRA Z, 0x118EC
1046:                      hci_send_cmd(&hci_write_scan_enable, hci_stack.new_scan_enable_value);
0118DC  FB8000     ZE W0, W0
0118DE  781F80     MOV W0, [W15++]
0118E0  2EA6A0     MOV #0xEA6A, W0
0118E2  781F80     MOV W0, [W15++]
0118E4  026252     CALL hci_send_cmd
0118E6  000001     NOP
1047:                      hci_stack.new_scan_enable_value = 0xff;
0118E8  EBCC00     SETM.B [W8]
0118EA  5787E4     SUB W15, #0x4, W15
1048:                  }
1049:                  
1050:                  // send pending HCI commands
1051:                  for (it = (linked_item_t *) hci_stack.connections; it ; it = it->next){
0118EC  80F239     MOV 0x1E46, W9
0118EE  370034     BRA 0x11958
011956  780499     MOV [W9], W9
011958  E00009     CP0 W9
01195A  3AFFCA     BRA NZ, 0x118F0
1052:              
1053:                      if (!hci_can_send_packet_now(HCI_COMMAND_DATA_PACKET)) return;
0118F0  B3C010     MOV #0x1, W0
0118F2  025714     CALL hci_can_send_packet_now
0118F4  000001     NOP
0118F6  E00000     CP0 W0
0118F8  3200DF     BRA Z, 0x11AB8
1054:              
1055:                      connection = (hci_connection_t *) it;
1056:                      
1057:                      if (connection->state == RECEIVED_CONNECTION_REQUEST){
0118FA  900069     MOV [W9+12], W0
0118FC  500FE2     SUB W0, #0x2, [W15]
0118FE  3A000A     BRA NZ, 0x11914
1058:                          log_info("sending hci_accept_connection_request\n");
1059:                          hci_send_cmd(&hci_accept_connection_request, connection->address, 1);
011900  200010     MOV #0x1, W0
011902  781F80     MOV W0, [W15++]
011904  449FE4     ADD W9, #0x4, [W15++]
011906  2EAE80     MOV #0xEAE8, W0
011908  781F80     MOV W0, [W15++]
01190A  026252     CALL hci_send_cmd
01190C  000001     NOP
1060:                          connection->state = ACCEPTED_CONNECTION_REQUEST;
01190E  200030     MOV #0x3, W0
011910  9804E0     MOV W0, [W9+12]
011912  5787E6     SUB W15, #0x6, W15
1061:                      }
1062:              
1063:                      if (!hci_can_send_packet_now(HCI_COMMAND_DATA_PACKET)) return;
011914  B3C010     MOV #0x1, W0
011916  025714     CALL hci_can_send_packet_now
011918  000001     NOP
01191A  E00000     CP0 W0
01191C  3200CD     BRA Z, 0x11AB8
1064:                      
1065:                      if (connection->authentication_flags & HANDLE_LINK_KEY_REQUEST){
01191E  900079     MOV [W9+14], W0
011920  A31800     BTST.Z W0, #1
011922  320019     BRA Z, 0x11956
1066:                          link_key_t link_key;
1067:                          log_info("responding to link key request\n");
1068:                          if ( hci_stack.remote_device_db->get_link_key( &connection->address, &link_key)){
011924  448464     ADD W9, #0x4, W8
011926  80FA90     MOV DUMPSYS_ERROR, W0
011928  900120     MOV [W0+4], W2
01192A  78008E     MOV W14, W1
01192C  780008     MOV W8, W0
01192E  010002     CALL W2
011930  E00000     CP0 W0
011932  320008     BRA Z, 0x11944
1069:                             hci_send_cmd(&hci_link_key_request_reply, connection->address, &link_key);
011934  781F8E     MOV W14, [W15++]
011936  781F88     MOV W8, [W15++]
011938  2EAE00     MOV #0xEAE0, W0
01193A  781F80     MOV W0, [W15++]
01193C  026252     CALL hci_send_cmd
01193E  000001     NOP
011940  5787E6     SUB W15, #0x6, W15
011942  370006     BRA 0x11950
1070:                          } else {
1071:                             hci_send_cmd(&hci_link_key_request_negative_reply, connection->address);
011944  781F88     MOV W8, [W15++]
011946  2EAD80     MOV #0xEAD8, W0
011948  781F80     MOV W0, [W15++]
01194A  026252     CALL hci_send_cmd
01194C  000001     NOP
01194E  5787E4     SUB W15, #0x4, W15
1072:                          }
1073:                          connectionClearAuthenticationFlags(connection, HANDLE_LINK_KEY_REQUEST);
1074:                      }
1075:                  }
1076:              
1077:                  if (!hci_can_send_packet_now(HCI_COMMAND_DATA_PACKET)) return;
01195C  B3C010     MOV #0x1, W0
01195E  025714     CALL hci_can_send_packet_now
011960  000001     NOP
011962  E00000     CP0 W0
011964  3200A9     BRA Z, 0x11AB8
1078:                      
1079:                  switch (hci_stack.state){
011966  80FAA0     MOV DUMPSYS_ERROR, W0
011968  500FE3     SUB W0, #0x3, [W15]
01196A  320071     BRA Z, 0x11A4E
01196C  500FE5     SUB W0, #0x5, [W15]
01196E  320075     BRA Z, 0x11A5A
011970  500FE1     SUB W0, #0x1, [W15]
011972  3A00A2     BRA NZ, 0x11AB8
1080:                      case HCI_STATE_INITIALIZING:
1081:                          // log_info("hci_init: substate %u\n", hci_stack.substate);
1082:                          if (hci_stack.substate % 2) {
011974  21F568     MOV #0x1F56, W8
011976  FB8018     ZE [W8], W0
011978  A30800     BTST.Z W0, #0
01197A  3A009E     BRA NZ, 0x11AB8
1083:                              // odd: waiting for command completion
1084:                              return;
1085:                          }
1086:                          switch (hci_stack.substate >> 1){
01197C  D10000     LSR W0, W0
01197E  504FE3     SUB.B W0, #0x3, [W15]
011980  320030     BRA Z, 0x119E2
011982  3E0004     BRA GTU, 0x1198C
011984  504FE1     SUB.B W0, #0x1, [W15]
011986  320018     BRA Z, 0x119B8
011988  3E0025     BRA GTU, 0x119D4
01198A  370008     BRA 0x1199C
01198C  504FE5     SUB.B W0, #0x5, [W15]
01198E  320048     BRA Z, 0x11A20
011990  390041     BRA NC, 0x11A14
011992  504FE6     SUB.B W0, #0x6, [W15]
011994  320049     BRA Z, 0x11A28
011996  504FE7     SUB.B W0, #0x7, [W15]
011998  3A0057     BRA NZ, 0x11A48
01199A  370052     BRA 0x11A40
1087:                              case 0: // RESET
1088:                                  hci_send_cmd(&hci_reset);
01199C  2EA7A0     MOV #0xEA7A, W0
01199E  781F80     MOV W0, [W15++]
0119A0  026252     CALL hci_send_cmd
0119A2  000001     NOP
1089:                                  if (hci_stack.config == 0 || ((hci_uart_config_t *)hci_stack.config)->baudrate_main == 0){
0119A4  80F210     MOV 0x1E42, W0
0119A6  E9878F     DEC2 W15, W15
0119A8  E00000     CP0 W0
0119AA  32002E     BRA Z, 0x11A08
0119AC  9000C0     MOV [W0+8], W1
0119AE  900030     MOV [W0+6], W0
0119B0  500FE0     SUB W0, #0x0, [W15]
0119B2  588FE0     SUBB W1, #0x0, [W15]
0119B4  3A0049     BRA NZ, 0x11A48
0119B6  370028     BRA 0x11A08
1090:                                      // skip baud change
1091:                                      hci_stack.substate = 4; // >> 1 = 2
1092:                                  }
1093:                                  break;
1094:                              case 1: // SEND BAUD CHANGE
1095:                                  hci_stack.control->baudrate_cmd(hci_stack.config, ((hci_uart_config_t *)hci_stack.config)->baudrate_main, hci_stack.hci_packet_buffer);
0119B8  80F210     MOV 0x1E42, W0
0119BA  900130     MOV [W0+6], W2
0119BC  9001C0     MOV [W0+8], W3
0119BE  80F221     MOV 0x1E44, W1
0119C0  900261     MOV [W1+12], W4
0119C2  21E481     MOV #0x1E48, W1
0119C4  010004     CALL W4
1096:                                  hci_send_cmd_packet(hci_stack.hci_packet_buffer, 3 + hci_stack.hci_packet_buffer[2]);
0119C6  21E4A0     MOV #0x1E4A, W0
0119C8  FB8090     ZE [W0], W1
0119CA  4080E3     ADD W1, #0x3, W1
0119CC  21E480     MOV #0x1E48, W0
0119CE  022DA8     CALL hci_send_cmd_packet
0119D0  000001     NOP
0119D2  37003A     BRA 0x11A48
1097:                                  break;
1098:                              case 2: // LOCAL BAUD CHANGE
1099:                                  hci_stack.hci_transport->set_baudrate(((hci_uart_config_t *)hci_stack.config)->baudrate_main);
0119D4  80F210     MOV 0x1E42, W0
0119D6  9000C0     MOV [W0+8], W1
0119D8  900030     MOV [W0+6], W0
0119DA  80F202     MOV hci_stack, W2
0119DC  900152     MOV [W2+10], W2
0119DE  010002     CALL W2
1100:                                  hci_stack.substate += 2;
0119E0  E8CC18     INC2.B [W8], [W8]
1101:                                  // break missing here for fall through
1102:                                  
1103:                              case 3:
1104:                                  // custom initialization
1105:                                  if (hci_stack.control && hci_stack.control->next_cmd){
0119E2  80F220     MOV 0x1E44, W0
0119E4  E00000     CP0 W0
0119E6  320014     BRA Z, 0x11A10
0119E8  900170     MOV [W0+14], W2
0119EA  E00002     CP0 W2
0119EC  320011     BRA Z, 0x11A10
1106:                                      int valid_cmd = (*hci_stack.control->next_cmd)(hci_stack.config, hci_stack.hci_packet_buffer);
0119EE  21E481     MOV #0x1E48, W1
0119F0  80F210     MOV 0x1E42, W0
0119F2  010002     CALL W2
1107:                                      if (valid_cmd){
0119F4  E00000     CP0 W0
0119F6  32000C     BRA Z, 0x11A10
1108:                                          int size = 3 + hci_stack.hci_packet_buffer[2];
1109:                                          hci_stack.hci_transport->send_packet(HCI_COMMAND_DATA_PACKET, hci_stack.hci_packet_buffer, size);
0119F8  21E4A0     MOV #0x1E4A, W0
0119FA  FB8110     ZE [W0], W2
0119FC  410163     ADD W2, #0x3, W2
0119FE  80F200     MOV hci_stack, W0
011A00  9001A0     MOV [W0+4], W3
011A02  21E481     MOV #0x1E48, W1
011A04  B3C010     MOV #0x1, W0
011A06  010003     CALL W3
1110:                                          hci_stack.substate = 4; // more init commands
011A08  B3C041     MOV #0x4, W1
011A0A  21F560     MOV #0x1F56, W0
011A0C  784801     MOV.B W1, [W0]
011A0E  37001C     BRA 0x11A48
1111:                                          break;
1112:                                      }
1113:                                      log_info("hci_run: init script done\n\r");
1114:                                  }
1115:                                  // otherwise continue
1116:              					hci_send_cmd(&hci_read_bd_addr);
011A10  2EA180     MOV #0xEA18, W0
011A12  370001     BRA 0x11A16
1117:              					break;
1118:              				case 4:
1119:              					hci_send_cmd(&hci_read_buffer_size);
011A14  2EA1C0     MOV #0xEA1C, W0
011A16  781F80     MOV W0, [W15++]
011A18  026252     CALL hci_send_cmd
011A1A  000001     NOP
1120:              					break;
011A1C  E9878F     DEC2 W15, W15
011A1E  370014     BRA 0x11A48
1121:                              case 5:
1122:                                  // ca. 15 sec
1123:                                  hci_send_cmd(&hci_write_page_timeout, 0x6000);
011A20  260000     MOV #0x6000, W0
011A22  781F80     MOV W0, [W15++]
011A24  2EA6E0     MOV #0xEA6E, W0
011A26  370007     BRA 0x11A36
1124:                                  break;
1125:              				case 6:
1126:              					hci_send_cmd(&hci_write_scan_enable, (hci_stack.connectable << 1) | hci_stack.discoverable); // page scan
011A28  21F590     MOV #0x1F59, W0
011A2A  FB8010     ZE [W0], W0
011A2C  400000     ADD W0, W0, W0
011A2E  21F581     MOV #0x1F58, W1
011A30  FB8091     ZE [W1], W1
011A32  701F81     IOR W0, W1, [W15++]
011A34  2EA6A0     MOV #0xEA6A, W0
011A36  781F80     MOV W0, [W15++]
011A38  026252     CALL hci_send_cmd
011A3A  000001     NOP
1127:              					break;
011A3C  5787E4     SUB W15, #0x4, W15
011A3E  370004     BRA 0x11A48
1128:                              case 7:
1129:              #ifndef EMBEDDED
1130:                              {
1131:                                  char hostname[30];
1132:                                  gethostname(hostname, 30);
1133:                                  hostname[29] = '\0';
1134:                                  hci_send_cmd(&hci_write_local_name, hostname);
1135:                                  break;
1136:                              }
1137:                              case 8:
1138:              #ifdef USE_BLUETOOL
1139:                                  hci_send_cmd(&hci_write_class_of_device, 0x007a020c); // Smartphone
1140:                                  break;
1141:                                  
1142:                              case 9:
1143:              #endif
1144:              #endif
1145:                                  // done.
1146:                                  hci_stack.state = HCI_STATE_WORKING;
011A40  200020     MOV #0x2, W0
011A42  88FAA0     MOV W0, DUMPSYS_ERROR
1147:                                  hci_emit_state();
011A44  025A04     CALL hci_emit_state
011A46  000001     NOP
1148:                                  break;
1149:                              default:
1150:                                  break;
1151:                          }
1152:                          hci_stack.substate++;
011A48  21F560     MOV #0x1F56, W0
011A4A  E84810     INC.B [W0], [W0]
011A4C  370035     BRA 0x11AB8
1153:                          break;
1154:                          
1155:                      case HCI_STATE_HALTING:
1156:              
1157:                          log_info("HCI_STATE_HALTING\n");
1158:                          // close all open connections
1159:                          connection =  (hci_connection_t *) hci_stack.connections;
011A4E  80F238     MOV 0x1E46, W8
1160:                          if (connection){
011A50  E00008     CP0 W8
011A52  3A000D     BRA NZ, 0x11A6E
1161:                              
1162:                              // send disconnect
1163:                              if (!hci_can_send_packet_now(HCI_COMMAND_DATA_PACKET)) return;
1164:                              
1165:                              log_info("HCI_STATE_HALTING, connection %p, handle %u\n", connection, (uint16_t)connection->con_handle);
1166:                              hci_send_cmd(&hci_disconnect, connection->con_handle, 0x13);  // remote closed connection
1167:              
1168:                              // send disconnected event right away - causes higher layer connections to get closed, too.
1169:                              hci_shutdown_connection(connection);
1170:                              return;
1171:                          }
1172:                          log_info("HCI_STATE_HALTING, calling off\n");
1173:                          
1174:                          // switch mode
1175:                          hci_power_control_off();
011A54  025F3C     CALL hci_power_control_off
011A56  000001     NOP
011A58  37002D     BRA 0x11AB4
1176:                          
1177:                          log_info("HCI_STATE_HALTING, emitting state\n");
1178:                          hci_emit_state();
1179:                          log_info("HCI_STATE_HALTING, done\n");
1180:                          break;
1181:                          
1182:                      case HCI_STATE_FALLING_ASLEEP:
1183:                          switch(hci_stack.substate) {
011A5A  21F569     MOV #0x1F56, W9
011A5C  784019     MOV.B [W9], W0
011A5E  E00400     CP0.B W0
011A60  320003     BRA Z, 0x11A68
011A62  504FE2     SUB.B W0, #0x2, [W15]
011A64  3A0029     BRA NZ, 0x11AB8
011A66  370024     BRA 0x11AB0
1184:                              case 0:
1185:                                  log_info("HCI_STATE_FALLING_ASLEEP\n");
1186:                                  // close all open connections
1187:                                  connection =  (hci_connection_t *) hci_stack.connections;
011A68  80F238     MOV 0x1E46, W8
1188:              
1189:              #if defined(USE_POWERMANAGEMENT) && defined(USE_BLUETOOL)
1190:                                  // don't close connections, if H4 supports power management
1191:                                  if (bt_control_iphone_power_management_enabled()){
1192:                                      connection = NULL;
1193:                                  }
1194:              #endif
1195:                                  if (connection){
011A6A  E00008     CP0 W8
011A6C  320012     BRA Z, 0x11A92
1196:                                      
1197:                                      // send disconnect
1198:                                      if (!hci_can_send_packet_now(HCI_COMMAND_DATA_PACKET)) return;
011A6E  B3C010     MOV #0x1, W0
011A70  025714     CALL hci_can_send_packet_now
011A72  000001     NOP
011A74  E00000     CP0 W0
011A76  320020     BRA Z, 0x11AB8
1199:              
1200:                                      log_info("HCI_STATE_FALLING_ASLEEP, connection %p, handle %u\n", connection, (uint16_t)connection->con_handle);
1201:                                      hci_send_cmd(&hci_disconnect, connection->con_handle, 0x13);  // remote closed connection
011A78  200130     MOV #0x13, W0
011A7A  781F80     MOV W0, [W15++]
011A7C  900058     MOV [W8+10], W0
011A7E  781F80     MOV W0, [W15++]
011A80  2EAF00     MOV #0xEAF0, W0
011A82  781F80     MOV W0, [W15++]
011A84  026252     CALL hci_send_cmd
011A86  000001     NOP
1202:                                      
1203:                                      // send disconnected event right away - causes higher layer connections to get closed, too.
1204:                                      hci_shutdown_connection(connection);
011A88  780008     MOV W8, W0
011A8A  025D32     CALL hci_shutdown_connection
011A8C  000001     NOP
1205:                                      return;
011A8E  5787E6     SUB W15, #0x6, W15
011A90  370013     BRA 0x11AB8
1206:                                  }
1207:                                  
1208:                                  // disable page and inquiry scan
1209:                                  if (!hci_can_send_packet_now(HCI_COMMAND_DATA_PACKET)) return;
011A92  B3C010     MOV #0x1, W0
011A94  025714     CALL hci_can_send_packet_now
011A96  000001     NOP
011A98  E00000     CP0 W0
011A9A  32000E     BRA Z, 0x11AB8
1210:                                  
1211:                                  log_info("HCI_STATE_HALTING, disabling inq cans\n");
1212:                                  hci_send_cmd(&hci_write_scan_enable, hci_stack.connectable << 1); // drop inquiry scan but keep page scan
011A9C  21F590     MOV #0x1F59, W0
011A9E  FB8010     ZE [W0], W0
011AA0  401F80     ADD W0, W0, [W15++]
011AA2  2EA6A0     MOV #0xEA6A, W0
011AA4  781F80     MOV W0, [W15++]
011AA6  026252     CALL hci_send_cmd
011AA8  000001     NOP
1213:                                  
1214:                                  // continue in next sub state
1215:                                  hci_stack.substate++;
011AAA  E84C99     INC.B [W9], [W9]
1216:                                  break;
011AAC  5787E4     SUB W15, #0x4, W15
011AAE  370004     BRA 0x11AB8
1217:                              case 1:
1218:                                  // wait for command complete "hci_write_scan_enable" in event_handler();
1219:                                  break;
1220:                              case 2:
1221:                                  log_info("HCI_STATE_HALTING, calling sleep\n");
1222:              #if defined(USE_POWERMANAGEMENT) && defined(USE_BLUETOOL)
1223:                                  // don't actually go to sleep, if H4 supports power management
1224:                                  if (bt_control_iphone_power_management_enabled()){
1225:                                      // SLEEP MODE reached
1226:                                      hci_stack.state = HCI_STATE_SLEEPING; 
1227:                                      hci_emit_state();
1228:                                      break;
1229:                                  }
1230:              #endif
1231:                                  // switch mode
1232:                                  hci_power_control_sleep();  // changes hci_stack.state to SLEEP
011AB0  0262F4     CALL hci_power_control_sleep
011AB2  000001     NOP
1233:                                  hci_emit_state();
011AB4  025A04     CALL hci_emit_state
011AB6  000001     NOP
1234:                                  break;
1235:                                  
1236:                              default:
1237:                                  break;
1238:                          }
1239:                          break;
1240:                          
1241:                      default:
1242:                          break;
1243:                  }
1244:              }
1245:              
1246:              int hci_send_cmd_packet(uint8_t *packet, int size){
1247:                  bd_addr_t addr;
1248:                  hci_connection_t * conn;
1249:                  // house-keeping
1250:                  
1251:                  // create_connection?
1252:                  if (IS_COMMAND(packet, hci_create_connection)){
012DB2  E80500     INC W0, W10
012DB4  FB8010     ZE [W0], W0
012DB6  FB809A     ZE [W10], W1
012DB8  DD08C8     SL W1, #8, W1
012DBA  700001     IOR W0, W1, W0
012DBC  2EAFC1     MOV #0xEAFC, W1
012DBE  500F91     SUB W0, [W1], [W15]
012DC0  3A0020     BRA NZ, 0x12E02
1253:                      bt_flip_addr(addr, &packet[3]);
012DC2  4480E3     ADD W9, #0x3, W1
012DC4  57806E     SUB W15, #0xE, W0
012DC6  02616A     CALL bt_flip_addr
012DC8  000001     NOP
1254:                      log_info("Create_connection to %s\n", bd_addr_to_str(addr));
1255:                      conn = connection_for_address(addr);
012DCA  57806E     SUB W15, #0xE, W0
012DCC  025AA2     CALL connection_for_address
012DCE  000001     NOP
012DD0  780100     MOV W0, W2
1256:                      if (conn) {
012DD2  E00000     CP0 W0
012DD4  320009     BRA Z, 0x12DE8
1257:                          // if connection exists
1258:                          if (conn->state == OPEN) {
012DD6  900060     MOV [W0+12], W0
012DD8  EB0080     CLR W1
012DDA  500FE5     SUB W0, #0x5, [W15]
012DDC  3A0059     BRA NZ, 0x12E90
1259:                              // and OPEN, emit connection complete command
1260:                              hci_emit_connection_complete(conn, 0);
012DDE  780002     MOV W2, W0
012DE0  024CD6     CALL hci_emit_connection_complete
012DE2  000001     NOP
012DE4  EB0080     CLR W1
012DE6  370054     BRA 0x12E90
1261:                          }
1262:                          //    otherwise, just ignore as it is already in the open process
1263:                          return 0; // don't sent packet to controller
1264:                          
1265:                      }
1266:                      // create connection struct and register, state = SENT_CREATE_CONNECTION
1267:                      conn = create_connection_for_addr(addr);
012DE8  57806E     SUB W15, #0xE, W0
012DEA  024DE0     CALL create_connection_for_addr
012DEC  000001     NOP
012DEE  780400     MOV W0, W8
1268:                      if (!conn){
012DF0  E00000     CP0 W0
012DF2  3A0005     BRA NZ, 0x12DFE
1269:                          // notify client that alloc failed
1270:                          hci_emit_connection_complete(conn, BTSTACK_MEMORY_ALLOC_FAILED);
012DF4  B3C561     MOV #0x56, W1
012DF6  024CD6     CALL hci_emit_connection_complete
012DF8  000001     NOP
012DFA  780088     MOV W8, W1
012DFC  370049     BRA 0x12E90
1271:                          return 0; // don't sent packet to controller
1272:                      }
1273:                      conn->state = SENT_CREATE_CONNECTION;
012DFE  200010     MOV #0x1, W0
012E00  980460     MOV W0, [W8+12]
1274:                  }
1275:                  
1276:                  if (IS_COMMAND(packet, hci_link_key_request_reply)){
012E02  FB8019     ZE [W9], W0
012E04  FB809A     ZE [W10], W1
012E06  DD08C8     SL W1, #8, W1
012E08  700001     IOR W0, W1, W0
012E0A  2EAE01     MOV #0xEAE0, W1
012E0C  500F91     SUB W0, [W1], [W15]
012E0E  3A0004     BRA NZ, 0x12E18
1277:                      hci_add_connection_flags_for_flipped_bd_addr(&packet[3], SENT_LINK_KEY_REPLY);
012E10  448063     ADD W9, #0x3, W0
012E12  200041     MOV #0x4, W1
012E14  025B14     CALL hci_add_connection_flags_for_flipped_bd_addr
012E16  000001     NOP
1278:                  }
1279:                  if (IS_COMMAND(packet, hci_link_key_request_negative_reply)){
012E18  FB8019     ZE [W9], W0
012E1A  FB809A     ZE [W10], W1
012E1C  DD08C8     SL W1, #8, W1
012E1E  700001     IOR W0, W1, W0
012E20  2EAD81     MOV #0xEAD8, W1
012E22  500F91     SUB W0, [W1], [W15]
012E24  3A0004     BRA NZ, 0x12E2E
1280:                      hci_add_connection_flags_for_flipped_bd_addr(&packet[3], SENT_LINK_KEY_NEGATIVE_REQUEST);
012E26  448063     ADD W9, #0x3, W0
012E28  200081     MOV #0x8, W1
012E2A  025B14     CALL hci_add_connection_flags_for_flipped_bd_addr
012E2C  000001     NOP
1281:                  }
1282:                  if (IS_COMMAND(packet, hci_pin_code_request_reply)){
012E2E  FB8019     ZE [W9], W0
012E30  FB809A     ZE [W10], W1
012E32  DD08C8     SL W1, #8, W1
012E34  700001     IOR W0, W1, W0
012E36  2EAD41     MOV #0xEAD4, W1
012E38  500F91     SUB W0, [W1], [W15]
012E3A  3A0004     BRA NZ, 0x12E44
1283:                      hci_add_connection_flags_for_flipped_bd_addr(&packet[3], SENT_PIN_CODE_REPLY);
012E3C  448063     ADD W9, #0x3, W0
012E3E  200401     MOV #0x40, W1
012E40  025B14     CALL hci_add_connection_flags_for_flipped_bd_addr
012E42  000001     NOP
1284:                  }
1285:                  if (IS_COMMAND(packet, hci_pin_code_request_negative_reply)){
012E44  FB8019     ZE [W9], W0
012E46  FB809A     ZE [W10], W1
012E48  DD08C8     SL W1, #8, W1
012E4A  700001     IOR W0, W1, W0
012E4C  2EACC1     MOV #0xEACC, W1
012E4E  500F91     SUB W0, [W1], [W15]
012E50  3A0004     BRA NZ, 0x12E5A
1286:                      hci_add_connection_flags_for_flipped_bd_addr(&packet[3], SENT_PIN_CODE_NEGATIVE_REPLY);
012E52  448063     ADD W9, #0x3, W0
012E54  200801     MOV #0x80, W1
012E56  025B14     CALL hci_add_connection_flags_for_flipped_bd_addr
012E58  000001     NOP
1287:                  }
1288:                  
1289:                  if (IS_COMMAND(packet, hci_delete_stored_link_key)){
012E5A  FB8019     ZE [W9], W0
012E5C  FB809A     ZE [W10], W1
012E5E  DD08C8     SL W1, #8, W1
012E60  700001     IOR W0, W1, W0
012E62  2EA761     MOV #0xEA76, W1
012E64  500F91     SUB W0, [W1], [W15]
012E66  3A000B     BRA NZ, 0x12E7E
1290:                      if (hci_stack.remote_device_db){
012E68  21F520     MOV #0x1F52, W0
012E6A  E00010     CP0 [W0]
012E6C  320008     BRA Z, 0x12E7E
1291:                          bt_flip_addr(addr, &packet[3]);
012E6E  4480E3     ADD W9, #0x3, W1
012E70  57806E     SUB W15, #0xE, W0
012E72  02616A     CALL bt_flip_addr
012E74  000001     NOP
1292:                          hci_stack.remote_device_db->delete_link_key(&addr);
012E76  80FA90     MOV DUMPSYS_ERROR, W0
012E78  9000C0     MOV [W0+8], W1
012E7A  57806E     SUB W15, #0xE, W0
012E7C  010001     CALL W1
1293:                      }
1294:                  }
1295:                  
1296:                  hci_stack.num_cmd_packets--;
012E7E  21F4A0     MOV #0x1F4A, W0
012E80  E94810     DEC.B [W0], [W0]
1297:                  return hci_stack.hci_transport->send_packet(HCI_COMMAND_DATA_PACKET, packet, size);
012E82  80F200     MOV hci_stack, W0
012E84  9001A0     MOV [W0+4], W3
012E86  78010B     MOV W11, W2
012E88  780089     MOV W9, W1
012E8A  B3C010     MOV #0x1, W0
012E8C  010003     CALL W3
012E8E  780080     MOV W0, W1
1298:              }
1299:              
1300:              /**
1301:               * pre: numcmds >= 0 - it's allowed to send a command to the controller
1302:               */
1303:              int hci_send_cmd(const hci_cmd_t *cmd, ...){
1304:                  va_list argptr;
1305:                  va_start(argptr, cmd);
1306:                  uint16_t size = hci_create_cmd_internal(hci_stack.hci_packet_buffer, cmd, argptr);
016256  578168     SUB W15, #0x8, W2
016258  21E480     MOV #0x1E48, W0
01625A  022526     CALL hci_create_cmd_internal
01625C  000001     NOP
01625E  780080     MOV W0, W1
1307:                  va_end(argptr);
1308:                  return hci_send_cmd_packet(hci_stack.hci_packet_buffer, size);
016260  21E480     MOV #0x1E48, W0
016262  022DA8     CALL hci_send_cmd_packet
016264  000001     NOP
1309:              }
1310:              
1311:              // Create various non-HCI events. 
1312:              // TODO: generalize, use table similar to hci_create_command
1313:              
1314:              void hci_emit_state(){
1315:                  log_info("BTSTACK_EVENT_STATE %u", hci_stack.state);
1316:                  uint8_t event[3];
1317:                  event[0] = BTSTACK_EVENT_STATE;
015A06  B3C600     MOV #0x60, W0
015A08  9FFFC0     MOV.B W0, [W15-4]
1318:                  event[1] = sizeof(event) - 2;
015A0A  B3C010     MOV #0x1, W0
015A0C  9FFFD0     MOV.B W0, [W15-3]
1319:                  event[2] = hci_stack.state;
015A0E  80FAA0     MOV DUMPSYS_ERROR, W0
015A10  9FFFE0     MOV.B W0, [W15-2]
1320:                  hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
015A12  200033     MOV #0x3, W3
015A14  578164     SUB W15, #0x4, W2
015A16  EB4080     CLR.B W1
015A18  B3C040     MOV #0x4, W0
015A1A  026798     CALL hci_dump_packet
015A1C  000001     NOP
1321:                  hci_stack.packet_handler(HCI_EVENT_PACKET, event, sizeof(event));
015A1E  200032     MOV #0x3, W2
015A20  5780E4     SUB W15, #0x4, W1
015A22  B3C040     MOV #0x4, W0
015A24  80FA83     MOV pCurrentConfigurationDescriptor, W3
015A26  010003     CALL W3
1322:              }
1323:              
1324:              void hci_emit_connection_complete(hci_connection_t *conn, uint8_t status){
1325:                  uint8_t event[13];
1326:                  event[0] = HCI_EVENT_CONNECTION_COMPLETE;
014CDC  B3C030     MOV #0x3, W0
014CDE  9FF780     MOV.B W0, [W15-16]
1327:                  event[1] = sizeof(event) - 2;
014CE0  B3C0B0     MOV #0xB, W0
014CE2  9FF790     MOV.B W0, [W15-15]
1328:                  event[2] = status;
014CE4  9FF7A1     MOV.B W1, [W15-14]
1329:                  bt_store_16(event, 3, conn->con_handle);
014CE6  900158     MOV [W8+10], W2
014CE8  200031     MOV #0x3, W1
014CEA  578070     SUB W15, #0x10, W0
014CEC  026614     CALL bt_store_16
014CEE  000001     NOP
1330:                  bt_flip_addr(&event[5], conn->address);
014CF0  4400E4     ADD W8, #0x4, W1
014CF2  57806B     SUB W15, #0xB, W0
014CF4  02616A     CALL bt_flip_addr
014CF6  000001     NOP
1331:                  event[11] = 1; // ACL connection
014CF8  B3C010     MOV #0x1, W0
014CFA  9FFFB0     MOV.B W0, [W15-5]
1332:                  event[12] = 0; // encryption disabled
014CFC  EB4080     CLR.B W1
014CFE  9FFFC1     MOV.B W1, [W15-4]
1333:                  hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
014D00  2000D3     MOV #0xD, W3
014D02  578170     SUB W15, #0x10, W2
014D04  B3C040     MOV #0x4, W0
014D06  026798     CALL hci_dump_packet
014D08  000001     NOP
1334:                  hci_stack.packet_handler(HCI_EVENT_PACKET, event, sizeof(event));
014D0A  2000D2     MOV #0xD, W2
014D0C  5780F0     SUB W15, #0x10, W1
014D0E  B3C040     MOV #0x4, W0
014D10  80FA83     MOV pCurrentConfigurationDescriptor, W3
014D12  010003     CALL W3
1335:              }
1336:              
1337:              void hci_emit_disconnection_complete(uint16_t handle, uint8_t reason){
1338:                  uint8_t event[6];
1339:                  event[0] = HCI_EVENT_DISCONNECTION_COMPLETE;
014EE8  B3C050     MOV #0x5, W0
014EEA  9FF7C0     MOV.B W0, [W15-12]
1340:                  event[1] = sizeof(event) - 2;
014EEC  B3C048     MOV #0x4, W8
014EEE  9FF7D8     MOV.B W8, [W15-11]
1341:                  event[2] = 0; // status = OK
014EF0  EB4480     CLR.B W9
014EF2  9FF7E9     MOV.B W9, [W15-10]
1342:                  bt_store_16(event, 3, handle);
014EF4  200031     MOV #0x3, W1
014EF6  57806C     SUB W15, #0xC, W0
014EF8  026614     CALL bt_store_16
014EFA  000001     NOP
1343:                  event[5] = reason;
014EFC  9FFF9A     MOV.B W10, [W15-7]
1344:                  hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
014EFE  200063     MOV #0x6, W3
014F00  57816C     SUB W15, #0xC, W2
014F02  784089     MOV.B W9, W1
014F04  784008     MOV.B W8, W0
014F06  026798     CALL hci_dump_packet
014F08  000001     NOP
1345:                  hci_stack.packet_handler(HCI_EVENT_PACKET, event, sizeof(event));
014F0A  200062     MOV #0x6, W2
014F0C  5780EC     SUB W15, #0xC, W1
014F0E  784008     MOV.B W8, W0
014F10  80FA83     MOV pCurrentConfigurationDescriptor, W3
014F12  010003     CALL W3
1346:              }
1347:              
1348:              void hci_emit_l2cap_check_timeout(hci_connection_t *conn){
1349:                  log_info("L2CAP_EVENT_TIMEOUT_CHECK");
1350:                  uint8_t event[4];
1351:                  event[0] = L2CAP_EVENT_TIMEOUT_CHECK;
0157D4  B3C731     MOV #0x73, W1
0157D6  9FFFC1     MOV.B W1, [W15-4]
1352:                  event[1] = sizeof(event) - 2;
0157D8  B3C021     MOV #0x2, W1
0157DA  9FFFD1     MOV.B W1, [W15-3]
1353:                  bt_store_16(event, 2, conn->con_handle);
0157DC  900150     MOV [W0+10], W2
0157DE  200021     MOV #0x2, W1
0157E0  578064     SUB W15, #0x4, W0
0157E2  026614     CALL bt_store_16
0157E4  000001     NOP
1354:                  hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
0157E6  200043     MOV #0x4, W3
0157E8  578164     SUB W15, #0x4, W2
0157EA  EB4080     CLR.B W1
0157EC  784003     MOV.B W3, W0
0157EE  026798     CALL hci_dump_packet
0157F0  000001     NOP
1355:                  hci_stack.packet_handler(HCI_EVENT_PACKET, event, sizeof(event));
0157F2  200042     MOV #0x4, W2
0157F4  5780E4     SUB W15, #0x4, W1
0157F6  B3C040     MOV #0x4, W0
0157F8  80FA83     MOV pCurrentConfigurationDescriptor, W3
0157FA  010003     CALL W3
1356:              }
1357:              
1358:              void hci_emit_nr_connections_changed(){
1359:                  log_info("BTSTACK_EVENT_NR_CONNECTIONS_CHANGED %u", nr_hci_connections());
1360:                  uint8_t event[3];
1361:                  event[0] = BTSTACK_EVENT_NR_CONNECTIONS_CHANGED;
015554  B3C610     MOV #0x61, W0
015556  9FFFC0     MOV.B W0, [W15-4]
1362:                  event[1] = sizeof(event) - 2;
015558  B3C010     MOV #0x1, W0
01555A  9FFFD0     MOV.B W0, [W15-3]
1363:                  event[2] = nr_hci_connections();
01556A  9FFFE1     MOV.B W1, [W15-2]
1364:                  hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
01556C  200033     MOV #0x3, W3
01556E  578164     SUB W15, #0x4, W2
015570  784080     MOV.B W0, W1
015572  B3C040     MOV #0x4, W0
015574  026798     CALL hci_dump_packet
015576  000001     NOP
1365:                  hci_stack.packet_handler(HCI_EVENT_PACKET, event, sizeof(event));
015578  200032     MOV #0x3, W2
01557A  5780E4     SUB W15, #0x4, W1
01557C  B3C040     MOV #0x4, W0
01557E  80FA83     MOV pCurrentConfigurationDescriptor, W3
015580  010003     CALL W3
1366:              }
1367:              
1368:              void hci_emit_hci_open_failed(){
1369:                  log_info("BTSTACK_EVENT_POWERON_FAILED");
1370:                  uint8_t event[2];
1371:                  event[0] = BTSTACK_EVENT_POWERON_FAILED;
015D12  B3C620     MOV #0x62, W0
015D14  9FFFE0     MOV.B W0, [W15-2]
1372:                  event[1] = sizeof(event) - 2;
015D16  EB4080     CLR.B W1
015D18  9FFFF1     MOV.B W1, [W15-1]
1373:                  hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
015D1A  200023     MOV #0x2, W3
015D1C  E9810F     DEC2 W15, W2
015D1E  B3C040     MOV #0x4, W0
015D20  026798     CALL hci_dump_packet
015D22  000001     NOP
1374:                  hci_stack.packet_handler(HCI_EVENT_PACKET, event, sizeof(event));
015D24  200022     MOV #0x2, W2
015D26  E9808F     DEC2 W15, W1
015D28  B3C040     MOV #0x4, W0
015D2A  80FA83     MOV pCurrentConfigurationDescriptor, W3
015D2C  010003     CALL W3
1375:              }
1376:              
1377:              #ifndef EMBEDDED
1378:              void hci_emit_btstack_version() {
1379:                  log_info("BTSTACK_EVENT_VERSION %u.%u", BTSTACK_MAJOR, BTSTACK_MINOR);
1380:                  uint8_t event[6];
1381:                  event[0] = BTSTACK_EVENT_VERSION;
1382:                  event[1] = sizeof(event) - 2;
1383:                  event[2] = BTSTACK_MAJOR;
1384:                  event[3] = BTSTACK_MINOR;
1385:                  bt_store_16(event, 4, BTSTACK_REVISION);
1386:                  hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
1387:                  hci_stack.packet_handler(HCI_EVENT_PACKET, event, sizeof(event));
1388:              }
1389:              #endif
1390:              
1391:              void hci_emit_system_bluetooth_enabled(uint8_t enabled){
1392:                  log_info("BTSTACK_EVENT_SYSTEM_BLUETOOTH_ENABLED %u", enabled);
1393:                  uint8_t event[3];
1394:                  event[0] = BTSTACK_EVENT_SYSTEM_BLUETOOTH_ENABLED;
015AF0  B3C641     MOV #0x64, W1
015AF2  9FFFC1     MOV.B W1, [W15-4]
1395:                  event[1] = sizeof(event) - 2;
015AF4  B3C011     MOV #0x1, W1
015AF6  9FFFD1     MOV.B W1, [W15-3]
1396:                  event[2] = enabled;
015AF8  9FFFE0     MOV.B W0, [W15-2]
1397:                  hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
015AFA  200033     MOV #0x3, W3
015AFC  578164     SUB W15, #0x4, W2
015AFE  EB4080     CLR.B W1
015B00  B3C040     MOV #0x4, W0
015B02  026798     CALL hci_dump_packet
015B04  000001     NOP
1398:                  hci_stack.packet_handler(HCI_EVENT_PACKET, event, sizeof(event));
015B06  200032     MOV #0x3, W2
015B08  5780E4     SUB W15, #0x4, W1
015B0A  B3C040     MOV #0x4, W0
015B0C  80FA83     MOV pCurrentConfigurationDescriptor, W3
015B0E  010003     CALL W3
1399:              }
1400:              
1401:              void hci_emit_remote_name_cached(bd_addr_t *addr, device_name_t *name){
1402:                  uint8_t event[2+1+6+248+1]; // +1 for \0 in log_info
1403:                  event[0] = BTSTACK_EVENT_REMOTE_NAME_CACHED;
0149B4  B3C650     MOV #0x65, W0
0149B6  9DFFA0     MOV.B W0, [W15-262]
1404:                  event[1] = sizeof(event) - 2 - 1;
0149B8  EBC000     SETM.B W0
0149BA  9DFFB0     MOV.B W0, [W15-261]
1405:                  event[2] = 0;   // just to be compatible with HCI_EVENT_REMOTE_NAME_REQUEST_COMPLETE
0149BC  EB4400     CLR.B W8
0149BE  9DFFC8     MOV.B W8, [W15-260]
1406:                  bt_flip_addr(&event[3], *addr);
0149C0  780082     MOV W2, W1
0149C2  2FEFD2     MOV #0xFEFD, W2
0149C4  478002     ADD W15, W2, W0
0149C6  02616A     CALL bt_flip_addr
0149C8  000001     NOP
1407:                  memcpy(&event[9], name, 248);
0149CA  2FEFA1     MOV #0xFEFA, W1
0149CC  40808F     ADD W1, W15, W1
0149CE  408069     ADD W1, #0x9, W0
0149D0  0900F7     REPEAT #0xF7
0149D2  785839     MOV.B [W9++], [W0++]
0149D4  B10F80     SUB #0xF8, W0
0149D6  B10F89     SUB #0xF8, W9
1408:                  
1409:                  event[9+248] = 0;   // assert \0 for log_info
0149D8  9FFFB8     MOV.B W8, [W15-5]
1410:                  log_info("BTSTACK_EVENT_REMOTE_NAME_CACHED %s = '%s'", bd_addr_to_str(*addr), &event[9]);
1411:              
1412:                  hci_dump_packet(HCI_EVENT_PACKET, 0, event, sizeof(event)-1);
0149DA  201013     MOV #0x101, W3
0149DC  780101     MOV W1, W2
0149DE  784088     MOV.B W8, W1
0149E0  B3C040     MOV #0x4, W0
0149E2  026798     CALL hci_dump_packet
0149E4  000001     NOP
1413:                  hci_stack.packet_handler(HCI_EVENT_PACKET, event, sizeof(event)-1);
0149E6  201012     MOV #0x101, W2
0149E8  2FEFA1     MOV #0xFEFA, W1
0149EA  40808F     ADD W1, W15, W1
0149EC  B3C040     MOV #0x4, W0
0149EE  80FA83     MOV pCurrentConfigurationDescriptor, W3
0149F0  010003     CALL W3
1414:              }
1415:              
1416:              void hci_emit_discoverable_enabled(uint8_t enabled){
1417:                  log_info("BTSTACK_EVENT_DISCOVERABLE_ENABLED %u", enabled);
1418:                  uint8_t event[3];
1419:                  event[0] = BTSTACK_EVENT_DISCOVERABLE_ENABLED;
015ACA  B3C661     MOV #0x66, W1
015ACC  9FFFC1     MOV.B W1, [W15-4]
1420:                  event[1] = sizeof(event) - 2;
015ACE  B3C011     MOV #0x1, W1
015AD0  9FFFD1     MOV.B W1, [W15-3]
1421:                  event[2] = enabled;
015AD2  9FFFE0     MOV.B W0, [W15-2]
1422:                  hci_dump_packet( HCI_EVENT_PACKET, 0, event, sizeof(event));
015AD4  200033     MOV #0x3, W3
015AD6  578164     SUB W15, #0x4, W2
015AD8  EB4080     CLR.B W1
015ADA  B3C040     MOV #0x4, W0
015ADC  026798     CALL hci_dump_packet
015ADE  000001     NOP
1423:                  hci_stack.packet_handler(HCI_EVENT_PACKET, event, sizeof(event));
015AE0  200032     MOV #0x3, W2
015AE2  5780E4     SUB W15, #0x4, W1
015AE4  B3C040     MOV #0x4, W0
015AE6  80FA83     MOV pCurrentConfigurationDescriptor, W3
015AE8  010003     CALL W3
1424:              }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libbtstack/src/btstack_memory.c
016674  780080     MOV W0, W1
01667C  780080     MOV W0, W1
016684  780080     MOV W0, W1
01668C  780080     MOV W0, W1
016694  780080     MOV W0, W1
01669C  780080     MOV W0, W1
0166A4  780080     MOV W0, W1
1:                 /*
2:                  * Copyright (C) 2009-2012 by Matthias Ringwald
3:                  *
4:                  * Redistribution and use in source and binary forms, with or without
5:                  * modification, are permitted provided that the following conditions
6:                  * are met:
7:                  *
8:                  * 1. Redistributions of source code must retain the above copyright
9:                  *    notice, this list of conditions and the following disclaimer.
10:                 * 2. Redistributions in binary form must reproduce the above copyright
11:                 *    notice, this list of conditions and the following disclaimer in the
12:                 *    documentation and/or other materials provided with the distribution.
13:                 * 3. Neither the name of the copyright holders nor the names of
14:                 *    contributors may be used to endorse or promote products derived
15:                 *    from this software without specific prior written permission.
16:                 * 4. Any redistribution, use, or modification is done solely for
17:                 *    personal benefit and not for any commercial purpose or for
18:                 *    monetary gain.
19:                 *
20:                 * THIS SOFTWARE IS PROVIDED BY MATTHIAS RINGWALD AND CONTRIBUTORS
21:                 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
22:                 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
23:                 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MATTHIAS
24:                 * RINGWALD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
25:                 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
26:                 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
27:                 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
28:                 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
29:                 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
30:                 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
31:                 * SUCH DAMAGE.
32:                 *
33:                 * Please inquire about commercial licensing options at btstack@ringwald.ch
34:                 *
35:                 */
36:                
37:                /*
38:                 *  btstsack_memory.h
39:                 *
40:                 *  @brief BTstack memory management via configurable memory pools
41:                 *
42:                 *  @note code semi-atuomatically generated by btstack_memory_generator.py
43:                 *
44:                 */
45:                
46:                #include "btstack_memory.h"
47:                #include <btstack/memory_pool.h>
48:                
49:                #include <stdlib.h>
50:                
51:                #include "config.h"
52:                #include "hci.h"
53:                #include "l2cap.h"
54:                #include "rfcomm.h"
55:                
56:                // MARK: hci_connection_t
57:                #ifdef MAX_NO_HCI_CONNECTIONS
58:                #if MAX_NO_HCI_CONNECTIONS > 0
59:                static hci_connection_t hci_connection_storage[MAX_NO_HCI_CONNECTIONS];
60:                static memory_pool_t hci_connection_pool;
61:                void * btstack_memory_hci_connection_get(void){
62:                    return memory_pool_get(&hci_connection_pool);
0166E4  267740     MOV #0x6774, W0
0166E6  0465D6     GOTO memory_pool_get
0166E8  000001     NOP
63:                }
64:                void btstack_memory_hci_connection_free(void *hci_connection){
65:                    memory_pool_free(&hci_connection_pool, hci_connection);
016676  267740     MOV #0x6774, W0
016678  046732     GOTO memory_pool_free
01667A  000001     NOP
66:                }
67:                #else
68:                void * btstack_memory_hci_connection_get(void){
69:                    return NULL;
70:                }
71:                void btstack_memory_hci_connection_free(void *hci_connection){
72:                };
73:                #endif
74:                #elif defined(HAVE_MALLOC)
75:                void * btstack_memory_hci_connection_get(void){
76:                    return malloc(sizeof(hci_connection_t));
77:                }
78:                void  btstack_memory_hci_connection_free(void *hci_connection){
79:                    free(hci_connection);
80:                }
81:                #endif
82:                
83:                
84:                // MARK: l2cap_service_t
85:                #ifdef MAX_NO_L2CAP_SERVICES
86:                #if MAX_NO_L2CAP_SERVICES > 0
87:                static l2cap_service_t l2cap_service_storage[MAX_NO_L2CAP_SERVICES];
88:                static memory_pool_t l2cap_service_pool;
89:                void * btstack_memory_l2cap_service_get(void){
90:                    return memory_pool_get(&l2cap_service_pool);
0166EA  2675A0     MOV #0x675A, W0
0166EC  0465D6     GOTO memory_pool_get
0166EE  000001     NOP
91:                }
92:                void btstack_memory_l2cap_service_free(void *l2cap_service){
93:                    memory_pool_free(&l2cap_service_pool, l2cap_service);
01667E  2675A0     MOV #0x675A, W0
016680  046732     GOTO memory_pool_free
016682  000001     NOP
94:                }
95:                #else
96:                void * btstack_memory_l2cap_service_get(void){
97:                    return NULL;
98:                }
99:                void btstack_memory_l2cap_service_free(void *l2cap_service){
100:               };
101:               #endif
102:               #elif defined(HAVE_MALLOC)
103:               void * btstack_memory_l2cap_service_get(void){
104:                   return malloc(sizeof(l2cap_service_t));
105:               }
106:               void  btstack_memory_l2cap_service_free(void *l2cap_service){
107:                   free(l2cap_service);
108:               }
109:               #endif
110:               
111:               
112:               // MARK: l2cap_channel_t
113:               #ifdef MAX_NO_L2CAP_CHANNELS
114:               #if MAX_NO_L2CAP_CHANNELS > 0
115:               static l2cap_channel_t l2cap_channel_storage[MAX_NO_L2CAP_CHANNELS];
116:               static memory_pool_t l2cap_channel_pool;
117:               void * btstack_memory_l2cap_channel_get(void){
118:                   return memory_pool_get(&l2cap_channel_pool);
0166F0  267140     MOV #0x6714, W0
0166F2  0465D6     GOTO memory_pool_get
0166F4  000001     NOP
119:               }
120:               void btstack_memory_l2cap_channel_free(void *l2cap_channel){
121:                   memory_pool_free(&l2cap_channel_pool, l2cap_channel);
016686  267140     MOV #0x6714, W0
016688  046732     GOTO memory_pool_free
01668A  000001     NOP
122:               }
123:               #else
124:               void * btstack_memory_l2cap_channel_get(void){
125:                   return NULL;
126:               }
127:               void btstack_memory_l2cap_channel_free(void *l2cap_channel){
128:               };
129:               #endif
130:               #elif defined(HAVE_MALLOC)
131:               void * btstack_memory_l2cap_channel_get(void){
132:                   return malloc(sizeof(l2cap_channel_t));
133:               }
134:               void  btstack_memory_l2cap_channel_free(void *l2cap_channel){
135:                   free(l2cap_channel);
136:               }
137:               #endif
138:               
139:               
140:               // MARK: rfcomm_multiplexer_t
141:               #ifdef MAX_NO_RFCOMM_MULTIPLEXERS
142:               #if MAX_NO_RFCOMM_MULTIPLEXERS > 0
143:               static rfcomm_multiplexer_t rfcomm_multiplexer_storage[MAX_NO_RFCOMM_MULTIPLEXERS];
144:               static memory_pool_t rfcomm_multiplexer_pool;
145:               void * btstack_memory_rfcomm_multiplexer_get(void){
146:                   return memory_pool_get(&rfcomm_multiplexer_pool);
0166F6  266F20     MOV #0x66F2, W0
0166F8  0465D6     GOTO memory_pool_get
0166FA  000001     NOP
147:               }
148:               void btstack_memory_rfcomm_multiplexer_free(void *rfcomm_multiplexer){
149:                   memory_pool_free(&rfcomm_multiplexer_pool, rfcomm_multiplexer);
01668E  266F20     MOV #0x66F2, W0
016690  046732     GOTO memory_pool_free
016692  000001     NOP
150:               }
151:               #else
152:               void * btstack_memory_rfcomm_multiplexer_get(void){
153:                   return NULL;
154:               }
155:               void btstack_memory_rfcomm_multiplexer_free(void *rfcomm_multiplexer){
156:               };
157:               #endif
158:               #elif defined(HAVE_MALLOC)
159:               void * btstack_memory_rfcomm_multiplexer_get(void){
160:                   return malloc(sizeof(rfcomm_multiplexer_t));
161:               }
162:               void  btstack_memory_rfcomm_multiplexer_free(void *rfcomm_multiplexer){
163:                   free(rfcomm_multiplexer);
164:               }
165:               #endif
166:               
167:               
168:               // MARK: rfcomm_service_t
169:               #ifdef MAX_NO_RFCOMM_SERVICES
170:               #if MAX_NO_RFCOMM_SERVICES > 0
171:               static rfcomm_service_t rfcomm_service_storage[MAX_NO_RFCOMM_SERVICES];
172:               static memory_pool_t rfcomm_service_pool;
173:               void * btstack_memory_rfcomm_service_get(void){
174:                   return memory_pool_get(&rfcomm_service_pool);
0166FC  266E20     MOV #0x66E2, W0
0166FE  0465D6     GOTO memory_pool_get
016700  000001     NOP
175:               }
176:               void btstack_memory_rfcomm_service_free(void *rfcomm_service){
177:                   memory_pool_free(&rfcomm_service_pool, rfcomm_service);
016696  266E20     MOV #0x66E2, W0
016698  046732     GOTO memory_pool_free
01669A  000001     NOP
178:               }
179:               #else
180:               void * btstack_memory_rfcomm_service_get(void){
181:                   return NULL;
182:               }
183:               void btstack_memory_rfcomm_service_free(void *rfcomm_service){
184:               };
185:               #endif
186:               #elif defined(HAVE_MALLOC)
187:               void * btstack_memory_rfcomm_service_get(void){
188:                   return malloc(sizeof(rfcomm_service_t));
189:               }
190:               void  btstack_memory_rfcomm_service_free(void *rfcomm_service){
191:                   free(rfcomm_service);
192:               }
193:               #endif
194:               
195:               
196:               // MARK: rfcomm_channel_t
197:               #ifdef MAX_NO_RFCOMM_CHANNELS
198:               #if MAX_NO_RFCOMM_CHANNELS > 0
199:               static rfcomm_channel_t rfcomm_channel_storage[MAX_NO_RFCOMM_CHANNELS];
200:               static memory_pool_t rfcomm_channel_pool;
201:               void * btstack_memory_rfcomm_channel_get(void){
202:                   return memory_pool_get(&rfcomm_channel_pool);
016702  266BA0     MOV #0x66BA, W0
016704  0465D6     GOTO memory_pool_get
016706  000001     NOP
203:               }
204:               void btstack_memory_rfcomm_channel_free(void *rfcomm_channel){
205:                   memory_pool_free(&rfcomm_channel_pool, rfcomm_channel);
01669E  266BA0     MOV #0x66BA, W0
0166A0  046732     GOTO memory_pool_free
0166A2  000001     NOP
206:               }
207:               #else
208:               void * btstack_memory_rfcomm_channel_get(void){
209:                   return NULL;
210:               }
211:               void btstack_memory_rfcomm_channel_free(void *rfcomm_channel){
212:               };
213:               #endif
214:               #elif defined(HAVE_MALLOC)
215:               void * btstack_memory_rfcomm_channel_get(void){
216:                   return malloc(sizeof(rfcomm_channel_t));
217:               }
218:               void  btstack_memory_rfcomm_channel_free(void *rfcomm_channel){
219:                   free(rfcomm_channel);
220:               }
221:               #endif
222:               
223:               
224:               // MARK: db_mem_device_name_t
225:               #ifdef MAX_NO_DB_MEM_DEVICE_NAMES
226:               #if MAX_NO_DB_MEM_DEVICE_NAMES > 0
227:               static db_mem_device_name_t db_mem_device_name_storage[MAX_NO_DB_MEM_DEVICE_NAMES];
228:               static memory_pool_t db_mem_device_name_pool;
229:               void * btstack_memory_db_mem_device_name_get(void){
230:                   return memory_pool_get(&db_mem_device_name_pool);
231:               }
232:               void btstack_memory_db_mem_device_name_free(void *db_mem_device_name){
233:                   memory_pool_free(&db_mem_device_name_pool, db_mem_device_name);
234:               }
235:               #else
236:               void * btstack_memory_db_mem_device_name_get(void){
237:                   return NULL;
238:               }
239:               void btstack_memory_db_mem_device_name_free(void *db_mem_device_name){
240:               };
241:               #endif
242:               #elif defined(HAVE_MALLOC)
243:               void * btstack_memory_db_mem_device_name_get(void){
244:                   return malloc(sizeof(db_mem_device_name_t));
245:               }
246:               void  btstack_memory_db_mem_device_name_free(void *db_mem_device_name){
247:                   free(db_mem_device_name);
248:               }
249:               #endif
250:               
251:               
252:               // MARK: db_mem_device_link_key_t
253:               #ifdef MAX_NO_DB_MEM_DEVICE_LINK_KEYS
254:               #if MAX_NO_DB_MEM_DEVICE_LINK_KEYS > 0
255:               static db_mem_device_link_key_t db_mem_device_link_key_storage[MAX_NO_DB_MEM_DEVICE_LINK_KEYS];
256:               static memory_pool_t db_mem_device_link_key_pool;
257:               void * btstack_memory_db_mem_device_link_key_get(void){
258:                   return memory_pool_get(&db_mem_device_link_key_pool);
016708  266840     MOV #0x6684, W0
01670A  0465D6     GOTO memory_pool_get
01670C  000001     NOP
259:               }
260:               void btstack_memory_db_mem_device_link_key_free(void *db_mem_device_link_key){
261:                   memory_pool_free(&db_mem_device_link_key_pool, db_mem_device_link_key);
0166A6  266840     MOV #0x6684, W0
0166A8  046732     GOTO memory_pool_free
0166AA  000001     NOP
262:               }
263:               #else
264:               void * btstack_memory_db_mem_device_link_key_get(void){
265:                   return NULL;
266:               }
267:               void btstack_memory_db_mem_device_link_key_free(void *db_mem_device_link_key){
268:               };
269:               #endif
270:               #elif defined(HAVE_MALLOC)
271:               void * btstack_memory_db_mem_device_link_key_get(void){
272:                   return malloc(sizeof(db_mem_device_link_key_t));
273:               }
274:               void  btstack_memory_db_mem_device_link_key_free(void *db_mem_device_link_key){
275:                   free(db_mem_device_link_key);
276:               }
277:               #endif
278:               
279:               
280:               // MARK: db_mem_service_t
281:               #ifdef MAX_NO_DB_MEM_SERVICES
282:               #if MAX_NO_DB_MEM_SERVICES > 0
283:               static db_mem_service_t db_mem_service_storage[MAX_NO_DB_MEM_SERVICES];
284:               static memory_pool_t db_mem_service_pool;
285:               void * btstack_memory_db_mem_service_get(void){
286:                   return memory_pool_get(&db_mem_service_pool);
287:               }
288:               void btstack_memory_db_mem_service_free(void *db_mem_service){
289:                   memory_pool_free(&db_mem_service_pool, db_mem_service);
290:               }
291:               #else
292:               void * btstack_memory_db_mem_service_get(void){
293:                   return NULL;
294:               }
295:               void btstack_memory_db_mem_service_free(void *db_mem_service){
296:               };
297:               #endif
298:               #elif defined(HAVE_MALLOC)
299:               void * btstack_memory_db_mem_service_get(void){
300:                   return malloc(sizeof(db_mem_service_t));
301:               }
302:               void  btstack_memory_db_mem_service_free(void *db_mem_service){
303:                   free(db_mem_service);
304:               }
305:               #endif
306:               
307:               // init
308:               void btstack_memory_init(void){
309:               #if MAX_NO_HCI_CONNECTIONS > 0
310:                   memory_pool_create(&hci_connection_pool, hci_connection_storage, MAX_NO_HCI_CONNECTIONS, sizeof(hci_connection_t));
0147C8  201203     MOV #0x120, W3
0147CA  200012     MOV #0x1, W2
0147CC  267761     MOV #0x6776, W1
0147CE  267740     MOV #0x6774, W0
0147D0  026450     CALL memory_pool_create
0147D2  000001     NOP
311:               #endif
312:               #if MAX_NO_L2CAP_SERVICES > 0
313:                   memory_pool_create(&l2cap_service_pool, l2cap_service_storage, MAX_NO_L2CAP_SERVICES, sizeof(l2cap_service_t));
0147D4  2000C3     MOV #0xC, W3
0147D6  200022     MOV #0x2, W2
0147D8  2675C1     MOV #0x675C, W1
0147DA  2675A0     MOV #0x675A, W0
0147DC  026450     CALL memory_pool_create
0147DE  000001     NOP
314:               #endif
315:               #if MAX_NO_L2CAP_CHANNELS > 0
316:                   memory_pool_create(&l2cap_channel_pool, l2cap_channel_storage, MAX_NO_L2CAP_CHANNELS, sizeof(l2cap_channel_t));
0147E0  200223     MOV #0x22, W3
0147E2  200022     MOV #0x2, W2
0147E4  267161     MOV #0x6716, W1
0147E6  267140     MOV #0x6714, W0
0147E8  026450     CALL memory_pool_create
0147EA  000001     NOP
317:               #endif
318:               #if MAX_NO_RFCOMM_MULTIPLEXERS > 0
319:                   memory_pool_create(&rfcomm_multiplexer_pool, rfcomm_multiplexer_storage, MAX_NO_RFCOMM_MULTIPLEXERS, sizeof(rfcomm_multiplexer_t));
0147EC  200203     MOV #0x20, W3
0147EE  200012     MOV #0x1, W2
0147F0  266F41     MOV #0x66F4, W1
0147F2  266F20     MOV #0x66F2, W0
0147F4  026450     CALL memory_pool_create
0147F6  000001     NOP
320:               #endif
321:               #if MAX_NO_RFCOMM_SERVICES > 0
322:                   memory_pool_create(&rfcomm_service_pool, rfcomm_service_storage, MAX_NO_RFCOMM_SERVICES, sizeof(rfcomm_service_t));
0147F8  2000E3     MOV #0xE, W3
0147FA  200012     MOV #0x1, W2
0147FC  266E41     MOV #0x66E4, W1
0147FE  266E20     MOV #0x66E2, W0
014800  026450     CALL memory_pool_create
014802  000001     NOP
323:               #endif
324:               #if MAX_NO_RFCOMM_CHANNELS > 0
325:                   memory_pool_create(&rfcomm_channel_pool, rfcomm_channel_storage, MAX_NO_RFCOMM_CHANNELS, sizeof(rfcomm_channel_t));
014804  200263     MOV #0x26, W3
014806  200012     MOV #0x1, W2
014808  266BC1     MOV #0x66BC, W1
01480A  266BA0     MOV #0x66BA, W0
01480C  026450     CALL memory_pool_create
01480E  000001     NOP
326:               #endif
327:               #if MAX_NO_DB_MEM_DEVICE_NAMES > 0
328:                   memory_pool_create(&db_mem_device_name_pool, db_mem_device_name_storage, MAX_NO_DB_MEM_DEVICE_NAMES, sizeof(db_mem_device_name_t));
329:               #endif
330:               #if MAX_NO_DB_MEM_DEVICE_LINK_KEYS > 0
331:                   memory_pool_create(&db_mem_device_link_key_pool, db_mem_device_link_key_storage, MAX_NO_DB_MEM_DEVICE_LINK_KEYS, sizeof(db_mem_device_link_key_t));
014810  2001A3     MOV #0x1A, W3
014812  200022     MOV #0x2, W2
014814  266861     MOV #0x6686, W1
014816  266840     MOV #0x6684, W0
014818  046450     GOTO memory_pool_create
01481A  000001     NOP
332:               #endif
333:               #if MAX_NO_DB_MEM_SERVICES > 0
334:                   memory_pool_create(&db_mem_service_pool, db_mem_service_storage, MAX_NO_DB_MEM_SERVICES, sizeof(db_mem_service_t));
335:               #endif
336:               }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libadb/adb_packet.c  -----
01276A  FA0006     LNK #0x6
01276C  781F88     MOV W8, [W15++]
014DA0  FA0000     LNK #0x0
014DA2  BE9F88     MOV.D W8, [W15++]
014DA4  781F8A     MOV W10, [W15++]
014DA6  BE0400     MOV.D W0, W8
014DA8  BE0002     MOV.D W2, W0
014DAA  780506     MOV W6, W10
014DAC  97B90F     MOV [W15-16], W2
014DAE  97B99F     MOV [W15-14], W3
0154EA  BE9F88     MOV.D W8, [W15++]
0154EC  780300     MOV W0, W6
015C1C  781F88     MOV W8, [W15++]
015C1E  780400     MOV W0, W8
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include <assert.h>
31:                
32:                #include "adb_packet.h"
33:                #include "usb_host_android.h"
34:                #include "logging.h"
35:                
36:                #define CHANGE_STATE(var,state)              \
37:                do {                                         \
38:                  log_printf("%s set to %s", #var, #state);  \
39:                  var = state;                               \
40:                } while (0)
41:                
42:                ////////////////////////////////////////////////////////////////////////////////
43:                // Types
44:                ////////////////////////////////////////////////////////////////////////////////
45:                
46:                typedef struct {
47:                  UINT32 command;       /* command identifier constant      */
48:                  UINT32 arg0;          /* first argument                   */
49:                  UINT32 arg1;          /* second argument                  */
50:                  UINT32 data_length;   /* length of payload (0 is allowed) */
51:                  UINT32 data_check;    /* checksum of data payload         */
52:                  UINT32 magic;         /* command ^ 0xffffffff             */
53:                } ADB_PACKET_HEADER;
54:                
55:                typedef enum {
56:                  ADB_PACKET_STATE_START,
57:                  ADB_PACKET_STATE_WAIT_HEADER,
58:                  ADB_PACKET_STATE_WAIT_DATA,
59:                  ADB_PACKET_STATE_IDLE,
60:                  ADB_PACKET_STATE_ERROR
61:                } ADB_PACKET_STATE;
62:                
63:                ////////////////////////////////////////////////////////////////////////////////
64:                // Globals
65:                ////////////////////////////////////////////////////////////////////////////////
66:                
67:                static ADB_PACKET_HEADER adb_packet_send_header;
68:                static ADB_PACKET_HEADER adb_packet_recv_header;
69:                static ADB_PACKET_STATE adb_packet_send_state;
70:                static ADB_PACKET_STATE adb_packet_recv_state;
71:                static const BYTE* adb_packet_send_data;
72:                static BYTE adb_packet_recv_data[ADB_PACKET_MAX_RECV_DATA_BYTES];
73:                
74:                ////////////////////////////////////////////////////////////////////////////////
75:                // Functions & Macros
76:                ////////////////////////////////////////////////////////////////////////////////
77:                
78:                #define ADB_PACKET_STATE_BUSY(state) ((state) < ADB_PACKET_STATE_IDLE)
79:                
80:                static UINT32 ADBChecksum(const BYTE* data, UINT32 len) {
015C20  B83360     MUL.UU W6, #0, W6
015C22  BE0206     MOV.D W6, W4
015C24  370007     BRA 0x15C34
81:                  UINT32 sum = 0;
82:                  UINT32 i;
83:                  for (i = 0; i < len; ++i) {
015C30  420261     ADD W4, #0x1, W4
015C32  4A82E0     ADDC W5, #0x0, W5
015C34  520F82     SUB W4, W2, [W15]
015C36  5A8F83     SUBB W5, W3, [W15]
015C38  39FFF6     BRA NC, 0x15C26
84:                    sum += *(data++);
015C26  7A4068     MOV.B [W8+W4], W0
015C28  FB8000     ZE W0, W0
015C2A  200001     MOV #0x0, W1
015C2C  400306     ADD W0, W6, W6
015C2E  488387     ADDC W1, W7, W7
85:                  }
86:                  return sum;
87:                }
88:                
89:                static void ADBPacketSendTasks() {
90:                  BYTE ret_val;
91:                  switch (adb_packet_send_state) {
01276E  823078     MOV adb_packet_send_state, W8
012770  540FE1     SUB W8, #0x1, [W15]
012772  32000E     BRA Z, 0x12790
012774  390003     BRA NC, 0x1277C
012776  540FE2     SUB W8, #0x2, [W15]
012778  3A002E     BRA NZ, 0x127D6
01277A  370020     BRA 0x127BC
92:                   case ADB_PACKET_STATE_START:
93:                    if (USBHostAndroidWrite((BYTE*) &adb_packet_send_header,
01277C  200011     MOV #0x1, W1
01277E  200182     MOV #0x18, W2
012780  200003     MOV #0x0, W3
012782  246280     MOV #0x4628, W0
012784  025370     CALL USBHostAndroidWrite
012786  000001     NOP
012788  E00400     CP0.B W0
01278A  3A0021     BRA NZ, 0x127CE
94:                                            sizeof(ADB_PACKET_HEADER),
95:                                            ANDROID_INTERFACE_ADB) != USB_SUCCESS) {
96:                      CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_ERROR);
97:                      break;
98:                    }
99:                    CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_WAIT_HEADER);
01278C  200010     MOV #0x1, W0
01278E  370022     BRA 0x127D4
100:                   break;
101:               
102:                  case ADB_PACKET_STATE_WAIT_HEADER:
103:                   if (USBHostAndroidTxIsComplete(&ret_val, ANDROID_INTERFACE_ADB)) {
012790  780088     MOV W8, W1
012792  578068     SUB W15, #0x8, W0
012794  026136     CALL USBHostAndroidTxIsComplete
012796  000001     NOP
012798  E00000     CP0 W0
01279A  32001D     BRA Z, 0x127D6
104:                     if (ret_val != USB_SUCCESS) {
01279C  97F80F     MOV.B [W15-8], W0
01279E  E00400     CP0.B W0
0127A0  3A0016     BRA NZ, 0x127CE
105:                       CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_ERROR);
106:                       break;
107:                     }
108:                     if (adb_packet_send_header.data_length == 0) {
0127A2  8231A2     MOV 0x4634, W2
0127A4  8231B3     MOV 0x4636, W3
0127A6  510FE0     SUB W2, #0x0, [W15]
0127A8  598FE0     SUBB W3, #0x0, [W15]
0127AA  320013     BRA Z, 0x127D2
109:                       CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_IDLE);
110:                       break;
111:                     }
112:                     if (USBHostAndroidWrite(adb_packet_send_data,
0127AC  823050     MOV adb_packet_send_data, W0
0127AE  780088     MOV W8, W1
0127B0  025370     CALL USBHostAndroidWrite
0127B2  000001     NOP
0127B4  E00400     CP0.B W0
0127B6  3A000B     BRA NZ, 0x127CE
113:                                             adb_packet_send_header.data_length,
114:                                             ANDROID_INTERFACE_ADB) != USB_SUCCESS) {
115:                       CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_ERROR);
116:                       break;
117:                     }
118:                     CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_WAIT_DATA);
0127B8  200020     MOV #0x2, W0
0127BA  37000C     BRA 0x127D4
119:                   }
120:                   break;
121:               
122:                  case ADB_PACKET_STATE_WAIT_DATA:
123:                   if (USBHostAndroidTxIsComplete(&ret_val, ANDROID_INTERFACE_ADB)) {
0127BC  200011     MOV #0x1, W1
0127BE  578068     SUB W15, #0x8, W0
0127C0  026136     CALL USBHostAndroidTxIsComplete
0127C2  000001     NOP
0127C4  E00000     CP0 W0
0127C6  320007     BRA Z, 0x127D6
124:                     if (ret_val != USB_SUCCESS) {
0127C8  97F80F     MOV.B [W15-8], W0
0127CA  E00400     CP0.B W0
0127CC  320002     BRA Z, 0x127D2
125:                       CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_ERROR);
0127CE  200040     MOV #0x4, W0
0127D0  370001     BRA 0x127D4
126:                       break;
127:                     }
128:                     CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_IDLE);
0127D2  200030     MOV #0x3, W0
0127D4  8A3070     MOV W0, adb_packet_send_state
129:                   }
130:                   break;
131:               
132:                  case ADB_PACKET_STATE_IDLE:
133:                  case ADB_PACKET_STATE_ERROR:
134:                   break;
135:                 }
136:               }
137:               
138:               static void ADBPacketRecvTasks() {
139:                 BYTE ret_val;
140:                 DWORD bytes_received;
141:                 switch (adb_packet_recv_state) {
0127D6  823068     MOV adb_packet_recv_state, W8
0127D8  540FE1     SUB W8, #0x1, [W15]
0127DA  32000E     BRA Z, 0x127F8
0127DC  390003     BRA NC, 0x127E4
0127DE  540FE2     SUB W8, #0x2, [W15]
0127E0  3A004E     BRA NZ, 0x1287E
0127E2  370032     BRA 0x12848
142:                  case ADB_PACKET_STATE_START:
143:                   if (USBHostAndroidRead((BYTE*) &adb_packet_recv_header,
0127E4  200011     MOV #0x1, W1
0127E6  200182     MOV #0x18, W2
0127E8  200003     MOV #0x0, W3
0127EA  246100     MOV #0x4610, W0
0127EC  025138     CALL USBHostAndroidRead
0127EE  000001     NOP
0127F0  E00400     CP0.B W0
0127F2  3A0041     BRA NZ, 0x12876
144:                                          sizeof(ADB_PACKET_HEADER),
145:                                          ANDROID_INTERFACE_ADB) != USB_SUCCESS) {
146:                     CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_ERROR);
147:                     break;
148:                   }
149:                   CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_WAIT_HEADER);
0127F4  200010     MOV #0x1, W0
0127F6  370042     BRA 0x1287C
150:                   break;
151:               
152:                  case ADB_PACKET_STATE_WAIT_HEADER:
153:                   if (USBHostAndroidRxIsComplete(&ret_val, &bytes_received,
0127F8  780108     MOV W8, W2
0127FA  5780E6     SUB W15, #0x6, W1
0127FC  578068     SUB W15, #0x8, W0
0127FE  025EE2     CALL USBHostAndroidRxIsComplete
012800  000001     NOP
012802  E00000     CP0 W0
012804  32003C     BRA Z, 0x1287E
154:                                                  ANDROID_INTERFACE_ADB)) {
155:                     if (ret_val != USB_SUCCESS) {
012806  97F80F     MOV.B [W15-8], W0
012808  E00400     CP0.B W0
01280A  3A0035     BRA NZ, 0x12876
156:                       CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_ERROR);
157:                       break;
158:                     }
159:               // TODO: probably not needed
160:               //      if (bytes_received == 0) {
161:               //        adb_packet_recv_header.command = 0;
162:               //        CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_IDLE);
163:               //        break;
164:               //      }
165:                     if (bytes_received != sizeof(ADB_PACKET_HEADER)
01280C  97B85F     MOV [W15-6], W0
01280E  97B8EF     MOV [W15-4], W1
012810  500FF8     SUB W0, #0x18, [W15]
012812  588FE0     SUBB W1, #0x0, [W15]
012814  3A0030     BRA NZ, 0x12876
012816  823120     MOV 0x4624, W0
012818  823131     MOV 0x4626, W1
01281A  EA8000     COM W0, W0
01281C  EA8081     COM W1, W1
01281E  246102     MOV #0x4610, W2
012820  100FB2     SUBR W0, [W2++], [W15]
012822  188FA2     SUBBR W1, [W2--], [W15]
012824  3A0028     BRA NZ, 0x12876
012826  8230E2     MOV 0x461C, W2
012828  8230F3     MOV 0x461E, W3
01282A  210000     MOV #0x1000, W0
01282C  510F80     SUB W2, W0, [W15]
01282E  598FE0     SUBB W3, #0x0, [W15]
012830  3E0022     BRA GTU, 0x12876
166:                         || adb_packet_recv_header.command != (~adb_packet_recv_header.magic)
167:                         || adb_packet_recv_header.data_length > ADB_PACKET_MAX_RECV_DATA_BYTES) {
168:                       CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_ERROR);
169:                       break;
170:                     }
171:                     if (adb_packet_recv_header.data_length == 0) {
012832  510FE0     SUB W2, #0x0, [W15]
012834  598FE0     SUBB W3, #0x0, [W15]
012836  320021     BRA Z, 0x1287A
172:                       CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_IDLE);
173:                       break;
174:                     }
175:                     if (USBHostAndroidRead(adb_packet_recv_data,
012838  780088     MOV W8, W1
01283A  2360A0     MOV #0x360A, W0
01283C  025138     CALL USBHostAndroidRead
01283E  000001     NOP
012840  E00400     CP0.B W0
012842  3A0019     BRA NZ, 0x12876
176:                                            adb_packet_recv_header.data_length,
177:                                            ANDROID_INTERFACE_ADB) != USB_SUCCESS) {
178:                       CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_ERROR);
179:                       break;
180:                     }
181:                     CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_WAIT_DATA);
012844  200020     MOV #0x2, W0
012846  37001A     BRA 0x1287C
182:                   }
183:                   break;
184:               
185:                  case ADB_PACKET_STATE_WAIT_DATA:
186:                   if (USBHostAndroidRxIsComplete(&ret_val,
012848  200012     MOV #0x1, W2
01284A  5780E6     SUB W15, #0x6, W1
01284C  578068     SUB W15, #0x8, W0
01284E  025EE2     CALL USBHostAndroidRxIsComplete
012850  000001     NOP
012852  E00000     CP0 W0
012854  320014     BRA Z, 0x1287E
187:                                                  &bytes_received,
188:                                                  ANDROID_INTERFACE_ADB)) {
189:                     if (ret_val != USB_SUCCESS || bytes_received != adb_packet_recv_header.data_length) {
012856  97F80F     MOV.B [W15-8], W0
012858  E00400     CP0.B W0
01285A  3A000D     BRA NZ, 0x12876
01285C  97B95F     MOV [W15-6], W2
01285E  97B9EF     MOV [W15-4], W3
012860  2461C0     MOV #0x461C, W0
012862  510FB0     SUB W2, [W0++], [W15]
012864  598FA0     SUBB W3, [W0--], [W15]
012866  3A0007     BRA NZ, 0x12876
190:                       CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_ERROR);
191:                       break;
192:                     }
193:               
194:                     if (ADBChecksum(adb_packet_recv_data, adb_packet_recv_header.data_length) != adb_packet_recv_header.data_check) {
012868  2360A0     MOV #0x360A, W0
01286A  025C1C     CALL ADBChecksum
01286C  000001     NOP
01286E  246202     MOV #0x4620, W2
012870  500FB2     SUB W0, [W2++], [W15]
012872  588FA2     SUBB W1, [W2--], [W15]
012874  320002     BRA Z, 0x1287A
195:                       CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_ERROR);
012876  200040     MOV #0x4, W0
012878  370001     BRA 0x1287C
196:                       break;
197:                     }
198:               	    CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_IDLE);
01287A  200030     MOV #0x3, W0
01287C  8A3060     MOV W0, adb_packet_recv_state
199:                   }
200:                   break;
201:                  case ADB_PACKET_STATE_IDLE:
202:                  case ADB_PACKET_STATE_ERROR:
203:                   break;
204:                 }
205:               }
206:               
207:               void ADBPacketSend(UINT32 cmd, UINT32 arg0, UINT32 arg1, const void* data, UINT32 data_len) {
208:                 assert(!ADB_PACKET_STATE_BUSY(adb_packet_send_state));
209:                 adb_packet_send_header.command = cmd;
014DB0  8A3148     MOV W8, adb_packet_send_header
014DB2  8A3159     MOV W9, 0x462A
210:                 adb_packet_send_header.arg0 = arg0;
014DB4  8A3160     MOV W0, 0x462C
014DB6  8A3171     MOV W1, 0x462E
211:                 adb_packet_send_header.arg1 = arg1;
014DB8  8A3184     MOV W4, 0x4630
014DBA  8A3195     MOV W5, 0x4632
212:                 adb_packet_send_header.data_length = data_len;
014DBC  8A31A2     MOV W2, 0x4634
014DBE  8A31B3     MOV W3, 0x4636
213:                 adb_packet_send_header.data_check = ADBChecksum(data, data_len);
014DC0  780006     MOV W6, W0
014DC2  025C1C     CALL ADBChecksum
014DC4  000001     NOP
014DC6  8A31C0     MOV W0, 0x4638
014DC8  8A31D1     MOV W1, 0x463A
214:                 adb_packet_send_header.magic = ~cmd;
014DCA  EA8408     COM W8, W8
014DCC  EA8489     COM W9, W9
014DCE  8A31E8     MOV W8, 0x463C
014DD0  8A31F9     MOV W9, 0x463E
215:                 adb_packet_send_data = (const BYTE*) data;
014DD2  8A305A     MOV W10, adb_packet_send_data
216:                 CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_START);
014DD4  EB0000     CLR W0
014DD6  8A3070     MOV W0, adb_packet_send_state
217:               }
218:               
219:               ADB_RESULT ADBPacketSendStatus() {
220:                 if (ADB_PACKET_STATE_BUSY(adb_packet_send_state)) return ADB_RESULT_BUSY;
016464  823071     MOV adb_packet_send_state, W1
016466  200020     MOV #0x2, W0
016468  508F80     SUB W1, W0, [W15]
01646A  360004     BRA LEU, 0x16474
221:                 return adb_packet_send_state == ADB_PACKET_STATE_IDLE ? ADB_RESULT_OK : ADB_RESULT_ERROR;
01646C  6880E3     XOR W1, #0x3, W1
01646E  EA0001     NEG W1, W0
016470  700001     IOR W0, W1, W0
016472  DE004F     LSR W0, #15, W0
222:               }
223:               
224:               void ADBPacketRecv() {
225:                 assert(!ADB_PACKET_STATE_BUSY(adb_packet_recv_state));
226:                 CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_START);
0166DE  EB0000     CLR W0
0166E0  8A3060     MOV W0, adb_packet_recv_state
227:               }
228:               
229:               ADB_RESULT ADBPacketRecvStatus(UINT32* cmd, UINT32* arg0, UINT32* arg1, void** data, UINT32* data_len) {
230:                 if (ADB_PACKET_STATE_BUSY(adb_packet_recv_state)) return ADB_RESULT_BUSY;
0154EE  823065     MOV adb_packet_recv_state, W5
0154F0  200020     MOV #0x2, W0
0154F2  528F80     SUB W5, W0, [W15]
0154F4  360012     BRA LEU, 0x1551A
231:                 if (adb_packet_recv_state == ADB_PACKET_STATE_ERROR) return ADB_RESULT_ERROR;
0154F6  200010     MOV #0x1, W0
0154F8  528FE4     SUB W5, #0x4, [W15]
0154FA  32000F     BRA Z, 0x1551A
232:                 *cmd = adb_packet_recv_header.command;
0154FC  823088     MOV adb_packet_recv_header, W8
0154FE  823099     MOV 0x4612, W9
015500  BE8B08     MOV.D W8, [W6]
233:                 *arg0 = adb_packet_recv_header.arg0;
015502  8230A6     MOV 0x4614, W6
015504  8230B7     MOV 0x4616, W7
015506  BE8886     MOV.D W6, [W1]
234:                 *arg1 = adb_packet_recv_header.arg1;
015508  8230C8     MOV 0x4618, W8
01550A  8230D9     MOV 0x461A, W9
01550C  BE8908     MOV.D W8, [W2]
235:                 *data_len = adb_packet_recv_header.data_length;
01550E  8230E0     MOV 0x461C, W0
015510  8230F1     MOV 0x461E, W1
015512  BE8A00     MOV.D W0, [W4]
236:                 *data = adb_packet_recv_data;
015514  2360A0     MOV #0x360A, W0
015516  780980     MOV W0, [W3]
015518  EB0000     CLR W0
237:                 return ADB_RESULT_OK;
238:               }
239:               
240:               void ADBPacketReset() {
241:                 CHANGE_STATE(adb_packet_send_state, ADB_PACKET_STATE_IDLE);
01664C  200030     MOV #0x3, W0
01664E  8A3070     MOV W0, adb_packet_send_state
242:                 CHANGE_STATE(adb_packet_recv_state, ADB_PACKET_STATE_IDLE);
016650  8A3060     MOV W0, adb_packet_recv_state
243:               }
244:               
245:               void ADBPacketTasks() {
246:                 ADBPacketSendTasks();
247:                 ADBPacketRecvTasks();
248:               }
249:               
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libadb/adb_file.c  -------
0123EA  BE9F88     MOV.D W8, [W15++]
0123EC  BE9F8A     MOV.D W10, [W15++]
0123EE  BE9F8C     MOV.D W12, [W15++]
0123F0  780601     MOV W1, W12
0123F2  BE0402     MOV.D W2, W8
014564  BE9F88     MOV.D W8, [W15++]
014566  BE9F8A     MOV.D W10, [W15++]
014568  781F8C     MOV W12, [W15++]
01456A  780600     MOV W0, W12
01456C  780581     MOV W1, W11
0148C0  BE9F88     MOV.D W8, [W15++]
015C88  BE9F88     MOV.D W8, [W15++]
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include <assert.h>
31:                #include <string.h>
32:                #include "logging.h"
33:                #include "adb_file.h"
34:                
35:                #define CHANGE_STATE(var,state)              \
36:                do {                                         \
37:                  log_printf("%s set to %s", #var, #state);  \
38:                  var = state;                               \
39:                } while (0)
40:                
41:                #define MKID(a,b,c,d) (((UINT32) (a)) | (((UINT32) (b)) << 8) | (((UINT32) (c)) << 16) | (((UINT32) (d)) << 24))
42:                
43:                #define ID_STAT MKID('S','T','A','T')
44:                #define ID_LIST MKID('L','I','S','T')
45:                #define ID_ULNK MKID('U','L','N','K')
46:                #define ID_SEND MKID('S','E','N','D')
47:                #define ID_RECV MKID('R','E','C','V')
48:                #define ID_DENT MKID('D','E','N','T')
49:                #define ID_DONE MKID('D','O','N','E')
50:                #define ID_DATA MKID('D','A','T','A')
51:                #define ID_OKAY MKID('O','K','A','Y')
52:                #define ID_FAIL MKID('F','A','I','L')
53:                #define ID_QUIT MKID('Q','U','I','T')
54:                
55:                typedef union {
56:                    UINT32 id;
57:                    struct {
58:                        UINT32 id;
59:                        UINT32 namelen;
60:                    } req;
61:                    struct {
62:                        UINT32 id;
63:                        UINT32 mode;
64:                        UINT32 size;
65:                        UINT32 time;
66:                    } stat;
67:                    struct {
68:                        UINT32 id;
69:                        UINT32 mode;
70:                        UINT32 size;
71:                        UINT32 time;
72:                        UINT32 namelen;
73:                    } dent;
74:                    struct {
75:                        UINT32 id;
76:                        UINT32 size;
77:                    } data;
78:                    struct {
79:                        UINT32 id;
80:                        UINT32 msglen;
81:                    } status;    
82:                } adb_syncmsg;
83:                
84:                typedef struct {
85:                  UINT32 id;
86:                  UINT32 namelen;
87:                } adb_req;
88:                
89:                typedef enum {
90:                  ADB_FILE_STATE_FREE = 0,
91:                  ADB_FILE_STATE_WAIT_OPEN,
92:                  ADB_FILE_STATE_WAIT_HEADER,
93:                  ADB_FILE_STATE_WAIT_DATA,
94:                  ADB_FILE_STATE_WAIT_FAIL_DATA
95:                } ADB_FILE_STATE;
96:                
97:                typedef struct {
98:                  ADB_FILE_STATE state;
99:                  ADBFileRecvFunc func;
100:                 ADB_CHANNEL_HANDLE handle;
101:                 UINT32 read_remain;
102:                 adb_syncmsg msg;
103:                 adb_req req;
104:                 char path[ADB_FILE_MAX_PATH_LENGTH];
105:               } ADB_FILE;
106:               
107:               static ADB_FILE adb_files[ADB_FILE_MAX_FILES];
108:               static int adb_file_buffer_refcount;
109:               
110:               static void ADBFileCallback(ADB_CHANNEL_HANDLE h, const void* data, UINT32 data_len) {
0123F4  EB0680     CLR W13
0123F6  26EB21     MOV #0x6EB2, W1
0123F8  370004     BRA 0x12402
111:                 int i;
112:                 ADB_FILE* f;
113:                 for (i = 0; i < ADB_FILE_MAX_FILES && adb_files[i].handle != h; ++i);
0123FA  E8068D     INC W13, W13
0123FC  B00661     ADD #0x66, W1
0123FE  568FE2     SUB W13, #0x2, [W15]
012400  320002     BRA Z, 0x12406
012402  100F91     SUBR W0, [W1], [W15]
012404  3AFFFA     BRA NZ, 0x123FA
114:                 assert(i < ADB_FILE_MAX_FILES);
115:                 f = &adb_files[i];
012406  200660     MOV #0x66, W0
012408  B9E800     MUL.SS W13, W0, W0
01240A  26EAE2     MOV #0x6EAE, W2
01240C  410500     ADD W2, W0, W10
116:               
117:                 // handle unexpected channel closure
118:                 if (!data) goto error;
01240E  E0000C     CP0 W12
012410  32007B     BRA Z, error
119:               
120:                 // consume data
121:                 while (1) {
122:                   switch (f->state) {
012412  78001A     MOV [W10], W0
012414  500FE2     SUB W0, #0x2, [W15]
012416  320006     BRA Z, 0x12424
012418  390074     BRA NC, close_and_error
01241A  500FE3     SUB W0, #0x3, [W15]
01241C  320032     BRA Z, 0x12482
01241E  500FE4     SUB W0, #0x4, [W15]
012420  3AFFF8     BRA NZ, 0x12412
012422  370065     BRA 0x124EE
123:                    case ADB_FILE_STATE_FREE:
124:                    case ADB_FILE_STATE_WAIT_OPEN:
125:                     goto close_and_error;
126:                 
127:                    case ADB_FILE_STATE_WAIT_HEADER:
128:                     if (data_len >= f->read_remain) {
012424  90013A     MOV [W10+6], W2
012426  9001CA     MOV [W10+8], W3
012428  4505EA     ADD W10, #0xA, W11
01242A  540F82     SUB W8, W2, [W15]
01242C  5C8F83     SUBB W9, W3, [W15]
01242E  390022     BRA NC, 0x12474
129:                       memcpy(((BYTE*) &f->msg.data) + sizeof f->msg.data - f->read_remain, data, f->read_remain);
012430  558002     SUB W11, W2, W0
012432  400068     ADD W0, #0x8, W0
012434  78008C     MOV W12, W1
012436  0256DE     CALL memcpy
012438  000000     NOP
130:                       data = ((const BYTE*) data) + f->read_remain;
01243A  90003A     MOV [W10+6], W0
01243C  9000CA     MOV [W10+8], W1
01243E  460600     ADD W12, W0, W12
131:                       data_len -= f->read_remain;
012440  540400     SUB W8, W0, W8
012442  5C8481     SUBB W9, W1, W9
132:                       f->read_remain = f->msg.data.size;
012444  90007A     MOV [W10+14], W0
012446  90088A     MOV [W10+16], W1
012448  980530     MOV W0, [W10+6]
01244A  980541     MOV W1, [W10+8]
133:                       if (f->msg.data.id == ID_DATA || f->msg.data.id == ID_DONE) {
01244C  BE011B     MOV.D [W11], W2
01244E  241440     MOV #0x4144, W0
012450  241541     MOV #0x4154, W1
012452  510F80     SUB W2, W0, [W15]
012454  598F81     SUBB W3, W1, [W15]
012456  320005     BRA Z, 0x12462
012458  24F440     MOV #0x4F44, W0
01245A  2454E1     MOV #0x454E, W1
01245C  510F80     SUB W2, W0, [W15]
01245E  598F81     SUBB W3, W1, [W15]
012460  3A0002     BRA NZ, 0x12466
134:                         CHANGE_STATE(f->state, ADB_FILE_STATE_WAIT_DATA);
012462  200030     MOV #0x3, W0
012464  370037     BRA 0x124D4
135:                       } else if (f->msg.data.id == ID_FAIL) {
012466  241460     MOV #0x4146, W0
012468  24C491     MOV #0x4C49, W1
01246A  510F80     SUB W2, W0, [W15]
01246C  598F81     SUBB W3, W1, [W15]
01246E  3A0049     BRA NZ, close_and_error
136:                         CHANGE_STATE(f->state, ADB_FILE_STATE_WAIT_FAIL_DATA);
012470  200040     MOV #0x4, W0
012472  370030     BRA 0x124D4
137:                       } else {
138:                         goto close_and_error;
139:                       }
140:                     } else {
141:                       memcpy(((BYTE*) &f->msg.data) + sizeof f->msg.data - f->read_remain, data, data_len);
012474  558002     SUB W11, W2, W0
012476  400068     ADD W0, #0x8, W0
012478  780108     MOV W8, W2
01247A  78008C     MOV W12, W1
01247C  0256DE     CALL memcpy
01247E  000000     NOP
012480  370033     BRA 0x124E8
142:                       f->read_remain -= data_len; 
143:                       return;
144:                     }
145:                     break;
146:                 
147:                    case ADB_FILE_STATE_WAIT_DATA:
148:                     if (data_len >= f->read_remain) {
012482  90013A     MOV [W10+6], W2
012484  9001CA     MOV [W10+8], W3
012486  540F82     SUB W8, W2, [W15]
012488  5C8F83     SUBB W9, W3, [W15]
01248A  390026     BRA NC, 0x124D8
149:                       if (data_len > 0) {
01248C  540FE0     SUB W8, #0x0, [W15]
01248E  5C8FE0     SUBB W9, #0x0, [W15]
012490  320004     BRA Z, 0x1249A
150:                         f->func(i, data, f->read_remain);
012492  90021A     MOV [W10+2], W4
012494  78008C     MOV W12, W1
012496  78000D     MOV W13, W0
012498  010004     CALL W4
151:                       }
152:                       if (f->msg.id == ID_DONE) {
01249A  90015A     MOV [W10+10], W2
01249C  9001EA     MOV [W10+12], W3
01249E  90023A     MOV [W10+6], W4
0124A0  9002CA     MOV [W10+8], W5
0124A2  24F440     MOV #0x4F44, W0
0124A4  2454E1     MOV #0x454E, W1
0124A6  510F80     SUB W2, W0, [W15]
0124A8  598F81     SUBB W3, W1, [W15]
0124AA  3A000C     BRA NZ, 0x124C4
153:                         if (data_len != f->read_remain) goto close_and_error;
0124AC  540F84     SUB W8, W4, [W15]
0124AE  5C8F85     SUBB W9, W5, [W15]
0124B0  3A0028     BRA NZ, close_and_error
154:                         // success - EOF
155:                         f->func(i, NULL, 0);
0124B2  90021A     MOV [W10+2], W4
0124B4  B81160     MUL.UU W2, #0, W2
0124B6  EB0080     CLR W1
0124B8  78000D     MOV W13, W0
0124BA  010004     CALL W4
156:                         ADBClose(f->handle);
0124BC  90002A     MOV [W10+4], W0
0124BE  0262C8     CALL ADBClose
0124C0  000001     NOP
0124C2  370028     BRA 0x12514
157:                         memset(f, 0, sizeof(ADB_FILE));
158:                         return;
159:                       } else {
160:                         data = ((const BYTE*) data) + f->read_remain;
0124C4  460604     ADD W12, W4, W12
161:                         data_len -= f->read_remain;
0124C6  540404     SUB W8, W4, W8
0124C8  5C8485     SUBB W9, W5, W9
162:                         f->read_remain = sizeof f->msg.data;
0124CA  200080     MOV #0x8, W0
0124CC  200001     MOV #0x0, W1
0124CE  980530     MOV W0, [W10+6]
0124D0  980541     MOV W1, [W10+8]
163:                         CHANGE_STATE(f->state, ADB_FILE_STATE_WAIT_HEADER);
0124D2  200020     MOV #0x2, W0
0124D4  780D00     MOV W0, [W10]
0124D6  37FF9D     BRA 0x12412
164:                       }
165:                     } else {
166:                       if (data_len > 0) {
0124D8  540FE0     SUB W8, #0x0, [W15]
0124DA  5C8FE0     SUBB W9, #0x0, [W15]
0124DC  320005     BRA Z, 0x124E8
167:                         f->func(i, data, data_len);
0124DE  90021A     MOV [W10+2], W4
0124E0  BE0108     MOV.D W8, W2
0124E2  78008C     MOV W12, W1
0124E4  78000D     MOV W13, W0
0124E6  010004     CALL W4
168:                       }
169:                       f->read_remain -= data_len;
0124E8  90003A     MOV [W10+6], W0
0124EA  9000CA     MOV [W10+8], W1
0124EC  370005     BRA 0x124F8
170:                       return;
171:                     }
172:                     break;
173:               
174:                    case ADB_FILE_STATE_WAIT_FAIL_DATA:
175:                     if (data_len >= f->read_remain) {
0124EE  90003A     MOV [W10+6], W0
0124F0  9000CA     MOV [W10+8], W1
0124F2  540F80     SUB W8, W0, [W15]
0124F4  5C8F81     SUBB W9, W1, [W15]
0124F6  310005     BRA C, close_and_error
176:                       goto close_and_error;
177:                     } else {
178:                       f->read_remain -= data_len;
0124F8  500008     SUB W0, W8, W0
0124FA  588089     SUBB W1, W9, W1
0124FC  980530     MOV W0, [W10+6]
0124FE  980541     MOV W1, [W10+8]
012500  37000E     BRA 0x1251E
179:                       return;
180:                     }
181:                     break;
182:                   }
183:                 }
184:                 return;
185:               
186:               close_and_error:
187:                 ADBClose(f->handle);
012502  90002A     MOV [W10+4], W0
012504  0262C8     CALL ADBClose
012506  000001     NOP
188:               error:
189:                 log_printf("Failed to open or read file %s", f->path);
190:                 f->func(i, NULL, 1);
012508  90021A     MOV [W10+2], W4
01250A  200012     MOV #0x1, W2
01250C  200003     MOV #0x0, W3
01250E  EB0080     CLR W1
012510  78000D     MOV W13, W0
012512  010004     CALL W4
191:                 memset(f, 0, sizeof(ADB_FILE));
012514  200662     MOV #0x66, W2
012516  EB0080     CLR W1
012518  78000A     MOV W10, W0
01251A  025720     CALL memset
01251C  000000     NOP
192:               }
193:               
194:               ADB_FILE_HANDLE ADBFileRead(const char* path, ADBChannelRecvFunc recv_func) {
01456E  EB0500     CLR W10
014570  26EAE0     MOV #0x6EAE, W0
014572  370004     BRA 0x1457C
195:                 int i;
196:                 assert(path != NULL);
197:                 assert(strlen(path) < ADB_FILE_MAX_PATH_LENGTH);
198:                 for (i = 0; i < ADB_FILE_MAX_FILES && adb_files[i].state != ADB_FILE_STATE_FREE; ++i);
014574  E8050A     INC W10, W10
014576  B00660     ADD #0x66, W0
014578  550FE2     SUB W10, #0x2, [W15]
01457A  32001A     BRA Z, 0x145B0
01457C  E00010     CP0 [W0]
01457E  3AFFFA     BRA NZ, 0x14574
199:                 if (i == ADB_FILE_MAX_FILES) {
200:                   log_printf("Exceeded maximum number of open files: %d", ADB_FILE_MAX_FILES);
201:                   return ADB_FILE_INVALID_HANDLE;
202:                 }
203:                 if ((adb_files[i].handle = ADBOpen("sync:", &ADBFileCallback)) == ADB_INVALID_CHANNEL_HANDLE) {
014580  252F81     MOV #0x52F8, W1
014582  271060     MOV #0x7106, W0
014584  023D4C     CALL ADBOpen
014586  000001     NOP
014588  200662     MOV #0x66, W2
01458A  B9D102     MUL.SS W10, W2, W2
01458C  780402     MOV W2, W8
01458E  4100E4     ADD W2, #0x4, W1
014590  26EAE9     MOV #0x6EAE, W9
014592  78B480     MOV W0, [W9+W1]
014594  400FE1     ADD W0, #0x1, [W15]
014596  32000C     BRA Z, 0x145B0
204:                   log_printf("Failed to open ADB channel to sync:");
205:                   return ADB_FILE_INVALID_HANDLE;
206:                 }
207:                 adb_files[i].func = recv_func;
014598  E88002     INC2 W2, W0
01459A  78348B     MOV W11, [W9+W0]
208:                 strncpy(adb_files[i].path, path, ADB_FILE_MAX_PATH_LENGTH);
01459C  200260     MOV #0x26, W0
01459E  400002     ADD W0, W2, W0
0145A0  400009     ADD W0, W9, W0
0145A2  200402     MOV #0x40, W2
0145A4  78008C     MOV W12, W1
0145A6  02575C     CALL strncpy
0145A8  000000     NOP
209:                 CHANGE_STATE(adb_files[i].state, ADB_FILE_STATE_WAIT_OPEN);
0145AA  200010     MOV #0x1, W0
0145AC  7C3480     MOV W0, [W9+W8]
0145AE  370001     BRA 0x145B2
210:                 log_printf("Success opening file %s. Handle is %d", path, i);
211:                 return i;
0145B0  EB8500     SETM W10
212:               }
213:               
214:               void ADBFileClose(ADB_FILE_HANDLE h) {
215:                 log_printf("Closing file %d", h);
216:                 assert(h >= 0 && h < ADB_FILE_MAX_FILES);
217:                 ADB_FILE* f = &adb_files[h];
015C8A  200669     MOV #0x66, W9
015C8C  B98109     MUL.SS W0, W9, W2
015C8E  26EAE0     MOV #0x6EAE, W0
015C90  400402     ADD W0, W2, W8
218:                 if (f->state != ADB_FILE_STATE_FREE) {
015C92  E00018     CP0 [W8]
015C94  320008     BRA Z, 0x15CA6
219:                   ADBClose(f->handle);
015C96  900028     MOV [W8+4], W0
015C98  0262C8     CALL ADBClose
015C9A  000001     NOP
220:                   memset(f, 0, sizeof(ADB_FILE));
015C9C  780109     MOV W9, W2
015C9E  EB0080     CLR W1
015CA0  780008     MOV W8, W0
015CA2  025720     CALL memset
015CA4  000000     NOP
221:                 }
222:               }
223:               
224:               void ADBFileInit() {
225:                 memset(adb_files, 0, sizeof adb_files);
0164CE  200CC2     MOV #0xCC, W2
0164D0  EB0080     CLR W1
0164D2  26EAE0     MOV #0x6EAE, W0
0164D4  025720     CALL memset
0164D6  000000     NOP
226:                 adb_file_buffer_refcount = 0;
0164D8  EB0000     CLR W0
0164DA  8B7560     MOV W0, adb_file_buffer_refcount
227:               }
228:               
229:               void ADBFileTasks() {
0148C2  26EAE8     MOV #0x6EAE, W8
0148CA  4404E4     ADD W8, #0x4, W9
230:                 int i;
231:                 for (i = 0; i < ADB_FILE_MAX_FILES; ++i) {
014906  26F7A0     MOV #0x6F7A, W0
014908  540F80     SUB W8, W0, [W15]
01490A  3AFFDC     BRA NZ, 0x148C4
232:                   ADB_FILE* f = &adb_files[i];
233:                   if (f->state == ADB_FILE_STATE_WAIT_OPEN && ADBChannelReady(f->handle)) {
0148C4  200010     MOV #0x1, W0
0148C6  100F98     SUBR W0, [W8], [W15]
0148C8  3A001D     BRA NZ, 0x14904
0148CC  780019     MOV [W9], W0
0148CE  025E42     CALL ADBChannelReady
0148D0  000001     NOP
0148D2  E00000     CP0 W0
0148D4  320017     BRA Z, 0x14904
234:                     f->req.id = ID_RECV;
0148D6  245520     MOV #0x4552, W0
0148D8  256431     MOV #0x5643, W1
0148DA  980C70     MOV W0, [W8+30]
0148DC  981401     MOV W1, [W8+32]
235:                     f->req.namelen = strlen(f->path);
0148DE  200260     MOV #0x26, W0
0148E0  400008     ADD W0, W8, W0
0148E2  02578A     CALL strlen
0148E4  000000     NOP
0148E6  200001     MOV #0x0, W1
0148E8  981410     MOV W0, [W8+34]
0148EA  981421     MOV W1, [W8+36]
236:                     ADBWrite(f->handle, &f->req, sizeof f->req + f->req.namelen);
0148EC  400168     ADD W0, #0x8, W2
0148EE  4881E0     ADDC W1, #0x0, W3
0148F0  4400FE     ADD W8, #0x1E, W1
0148F2  780019     MOV [W9], W0
0148F4  0262DE     CALL ADBWrite
0148F6  000001     NOP
237:                     f->read_remain = sizeof f->msg.data;
0148F8  200080     MOV #0x8, W0
0148FA  200001     MOV #0x0, W1
0148FC  980430     MOV W0, [W8+6]
0148FE  980441     MOV W1, [W8+8]
238:                     CHANGE_STATE(f->state, ADB_FILE_STATE_WAIT_HEADER);
014900  200020     MOV #0x2, W0
014902  780C00     MOV W0, [W8]
014904  B00668     ADD #0x66, W8
239:                   }
240:                 }
241:               }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/libadb/adb.c  ------------
010632  FA0012     LNK #0x12
010634  BE9F88     MOV.D W8, [W15++]
010636  BE9F8A     MOV.D W10, [W15++]
013D4C  BE9F88     MOV.D W8, [W15++]
013D4E  BE9F8A     MOV.D W10, [W15++]
013D50  BE9F8C     MOV.D W12, [W15++]
013D52  780200     MOV W0, W4
013D54  780681     MOV W1, W13
0155BA  BE9F88     MOV.D W8, [W15++]
015E42  780080     MOV W0, W1
0162C8  780080     MOV W0, W1
0162DE  780200     MOV W0, W4
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include <string.h>
31:                #include <assert.h>
32:                
33:                #include "adb_private.h"
34:                #include "adb_packet.h"
35:                #include "usb_host_android.h"
36:                #include "logging.h"
37:                
38:                #define CHANGE_CHANNEL_STATE(ch,st)                          \
39:                  do {                                                       \
40:                    log_printf("Channel %d state changed to %s", ch, #st);  \
41:                    adb_channels[ch].state = st;                             \
42:                  } while (0)
43:                
44:                #define CHANGE_STATE(var,state)              \
45:                do {                                         \
46:                  log_printf("%s set to %s", #var, #state);  \
47:                  var = state;                               \
48:                } while (0)
49:                
50:                
51:                ////////////////////////////////////////////////////////////////////////////////
52:                // Constants
53:                ////////////////////////////////////////////////////////////////////////////////
54:                
55:                // ADB protocol defines
56:                #define ADB_CNXN 0x4e584e43
57:                #define ADB_OPEN 0x4e45504f
58:                #define ADB_OKAY 0x59414b4f
59:                #define ADB_CLSE 0x45534c43
60:                #define ADB_WRTE 0x45545257
61:                
62:                #define ADB_VERSION 0x01000000        // ADB protocol version
63:                
64:                ////////////////////////////////////////////////////////////////////////////////
65:                // Types
66:                ////////////////////////////////////////////////////////////////////////////////
67:                
68:                typedef enum {
69:                  ADB_CONN_STATE_ERROR,
70:                  ADB_CONN_STATE_WAIT_ATTACH,
71:                  ADB_CONN_STATE_WAIT_CONNECT,
72:                  ADB_CONN_STATE_CONNECTED
73:                } ADB_CONN_STATE;
74:                
75:                typedef enum {
76:                  ADB_CHAN_STATE_FREE = 0,
77:                  ADB_CHAN_STATE_START,
78:                  ADB_CHAN_STATE_WAIT_OPEN,
79:                  ADB_CHAN_STATE_IDLE,
80:                  ADB_CHAN_STATE_WAIT_READY,
81:                  ADB_CHAN_STATE_CLOSE_REQUESTED,
82:                  ADB_CHAN_STATE_WAIT_CLOSE,
83:                } ADB_CHAN_STATE;
84:                
85:                typedef struct {
86:                  ADB_CHAN_STATE state;
87:                  const void* data;
88:                  UINT32 data_len;
89:                  char name[ADB_CHANNEL_NAME_MAX_LENGTH];
90:                  UINT32 local_id;
91:                  UINT32 remote_id;
92:                  BOOL pending_ack;
93:                  ADBChannelRecvFunc recv_func;
94:                } ADB_CHANNEL;
95:                
96:                ////////////////////////////////////////////////////////////////////////////////
97:                // Globals
98:                ////////////////////////////////////////////////////////////////////////////////
99:                static ADB_CONN_STATE adb_conn_state;
100:               static ADB_CHANNEL adb_channels[ADB_MAX_CHANNELS];
101:               static char ADB_HOSTNAME_STRING[] = "host::";  // Leave non-const. USB stack
102:                                                              // doesn't work from ROM.
103:               static unsigned int adb_buffer_refcount;
104:               static UINT32 local_id_counter = 1;  // used for allocating unique local ids.
105:               
106:               ////////////////////////////////////////////////////////////////////////////////
107:               // Functions & Macros
108:               ////////////////////////////////////////////////////////////////////////////////
109:               
110:               BOOL ADBAttached() {
0166D8  838580     MOV 0x70B0, W0
0166DA  600061     AND W0, #0x1, W0
111:                 return USBHostAndroidIsInterfaceAttached(ANDROID_INTERFACE_ADB);
112:               }
113:               
114:               BOOL ADBConnected() {
016518  EB0080     CLR W1
01651A  833410     MOV adb_conn_state, W0
01651C  500FE2     SUB W0, #0x2, [W15]
01651E  360001     BRA LEU, 0x16522
016520  200011     MOV #0x1, W1
115:                 return adb_conn_state > ADB_CONN_STATE_WAIT_CONNECT;
116:               }
117:               
118:               static void ADBReset() {
0155BC  EB0480     CLR W9
0155BE  263E28     MOV #0x63E2, W8
119:                 // close all open channels
120:                 ADB_CHANNEL_HANDLE h;
121:                 for (h = 0; h < ADB_MAX_CHANNELS; ++h) {
0155CE  E80489     INC W9, W9
0155D0  B00548     ADD #0x54, W8
0155D2  548FE8     SUB W9, #0x8, [W15]
0155D4  3AFFF5     BRA NZ, 0x155C0
122:                   if (adb_channels[h].state != ADB_CHAN_STATE_FREE) {
0155C0  E00018     CP0 [W8]
0155C2  320005     BRA Z, 0x155CE
123:                     adb_channels[h].recv_func(h, NULL, 0);
0155C4  902A18     MOV [W8+82], W4
0155C6  B81160     MUL.UU W2, #0, W2
0155C8  EB0080     CLR W1
0155CA  780009     MOV W9, W0
0155CC  010004     CALL W4
124:                   }
125:                 }
126:                 memset(adb_channels, 0, sizeof adb_channels);
0155D6  202A02     MOV #0x2A0, W2
0155D8  EB0080     CLR W1
0155DA  263E20     MOV #0x63E2, W0
0155DC  025720     CALL memset
0155DE  000000     NOP
127:                 adb_buffer_refcount = 0;
0155E0  EB0000     CLR W0
0155E2  8B1F00     MOV W0, adb_buffer_refcount
128:                 CHANGE_STATE(adb_conn_state, ADB_CONN_STATE_WAIT_ATTACH);
0155E4  200010     MOV #0x1, W0
0155E6  8B3410     MOV W0, adb_conn_state
129:               }
130:               
131:               void ADBBufferRef() {
132:                 ++adb_buffer_refcount;
016644  831F00     MOV adb_buffer_refcount, W0
016646  E80000     INC W0, W0
016648  8B1F00     MOV W0, adb_buffer_refcount
133:               }
134:               
135:               void ADBBufferUnref() {
136:                 assert(adb_buffer_refcount);
137:                 --adb_buffer_refcount;
01611C  831F00     MOV adb_buffer_refcount, W0
01611E  E90080     DEC W0, W1
016120  8B1F01     MOV W1, adb_buffer_refcount
138:                 if (adb_conn_state < ADB_CONN_STATE_WAIT_CONNECT) return;
016122  833410     MOV adb_conn_state, W0
016124  500FE1     SUB W0, #0x1, [W15]
016126  360006     BRA LEU, 0x16134
139:                 if (adb_buffer_refcount == 0) {
016128  E00001     CP0 W1
01612A  3A0004     BRA NZ, 0x16134
140:                   adb_buffer_refcount = 1;
01612C  200010     MOV #0x1, W0
01612E  8B1F00     MOV W0, adb_buffer_refcount
141:                   ADBPacketRecv();
142:                 }
143:               }
144:               
145:               static void ADBChannelTasks() {
146:                 static ADB_CHANNEL_HANDLE current_channel = 0;
147:                 ADB_RESULT adb_res;
148:                 ADB_CHANNEL_HANDLE h;
149:                 if ((adb_res = ADBPacketSendStatus()) == ADB_RESULT_BUSY) return;
0107C2  026464     CALL ADBPacketSendStatus
0107C4  000001     NOP
0107C6  500FE2     SUB W0, #0x2, [W15]
0107C8  320073     BRA Z, 0x108B0
150:                 if (adb_res == ADB_RESULT_ERROR) {
0107CA  500FE1     SUB W0, #0x1, [W15]
0107CC  3A0003     BRA NZ, 0x107D4
151:                   CHANGE_STATE(adb_conn_state, ADB_CONN_STATE_ERROR);
0107CE  EB0000     CLR W0
0107D0  8B3410     MOV W0, adb_conn_state
0107D2  37006E     BRA 0x108B0
0107D4  831EF2     MOV 0x63DE, W2
0107D6  200083     MOV #0x8, W3
152:                   return;
153:                 }
154:                 for (h = 0; h < ADB_MAX_CHANNELS; ++h) {
01080E  3AFFE4     BRA NZ, 0x107D8
010810  8B1EF2     MOV W2, 0x63DE
010812  37004E     BRA 0x108B0
155:                   if (++current_channel == ADB_MAX_CHANNELS) current_channel = 0;
0107D8  E80102     INC W2, W2
0107DA  510FE8     SUB W2, #0x8, [W15]
0107DC  3A0001     BRA NZ, 0x107E0
0107DE  EB0100     CLR W2
156:                   if (adb_channels[current_channel].state == ADB_CHAN_STATE_FREE) {
0107E0  20054B     MOV #0x54, W11
0107E2  B9900B     MUL.SS W2, W11, W0
0107E4  780480     MOV W0, W9
0107E6  263E2A     MOV #0x63E2, W10
0107E8  7800EA     MOV [W10+W0], W1
0107EA  E00001     CP0 W1
0107EC  32000F     BRA Z, 0x1080C
157:                     continue;
158:                   }
159:                   if (adb_channels[current_channel].state == ADB_CHAN_STATE_START) {
0107EE  508FE1     SUB W1, #0x1, [W15]
0107F0  320048     BRA Z, 0x10882
010882  8B1EF2     MOV W2, 0x63DE
160:                     ADBPacketSend(ADB_OPEN, adb_channels[current_channel].local_id, 0, adb_channels[current_channel].name, strlen(adb_channels[current_channel].name) + 1);
010884  448468     ADD W9, #0x8, W8
010886  44040A     ADD W8, W10, W8
010888  B00489     ADD #0x48, W9
01088A  44848A     ADD W9, W10, W9
01088C  780008     MOV W8, W0
01088E  02578A     CALL strlen
010890  000000     NOP
010892  E80000     INC W0, W0
010894  200001     MOV #0x0, W1
010896  BE9F80     MOV.D W0, [W15++]
010898  780308     MOV W8, W6
01089A  B82260     MUL.UU W4, #0, W4
01089C  BE0119     MOV.D [W9], W2
01089E  2504F0     MOV #0x504F, W0
0108A0  24E451     MOV #0x4E45, W1
0108A2  024DA0     CALL ADBPacketSend
0108A4  000001     NOP
161:                     CHANGE_CHANNEL_STATE(current_channel, ADB_CHAN_STATE_WAIT_OPEN);
0108A6  831EF0     MOV 0x63DE, W0
0108A8  B9800B     MUL.SS W0, W11, W0
0108AA  200022     MOV #0x2, W2
0108AC  783502     MOV W2, [W10+W0]
0108AE  5787E4     SUB W15, #0x4, W15
162:                     return;
163:                   }
164:                   if (adb_channels[current_channel].pending_ack) {
0107F2  200500     MOV #0x50, W0
0107F4  400009     ADD W0, W9, W0
0107F6  78036A     MOV [W10+W0], W6
0107F8  E00006     CP0 W6
0107FA  3A0010     BRA NZ, 0x1081C
01081C  8B1EF2     MOV W2, 0x63DE
165:                     ADBPacketSend(ADB_OKAY, adb_channels[current_channel].local_id, adb_channels[current_channel].remote_id, NULL, 0);
01081E  44800A     ADD W9, W10, W0
010820  B81160     MUL.UU W2, #0, W2
010822  BE9F82     MOV.D W2, [W15++]
010824  EB0300     CLR W6
010826  902260     MOV [W0+76], W4
010828  9022F0     MOV [W0+78], W5
01082A  902140     MOV [W0+72], W2
01082C  9021D0     MOV [W0+74], W3
01082E  24B4F0     MOV #0x4B4F, W0
010830  259411     MOV #0x5941, W1
010832  024DA0     CALL ADBPacketSend
010834  000001     NOP
166:                     adb_channels[current_channel].pending_ack = FALSE;
010836  831EF0     MOV 0x63DE, W0
010838  B9800B     MUL.SS W0, W11, W0
01083A  B00500     ADD #0x50, W0
01083C  EB0100     CLR W2
01083E  370036     BRA 0x108AC
167:                     return;
168:                   }
169:                   if (adb_channels[current_channel].state == ADB_CHAN_STATE_CLOSE_REQUESTED) {
0107FC  508FE5     SUB W1, #0x5, [W15]
0107FE  320020     BRA Z, 0x10840
010840  8B1EF2     MOV W2, 0x63DE
170:                     ADBPacketSend(ADB_CLSE, adb_channels[current_channel].local_id, adb_channels[current_channel].remote_id, NULL, 0);
010842  44800A     ADD W9, W10, W0
010844  B82260     MUL.UU W4, #0, W4
010846  BE9F84     MOV.D W4, [W15++]
010848  902260     MOV [W0+76], W4
01084A  9022F0     MOV [W0+78], W5
01084C  902140     MOV [W0+72], W2
01084E  9021D0     MOV [W0+74], W3
010850  24C430     MOV #0x4C43, W0
010852  245531     MOV #0x4553, W1
010854  024DA0     CALL ADBPacketSend
010856  000001     NOP
171:                     CHANGE_CHANNEL_STATE(current_channel, ADB_CHAN_STATE_WAIT_CLOSE);
010858  831EF0     MOV 0x63DE, W0
01085A  B9800B     MUL.SS W0, W11, W0
01085C  200062     MOV #0x6, W2
01085E  370026     BRA 0x108AC
172:                     return;
173:                   }
174:                   if (adb_channels[current_channel].state == ADB_CHAN_STATE_IDLE
010800  508FE3     SUB W1, #0x3, [W15]
010802  3A0004     BRA NZ, 0x1080C
010804  E88009     INC2 W9, W0
010806  78036A     MOV [W10+W0], W6
010808  E00006     CP0 W6
01080A  3A002A     BRA NZ, 0x10860
010860  8B1EF2     MOV W2, 0x63DE
175:                       && adb_channels[current_channel].data != NULL) {
176:                     ADBPacketSend(ADB_WRTE, adb_channels[current_channel].local_id, adb_channels[current_channel].remote_id, adb_channels[current_channel].data, adb_channels[current_channel].data_len);
010862  44808A     ADD W9, W10, W1
010864  900221     MOV [W1+4], W4
010866  9002B1     MOV [W1+6], W5
010868  BE9F84     MOV.D W4, [W15++]
01086A  902261     MOV [W1+76], W4
01086C  9022F1     MOV [W1+78], W5
01086E  902141     MOV [W1+72], W2
010870  9021D1     MOV [W1+74], W3
010872  252570     MOV #0x5257, W0
010874  245541     MOV #0x4554, W1
010876  024DA0     CALL ADBPacketSend
010878  000001     NOP
177:                     CHANGE_CHANNEL_STATE(current_channel, ADB_CHAN_STATE_WAIT_READY);
01080C  E90183     DEC W3, W3
01087A  831EF0     MOV 0x63DE, W0
01087C  B9800B     MUL.SS W0, W11, W0
01087E  200042     MOV #0x4, W2
010880  370015     BRA 0x108AC
178:                     return;
179:                   }
180:                 }
181:               }
182:               
183:               static void ADBHandlePacket(UINT32 cmd, UINT32 arg0, UINT32 arg1, const void* recv_data, UINT32 data_len) {
184:                 int h = arg1 & 0xFF;
01067E  780486     MOV W6, W9
010680  B20FF9     AND #0xFF, W9
185:                 switch(cmd) {
010682  97B24F     MOV [W15-24], W4
010684  97B2DF     MOV [W15-22], W5
010686  252570     MOV #0x5257, W0
010688  245541     MOV #0x4554, W1
01068A  520F80     SUB W4, W0, [W15]
01068C  5A8F81     SUBB W5, W1, [W15]
01068E  320053     BRA Z, 0x10736
010690  3E0006     BRA GTU, 0x1069E
010692  24C430     MOV #0x4C43, W0
010694  245531     MOV #0x4553, W1
010696  520F80     SUB W4, W0, [W15]
010698  5A8F81     SUBB W5, W1, [W15]
01069A  3A0070     BRA NZ, 0x1077C
01069C  37002E     BRA 0x106FA
01069E  24E430     MOV #0x4E43, W0
0106A0  24E581     MOV #0x4E58, W1
0106A2  520F80     SUB W4, W0, [W15]
0106A4  5A8F81     SUBB W5, W1, [W15]
0106A6  320006     BRA Z, 0x106B4
0106A8  24B4F0     MOV #0x4B4F, W0
0106AA  259411     MOV #0x5941, W1
0106AC  520F80     SUB W4, W0, [W15]
0106AE  5A8F81     SUBB W5, W1, [W15]
0106B0  3A0065     BRA NZ, 0x1077C
0106B2  370003     BRA 0x106BA
186:                  case ADB_CNXN:
187:                   log_printf("ADB established connection with [%s]", (const char*) recv_data);
188:                   // TODO: arg1 contains max_data - handle
189:                   CHANGE_STATE(adb_conn_state, ADB_CONN_STATE_CONNECTED);
0106B4  200030     MOV #0x3, W0
0106B6  8B3410     MOV W0, adb_conn_state
0106B8  370061     BRA 0x1077C
190:                   break;
191:               
192:                  case ADB_OPEN:
193:                   // should not happen. ignored.
194:                   break;
195:               
196:                  case ADB_OKAY:
197:                   if (h >= 0 && h < ADB_MAX_CHANNELS && adb_channels[h].local_id == arg1) {
0106BA  548FE7     SUB W9, #0x7, [W15]
0106BC  3E005F     BRA GTU, 0x1077C
0106BE  200540     MOV #0x54, W0
0106C0  B9C800     MUL.SS W9, W0, W0
0106C2  780100     MOV W0, W2
0106C4  B00480     ADD #0x48, W0
0106C6  263E23     MOV #0x63E2, W3
0106C8  400003     ADD W0, W3, W0
0106CA  130FB0     SUBR W6, [W0++], [W15]
0106CC  1B8FA0     SUBBR W7, [W0--], [W15]
0106CE  3A0056     BRA NZ, 0x1077C
198:                     if (adb_channels[h].state == ADB_CHAN_STATE_WAIT_OPEN) {
0106D0  790063     MOV [W3+W2], W0
0106D2  500FE2     SUB W0, #0x2, [W15]
0106D4  3A0004     BRA NZ, 0x106DE
199:                       log_printf("Channel %d is open. Remote ID: 0x%lx. Name: %s", h, arg0, adb_channels[h].name);
200:                       adb_channels[h].remote_id = arg0;
0106D6  410003     ADD W2, W3, W0
0106D8  98206A     MOV W10, [W0+76]
0106DA  98207B     MOV W11, [W0+78]
0106DC  37000B     BRA 0x106F4
201:                       CHANGE_CHANNEL_STATE(h, ADB_CHAN_STATE_IDLE);
202:                     } else if (adb_channels[h].state == ADB_CHAN_STATE_WAIT_READY
0106DE  500FE4     SUB W0, #0x4, [W15]
0106E0  3A004D     BRA NZ, 0x1077C
0106E2  2004C0     MOV #0x4C, W0
0106E4  400002     ADD W0, W2, W0
0106E6  400003     ADD W0, W3, W0
0106E8  150FB0     SUBR W10, [W0++], [W15]
0106EA  1D8FA0     SUBBR W11, [W0--], [W15]
0106EC  3A0047     BRA NZ, 0x1077C
203:                       && adb_channels[h].remote_id == arg0) {
204:                       adb_channels[h].data = NULL;
0106EE  E88002     INC2 W2, W0
0106F0  EB0080     CLR W1
0106F2  783181     MOV W1, [W3+W0]
205:                       CHANGE_CHANNEL_STATE(h, ADB_CHAN_STATE_IDLE);
0106F4  200030     MOV #0x3, W0
0106F6  793180     MOV W0, [W3+W2]
0106F8  370041     BRA 0x1077C
206:                     }
207:                   } else {
208:                     log_printf("Remote side sent an OK on an unexpected ID: 0x%lx", arg1);
209:                   }
210:                   break;
211:               
212:                  case ADB_CLSE:
213:                   if (h >= 0 && h < ADB_MAX_CHANNELS && adb_channels[h].local_id == arg1) {
0106FA  548FE7     SUB W9, #0x7, [W15]
0106FC  3E003F     BRA GTU, 0x1077C
0106FE  200540     MOV #0x54, W0
010700  B9C800     MUL.SS W9, W0, W0
010702  780400     MOV W0, W8
010704  B00480     ADD #0x48, W0
010706  263E2A     MOV #0x63E2, W10
010708  40000A     ADD W0, W10, W0
01070A  130FB0     SUBR W6, [W0++], [W15]
01070C  1B8FA0     SUBBR W7, [W0--], [W15]
01070E  3A0036     BRA NZ, 0x1077C
214:                     if (adb_channels[h].state == ADB_CHAN_STATE_WAIT_OPEN) {
010710  7C00EA     MOV [W10+W8], W1
010712  508FE2     SUB W1, #0x2, [W15]
010714  320006     BRA Z, 0x10722
215:                       log_printf("Channel %d open failed. Name: %s", h, adb_channels[h].name);
216:                       adb_channels[h].recv_func(h, NULL, 0);
217:                       CHANGE_CHANNEL_STATE(h, ADB_CHAN_STATE_FREE);
218:                     } else if (adb_channels[h].state == ADB_CHAN_STATE_WAIT_CLOSE
010716  508065     SUB W1, #0x5, W0
010718  500FE1     SUB W0, #0x1, [W15]
01071A  36000A     BRA LEU, 0x10730
219:                         || adb_channels[h].state == ADB_CHAN_STATE_CLOSE_REQUESTED) {
220:                       log_printf("Channel %d closed. Name: %s", h, adb_channels[h].name);
221:                       CHANGE_CHANNEL_STATE(h, ADB_CHAN_STATE_FREE);
222:                     } else if ((adb_channels[h].state == ADB_CHAN_STATE_WAIT_READY
01071C  508063     SUB W1, #0x3, W0
01071E  500FE1     SUB W0, #0x1, [W15]
010720  3E002D     BRA GTU, 0x1077C
223:                                 || adb_channels[h].state == ADB_CHAN_STATE_IDLE)
224:                       // in the ADB documentation it says that only failed attempts to open
225:                       // will result in CLSE with local-id (arg0) of 0, and that in any other
226:                       // case we should ignore the message if it is not equal to our remote
227:                       // ID. In practice, however, we do get CLSE(0, ...) as result of a
228:                       // legitimate closure on the server-side, so this check is disabled.
229:                                /*&& adb_channels[arg1].remote_id == arg0*/) {
230:                       log_printf("Channel %d closed by remote side. Name: %s", h, adb_channels[h].name);
231:                       adb_channels[h].recv_func(h, NULL, 0);
010722  200520     MOV #0x52, W0
010724  400008     ADD W0, W8, W0
010726  78026A     MOV [W10+W0], W4
010728  B81160     MUL.UU W2, #0, W2
01072A  EB0080     CLR W1
01072C  780009     MOV W9, W0
01072E  010004     CALL W4
232:                       CHANGE_CHANNEL_STATE(h, ADB_CHAN_STATE_FREE);
010730  EB0000     CLR W0
010732  7C3500     MOV W0, [W10+W8]
010734  370023     BRA 0x1077C
233:                     }
234:                   } else {
235:                     log_printf("Remote side sent a CLSE on an unexpected ID: 0x%lx", arg1);
236:                   }
237:                   break;
238:               
239:                  case ADB_WRTE:
240:                   if (h >= 0 && h < ADB_MAX_CHANNELS && adb_channels[h].local_id == arg1
010736  548FE7     SUB W9, #0x7, [W15]
010738  3E0021     BRA GTU, 0x1077C
01073A  200540     MOV #0x54, W0
01073C  B9C800     MUL.SS W9, W0, W0
01073E  780080     MOV W0, W1
010740  B00480     ADD #0x48, W0
010742  263E24     MOV #0x63E2, W4
010744  400004     ADD W0, W4, W0
010746  130FB0     SUBR W6, [W0++], [W15]
010748  1B8FA0     SUBBR W7, [W0--], [W15]
01074A  3A0018     BRA NZ, 0x1077C
01074C  2004C0     MOV #0x4C, W0
01074E  400001     ADD W0, W1, W0
010750  400004     ADD W0, W4, W0
010752  150FB0     SUBR W10, [W0++], [W15]
010754  1D8FA0     SUBBR W11, [W0--], [W15]
010756  3A0012     BRA NZ, 0x1077C
241:                       && adb_channels[h].remote_id == arg0) {
242:                     if (adb_channels[h].state < ADB_CHAN_STATE_CLOSE_REQUESTED
010758  788064     MOV [W4+W1], W0
01075A  500FE4     SUB W0, #0x4, [W15]
01075C  3E0009     BRA GTU, 0x10770
01075E  510FE0     SUB W2, #0x0, [W15]
010760  598FE0     SUBB W3, #0x0, [W15]
010762  320006     BRA Z, 0x10770
243:                         && data_len > 0) {
244:                       adb_channels[h].recv_func(h, recv_data, data_len);
010764  200520     MOV #0x52, W0
010766  400001     ADD W0, W1, W0
010768  780264     MOV [W4+W0], W4
01076A  780088     MOV W8, W1
01076C  780009     MOV W9, W0
01076E  010004     CALL W4
245:                     }
246:                     adb_channels[h].pending_ack = TRUE;
010770  200540     MOV #0x54, W0
010772  B9C800     MUL.SS W9, W0, W0
010774  B00500     ADD #0x50, W0
010776  200013     MOV #0x1, W3
010778  263E22     MOV #0x63E2, W2
01077A  783103     MOV W3, [W2+W0]
247:                   } else {
248:                     log_printf("Remote side sent a WRTE on an unexpected ID: 0x%lx", arg1);
249:                   }
250:                   break;
251:               
252:                  default:
253:                   log_printf("Unknown command 0x%lx. Ignoring.", cmd);
254:                 }
255:               }
256:               
257:               ADB_CHANNEL_HANDLE ADBOpen(const char* name, ADBChannelRecvFunc recv_func) {
013D56  EB0580     CLR W11
013D58  263E20     MOV #0x63E2, W0
013D5A  2642AC     MOV #0x642A, W12
013D5C  263EA3     MOV #0x63EA, W3
258:                 assert(name != NULL);
259:                 assert(strlen(name) < ADB_CHANNEL_NAME_MAX_LENGTH);
260:                 assert(recv_func != NULL);
261:                 // find a free channel
262:                 ADB_CHANNEL_HANDLE h;
263:                 for (h = 0; h < ADB_MAX_CHANNELS; ++h) {
013DA2  E8058B     INC W11, W11
013DA4  B00543     ADD #0x54, W3
013DA6  B0054C     ADD #0x54, W12
013DA8  B00540     ADD #0x54, W0
013DAA  558FE8     SUB W11, #0x8, [W15]
013DAC  3AFFD8     BRA NZ, 0x13D5E
013DAE  EB8580     SETM W11
264:                   if (adb_channels[h].state == ADB_CHAN_STATE_FREE) {
013D5E  E00010     CP0 [W0]
013D60  3A0020     BRA NZ, 0x13DA2
265:                     CHANGE_CHANNEL_STATE(h, ADB_CHAN_STATE_START);
013D62  200548     MOV #0x54, W8
013D64  B9DC08     MUL.SS W11, W8, W8
013D66  263E2A     MOV #0x63E2, W10
013D68  200010     MOV #0x1, W0
013D6A  7C3500     MOV W0, [W10+W8]
266:                     strncpy(adb_channels[h].name, name, ADB_CHANNEL_NAME_MAX_LENGTH);
013D6C  200402     MOV #0x40, W2
013D6E  780084     MOV W4, W1
013D70  780003     MOV W3, W0
013D72  02575C     CALL strncpy
013D74  000000     NOP
267:                     adb_channels[h].pending_ack = FALSE;
013D76  200500     MOV #0x50, W0
013D78  400008     ADD W0, W8, W0
013D7A  EB0080     CLR W1
013D7C  783501     MOV W1, [W10+W0]
268:                     adb_channels[h].data = NULL;
013D7E  E88008     INC2 W8, W0
013D80  783501     MOV W1, [W10+W0]
269:                     adb_channels[h].recv_func = recv_func;
013D82  B00528     ADD #0x52, W8
013D84  7C350D     MOV W13, [W10+W8]
270:                     adb_channels[h].local_id = (local_id_counter++) << 8 | h;
013D86  838780     MOV local_id_counter, W0
013D88  838791     MOV 0x70F2, W1
013D8A  DD0A48     SL W1, #8, W4
013D8C  DE02C8     LSR W0, #8, W5
013D8E  720285     IOR W4, W5, W5
013D90  DD0248     SL W0, #8, W4
013D92  B95961     MUL.SU W11, #1, W2
013D94  721E02     IOR W4, W2, [W12++]
013D96  729603     IOR W5, W3, [W12--]
013D98  400061     ADD W0, #0x1, W0
013D9A  4880E0     ADDC W1, #0x0, W1
013D9C  8B8780     MOV W0, local_id_counter
013D9E  8B8791     MOV W1, 0x70F2
013DA0  370007     BRA 0x13DB0
271:                     log_printf("Trying to open channel %d with local ID 0x%lx, name: %s", h,
272:                                 adb_channels[h].local_id, name);
273:                     return h;
274:                   }
275:                 }
276:                 return ADB_INVALID_CHANNEL_HANDLE;
277:               }
278:               
279:               void ADBClose(ADB_CHANNEL_HANDLE handle) {
280:                 assert(handle >= 0 && handle < ADB_MAX_CHANNELS);
281:                 if (adb_channels[handle].state > ADB_CHAN_STATE_FREE) {
0162CA  200540     MOV #0x54, W0
0162CC  B98800     MUL.SS W1, W0, W0
0162CE  780080     MOV W0, W1
0162D0  263E22     MOV #0x63E2, W2
0162D2  780062     MOV [W2+W0], W0
0162D4  E00000     CP0 W0
0162D6  320002     BRA Z, 0x162DC
282:                   CHANGE_CHANNEL_STATE(handle, ADB_CHAN_STATE_CLOSE_REQUESTED);
283:                 }
284:               }
285:               
286:               BOOL ADBChannelReady(ADB_CHANNEL_HANDLE handle) {
287:                 return adb_channels[handle].state == ADB_CHAN_STATE_IDLE && adb_channels[handle].data == NULL;
015E44  200540     MOV #0x54, W0
015E46  B98800     MUL.SS W1, W0, W0
015E48  780080     MOV W0, W1
015E4A  263E22     MOV #0x63E2, W2
015E4C  780062     MOV [W2+W0], W0
015E4E  500FE3     SUB W0, #0x3, [W15]
015E50  3A0005     BRA NZ, 0x15E5C
015E52  E88001     INC2 W1, W0
015E54  780062     MOV [W2+W0], W0
015E56  200011     MOV #0x1, W1
015E58  E00000     CP0 W0
015E5A  320001     BRA Z, 0x15E5E
015E5C  EB0080     CLR W1
288:               }
289:               
290:               void ADBWrite(ADB_CHANNEL_HANDLE handle, const void* data, UINT32 data_len) {
291:                 assert(handle >= 0 && handle < ADB_MAX_CHANNELS);
292:                 assert(adb_channels[handle].state == ADB_CHAN_STATE_IDLE);
293:                 adb_channels[handle].data = data;
0162E0  200540     MOV #0x54, W0
0162E2  B9A200     MUL.SS W4, W0, W4
0162E4  780284     MOV W4, W5
0162E6  E88204     INC2 W4, W4
0162E8  263E20     MOV #0x63E2, W0
0162EA  7A3001     MOV W1, [W0+W4]
294:                 adb_channels[handle].data_len = data_len;
0162EC  428000     ADD W5, W0, W0
0162EE  980022     MOV W2, [W0+4]
0162F0  980033     MOV W3, [W0+6]
295:               }
296:               
297:               ADB_RESULT ADBWriteStatus();
298:               void ADBRead(ADB_CHANNEL_HANDLE handle);
299:               ADB_RESULT ADBReadStatus(ADB_CHANNEL_HANDLE handle, void** data, UINT32* data_len);
300:               
301:               void ADBInit() {
302:                 memset(adb_channels, 0, sizeof adb_channels);
0164BE  202A02     MOV #0x2A0, W2
0164C0  EB0080     CLR W1
0164C2  263E20     MOV #0x63E2, W0
0164C4  025720     CALL memset
0164C6  000000     NOP
303:                 CHANGE_STATE(adb_conn_state, ADB_CONN_STATE_WAIT_ATTACH);
0164C8  200010     MOV #0x1, W0
0164CA  8B3410     MOV W0, adb_conn_state
304:               }
305:               
306:               int ADBTasks() {
307:                 ADB_RESULT adb_res;
308:                 UINT32 cmd, arg0, arg1, data_len;
309:                 void* recv_data;
310:               
311:               
312:                 if (adb_conn_state > ADB_CONN_STATE_WAIT_ATTACH) {
010638  833410     MOV adb_conn_state, W0
01063A  500FE1     SUB W0, #0x1, [W15]
01063C  3600A1     BRA LEU, 0x10780
313:                   if (!ADBAttached()) {
01063E  838580     MOV 0x70B0, W0
010640  A30800     BTST.Z W0, #0
010642  3A0004     BRA NZ, 0x1064C
314:                     // detached
315:                     ADBReset();
010644  0255BA     CALL ADBReset
010646  000001     NOP
010648  EB0080     CLR W1
01064A  370137     BRA 0x108BA
316:                     return 0;
317:                   }
318:                   ADBPacketTasks();
01064C  02276A     CALL ADBPacketTasks
01064E  000001     NOP
319:                   if (adb_buffer_refcount > 0) {
010650  831F00     MOV adb_buffer_refcount, W0
010652  E00000     CP0 W0
010654  320095     BRA Z, 0x10780
320:                     if ((adb_res = ADBPacketRecvStatus(&cmd, &arg0, &arg1, &recv_data, &data_len)) != ADB_RESULT_BUSY) {
010656  57826C     SUB W15, #0xC, W4
010658  5781FA     SUB W15, #0x1A, W3
01065A  578170     SUB W15, #0x10, W2
01065C  5780F4     SUB W15, #0x14, W1
01065E  578078     SUB W15, #0x18, W0
010660  0254EA     CALL ADBPacketRecvStatus
010662  000001     NOP
010664  500FE2     SUB W0, #0x2, [W15]
010666  32008C     BRA Z, 0x10780
321:                       if (adb_res == ADB_RESULT_ERROR) {
010668  500FE1     SUB W0, #0x1, [W15]
01066A  3A0002     BRA NZ, 0x10670
322:                         CHANGE_STATE(adb_conn_state, ADB_CONN_STATE_ERROR);
01066C  EB0000     CLR W0
01066E  370023     BRA 0x106B6
323:                       } else {
324:                         ADBHandlePacket(cmd, arg0, arg1, recv_data, data_len);
010670  97B92F     MOV [W15-12], W2
010672  97B9BF     MOV [W15-10], W3
010674  97BB0F     MOV [W15-16], W6
010676  97BB9F     MOV [W15-14], W7
010678  97B56F     MOV [W15-20], W10
01067A  97B5FF     MOV [W15-18], W11
01067C  97B43F     MOV [W15-26], W8
325:                       }
326:                       ADBBufferUnref();
01077C  02611C     CALL ADBBufferUnref
01077E  000001     NOP
327:                     }
328:                   }
329:                 }
330:               
331:                 switch (adb_conn_state) {
010780  833418     MOV adb_conn_state, W8
010782  540FE1     SUB W8, #0x1, [W15]
010784  320004     BRA Z, 0x1078E
010786  390046     BRA NC, 0x10814
010788  540FE3     SUB W8, #0x3, [W15]
01078A  3A0092     BRA NZ, 0x108B0
01078C  37001A     BRA 0x107C2
332:                  case ADB_CONN_STATE_WAIT_ATTACH:
333:                   if (ADBAttached()) {
01078E  838580     MOV 0x70B0, W0
010790  A30800     BTST.Z W0, #0
010792  32008E     BRA Z, 0x108B0
334:                     log_printf("Device attached.");
335:                     ADBPacketReset();
010794  02664C     CALL ADBPacketReset
010796  000001     NOP
336:                     adb_buffer_refcount = 1;
010798  8B1F08     MOV W8, adb_buffer_refcount
337:                     ADBPacketRecv();  // start receiving
01079A  0266DE     CALL ADBPacketRecv
01079C  000001     NOP
338:                     ADBPacketSend(ADB_CNXN, ADB_VERSION, ADB_PACKET_MAX_RECV_DATA_BYTES, ADB_HOSTNAME_STRING, strlen(ADB_HOSTNAME_STRING) + 1);
01079E  270E80     MOV #0x70E8, W0
0107A0  02578A     CALL strlen
0107A2  000000     NOP
0107A4  E80000     INC W0, W0
0107A6  200001     MOV #0x0, W1
0107A8  BE9F80     MOV.D W0, [W15++]
0107AA  270E86     MOV #0x70E8, W6
0107AC  210004     MOV #0x1000, W4
0107AE  200005     MOV #0x0, W5
0107B0  200002     MOV #0x0, W2
0107B2  201003     MOV #0x100, W3
0107B4  24E430     MOV #0x4E43, W0
0107B6  24E581     MOV #0x4E58, W1
0107B8  024DA0     CALL ADBPacketSend
0107BA  000001     NOP
339:                     CHANGE_STATE(adb_conn_state, ADB_CONN_STATE_WAIT_CONNECT);
0107BC  200020     MOV #0x2, W0
0107BE  8B3410     MOV W0, adb_conn_state
0107C0  370076     BRA 0x108AE
340:                   }
341:                   break;
342:               
343:                  case ADB_CONN_STATE_WAIT_CONNECT:
344:                   break;
345:               
346:                  case ADB_CONN_STATE_CONNECTED:
347:                   ADBChannelTasks();
348:                   break;
349:               
350:                  case ADB_CONN_STATE_ERROR:
351:                   log_printf("Error occured. Resetting.");
352:                   ADBReset();
010814  0255BA     CALL ADBReset
010816  000001     NOP
010818  EB8080     SETM W1
01081A  37004F     BRA 0x108BA
353:                   return -1;
354:                 }
355:               
356:                 return ADBConnected();
0108B0  EB0080     CLR W1
0108B2  833410     MOV adb_conn_state, W0
0108B4  500FE2     SUB W0, #0x2, [W15]
0108B6  360001     BRA LEU, 0x108BA
0108B8  200011     MOV #0x1, W1
357:               }
358:               
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/app_layer_v1/uart.c  -----
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include "uart.h"
31:                
32:                #include <assert.h>
33:                #include "Compiler.h"
34:                #include "logging.h"
35:                #include "platform.h"
36:                #include "byte_queue.h"
37:                #include "pp_util.h"
38:                #include "protocol.h"
39:                #include "sync.h"
40:                
41:                #define RX_BUF_SIZE 256
42:                #define TX_BUF_SIZE 256
43:                
44:                typedef struct {
45:                  int num_tx_since_last_report;
46:                  BYTE_QUEUE rx_queue;
00E298  200428     MOV #0x42, W8
00E29A  784418     MOV.B [W8], W8
00E29C  FB8408     ZE W8, W8
00E29E  DE4445     LSR W8, #5, W8
00E2B2  BFC042     MOV.B SR, WREG
00E2C4  200421     MOV #0x42, W1
00E2C6  784091     MOV.B [W1], W1
00E2D4  BFC042     MOV.B SR, WREG
00E306  200428     MOV #0x42, W8
00E308  784418     MOV.B [W8], W8
00E30A  FB8408     ZE W8, W8
00E30C  DE4445     LSR W8, #5, W8
00E32A  BFC042     MOV.B SR, WREG
47:                  BYTE_QUEUE tx_queue;
00E2A0  BFC042     MOV.B SR, WREG
00E2A2  60407F     AND.B W0, #0x1F, W0
00E2A4  A07400     BSET.B W0, #7
00E2A6  B7E042     MOV.B WREG, SR
00E2B4  DD4445     SL W8, #5, W8
00E2B6  BFC042     MOV.B SR, WREG
00E2B8  60407F     AND.B W0, #0x1F, W0
00E2BA  704008     IOR.B W0, W8, W0
00E2BC  B7E042     MOV.B WREG, SR
00E2C8  BFC042     MOV.B SR, WREG
00E2CA  60407F     AND.B W0, #0x1F, W0
00E2CC  A07400     BSET.B W0, #7
00E2CE  B7E042     MOV.B WREG, SR
00E2D6  B3CE00     MOV #0xE0, W0
00E2D8  60C080     AND.B W1, W0, W1
00E2DA  BFC042     MOV.B SR, WREG
00E2DC  60407F     AND.B W0, #0x1F, W0
00E2DE  704001     IOR.B W0, W1, W0
00E2E0  B7E042     MOV.B WREG, SR
00E30E  BFC042     MOV.B SR, WREG
00E310  60407F     AND.B W0, #0x1F, W0
00E312  A07400     BSET.B W0, #7
00E314  B7E042     MOV.B WREG, SR
00E32C  DD4445     SL W8, #5, W8
00E32E  BFC042     MOV.B SR, WREG
00E330  60407F     AND.B W0, #0x1F, W0
00E332  704008     IOR.B W0, W8, W0
00E334  B7E042     MOV.B WREG, SR
48:                  BYTE rx_buffer[RX_BUF_SIZE];
49:                  BYTE tx_buffer[TX_BUF_SIZE];
50:                } UART_STATE;
51:                
52:                static UART_STATE uarts[NUM_UART_MODULES];
00E470  980048     MOV W8, [W0+8]
00E47E  980048     MOV W8, [W0+8]
53:                
00E472  980028     MOV W8, [W0+4]
00E480  980028     MOV W8, [W0+4]
54:                #define _UARTREG_REF_COMMA(num, dummy) (volatile UART*) &U##num##MODE,
00E474  980038     MOV W8, [W0+6]
00E482  980038     MOV W8, [W0+6]
55:                
56:                volatile UART* uart_reg[NUM_UART_MODULES] = {
57:                  REPEAT_1B(_UARTREG_REF_COMMA, NUM_UART_MODULES, 0)
58:                };
00E46A  448876     ADD W9, #0x16, [W0]
00E478  201162     MOV #0x116, W2
00E47A  448802     ADD W9, W2, [W0]
59:                
00E46C  201001     MOV #0x100, W1
00E46E  980011     MOV W1, [W0+2]
00E47C  980011     MOV W1, [W0+2]
60:                DEFINE_REG_SETTERS_1B(NUM_UART_MODULES, _U, RXIE)
61:                DEFINE_REG_SETTERS_1B(NUM_UART_MODULES, _U, RXIF)
62:                DEFINE_REG_SETTERS_1B(NUM_UART_MODULES, _U, RXIP)
63:                DEFINE_REG_SETTERS_1B(NUM_UART_MODULES, _U, TXIE)
64:                DEFINE_REG_SETTERS_1B(NUM_UART_MODULES, _U, TXIF)
65:                DEFINE_REG_SETTERS_1B(NUM_UART_MODULES, _U, TXIP)
00E1E6  F80036     PUSH RCOUNT
00E1E8  BE9F80     MOV.D W0, [W15++]
00E1EA  BE9F82     MOV.D W2, [W15++]
00E1EC  BE9F84     MOV.D W4, [W15++]
00E1EE  BE9F86     MOV.D W6, [W15++]
00E1F0  781F88     MOV W8, [W15++]
00E1F2  F80032     PUSH DSRPAG
00E1F4  202000     MOV #0x200, W0
00E1F6  880190     MOV W0, DSRPAG
66:                
67:                static void UARTConfigInternal(int uart_num, int rate, int speed4x, int two_stop_bits, int parity, int external);
68:                
69:                void UARTInit() {
00E558  EB0400     CLR W8
00E55A  21DD8A     MOV #0x1DD8, W10
00E55C  21DD09     MOV #0x1DD0, W9
70:                  int i;
71:                  for (i = 0; i < NUM_UART_MODULES; ++i) {
00E578  E80408     INC W8, W8
00E57A  540FE4     SUB W8, #0x4, [W15]
00E57C  3AFFF0     BRA NZ, 0xE55E
72:                    UARTConfigInternal(i, 0, 0, 0, 0, 0);
00E55E  EB0280     CLR W5
00E560  780205     MOV W5, W4
00E562  780185     MOV W5, W3
00E564  780105     MOV W5, W2
00E566  780085     MOV W5, W1
00E568  780008     MOV W8, W0
00E56A  07FF61     RCALL UARTConfigInternal
73:                    Set_URXIP[i](4);  // RX int. priority 4
00E56C  7800BA     MOV [W10++], W1
00E56E  200040     MOV #0x4, W0
00E570  010001     CALL W1
74:                    Set_UTXIP[i](4);  // TX int. priority 4
00E572  7800B9     MOV [W9++], W1
00E574  200040     MOV #0x4, W0
00E576  010001     CALL W1
75:                  }
00E352  9000C8     MOV [W8+8], W1
00E384  9000C8     MOV [W8+8], W1
76:                }
00E584  F80036     PUSH RCOUNT
00E586  BE9F80     MOV.D W0, [W15++]
00E588  BE9F82     MOV.D W2, [W15++]
00E58A  BE9F84     MOV.D W4, [W15++]
00E58C  BE9F86     MOV.D W6, [W15++]
00E58E  781F88     MOV W8, [W15++]
00E590  F80032     PUSH DSRPAG
00E592  202000     MOV #0x200, W0
00E594  880190     MOV W0, DSRPAG
77:                
78:                static inline void UARTSendStatus(int uart_num, int enabled) {
79:                  OUTGOING_MESSAGE msg;
80:                  msg.type = UART_STATUS;
00E4D4  2FFCD1     MOV #0xFFCD, W1
00E4D6  478001     ADD W15, W1, W0
00E4D8  B3C0D1     MOV #0xD, W1
00E4DA  784801     MOV.B W1, [W0]
00E510  B3C0D0     MOV #0xD, W0
00E512  9F7780     MOV.B W0, [W15-80]
81:                  msg.args.uart_status.uart_num = uart_num;
00E4DC  65C1E3     AND.B W11, #0x3, W3
00E4DE  97C8EF     MOV.B [W15-50], W1
00E4E0  B3CFC2     MOV #0xFC, W2
00E4E2  60C082     AND.B W1, W2, W1
00E4E4  70C083     IOR.B W1, W3, W1
00E514  658063     AND W11, #0x3, W0
00E516  DD0048     SL W0, #8, W0
00E518  2FCFF1     MOV #0xFCFF, W1
00E51A  97990F     MOV [W15-80], W2
00E51C  610101     AND W2, W1, W2
00E51E  710180     IOR W2, W0, W3
82:                  msg.args.uart_status.enabled = enabled;
00E4E6  A17401     BCLR.B W1, #7
00E4E8  9FCFE1     MOV.B W1, [W15-50]
00E520  280000     MOV #0x8000, W0
00E522  718080     IOR W3, W0, W1
00E524  9F9F81     MOV W1, [W15-80]
83:                  AppProtocolSendMessage(&msg);
00E4EA  07F2D0     RCALL AppProtocolSendMessage
00E526  2FFB00     MOV #0xFFB0, W0
00E528  40000F     ADD W0, W15, W0
00E52A  07F2B0     RCALL AppProtocolSendMessage
84:                }
85:                
86:                static void UARTConfigInternal(int uart_num, int rate, int speed4x, int two_stop_bits, int parity, int external) {
87:                  volatile UART* regs = uart_reg[uart_num];
00E444  400500     ADD W0, W0, W10
00E446  21DA80     MOV #0x1DA8, W0
00E448  78066A     MOV [W10+W0], W12
88:                  UART_STATE* uart = &uarts[uart_num];
00E44A  202160     MOV #0x216, W0
00E44C  B9D800     MUL.SS W11, W0, W0
00E44E  208502     MOV #0x850, W2
00E450  410480     ADD W2, W0, W9
89:                  if (external) {
90:                    log_printf("UARTConfig(%d, %d, %d, %d, %d)", uart_num, rate, speed4x,
91:                               two_stop_bits, parity);
92:                  }
93:                  SAVE_UART_FOR_LOG(uart_num);
94:                  Set_URXIE[uart_num](0);  // disable RX int.
00E452  21DC80     MOV #0x1DC8, W0
00E454  450700     ADD W10, W0, W14
00E456  78009E     MOV [W14], W1
00E458  EB0000     CLR W0
00E45A  010001     CALL W1
95:                  Set_UTXIE[uart_num](0);  // disable TX int.
00E45C  21DB00     MOV #0x1DB0, W0
00E45E  7800EA     MOV [W10+W0], W1
00E460  EB0000     CLR W0
00E462  010001     CALL W1
96:                  regs->uxmode = 0x0000;  // disable UART.
00E464  EB0400     CLR W8
00E466  780E08     MOV W8, [W12]
97:                  // clear SW buffers
98:                  ByteQueueInit(&uart->rx_queue, uart->rx_buffer, RX_BUF_SIZE);
00E468  E88009     INC2 W9, W0
99:                  ByteQueueInit(&uart->tx_queue, uart->tx_buffer, TX_BUF_SIZE);
00E476  44806C     ADD W9, #0xC, W0
100:                 uart->num_tx_since_last_report = 0;
00E484  780C88     MOV W8, [W9]
101:                 if (rate) {
00E486  97B1DF     MOV [W15-22], W3
00E488  E00003     CP0 W3
00E48A  320022     BRA Z, 0xE4D0
102:                   if (external) {
00E48C  E0000D     CP0 W13
00E48E  3A0040     BRA NZ, 0xE510
103:                     UARTSendStatus(uart_num, 1);
104:                   }
105:                   regs->uxbrg = rate;
00E490  97B15F     MOV [W15-22], W2
00E492  980642     MOV W2, [W12+8]
00E52C  97B15F     MOV [W15-22], W2
00E52E  980642     MOV W2, [W12+8]
106:                   Set_URXIF[uart_num](0);  // clear RX int.
00E494  21DC00     MOV #0x1DC0, W0
00E496  7800EA     MOV [W10+W0], W1
00E498  780008     MOV W8, W0
00E49A  010001     CALL W1
00E530  21DC00     MOV #0x1DC0, W0
00E532  7800EA     MOV [W10+W0], W1
00E534  780008     MOV W8, W0
00E536  010001     CALL W1
107:                   Set_UTXIF[uart_num](0);  // clear TX int.
00E49C  21DB80     MOV #0x1DB8, W0
00E49E  7800EA     MOV [W10+W0], W1
00E4A0  780008     MOV W8, W0
00E4A2  010001     CALL W1
00E538  21DB80     MOV #0x1DB8, W0
00E53A  7800EA     MOV [W10+W0], W1
00E53C  780008     MOV W8, W0
00E53E  010001     CALL W1
108:                   Set_URXIE[uart_num](1);  // enable RX int.
00E4A4  78009E     MOV [W14], W1
00E4A6  200010     MOV #0x1, W0
00E4A8  010001     CALL W1
00E540  78009E     MOV [W14], W1
00E542  200010     MOV #0x1, W0
00E544  010001     CALL W1
109:                   regs->uxmode = 0x8000 | (speed4x ? 0x0008 : 0x0000) | two_stop_bits | (parity << 1);  // enable
00E4AA  280080     MOV #0x8008, W0
00E4AC  97B1EF     MOV [W15-20], W3
00E4AE  E00003     CP0 W3
00E4B0  320024     BRA Z, 0xE4FA
00E4B2  97B17F     MOV [W15-18], W2
00E4B4  700082     IOR W0, W2, W1
00E4B6  97B98F     MOV [W15-16], W3
00E4B8  418003     ADD W3, W3, W0
00E4BA  708E00     IOR W1, W0, [W12]
00E4FA  500068     SUB W0, #0x8, W0
00E4FC  97B17F     MOV [W15-18], W2
00E4FE  700082     IOR W0, W2, W1
00E500  97B98F     MOV [W15-16], W3
00E502  418003     ADD W3, W3, W0
00E504  708E00     IOR W1, W0, [W12]
110:                   regs->uxsta = 0x8400;  // IRQ when TX buffer is empty, enable TX, IRQ when character received.
00E4BC  284000     MOV #0x8400, W0
00E4BE  980610     MOV W0, [W12+2]
00E506  284000     MOV #0x8400, W0
00E508  980610     MOV W0, [W12+2]
111:                   uart->num_tx_since_last_report = TX_BUF_SIZE;
00E4C0  201000     MOV #0x100, W0
00E4C2  780C80     MOV W0, [W9]
00E50A  201000     MOV #0x100, W0
00E50C  780C80     MOV W0, [W9]
00E50E  37FFDA     BRA 0xE4C4
112:                 } else {
113:                   if (external) {
00E4D0  E0000D     CP0 W13
00E4D2  32FFF8     BRA Z, 0xE4C4
114:                     UARTSendStatus(uart_num, 0);
115:                   }
116:                 }
117:               }
00E4C4  78074F     MOV [--W15], W14
00E4C6  BE064F     MOV.D [--W15], W12
00E4C8  BE054F     MOV.D [--W15], W10
00E4CA  BE044F     MOV.D [--W15], W8
00E4CC  B1044F     SUB #0x44, W15
00E4CE  060000     RETURN
00E4EC  78074F     MOV [--W15], W14
00E4EE  BE064F     MOV.D [--W15], W12
00E4F0  BE054F     MOV.D [--W15], W10
00E4F2  BE044F     MOV.D [--W15], W8
00E4F4  B1044F     SUB #0x44, W15
00E4F6  060000     RETURN
00E4F8  37FFEB     BRA 0xE4D0
118:               
119:               void UARTConfig(int uart_num, int rate, int speed4x, int two_stop_bits, int parity) {
120:                 UARTConfigInternal(uart_num, rate, speed4x, two_stop_bits, parity, 1);
00E550  200015     MOV #0x1, W5
00E552  37FF6D     BRA UARTConfigInternal
121:               }
00E554  BE9F88     MOV.D W8, [W15++]
00E556  781F8A     MOV W10, [W15++]
122:               
123:               
124:               static void UARTReportTxStatus(int uart_num) {
125:                 int report;
126:                 UART_STATE* uart = &uarts[uart_num];
127:                 BYTE prev = SyncInterruptLevel(4);
128:                 report = uart->num_tx_since_last_report;
00E2D0  78011B     MOV [W11], W2
129:                 uart->num_tx_since_last_report = 0;
00E2D2  EB0D80     CLR [W11]
130:                 SyncInterruptLevel(prev);
131:                 OUTGOING_MESSAGE msg;
132:                 msg.type = UART_REPORT_TX_STATUS;
00E2E2  B3C0F0     MOV #0xF, W0
00E2E4  9FD7D0     MOV.B W0, [W15-43]
133:                 msg.args.uart_report_tx_status.uart_num = uart_num;
134:                 msg.args.uart_report_tx_status.bytes_to_add = report;
00E2E6  DD10C2     SL W2, #2, W1
00E2E8  64C063     AND.B W9, #0x3, W0
00E2EA  704001     IOR.B W0, W1, W0
00E2EC  9FD7E0     MOV.B W0, [W15-42]
00E2EE  DE1146     LSR W2, #6, W2
00E2F0  9FD7F2     MOV.B W2, [W15-41]
135:                 AppProtocolSendMessage(&msg);
00E260  B0216B     ADD #0x216, W11
00E262  E84489     INC.B W9, W9
00E264  64C4E3     AND.B W9, #0x3, W9
00E2F2  2FFD50     MOV #0xFFD5, W0
00E2F4  40000F     ADD W0, W15, W0
00E2F6  07F3CA     RCALL AppProtocolSendMessage
00E2F8  B0216B     ADD #0x216, W11
00E2FA  E84489     INC.B W9, W9
00E2FC  64C4E3     AND.B W9, #0x3, W9
136:               }
137:               
138:               void UARTTasks() {
00E232  20850B     MOV #0x850, W11
00E234  EB4480     CLR.B W9
00E236  2FFB00     MOV #0xFFB0, W0
00E238  40000F     ADD W0, W15, W0
00E23A  400766     ADD W0, #0x6, W14
00E23C  4006E4     ADD W0, #0x4, W13
00E23E  400568     ADD W0, #0x8, W10
139:                 int i;
140:                 for (i = 0; i < NUM_UART_MODULES; ++i) {
00E266  3AFFEC     BRA NZ, 0xE240
00E302  BE9F88     MOV.D W8, [W15++]
00E304  780480     MOV W0, W9
141:                   int size1, size2;
142:                   const BYTE *data1, *data2;
143:                   UART_STATE* uart = &uarts[i];
144:                   BYTE_QUEUE* q = &uart->rx_queue;
00E240  E8860B     INC2 W11, W12
145:                   BYTE prev;
146:                   ByteQueuePeekMax(q, 64, &data1, &size1, &data2, &size2);
00E242  2FFB25     MOV #0xFFB2, W5
00E244  42828F     ADD W5, W15, W5
00E246  78020E     MOV W14, W4
00E248  2FFB03     MOV #0xFFB0, W3
00E24A  41818F     ADD W3, W15, W3
00E24C  78010D     MOV W13, W2
00E24E  200401     MOV #0x40, W1
00E250  78000C     MOV W12, W0
00E252  071C4C     RCALL ByteQueuePeekMax
147:                   if (size1) {
00E254  97990F     MOV [W15-80], W2
00E256  E00002     CP0 W2
00E258  3A000D     BRA NZ, 0xE274
148:                     log_printf("UART %d received %d bytes", i, size1 + size2);
149:                     OUTGOING_MESSAGE msg;
150:                     msg.type = UART_DATA;
00E274  B3C0E0     MOV #0xE, W0
00E276  784D00     MOV.B W0, [W10]
151:                     msg.args.uart_data.uart_num = i;
00E278  DD48CE     SL W9, #14, W1
00E27A  23FFF0     MOV #0x3FFF, W0
00E27C  600D1A     AND W0, [W10], [W10]
00E27E  708D1A     IOR W1, [W10], [W10]
152:                     msg.args.uart_data.size = size1 + size2 - 1;
00E280  979A1F     MOV [W15-78], W4
00E282  414004     ADD.B W2, W4, W0
00E284  E94000     DEC.B W0, W0
00E286  B203F0     AND #0x3F, W0
00E288  DD0048     SL W0, #8, W0
00E28A  2C0FF1     MOV #0xC0FF, W1
00E28C  608D1A     AND W1, [W10], [W10]
00E28E  700D1A     IOR W0, [W10], [W10]
153:                     AppProtocolSendMessageWithVarArgSplit(&msg, data1, size1, data2, size2);
00E290  9798AF     MOV [W15-76], W1
00E292  9799BF     MOV [W15-74], W3
00E294  78000A     MOV W10, W0
00E296  07F384     RCALL AppProtocolSendMessageWithVarArgSplit
154:                     prev = SyncInterruptLevel(4);
155:                     ByteQueuePull(q, size1 + size2);
00E2A8  97989F     MOV [W15-78], W1
00E2AA  97980F     MOV [W15-80], W0
00E2AC  400081     ADD W0, W1, W1
00E2AE  78000C     MOV W12, W0
00E2B0  071C30     RCALL ByteQueuePull
156:                     SyncInterruptLevel(prev);
157:                   }
158:                   if (uart->num_tx_since_last_report > TX_BUF_SIZE / 2) {
00E25A  200800     MOV #0x80, W0
00E25C  100F9B     SUBR W0, [W11], [W15]
00E25E  3C0032     BRA GT, 0xE2C4
00E2BE  200800     MOV #0x80, W0
00E2C0  100F9B     SUBR W0, [W11], [W15]
00E2C2  34FFCE     BRA LE, 0xE260
159:                     UARTReportTxStatus(i);
160:                   }
161:                 }
162:               }
00E268  78074F     MOV [--W15], W14
00E26A  BE064F     MOV.D [--W15], W12
00E26C  BE054F     MOV.D [--W15], W10
00E26E  BE044F     MOV.D [--W15], W8
00E270  B1044F     SUB #0x44, W15
00E272  060000     RETURN
163:               
164:               static void TXInterrupt(int uart_num) {
165:                 volatile UART* reg = uart_reg[uart_num];
00E342  400580     ADD W0, W0, W11
00E344  21DA80     MOV #0x1DA8, W0
00E346  78056B     MOV [W11+W0], W10
166:                 UART_STATE* uart = &uarts[uart_num];
00E348  202160     MOV #0x216, W0
00E34A  B98900     MUL.SS W1, W0, W2
00E34C  208500     MOV #0x850, W0
00E34E  400482     ADD W0, W2, W9
167:                 BYTE_QUEUE* q = &uart->tx_queue;
00E350  44846C     ADD W9, #0xC, W8
168:                 while (ByteQueueSize(q) && !(reg->uxsta & 0x0200)) {
00E354  E00001     CP0 W1
00E356  320003     BRA Z, 0xE35E
00E358  90001A     MOV [W10+2], W0
00E35A  A39800     BTST.Z W0, #9
00E35C  32000A     BRA Z, 0xE372
00E386  E00001     CP0 W1
00E388  32FFEA     BRA Z, 0xE35E
00E38A  90001A     MOV [W10+2], W0
00E38C  A39800     BTST.Z W0, #9
00E38E  32FFF2     BRA Z, 0xE374
169:                   Set_UTXIF[uart_num](0);
00E374  7E00EB     MOV [W11+W12], W1
00E376  EB0000     CLR W0
00E378  010001     CALL W1
170:                   reg->uxtxreg = ByteQueuePullByte(q);
00E37A  780008     MOV W8, W0
00E37C  071BA1     RCALL ByteQueuePullByte
00E37E  FB8000     ZE W0, W0
00E380  980520     MOV W0, [W10+4]
171:                   ++uart->num_tx_since_last_report;
00E382  E80C99     INC [W9], [W9]
172:                 }
173:                 Set_UTXIE[uart_num](ByteQueueSize(q) != 0);
00E35E  EA0001     NEG W1, W0
00E360  700001     IOR W0, W1, W0
00E362  DE004F     LSR W0, #15, W0
00E364  21DB01     MOV #0x1DB0, W1
00E366  7880EB     MOV [W11+W1], W1
00E368  010001     CALL W1
00E390  EA0001     NEG W1, W0
00E392  700001     IOR W0, W1, W0
00E394  DE004F     LSR W0, #15, W0
00E396  21DB01     MOV #0x1DB0, W1
00E398  7880EB     MOV [W11+W1], W1
00E39A  010001     CALL W1
174:               }
00E36A  78064F     MOV [--W15], W12
00E36C  BE054F     MOV.D [--W15], W10
00E36E  BE044F     MOV.D [--W15], W8
00E370  060000     RETURN
00E372  21DB8C     MOV #0x1DB8, W12
00E3A6  F80036     PUSH RCOUNT
00E3A8  BE9F80     MOV.D W0, [W15++]
00E3AA  BE9F82     MOV.D W2, [W15++]
00E3AC  BE9F84     MOV.D W4, [W15++]
00E3AE  BE9F86     MOV.D W6, [W15++]
00E3B0  F80032     PUSH DSRPAG
00E3B2  202000     MOV #0x200, W0
00E3B4  880190     MOV W0, DSRPAG
175:               
176:               static void RXInterrupt(int uart_num) {
177:                 volatile UART* reg = uart_reg[uart_num];
00E1F8  80ED78     MOV 0x1DAE, W8
00E596  80ED48     MOV uart_reg, W8
00E5D8  80ED58     MOV 0x1DAA, W8
00E61A  80ED68     MOV 0x1DAC, W8
178:                 BYTE_QUEUE* q = &uarts[uart_num].rx_queue;
179:                 while (reg->uxsta & 0x0001) {
00E1FA  900018     MOV [W8+2], W0
00E1FC  A30800     BTST.Z W0, #0
00E1FE  320007     BRA Z, 0xE20E
00E208  900018     MOV [W8+2], W0
00E20A  A30800     BTST.Z W0, #0
00E20C  3AFFF9     BRA NZ, 0xE200
00E598  900018     MOV [W8+2], W0
00E59A  A30800     BTST.Z W0, #0
00E59C  320007     BRA Z, 0xE5AC
00E5A6  900018     MOV [W8+2], W0
00E5A8  A30800     BTST.Z W0, #0
00E5AA  3AFFF9     BRA NZ, 0xE59E
00E5DA  900018     MOV [W8+2], W0
00E5DC  A30800     BTST.Z W0, #0
00E5DE  320007     BRA Z, 0xE5EE
00E5E8  900018     MOV [W8+2], W0
00E5EA  A30800     BTST.Z W0, #0
00E5EC  3AFFF9     BRA NZ, 0xE5E0
00E61C  900018     MOV [W8+2], W0
00E61E  A30800     BTST.Z W0, #0
00E620  320007     BRA Z, 0xE630
00E62A  900018     MOV [W8+2], W0
00E62C  A30800     BTST.Z W0, #0
00E62E  3AFFF9     BRA NZ, 0xE622
180:                   if (reg->uxsta & 0x000C) {
00E200  900018     MOV [W8+2], W0
00E202  60006C     AND W0, #0xC, W0
00E204  32000D     BRA Z, 0xE220
00E59E  900018     MOV [W8+2], W0
00E5A0  60006C     AND W0, #0xC, W0
00E5A2  32000D     BRA Z, 0xE5BE
00E5E0  900018     MOV [W8+2], W0
00E5E2  60006C     AND W0, #0xC, W0
00E5E4  32000D     BRA Z, 0xE600
00E622  900018     MOV [W8+2], W0
00E624  60006C     AND W0, #0xC, W0
00E626  32000D     BRA Z, 0xE642
181:                     // skip character with frame/parity err
182:                     (void) reg->uxrxreg;
00E206  900038     MOV [W8+6], W0
00E5A4  900038     MOV [W8+6], W0
00E5E6  900038     MOV [W8+6], W0
00E628  900038     MOV [W8+6], W0
183:                     continue;
184:                   }
185:                   ByteQueuePushByte(q, reg->uxrxreg);
00E228  B0044F     ADD #0x44, W15
00E22A  BE9F88     MOV.D W8, [W15++]
00E22C  BE9F8A     MOV.D W10, [W15++]
00E22E  BE9F8C     MOV.D W12, [W15++]
00E230  781F8E     MOV W14, [W15++]
00E5C6  F80036     PUSH RCOUNT
00E5C8  BE9F80     MOV.D W0, [W15++]
00E5CA  BE9F82     MOV.D W2, [W15++]
00E5CC  BE9F84     MOV.D W4, [W15++]
00E5CE  BE9F86     MOV.D W6, [W15++]
00E5D0  781F88     MOV W8, [W15++]
00E5D2  F80032     PUSH DSRPAG
00E5D4  202000     MOV #0x200, W0
00E5D6  880190     MOV W0, DSRPAG
00E608  F80036     PUSH RCOUNT
00E60A  BE9F80     MOV.D W0, [W15++]
00E60C  BE9F82     MOV.D W2, [W15++]
00E60E  BE9F84     MOV.D W4, [W15++]
00E610  BE9F86     MOV.D W6, [W15++]
00E612  781F88     MOV W8, [W15++]
00E614  F80032     PUSH DSRPAG
00E616  202000     MOV #0x200, W0
00E618  880190     MOV W0, DSRPAG
186:                 }
187:               }
188:               
189:               void UARTTransmit(int uart_num, const void* data, int size) {
190:                 log_printf("UARTTransmit(%d, %p, %d)", uart_num, data, size);
191:                 SAVE_UART_FOR_LOG(uart_num);
192:                 BYTE_QUEUE* q = &uarts[uart_num].tx_queue;
193:                 BYTE prev = SyncInterruptLevel(4);
194:                 ByteQueuePushBuffer(q, data, size);
00E316  202160     MOV #0x216, W0
00E318  B9CA00     MUL.SS W9, W0, W4
00E31A  2085C0     MOV #0x85C, W0
00E31C  420000     ADD W4, W0, W0
00E31E  071C2D     RCALL ByteQueuePushBuffer
195:                 Set_UTXIE[uart_num](1);  // enable TX int.
00E320  448089     ADD W9, W9, W1
00E322  21DB00     MOV #0x1DB0, W0
00E324  7800E1     MOV [W1+W0], W1
00E326  200010     MOV #0x1, W0
00E328  010001     CALL W1
196:                 SyncInterruptLevel(prev);
197:               }
00E33A  BE9F88     MOV.D W8, [W15++]
00E33C  BE9F8A     MOV.D W10, [W15++]
00E33E  781F8C     MOV W12, [W15++]
00E340  780080     MOV W0, W1
198:               
199:               #define DEFINE_INTERRUPT_HANDLERS(uart_num)                                   \
200:                void __attribute__((__interrupt__, auto_psv)) _U##uart_num##RXInterrupt() {  \
201:                  RXInterrupt(uart_num - 1);                                                 \
202:                  _U##uart_num##RXIF = 0;                                                    \
203:                }                                                                            \
204:                                                                                             \
205:                void __attribute__((__interrupt__, auto_psv)) _U##uart_num##TXInterrupt() {  \
206:                  TXInterrupt(uart_num - 1);                                                 \
207:                }
208:               
209:               #if NUM_UART_MODULES > 4
210:                 #error Currently only devices with 4 or less UARTs are supported. Please fix below.
211:               #endif
212:               
213:               #if NUM_UART_MODULES >= 1
214:                 DEFINE_INTERRUPT_HANDLERS(1)
00E42E  B0044F     ADD #0x44, W15
00E430  BE9F88     MOV.D W8, [W15++]
00E432  BE9F8A     MOV.D W10, [W15++]
00E434  BE9F8C     MOV.D W12, [W15++]
00E436  781F8E     MOV W14, [W15++]
00E438  780580     MOV W0, W11
00E43A  9FB7D1     MOV W1, [W15-22]
00E43C  9FB7E2     MOV W2, [W15-20]
00E43E  9FB7F3     MOV W3, [W15-18]
00E440  9FBF84     MOV W4, [W15-16]
00E442  780685     MOV W5, W13
00E5AC  A96085     BCLR 0x85, #3
00E5AE  F90032     POP DSRPAG
00E5B0  78044F     MOV [--W15], W8
00E5B2  BE034F     MOV.D [--W15], W6
00E5B4  BE024F     MOV.D [--W15], W4
00E5B6  BE014F     MOV.D [--W15], W2
00E5B8  BE004F     MOV.D [--W15], W0
00E5BA  F90036     POP RCOUNT
00E5BC  064000     RETFIE
215:               #endif
216:               
217:               #if NUM_UART_MODULES >= 2 && !ENABLE_LOGGING
218:                 DEFINE_INTERRUPT_HANDLERS(2)
00E40C  F80036     PUSH RCOUNT
00E40E  BE9F80     MOV.D W0, [W15++]
00E410  BE9F82     MOV.D W2, [W15++]
00E412  BE9F84     MOV.D W4, [W15++]
00E414  BE9F86     MOV.D W6, [W15++]
00E416  F80032     PUSH DSRPAG
00E418  202000     MOV #0x200, W0
00E41A  880190     MOV W0, DSRPAG
00E5EE  A9C087     BCLR 0x87, #6
00E5F0  F90032     POP DSRPAG
00E5F2  78044F     MOV [--W15], W8
00E5F4  BE034F     MOV.D [--W15], W6
00E5F6  BE024F     MOV.D [--W15], W4
00E5F8  BE014F     MOV.D [--W15], W2
00E5FA  BE004F     MOV.D [--W15], W0
00E5FC  F90036     POP RCOUNT
00E5FE  064000     RETFIE
219:               #endif
220:               
221:               #if NUM_UART_MODULES >= 3
222:                 DEFINE_INTERRUPT_HANDLERS(3)
00E3EA  F80036     PUSH RCOUNT
00E3EC  BE9F80     MOV.D W0, [W15++]
00E3EE  BE9F82     MOV.D W2, [W15++]
00E3F0  BE9F84     MOV.D W4, [W15++]
00E3F2  BE9F86     MOV.D W6, [W15++]
00E3F4  F80032     PUSH DSRPAG
00E3F6  202000     MOV #0x200, W0
00E3F8  880190     MOV W0, DSRPAG
00E630  A9408E     BCLR IFS5, #2
00E632  F90032     POP DSRPAG
00E634  78044F     MOV [--W15], W8
00E636  BE034F     MOV.D [--W15], W6
00E638  BE024F     MOV.D [--W15], W4
00E63A  BE014F     MOV.D [--W15], W2
00E63C  BE004F     MOV.D [--W15], W0
00E63E  F90036     POP RCOUNT
00E640  064000     RETFIE
223:               #endif
224:               
225:               #if NUM_UART_MODULES >= 4
226:                 DEFINE_INTERRUPT_HANDLERS(4)
00E20E  A9008F     BCLR 0x8F, #0
00E210  F90032     POP DSRPAG
00E212  78044F     MOV [--W15], W8
00E214  BE034F     MOV.D [--W15], W6
00E216  BE024F     MOV.D [--W15], W4
00E218  BE014F     MOV.D [--W15], W2
00E21A  BE004F     MOV.D [--W15], W0
00E21C  F90036     POP RCOUNT
00E21E  064000     RETFIE
00E3C8  F80036     PUSH RCOUNT
00E3CA  BE9F80     MOV.D W0, [W15++]
00E3CC  BE9F82     MOV.D W2, [W15++]
00E3CE  BE9F84     MOV.D W4, [W15++]
00E3D0  BE9F86     MOV.D W6, [W15++]
00E3D2  F80032     PUSH DSRPAG
00E3D4  202000     MOV #0x200, W0
00E3D6  880190     MOV W0, DSRPAG
227:               #endif
228:               
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/app_layer_v1/timers.c  ---
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include "timers.h"
31:                
32:                #include "Compiler.h"
33:                #include "logging.h"
34:                
35:                void TimersInit() {
36:                  log_printf("TimersInit()");
37:                  // timer 3 is sysclk / 8 = 2MHz
38:                  T3CON = 0x8010;
0164EE  280100     MOV #0x8010, W0
0164F0  880890     MOV W0, T3CON
39:                  // timer 4 is sysclk / 64 = 250KHz
40:                  T4CON = 0x8020;
0164F2  400070     ADD W0, #0x10, W0
0164F4  8808F0     MOV W0, T4CON
41:                  // timer 5 is sysclk / 256 = 62.5KHz
42:                  T5CON = 0x8030;
0164F6  400070     ADD W0, #0x10, W0
0164F8  880900     MOV W0, T5CON
43:                }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/app_layer_v1/spi.c  ------
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include "spi.h"
31:                
32:                #include <assert.h>
33:                #include "byte_queue.h"
34:                #include "platform.h"
35:                #include "logging.h"
36:                #include "pins.h"
37:                #include "pp_util.h"
38:                #include "protocol.h"
39:                #include "sync.h"
40:                
41:                #define RX_BUF_SIZE 256
42:                #define TX_BUF_SIZE 256
43:                
44:                typedef enum {
45:                  PACKET_STATE_IDLE,
46:                  PACKET_STATE_IN_PROGRESS,
00DCF6  200428     MOV #0x42, W8
00DCF8  784418     MOV.B [W8], W8
00DCFA  FB8408     ZE W8, W8
00DCFC  DE4445     LSR W8, #5, W8
00DD28  BFC042     MOV.B SR, WREG
00DD60  200428     MOV #0x42, W8
00DD62  784418     MOV.B [W8], W8
00DD64  FB8408     ZE W8, W8
00DD66  DE4445     LSR W8, #5, W8
00DD7C  BFC042     MOV.B SR, WREG
00DD9A  200428     MOV #0x42, W8
00DD9C  784418     MOV.B [W8], W8
00DD9E  FB8408     ZE W8, W8
00DDA0  DE4445     LSR W8, #5, W8
00DDCC  BFC042     MOV.B SR, WREG
00DE04  200428     MOV #0x42, W8
00DE06  784418     MOV.B [W8], W8
00DE08  FB8408     ZE W8, W8
00DE0A  DE4445     LSR W8, #5, W8
00DE20  BFC042     MOV.B SR, WREG
00DE32  200423     MOV #0x42, W3
00DE34  784193     MOV.B [W3], W3
00DE46  BFC042     MOV.B SR, WREG
00DE96  200428     MOV #0x42, W8
00DE98  784418     MOV.B [W8], W8
00DE9A  FB8408     ZE W8, W8
00DE9C  DE4445     LSR W8, #5, W8
00DED0  BFC042     MOV.B SR, WREG
47:                  PACKET_STATE_DONE
00DCFE  BFC042     MOV.B SR, WREG
00DD00  60407F     AND.B W0, #0x1F, W0
00DD02  B3CA01     MOV #0xA0, W1
00DD04  704001     IOR.B W0, W1, W0
00DD06  B7E042     MOV.B WREG, SR
00DD2A  DD4445     SL W8, #5, W8
00DD2C  BFC042     MOV.B SR, WREG
00DD2E  60407F     AND.B W0, #0x1F, W0
00DD30  704008     IOR.B W0, W8, W0
00DD32  B7E042     MOV.B WREG, SR
00DD68  BFC042     MOV.B SR, WREG
00DD6A  60407F     AND.B W0, #0x1F, W0
00DD6C  B3CA01     MOV #0xA0, W1
00DD6E  704001     IOR.B W0, W1, W0
00DD70  B7E042     MOV.B WREG, SR
00DD7E  DD4445     SL W8, #5, W8
00DD80  BFC042     MOV.B SR, WREG
00DD82  60407F     AND.B W0, #0x1F, W0
00DD84  704008     IOR.B W0, W8, W0
00DD86  B7E042     MOV.B WREG, SR
00DDA2  BFC042     MOV.B SR, WREG
00DDA4  60407F     AND.B W0, #0x1F, W0
00DDA6  B3CA01     MOV #0xA0, W1
00DDA8  704001     IOR.B W0, W1, W0
00DDAA  B7E042     MOV.B WREG, SR
00DDCE  DD4445     SL W8, #5, W8
00DDD0  BFC042     MOV.B SR, WREG
00DDD2  60407F     AND.B W0, #0x1F, W0
00DDD4  704008     IOR.B W0, W8, W0
00DDD6  B7E042     MOV.B WREG, SR
00DE0C  BFC042     MOV.B SR, WREG
00DE0E  60407F     AND.B W0, #0x1F, W0
00DE10  B3CA01     MOV #0xA0, W1
00DE12  704001     IOR.B W0, W1, W0
00DE14  B7E042     MOV.B WREG, SR
00DE22  DD4445     SL W8, #5, W8
00DE24  BFC042     MOV.B SR, WREG
00DE26  60407F     AND.B W0, #0x1F, W0
00DE28  704008     IOR.B W0, W8, W0
00DE2A  B7E042     MOV.B WREG, SR
00DE36  BFC042     MOV.B SR, WREG
00DE38  60407F     AND.B W0, #0x1F, W0
00DE3A  B3CA01     MOV #0xA0, W1
00DE3C  704001     IOR.B W0, W1, W0
00DE3E  B7E042     MOV.B WREG, SR
00DE48  B3CE00     MOV #0xE0, W0
00DE4A  61C180     AND.B W3, W0, W3
00DE4C  BFC042     MOV.B SR, WREG
00DE4E  60407F     AND.B W0, #0x1F, W0
00DE50  704003     IOR.B W0, W3, W0
00DE52  B7E042     MOV.B WREG, SR
00DE9E  BFC042     MOV.B SR, WREG
00DEA0  60407F     AND.B W0, #0x1F, W0
00DEA2  B3CA02     MOV #0xA0, W2
00DEA4  704002     IOR.B W0, W2, W0
00DEA6  B7E042     MOV.B WREG, SR
00DED2  DD4445     SL W8, #5, W8
00DED4  BFC042     MOV.B SR, WREG
00DED6  60407F     AND.B W0, #0x1F, W0
00DED8  704008     IOR.B W0, W8, W0
00DEDA  B7E042     MOV.B WREG, SR
48:                } PACKET_STATE;
49:                
50:                typedef struct {
51:                  PACKET_STATE packet_state;
52:                  int num_tx_since_last_report;
00DF22  980041     MOV W1, [W0+8]
00DF30  981401     MOV W1, [W8+32]
53:                  BYTE cur_msg_dest;
00DF24  980021     MOV W1, [W0+4]
00DF32  980021     MOV W1, [W0+4]
54:                  BYTE cur_msg_total_tx;  // total number of bytes left to send
00DF26  980031     MOV W1, [W0+6]
00DF34  980031     MOV W1, [W0+6]
55:                  BYTE cur_msg_data_tx;   // number of *non-garbage* bytes left to send
56:                  BYTE cur_msg_trim_rx;   // number of *garbage* bytes left to read
57:                  BYTE cur_msg_total_rx;  // number of total bytes left to read
58:                  BYTE cur_msg_rx_size;   // number of bytes to send back
00DF1A  200222     MOV #0x22, W2
00DF1C  440802     ADD W8, W2, [W0]
00DF2A  201222     MOV #0x122, W2
00DF2C  440802     ADD W8, W2, [W0]
59:                  BYTE can_send;          // number of bytes available in the FIFO
00DF1E  20100B     MOV #0x100, W11
00DF20  98001B     MOV W11, [W0+2]
00DF2E  98001B     MOV W11, [W0+2]
60:                
61:                  // message format:
62:                  // BYTE dest
63:                  // BYTE tx_size
64:                  // BYTE tx_data[tx_size]
65:                  BYTE_QUEUE rx_queue;
66:                
67:                  int num_messages_rx_queue;
68:                
69:                  // message format:
70:                  // BYTE dest
71:                  // BYTE total_size
72:                  // BYTE data_size
73:                  // BYTE rx_trim
74:                  // BYTE tx_data[tx_size]
75:                  BYTE_QUEUE tx_queue;
76:                
77:                  BYTE rx_buffer[RX_BUF_SIZE];
78:                  BYTE tx_buffer[TX_BUF_SIZE];
79:                } SPI_STATE;
80:                
81:                static SPI_STATE spis[NUM_SPI_MODULES];
82:                
83:                typedef struct {
84:                  unsigned int spixstat;
85:                  unsigned int spixcon1;
86:                  unsigned int spixcon2;
87:                  unsigned int reserved;
88:                  unsigned int spixbuf;
89:                } SPIREG;
90:                
91:                #define _SPIREG_REF_COMMA(num, dummy) (volatile SPIREG*) &SPI##num##STAT,
92:                
93:                volatile SPIREG* spi_reg[NUM_SPI_MODULES] = {
94:                  REPEAT_1B(_SPIREG_REF_COMMA, NUM_SPI_MODULES, 0)
95:                };
96:                
97:                DEFINE_REG_SETTERS_1B(NUM_SPI_MODULES, _SPI, IF)
98:                DEFINE_REG_SETTERS_1B(NUM_SPI_MODULES, _SPI, IE)
99:                DEFINE_REG_SETTERS_1B(NUM_SPI_MODULES, _SPI, IP)
00DABC  BE9F88     MOV.D W8, [W15++]
00DABE  BE9F8A     MOV.D W10, [W15++]
00DAC0  781F8C     MOV W12, [W15++]
00DAC2  780080     MOV W0, W1
100:               
101:               static void SPIConfigMasterInternal(int spi_num, int scale, int div, int smp_end, int clk_edge,
102:                              int clk_pol, int external);
103:               
104:               void SPIInit() {
00E012  EB0400     CLR W8
00E014  21E0A9     MOV #0x1E0A, W9
105:                 int i;
106:                 for (i = 0; i < NUM_SPI_MODULES; ++i) {
00E02C  E80408     INC W8, W8
00E02E  540FE3     SUB W8, #0x3, [W15]
00E030  3AFFF2     BRA NZ, 0xE016
107:                   SPIConfigMasterInternal(i, 0, 0, 0, 0, 0, 0);
00E016  EB0300     CLR W6
00E018  780286     MOV W6, W5
00E01A  780206     MOV W6, W4
00E01C  780186     MOV W6, W3
00E01E  780106     MOV W6, W2
00E020  780086     MOV W6, W1
00E022  780008     MOV W8, W0
00E024  07FF60     RCALL SPIConfigMasterInternal
108:                   Set_SPIIP[i](5);  // int. priority 5
00E026  7800B9     MOV [W9++], W1
00E028  200050     MOV #0x5, W0
00E02A  010001     CALL W1
109:                 }
110:               }
111:               
112:               static inline void SPISendStatus(int spi_num, int enabled) {
113:                 OUTGOING_MESSAGE msg;
114:                 msg.type = SPI_STATUS;
00DF98  B3C100     MOV #0x10, W0
00DF9A  9F7780     MOV.B W0, [W15-80]
00DFE6  2FFCD1     MOV #0xFFCD, W1
00DFE8  478001     ADD W15, W1, W0
00DFEA  B3C101     MOV #0x10, W1
00DFEC  784801     MOV.B W1, [W0]
115:                 msg.args.spi_status.spi_num = spi_num;
00DF9C  648063     AND W9, #0x3, W0
00DF9E  DD0048     SL W0, #8, W0
00DFA0  2FCFF1     MOV #0xFCFF, W1
00DFA2  97990F     MOV [W15-80], W2
00DFA4  610101     AND W2, W1, W2
00DFA6  710080     IOR W2, W0, W1
00DFEE  64C1E3     AND.B W9, #0x3, W3
00DFF0  97C8EF     MOV.B [W15-50], W1
00DFF2  B3CFC2     MOV #0xFC, W2
00DFF4  60C082     AND.B W1, W2, W1
00DFF6  70C083     IOR.B W1, W3, W1
116:                 msg.args.spi_status.enabled = enabled;
00DFA8  280000     MOV #0x8000, W0
00DFAA  708100     IOR W1, W0, W2
00DFAC  9F9F82     MOV W2, [W15-80]
00DFF8  A17401     BCLR.B W1, #7
00DFFA  9FCFE1     MOV.B W1, [W15-50]
117:                 AppProtocolSendMessage(&msg);
00DFAE  2FFB00     MOV #0xFFB0, W0
00DFB0  40000F     ADD W0, W15, W0
00DFB2  07F56C     RCALL AppProtocolSendMessage
00DFFC  07F547     RCALL AppProtocolSendMessage
118:               }
119:               
120:               static void SPIConfigMasterInternal(int spi_num, int scale, int div, int smp_end, int clk_edge,
121:                              int clk_pol, int external) {
122:                 volatile SPIREG* regs = spi_reg[spi_num];
00DEFE  400600     ADD W0, W0, W12
00DF00  21DF80     MOV #0x1DF8, W0
00DF02  78056C     MOV [W12+W0], W10
123:                 SPI_STATE* spi = &spis[spi_num];
00DF04  202220     MOV #0x222, W0
00DF06  B9C800     MUL.SS W9, W0, W0
00DF08  210A82     MOV #0x10A8, W2
00DF0A  410400     ADD W2, W0, W8
124:                 if (external) {
125:                   log_printf("SPIConfigMaster(%d, %d, %d, %d, %d, %d)", spi_num, scale, div,
126:                              smp_end, clk_edge, clk_pol);
127:                 }
128:                 Set_SPIIE[spi_num](0);  // disable int.
00DF0C  21DFE0     MOV #0x1DFE, W0
00DF0E  7800EC     MOV [W12+W0], W1
00DF10  EB0000     CLR W0
00DF12  010001     CALL W1
129:                 regs->spixstat = 0x0000;  // disable SPI
00DF14  EB0080     CLR W1
00DF16  780D01     MOV W1, [W10]
130:                 // clear SW buffers
131:                 ByteQueueInit(&spi->rx_queue, spi->rx_buffer, RX_BUF_SIZE);
00DF18  44006C     ADD W8, #0xC, W0
132:                 ByteQueueInit(&spi->tx_queue, spi->tx_buffer, TX_BUF_SIZE);
00DF28  440078     ADD W8, #0x18, W0
133:                 spi->num_tx_since_last_report = 0;
00DF36  980411     MOV W1, [W8+2]
134:                 spi->num_messages_rx_queue = 0;
00DF38  980C31     MOV W1, [W8+22]
135:                 spi->packet_state = PACKET_STATE_IDLE;
00DF3A  780C01     MOV W1, [W8]
136:                 if (scale || div) {
00DF3C  E0000E     CP0 W14
00DF3E  3A000B     BRA NZ, 0xDF56
00DF40  97B05F     MOV [W15-22], W0
00DF42  E00000     CP0 W0
00DF44  3A0008     BRA NZ, 0xDF56
137:                   if (external) {
00DF56  E0000D     CP0 W13
00DF58  3A001F     BRA NZ, 0xDF98
138:                     SPISendStatus(spi_num, 1);
139:                   }
140:                   spi->num_tx_since_last_report = TX_BUF_SIZE;
00DF5A  98041B     MOV W11, [W8+2]
00DFB4  98041B     MOV W11, [W8+2]
141:                   regs->spixcon1 = (smp_end << 9)
00DF5C  97B06F     MOV [W15-20], W0
00DF5E  DD00C9     SL W0, #9, W1
00DF60  97B17F     MOV [W15-18], W2
00DF62  DD1048     SL W2, #8, W0
00DF64  708080     IOR W1, W0, W1
00DF66  97B90F     MOV [W15-16], W2
00DF68  DD1046     SL W2, #6, W0
00DF6A  708080     IOR W1, W0, W1
00DF6C  97B15F     MOV [W15-22], W2
00DF6E  110067     SUBR W2, #0x7, W0
00DF70  DD0042     SL W0, #2, W0
00DF72  708080     IOR W1, W0, W1
00DF74  170063     SUBR W14, #0x3, W0
00DF76  708080     IOR W1, W0, W1
00DF78  A05001     BSET W1, #5
00DF7A  980511     MOV W1, [W10+2]
00DFB6  97B06F     MOV [W15-20], W0
00DFB8  DD00C9     SL W0, #9, W1
00DFBA  97B17F     MOV [W15-18], W2
00DFBC  DD1048     SL W2, #8, W0
00DFBE  708080     IOR W1, W0, W1
00DFC0  97B90F     MOV [W15-16], W2
00DFC2  DD1046     SL W2, #6, W0
00DFC4  708080     IOR W1, W0, W1
00DFC6  97B15F     MOV [W15-22], W2
00DFC8  110067     SUBR W2, #0x7, W0
00DFCA  DD0042     SL W0, #2, W0
00DFCC  708080     IOR W1, W0, W1
00DFCE  170063     SUBR W14, #0x3, W0
00DFD0  708080     IOR W1, W0, W1
00DFD2  A05001     BSET W1, #5
00DFD4  980511     MOV W1, [W10+2]
142:                                    | (clk_edge << 8)
143:                                    | (clk_pol << 6)
144:                                    | (1 << 5)  // master
145:                                    | ((7 - div) << 2)
146:                                    | ((3 - scale));
147:                   regs->spixcon2 = 0x0001;  // enhanced buffer mode
00DF7C  200010     MOV #0x1, W0
00DF7E  980520     MOV W0, [W10+4]
00DFD6  200010     MOV #0x1, W0
00DFD8  980520     MOV W0, [W10+4]
148:                   regs->spixstat = (1 << 15)  // enable
00DF80  280041     MOV #0x8004, W1
00DF82  780D01     MOV W1, [W10]
00DFDA  280041     MOV #0x8004, W1
00DFDC  780D01     MOV W1, [W10]
149:                                    | (1 << 2);  // int. when RX FIFO is non-empty
150:                   Set_SPIIF[spi_num](1);  // set int. flag, so int. will occur as soon as data is
00DF84  21E041     MOV #0x1E04, W1
00DF86  7880EC     MOV [W12+W1], W1
00DF88  010001     CALL W1
00DFDE  21E041     MOV #0x1E04, W1
00DFE0  7880EC     MOV [W12+W1], W1
00DFE2  010001     CALL W1
00DFE4  37FFD2     BRA 0xDF8A
151:                                       // written
152:                 } else {
153:                   if (external) {
00DF46  E0000D     CP0 W13
00DF48  3A004E     BRA NZ, 0xDFE6
154:                     SPISendStatus(spi_num, 0);
155:                   }
156:                 }
157:               }
00DF4A  78074F     MOV [--W15], W14
00DF4C  BE064F     MOV.D [--W15], W12
00DF4E  BE054F     MOV.D [--W15], W10
00DF50  BE044F     MOV.D [--W15], W8
00DF52  B1044F     SUB #0x44, W15
00DF54  060000     RETURN
00DF8A  78074F     MOV [--W15], W14
00DF8C  BE064F     MOV.D [--W15], W12
00DF8E  BE054F     MOV.D [--W15], W10
00DF90  BE044F     MOV.D [--W15], W8
00DF92  B1044F     SUB #0x44, W15
00DF94  060000     RETURN
00DF96  37FFDF     BRA 0xDF56
158:               
159:               void SPIConfigMaster(int spi_num, int scale, int div, int smp_end, int clk_edge,
160:                              int clk_pol) {
161:                 SPIConfigMasterInternal(spi_num, scale, div, smp_end, clk_edge, clk_pol, 1);
00E00C  200016     MOV #0x1, W6
00E00E  37FF6B     BRA SPIConfigMasterInternal
162:               }
00E010  BE9F88     MOV.D W8, [W15++]
163:               
164:               static void SPIReportTxStatus(int spi_num) {
165:                 int report;
166:                 SPI_STATE* spi = &spis[spi_num];
167:                 BYTE prev = SyncInterruptLevel(5);
168:                 report = spi->num_tx_since_last_report;
00DE40  97B07F     MOV [W15-18], W0
00DE42  780110     MOV [W0], W2
169:                 spi->num_tx_since_last_report = 0;
00DE44  EB0800     CLR [W0]
170:                 SyncInterruptLevel(prev);
171:                 OUTGOING_MESSAGE msg;
172:                 msg.type = SPI_REPORT_TX_STATUS;
00DE54  B3C120     MOV #0x12, W0
00DE56  9FD790     MOV.B W0, [W15-47]
173:                 msg.args.spi_report_tx_status.spi_num = spi_num;
174:                 msg.args.spi_report_tx_status.bytes_to_add = report;
00DE58  DD10C2     SL W2, #2, W1
00DE5A  674063     AND.B W14, #0x3, W0
00DE5C  704001     IOR.B W0, W1, W0
00DE5E  9FD7A0     MOV.B W0, [W15-46]
00DE60  DE1146     LSR W2, #6, W2
00DE62  9FD7B2     MOV.B W2, [W15-45]
175:                 AppProtocolSendMessage(&msg);
00DCCA  B0222D     ADD #0x222, W13
00DCCC  B02221     ADD #0x222, W1
00DCCE  9FB7F1     MOV W1, [W15-18]
00DCD0  E8470E     INC.B W14, W14
00DCD2  674763     AND.B W14, #0x3, W14
00DE64  2FFD10     MOV #0xFFD1, W0
00DE66  40000F     ADD W0, W15, W0
00DE68  07F611     RCALL AppProtocolSendMessage
00DE6A  97B0FF     MOV [W15-18], W1
00DE6C  B0222D     ADD #0x222, W13
00DE6E  B02221     ADD #0x222, W1
00DE70  9FB7F1     MOV W1, [W15-18]
00DE72  E8470E     INC.B W14, W14
00DE74  674763     AND.B W14, #0x3, W14
176:               }
177:               
178:               void SPITasks() {
00DCB0  210BED     MOV #0x10BE, W13
00DCB2  210AA0     MOV #0x10AA, W0
00DCB4  9FB7F0     MOV W0, [W15-18]
00DCB6  EB4700     CLR.B W14
00DCB8  2FFB41     MOV #0xFFB4, W1
00DCBA  478581     ADD W15, W1, W11
179:                 int i;
180:                 for (i = 0; i < NUM_SPI_MODULES; ++i) {
00DCD4  574FE3     SUB.B W14, #0x3, [W15]
00DCD6  3AFFF2     BRA NZ, 0xDCBC
00DE7C  BE9F88     MOV.D W8, [W15++]
00DE7E  BE9F8A     MOV.D W10, [W15++]
00DE80  BE9F8C     MOV.D W12, [W15++]
00DE82  781F8E     MOV W14, [W15++]
00DE84  780700     MOV W0, W14
00DE86  780602     MOV W2, W12
00DE88  780503     MOV W3, W10
00DE8A  780484     MOV W4, W9
00DE8C  780585     MOV W5, W11
181:                   int size1, size2, size;
182:                   const BYTE *data1, *data2;
183:                   SPI_STATE* spi = &spis[i];
184:                   BYTE_QUEUE* q = &spi->rx_queue;
00DCBC  56866A     SUB W13, #0xA, W12
185:                   BYTE prev;
186:                   while (spi->num_messages_rx_queue) {
00DCBE  E0001D     CP0 [W13]
00DCC0  3A0011     BRA NZ, 0xDCE4
00DD88  E00001     CP0 W1
00DD8A  32FF9B     BRA Z, 0xDCC2
00DE2C  E00001     CP0 W1
00DE2E  3AFF5C     BRA NZ, 0xDCE8
00DE30  37FF48     BRA 0xDCC2
187:                     OUTGOING_MESSAGE msg;
188:                     msg.type = SPI_DATA;
00DCE8  B3C110     MOV #0x11, W0
00DCEA  784D80     MOV.B W0, [W11]
00DD8C  B3C110     MOV #0x11, W0
00DD8E  784D80     MOV.B W0, [W11]
189:                     msg.args.spi_data.spi_num = i;
00DCEC  97B80F     MOV [W15-16], W0
00DCEE  DD00CE     SL W0, #14, W1
00DCF0  23FFF0     MOV #0x3FFF, W0
00DCF2  600D9B     AND W0, [W11], [W11]
00DCF4  708D9B     IOR W1, [W11], [W11]
00DD90  97B80F     MOV [W15-16], W0
00DD92  DD00CE     SL W0, #14, W1
00DD94  23FFF0     MOV #0x3FFF, W0
00DD96  600D9B     AND W0, [W11], [W11]
00DD98  708D9B     IOR W1, [W11], [W11]
190:                     prev = SyncInterruptLevel(5);
191:                     msg.args.spi_data.ss_pin = ByteQueuePullByte(q);
00DD08  78000C     MOV W12, W0
00DD0A  071EDA     RCALL ByteQueuePullByte
00DD0C  B203F0     AND #0x3F, W0
00DD0E  9798BF     MOV [W15-74], W1
00DD10  2FFC02     MOV #0xFFC0, W2
00DD12  608082     AND W1, W2, W1
00DD14  708080     IOR W1, W0, W1
00DD16  9F9FB1     MOV W1, [W15-74]
00DDAC  78000C     MOV W12, W0
00DDAE  071E88     RCALL ByteQueuePullByte
00DDB0  B203F0     AND #0x3F, W0
00DDB2  9798BF     MOV [W15-74], W1
00DDB4  2FFC02     MOV #0xFFC0, W2
00DDB6  608082     AND W1, W2, W1
00DDB8  708080     IOR W1, W0, W1
00DDBA  9F9FB1     MOV W1, [W15-74]
192:                     msg.args.spi_data.size = ByteQueuePullByte(q) - 1;
00DD18  78000C     MOV W12, W0
00DD1A  071ED2     RCALL ByteQueuePullByte
00DD1C  E94000     DEC.B W0, W0
00DD1E  B203F0     AND #0x3F, W0
00DD20  DD0048     SL W0, #8, W0
00DD22  2C0FF1     MOV #0xC0FF, W1
00DD24  608D9B     AND W1, [W11], [W11]
00DD26  700D9B     IOR W0, [W11], [W11]
00DDBC  78000C     MOV W12, W0
00DDBE  071E80     RCALL ByteQueuePullByte
00DDC0  E94000     DEC.B W0, W0
00DDC2  B203F0     AND #0x3F, W0
00DDC4  DD0048     SL W0, #8, W0
00DDC6  2C0FF1     MOV #0xC0FF, W1
00DDC8  608D9B     AND W1, [W11], [W11]
00DDCA  700D9B     IOR W0, [W11], [W11]
193:                     SyncInterruptLevel(prev);
194:                     ByteQueuePeekMax(q, msg.args.spi_data.size + 1, &data1, &size1, &data2,
00DD34  78009B     MOV [W11], W1
00DD36  DE08C8     LSR W1, #8, W1
00DD38  B203F1     AND #0x3F, W1
00DD3A  E80081     INC W1, W1
00DD3C  2FFAE5     MOV #0xFFAE, W5
00DD3E  42828F     ADD W5, W15, W5
00DD40  2FFB24     MOV #0xFFB2, W4
00DD42  42020F     ADD W4, W15, W4
00DD44  2FFAC3     MOV #0xFFAC, W3
00DD46  41818F     ADD W3, W15, W3
00DD48  2FFB02     MOV #0xFFB0, W2
00DD4A  41010F     ADD W2, W15, W2
00DD4C  78000C     MOV W12, W0
00DD4E  071ECE     RCALL ByteQueuePeekMax
00DDD8  78009B     MOV [W11], W1
00DDDA  DE08C8     LSR W1, #8, W1
00DDDC  B203F1     AND #0x3F, W1
00DDDE  E80081     INC W1, W1
00DDE0  2FFAE5     MOV #0xFFAE, W5
00DDE2  42828F     ADD W5, W15, W5
00DDE4  2FFB24     MOV #0xFFB2, W4
00DDE6  42020F     ADD W4, W15, W4
00DDE8  2FFAC3     MOV #0xFFAC, W3
00DDEA  41818F     ADD W3, W15, W3
00DDEC  2FFB02     MOV #0xFFB0, W2
00DDEE  41010F     ADD W2, W15, W2
00DDF0  78000C     MOV W12, W0
00DDF2  071E7C     RCALL ByteQueuePeekMax
195:                                      &size2);
196:                     size = size1 + size2;
00DD50  97956F     MOV [W15-84], W10
00DD52  9794FF     MOV [W15-82], W9
00DDF4  97956F     MOV [W15-84], W10
00DDF6  9794FF     MOV [W15-82], W9
197:                     assert(size == msg.args.spi_data.size + 1);
198:                     log_printf("SPI %d received %d bytes", i, size);
199:                     AppProtocolSendMessageWithVarArgSplit(&msg, data1, size1, data2, size2);
00DD54  97988F     MOV [W15-80], W1
00DD56  780209     MOV W9, W4
00DD58  97999F     MOV [W15-78], W3
00DD5A  78010A     MOV W10, W2
00DD5C  78000B     MOV W11, W0
00DD5E  07F620     RCALL AppProtocolSendMessageWithVarArgSplit
00DDF8  97988F     MOV [W15-80], W1
00DDFA  780209     MOV W9, W4
00DDFC  97999F     MOV [W15-78], W3
00DDFE  78010A     MOV W10, W2
00DE00  78000B     MOV W11, W0
00DE02  07F5CE     RCALL AppProtocolSendMessageWithVarArgSplit
200:                     prev = SyncInterruptLevel(5);
201:                     ByteQueuePull(q, size);
00DD72  450089     ADD W10, W9, W1
00DD74  78000C     MOV W12, W0
00DD76  071ECD     RCALL ByteQueuePull
00DE16  450089     ADD W10, W9, W1
00DE18  78000C     MOV W12, W0
00DE1A  071E7B     RCALL ByteQueuePull
202:                     --spi->num_messages_rx_queue;
00DD78  E9009D     DEC [W13], W1
00DD7A  780E81     MOV W1, [W13]
00DE1C  E9009D     DEC [W13], W1
00DE1E  780E81     MOV W1, [W13]
203:                     SyncInterruptLevel(prev);
204:                   }
205:                   if (spi->num_tx_since_last_report > TX_BUF_SIZE / 2) {
00DCC2  200800     MOV #0x80, W0
00DCC4  97B0FF     MOV [W15-18], W1
00DCC6  100F91     SUBR W0, [W1], [W15]
00DCC8  3C00B4     BRA GT, 0xDE32
206:                     SPIReportTxStatus(i);
207:                   }
208:                 }
209:               }
00DCD8  78074F     MOV [--W15], W14
00DCDA  BE064F     MOV.D [--W15], W12
00DCDC  BE054F     MOV.D [--W15], W10
00DCDE  BE044F     MOV.D [--W15], W8
00DCE0  B1048F     SUB #0x48, W15
00DCE2  060000     RETURN
00DCE4  FB800E     ZE W14, W0
00DCE6  9FBF80     MOV W0, [W15-16]
210:               
211:               static void SPIInterrupt(int spi_num) {
212:                 volatile SPIREG* reg = spi_reg[spi_num];
00DAC4  400600     ADD W0, W0, W12
00DAC6  21DF80     MOV #0x1DF8, W0
00DAC8  78056C     MOV [W12+W0], W10
213:                 SPI_STATE* spi = &spis[spi_num];
00DACA  202220     MOV #0x222, W0
00DACC  B98900     MUL.SS W1, W0, W2
00DACE  210A80     MOV #0x10A8, W0
00DAD0  400402     ADD W0, W2, W8
214:                 BYTE_QUEUE* tx_queue = &spi->tx_queue;
00DAD2  4405F8     ADD W8, #0x18, W11
215:                 BYTE_QUEUE* rx_queue = &spi->rx_queue;
00DAD4  4404EC     ADD W8, #0xC, W9
216:                 int bytes_to_write;
217:               
218:                 // packet initialiation if needed
219:                 if (spi->packet_state == PACKET_STATE_IDLE) {
00DAD6  E00018     CP0 [W8]
00DAD8  3A0026     BRA NZ, 0xDB26
220:                     assert(ByteQueueSize(tx_queue) >= 4);
221:                     // can't have incoming data on idle state. if we do - it's a bug
222:                     assert(reg->spixstat & (1 << 5));
223:                     spi->cur_msg_dest = ByteQueuePullByte(tx_queue);
00DADA  78000B     MOV W11, W0
00DADC  071FF1     RCALL ByteQueuePullByte
00DADE  984440     MOV.B W0, [W8+4]
224:                     spi->cur_msg_total_tx = ByteQueuePullByte(tx_queue);
00DAE0  78000B     MOV W11, W0
00DAE2  071FEE     RCALL ByteQueuePullByte
00DAE4  984450     MOV.B W0, [W8+5]
225:                     spi->cur_msg_total_rx = spi->cur_msg_total_tx;
00DAE6  984C00     MOV.B W0, [W8+8]
226:                     spi->cur_msg_data_tx = ByteQueuePullByte(tx_queue);
00DAE8  78000B     MOV W11, W0
00DAEA  071FEA     RCALL ByteQueuePullByte
00DAEC  984460     MOV.B W0, [W8+6]
227:                     spi->cur_msg_trim_rx = ByteQueuePullByte(tx_queue);
00DAEE  78000B     MOV W11, W0
00DAF0  071FE7     RCALL ByteQueuePullByte
00DAF2  984470     MOV.B W0, [W8+7]
228:                     spi->can_send = 8;
00DAF4  B3C081     MOV #0x8, W1
00DAF6  984C21     MOV.B W1, [W8+10]
229:                     spi->num_tx_since_last_report += 4;
00DAF8  900098     MOV [W8+2], W1
00DAFA  4080E4     ADD W1, #0x4, W1
00DAFC  980411     MOV W1, [W8+2]
230:               
231:                     // write packet header to rx_queue, if non-empty
232:                     spi->cur_msg_rx_size = spi->cur_msg_total_rx - spi->cur_msg_trim_rx;
00DAFE  904888     MOV.B [W8+8], W1
00DB00  50C080     SUB.B W1, W0, W1
00DB02  984C11     MOV.B W1, [W8+9]
233:                     if (spi->cur_msg_rx_size > 0) {
00DB04  3A0087     BRA NZ, 0xDC14
234:                       ByteQueuePushByte(rx_queue, spi->cur_msg_dest);
00DC14  9040C8     MOV.B [W8+4], W1
00DC16  780009     MOV W9, W0
00DC18  071F98     RCALL ByteQueuePushByte
235:                       ByteQueuePushByte(rx_queue, spi->cur_msg_rx_size);
00DC1A  904898     MOV.B [W8+9], W1
00DC1C  780009     MOV W9, W0
00DC1E  071F95     RCALL ByteQueuePushByte
236:                     }
237:               
238:                     PinSetLat(spi->cur_msg_dest, 0);  // activate SS
00DB06  904048     MOV.B [W8+4], W0
00DB08  FB8000     ZE W0, W0
00DB0A  EB0080     CLR W1
00DB0C  072189     RCALL PinSetLat
00DC20  904048     MOV.B [W8+4], W0
00DC22  FB8000     ZE W0, W0
00DC24  EB0080     CLR W1
00DC26  0720FC     RCALL PinSetLat
239:                     spi->packet_state = PACKET_STATE_IN_PROGRESS;
00DB0E  200010     MOV #0x1, W0
00DB10  780C00     MOV W0, [W8]
00DC28  200010     MOV #0x1, W0
00DC2A  780C00     MOV W0, [W8]
00DC2C  37FF72     BRA 0xDB12
240:                 } else {
241:                   // read as much incoming data as possible into rx_queue
242:                   Set_SPIIF[spi_num](0);
00DB26  21E040     MOV #0x1E04, W0
00DB28  7800EC     MOV [W12+W0], W1
00DB2A  EB0000     CLR W0
00DB2C  010001     CALL W1
243:                   while (!(reg->spixstat & (1 << 5))) {
00DB2E  A3581A     BTST.Z [W10], #5
00DB30  3A0058     BRA NZ, 0xDBE2
00DB4A  A3581A     BTST.Z [W10], #5
00DB4C  32FFF2     BRA Z, 0xDB32
00DB6E  A3581A     BTST.Z [W10], #5
00DB70  32FFE0     BRA Z, 0xDB32
00DB72  37FFED     BRA 0xDB4E
244:                     BYTE rx_byte = reg->spixbuf;
00DB32  9000CA     MOV [W10+8], W1
245:                     if (spi->cur_msg_trim_rx) {
00DB34  904078     MOV.B [W8+7], W0
00DB36  E00400     CP0.B W0
00DB38  320012     BRA Z, 0xDB5E
246:                       --spi->cur_msg_trim_rx;
00DB3A  E94000     DEC.B W0, W0
00DB3C  984470     MOV.B W0, [W8+7]
247:                     } else {
248:                       ByteQueuePushByte(rx_queue, rx_byte);
00DB5E  780009     MOV W9, W0
00DB60  071FF4     RCALL ByteQueuePushByte
249:                     }
250:                     --spi->cur_msg_total_rx;
00DB3E  904888     MOV.B [W8+8], W1
00DB40  E94081     DEC.B W1, W1
00DB42  984C01     MOV.B W1, [W8+8]
00DB62  904888     MOV.B [W8+8], W1
00DB64  E94081     DEC.B W1, W1
00DB66  984C01     MOV.B W1, [W8+8]
251:                     ++spi->can_send;  // for every byte read we can write one
00DB44  904828     MOV.B [W8+10], W0
00DB46  E84000     INC.B W0, W0
00DB48  984C20     MOV.B W0, [W8+10]
00DB68  904828     MOV.B [W8+10], W0
00DB6A  E84000     INC.B W0, W0
00DB6C  984C20     MOV.B W0, [W8+10]
252:                   }
253:                   if (!spi->cur_msg_total_rx) {
00DB4E  E00401     CP0.B W1
00DB50  3AFFE0     BRA NZ, 0xDB12
00DBE4  E00401     CP0.B W1
00DBE6  3AFF95     BRA NZ, 0xDB12
00DBE8  37FFB4     BRA 0xDB52
254:                     spi->packet_state = PACKET_STATE_DONE;
00DB52  200020     MOV #0x2, W0
00DB54  780C00     MOV W0, [W8]
255:                   }
256:                 }
257:               
258:                 // send as much data as possible
259:                 if (spi->packet_state == PACKET_STATE_IN_PROGRESS) {
00DB12  200010     MOV #0x1, W0
00DB14  100F98     SUBR W0, [W8], [W15]
00DB16  32002E     BRA Z, 0xDB74
00DB56  200010     MOV #0x1, W0
00DB58  100F98     SUBR W0, [W8], [W15]
00DB5A  3AFFDE     BRA NZ, 0xDB18
00DB5C  37000B     BRA 0xDB74
260:                   bytes_to_write = spi->cur_msg_total_tx;
00DB74  904058     MOV.B [W8+5], W0
00DB76  FB8080     ZE W0, W1
261:                   if (bytes_to_write > spi->can_send)  {
00DB78  904828     MOV.B [W8+10], W0
00DB7A  FB8000     ZE W0, W0
00DB7C  508F80     SUB W1, W0, [W15]
00DB7E  340057     BRA LE, 0xDC2E
00DC2E  780001     MOV W1, W0
262:                     bytes_to_write = spi->can_send;
263:                   }
264:                   while (bytes_to_write-- > 0) {
00DB80  E90480     DEC W0, W9
00DB82  E00000     CP0 W0
00DB84  34FFC9     BRA LE, 0xDB18
00DB9C  E90489     DEC W9, W9
00DB9E  E80009     INC W9, W0
00DBA0  A94042     BCLR SR, #2
00DBA2  34FFBA     BRA LE, 0xDB18
00DC0A  E90489     DEC W9, W9
00DC0C  E80009     INC W9, W0
00DC0E  A94042     BCLR SR, #2
00DC10  3CFFC9     BRA GT, 0xDBA4
00DC12  37FF82     BRA 0xDB18
00DC30  E90480     DEC W0, W9
00DC32  E00000     CP0 W0
00DC34  3CFFA8     BRA GT, 0xDB86
00DC36  37FF70     BRA 0xDB18
265:                     BYTE tx_byte = 0xFF;
266:                     if (spi->cur_msg_data_tx) {
00DB86  904068     MOV.B [W8+6], W0
00DB88  200FF1     MOV #0xFF, W1
00DB8A  E00400     CP0.B W0
00DB8C  3A002E     BRA NZ, 0xDBEA
00DBA4  904068     MOV.B [W8+6], W0
00DBA6  200FF1     MOV #0xFF, W1
00DBA8  E00400     CP0.B W0
00DBAA  32FFF1     BRA Z, 0xDB8E
00DBAC  37001E     BRA 0xDBEA
267:                       tx_byte = ByteQueuePullByte(tx_queue);
00DBEA  78000B     MOV W11, W0
00DBEC  071F69     RCALL ByteQueuePullByte
268:                       --spi->cur_msg_data_tx;
00DBEE  9040E8     MOV.B [W8+6], W1
00DBF0  E94081     DEC.B W1, W1
00DBF2  984461     MOV.B W1, [W8+6]
269:                       ++spi->num_tx_since_last_report;
00DBF4  900098     MOV [W8+2], W1
00DBF6  E80081     INC W1, W1
00DBF8  980411     MOV W1, [W8+2]
00DBFA  FB8080     ZE W0, W1
270:                     }
271:                     reg->spixbuf = tx_byte;
00DB8E  980541     MOV W1, [W10+8]
00DBFC  980541     MOV W1, [W10+8]
272:                     --spi->cur_msg_total_tx;
00DB90  904058     MOV.B [W8+5], W0
00DB92  E94000     DEC.B W0, W0
00DB94  984450     MOV.B W0, [W8+5]
00DBFE  904058     MOV.B [W8+5], W0
00DC00  E94000     DEC.B W0, W0
00DC02  984450     MOV.B W0, [W8+5]
273:                     --spi->can_send;
00DB96  904828     MOV.B [W8+10], W0
00DB98  E94000     DEC.B W0, W0
00DB9A  984C20     MOV.B W0, [W8+10]
00DC04  904828     MOV.B [W8+10], W0
00DC06  E94000     DEC.B W0, W0
00DC08  984C20     MOV.B W0, [W8+10]
274:                   }
275:                 }
276:               
277:                 // finalize packet if needed
278:                 if (spi->packet_state == PACKET_STATE_DONE) {
00DB18  200020     MOV #0x2, W0
00DB1A  100F98     SUBR W0, [W8], [W15]
00DB1C  320048     BRA Z, 0xDBAE
279:                   PinSetLat(spi->cur_msg_dest, 1);  // deactivate SS
00DBAE  904048     MOV.B [W8+4], W0
00DBB0  FB8000     ZE W0, W0
00DBB2  200011     MOV #0x1, W1
00DBB4  072135     RCALL PinSetLat
280:                   if (spi->cur_msg_rx_size) {
00DBB6  904818     MOV.B [W8+9], W0
00DBB8  E00400     CP0.B W0
00DBBA  3A003E     BRA NZ, 0xDC38
281:                     ++spi->num_messages_rx_queue;
00DC40  F80036     PUSH RCOUNT
00DC42  BE9F80     MOV.D W0, [W15++]
00DC44  BE9F82     MOV.D W2, [W15++]
00DC46  BE9F84     MOV.D W4, [W15++]
00DC48  BE9F86     MOV.D W6, [W15++]
00DC4A  F80032     PUSH DSRPAG
00DC4C  202000     MOV #0x200, W0
00DC4E  880190     MOV W0, DSRPAG
282:                   }
283:                   spi->packet_state = PACKET_STATE_IDLE;
00DBBC  EB0C00     CLR [W8]
284:                   Set_SPIIE[spi_num](ByteQueueSize(tx_queue) > 0);
00DBBE  EB0100     CLR W2
00DBC0  90004B     MOV [W11+8], W0
00DBC2  E00000     CP0 W0
00DBC4  340001     BRA LE, 0xDBC8
00DBC6  200012     MOV #0x1, W2
00DBC8  21DFE0     MOV #0x1DFE, W0
00DBCA  7800EC     MOV [W12+W0], W1
00DBCC  780002     MOV W2, W0
00DBCE  010001     CALL W1
285:                   Set_SPIIF[spi_num](1);
00DBD0  21E040     MOV #0x1E04, W0
00DBD2  7800EC     MOV [W12+W0], W1
00DBD4  200010     MOV #0x1, W0
00DBD6  010001     CALL W1
286:                 }
287:               }
00DB1E  78064F     MOV [--W15], W12
00DB20  BE054F     MOV.D [--W15], W10
00DB22  BE044F     MOV.D [--W15], W8
00DB24  060000     RETURN
00DBD8  78064F     MOV [--W15], W12
00DBDA  BE054F     MOV.D [--W15], W10
00DBDC  BE044F     MOV.D [--W15], W8
00DBDE  060000     RETURN
00DBE0  37FFA2     BRA 0xDB26
00DBE2  904888     MOV.B [W8+8], W1
288:               
289:               void SPITransmit(int spi_num, int dest, const void* data, int data_size,
290:                                int total_size, int trim_rx) {
291:                 BYTE_QUEUE* q = &spis[spi_num].tx_queue;
00DE8E  202220     MOV #0x222, W0
00DE90  B9F100     MUL.SS W14, W0, W2
00DE92  210C00     MOV #0x10C0, W0
00DE94  410680     ADD W2, W0, W13
292:                 BYTE prev = SyncInterruptLevel(5);
293:                 ByteQueuePushByte(q, dest);
00DEA8  78000D     MOV W13, W0
00DEAA  071E4F     RCALL ByteQueuePushByte
294:                 ByteQueuePushByte(q, total_size);
00DEAC  784089     MOV.B W9, W1
00DEAE  78000D     MOV W13, W0
00DEB0  071E4C     RCALL ByteQueuePushByte
295:                 ByteQueuePushByte(q, data_size);
00DEB2  78408A     MOV.B W10, W1
00DEB4  78000D     MOV W13, W0
00DEB6  071E49     RCALL ByteQueuePushByte
296:                 ByteQueuePushByte(q, trim_rx);
00DEB8  78408B     MOV.B W11, W1
00DEBA  78000D     MOV W13, W0
00DEBC  071E46     RCALL ByteQueuePushByte
297:                 ByteQueuePushBuffer(q, data, data_size);
00DEBE  78010A     MOV W10, W2
00DEC0  78008C     MOV W12, W1
00DEC2  78000D     MOV W13, W0
00DEC4  071E5A     RCALL ByteQueuePushBuffer
298:                 Set_SPIIE[spi_num](1);  // enable int.
00DEC6  47008E     ADD W14, W14, W1
00DEC8  21DFE0     MOV #0x1DFE, W0
00DECA  7800E1     MOV [W1+W0], W1
00DECC  200010     MOV #0x1, W0
00DECE  010001     CALL W1
299:                 SyncInterruptLevel(prev);
300:               }
00DEE6  B0044F     ADD #0x44, W15
00DEE8  BE9F88     MOV.D W8, [W15++]
00DEEA  BE9F8A     MOV.D W10, [W15++]
00DEEC  BE9F8C     MOV.D W12, [W15++]
00DEEE  781F8E     MOV W14, [W15++]
00DEF0  780480     MOV W0, W9
00DEF2  780701     MOV W1, W14
00DEF4  9FB7D2     MOV W2, [W15-22]
00DEF6  9FB7E3     MOV W3, [W15-20]
00DEF8  9FB7F4     MOV W4, [W15-18]
00DEFA  9FBF85     MOV W5, [W15-16]
00DEFC  780686     MOV W6, W13
301:               
302:               #define DEFINE_INTERRUPT_HANDLERS(spi_num)                                   \
303:                void __attribute__((__interrupt__, auto_psv)) _SPI##spi_num##Interrupt() {  \
304:                  SPIInterrupt(spi_num - 1);                                                \
305:                }
306:               
307:               #if NUM_SPI_MODULES > 3
308:                 #error Currently only devices with 3 or less SPIs are supported. Please fix below.
309:               #endif
310:               
311:               #if NUM_SPI_MODULES >= 1
312:                 DEFINE_INTERRUPT_HANDLERS(1)
00DC62  F80036     PUSH RCOUNT
00DC64  BE9F80     MOV.D W0, [W15++]
00DC66  BE9F82     MOV.D W2, [W15++]
00DC68  BE9F84     MOV.D W4, [W15++]
00DC6A  BE9F86     MOV.D W6, [W15++]
00DC6C  F80032     PUSH DSRPAG
00DC6E  202000     MOV #0x200, W0
00DC70  880190     MOV W0, DSRPAG
313:               #endif
314:               
315:               #if NUM_SPI_MODULES >= 2
316:                 DEFINE_INTERRUPT_HANDLERS(2)
00DC84  F80036     PUSH RCOUNT
00DC86  BE9F80     MOV.D W0, [W15++]
00DC88  BE9F82     MOV.D W2, [W15++]
00DC8A  BE9F84     MOV.D W4, [W15++]
00DC8C  BE9F86     MOV.D W6, [W15++]
00DC8E  F80032     PUSH DSRPAG
00DC90  202000     MOV #0x200, W0
00DC92  880190     MOV W0, DSRPAG
317:               #endif
318:               
319:               #if NUM_SPI_MODULES >= 3
320:                 DEFINE_INTERRUPT_HANDLERS(3)
00DCA6  B0048F     ADD #0x48, W15
00DCA8  BE9F88     MOV.D W8, [W15++]
00DCAA  BE9F8A     MOV.D W10, [W15++]
00DCAC  BE9F8C     MOV.D W12, [W15++]
00DCAE  781F8E     MOV W14, [W15++]
321:               #endif
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/app_layer_v1/rgb_led_matrix.c
011446  BE9F88     MOV.D W8, [W15++]
011448  780480     MOV W0, W9
1:                 /*
2:                  * Copyright 2012 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include "rgb_led_matrix.h"
31:                
32:                #include <string.h>
33:                #include <p24Fxxxx.h>
34:                
35:                // Connections:
36:                //
37:                // (r1 g1 b1 r2 g2 b2) (24 .. 19)
38:                // clk                 25
39:                // (a b c)             (7 10 11)
40:                // lat                 27
41:                // oe                  28
42:                
43:                // Ordering:
44:                //
45:                // Pixels sent from left to right.
46:                // MSB is upper half.
47:                
48:                #define DATA_CLK_PORT LATE
49:                #define CLK_PIN _LATE6
50:                #define ADDR_PORT LATD
51:                #define LAT_PIN _LATG6
52:                #define OE_PIN _LATG7
53:                
54:                #define SUB_FRAMES_PER_FRAME 3
55:                #define ROWS_PER_SUB_FRAME 8
56:                
57:                typedef uint8_t bin_row_t[64];
58:                typedef bin_row_t bin_frame_t[ROWS_PER_SUB_FRAME];
59:                typedef bin_frame_t frame_t[SUB_FRAMES_PER_FRAME];
60:                
61:                static frame_t frames[2] __attribute__((far));
62:                static const uint8_t *data;
63:                static int sub_frame;
64:                static int displayed_frame;
65:                static int back_frame_ready;
66:                static int shifter_repeat;
67:                static int address = 0;
68:                
69:                //static const frame_t DEFAULT_FRAME = {
70:                //#include "default_frame.inl"
71:                //};
72:                
73:                void RgbLedMatrixEnable(int shifter_len_32) {
74:                  _T4IE = 0;
01144A  A96097     BCLR 0x97, #3
75:                
76:                  if (shifter_len_32) {
01144C  E00000     CP0 W0
01144E  3A0008     BRA NZ, 0x11460
77:                    LATE = 0;
011460  EF22E4     CLR LATE
78:                    address = 7;
011462  200070     MOV #0x7, W0
011464  88F0E0     MOV W0, address
79:                    LATG = (1 << 7);
011466  200800     MOV #0x80, W0
011468  8817A0     MOV W0, LATG
80:                
81:                    ODCE &= ~0x7F;
01146A  2FF802     MOV #0xFF80, W2
01146C  FD0100     EXCH W0, W2
01146E  B622E6     AND ODCE
011470  FD0100     EXCH W0, W2
82:                    ODCD &= ~0x7;
011472  2FFF81     MOV #0xFFF8, W1
011474  FD0080     EXCH W0, W1
011476  B622DE     AND ODCD
011478  FD0080     EXCH W0, W1
83:                    ODCG &= ~0xC0;
01147A  2FF3F0     MOV #0xFF3F, W0
01147C  B622F6     AND ODCG
84:                
85:                    TRISE &= ~0x7F;
01147E  FD0100     EXCH W0, W2
011480  B622E0     AND TRISE
011482  FD0100     EXCH W0, W2
86:                    TRISD &= ~0x7;
011484  FD0080     EXCH W0, W1
011486  B622D8     AND TRISD
011488  FD0080     EXCH W0, W1
87:                    TRISG &= ~0xC0;
01148A  B622F0     AND TRISG
88:                
89:                    memset(frames[0], 0, sizeof(frames[0]));
01148C  253D88     MOV #0x53D8, W8
01148E  206002     MOV #0x600, W2
011490  EB0080     CLR W1
011492  780008     MOV W8, W0
011494  07A145     RCALL memset
90:                    // memcpy(frames[0], DEFAULT_FRAME, sizeof(frames[0]));
91:                    data = (const uint8_t *) frames[0];
011496  88F138     MOV W8, data
92:                    sub_frame = SUB_FRAMES_PER_FRAME;
011498  200030     MOV #0x3, W0
01149A  88F120     MOV W0, sub_frame
93:                    displayed_frame = 0;
01149C  EF3E22     CLR displayed_frame
94:                    back_frame_ready = 0;
01149E  EF3E20     CLR back_frame_ready
95:                    shifter_repeat = shifter_len_32;
0114A0  88F0F9     MOV W9, shifter_repeat
96:                
97:                    // timer 4 is sysclk / 64 = 250KHz
98:                    PR4 = 1;
0114A2  200010     MOV #0x1, W0
0114A4  8808D0     MOV W0, PR4
99:                    TMR4 = 0x0000;
0114A6  EF2114     CLR TMR4
100:                   _T4IP = 7;
0114A8  B3C700     MOV #0x70, W0
0114AA  B760B1     IOR.B 0xB1
101:                   _T4IE = 1;
0114AC  A86097     BSET 0x97, #3
102:                 } else {
103:                   TRISE |= 0x7F;
011450  2007F0     MOV #0x7F, W0
011452  B722E0     IOR TRISE
104:                   TRISD |= 0x7;
011454  200070     MOV #0x7, W0
011456  B722D8     IOR TRISD
105:                   TRISG |= 0xC0;
011458  200C00     MOV #0xC0, W0
01145A  B722F0     IOR TRISG
106:                 }
107:               }
01145C  BE044F     MOV.D [--W15], W8
01145E  060000     RETURN
0114B4  780080     MOV W0, W1
108:               
109:               void RgbLedMatrixFrame(const uint8_t frame[]) {
110:                 back_frame_ready = 0;
0114B6  EF3E20     CLR back_frame_ready
111:                 memcpy(frames[displayed_frame ^ 1], frame, 768 * shifter_repeat);
0114B8  80F112     MOV displayed_frame, W2
0114BA  A20002     BTG W2, #0
0114BC  206000     MOV #0x600, W0
0114BE  B99100     MUL.SS W2, W0, W2
0114C0  253D80     MOV #0x53D8, W0
0114C2  400002     ADD W0, W2, W0
0114C4  80F0F2     MOV shifter_repeat, W2
0114C6  203004     MOV #0x300, W4
0114C8  B99104     MUL.SS W2, W4, W2
0114CA  07A109     RCALL memcpy
112:                 back_frame_ready = 1;
0114CC  200010     MOV #0x1, W0
0114CE  88F100     MOV W0, back_frame_ready
113:               }
114:               
115:               static void draw_row() {
116:                 int i;
117:                 if (++address == ROWS_PER_SUB_FRAME) {
0114E6  EC1E1C     INC address, WREG
0114E8  88F0E0     MOV W0, address
0114EA  500FE8     SUB W0, #0x8, [W15]
0114EC  32009D     BRA Z, 0x11628
0114EE  80F121     MOV sub_frame, W1
118:                   // sub-frame done
119:                   address = 0;
011628  EF3E1C     CLR address
120:                   if (++sub_frame == SUB_FRAMES_PER_FRAME + 1) {
01162A  80F121     MOV sub_frame, W1
01162C  E80081     INC W1, W1
01162E  88F121     MOV W1, sub_frame
011630  508FE4     SUB W1, #0x4, [W15]
011632  3AFF5E     BRA NZ, 0x114F0
121:                     // frame done
122:                     sub_frame = 0;
011634  EB0080     CLR W1
011636  88F121     MOV W1, sub_frame
123:               
124:                     if (back_frame_ready) {
011638  E21E20     CP0 back_frame_ready
01163A  3A0016     BRA NZ, 0x11668
01163C  80F112     MOV displayed_frame, W2
125:                       displayed_frame = displayed_frame ^ 1;
011668  80F112     MOV displayed_frame, W2
01166A  A20002     BTG W2, #0
01166C  88F112     MOV W2, displayed_frame
126:                       back_frame_ready = 0;
01166E  88F101     MOV W1, back_frame_ready
127:                     }
128:                     data = (const uint8_t *) frames[displayed_frame];
01163E  206000     MOV #0x600, W0
011640  B99000     MUL.SS W2, W0, W0
011642  253D82     MOV #0x53D8, W2
011644  410100     ADD W2, W0, W2
011646  88F132     MOV W2, data
011648  80F121     MOV sub_frame, W1
129:                   }
130:                 }
131:               
132:                 if (sub_frame == SUB_FRAMES_PER_FRAME) {
0114F0  508FE3     SUB W1, #0x3, [W15]
0114F2  3200AD     BRA Z, 0x1164E
01164A  508FE3     SUB W1, #0x3, [W15]
01164C  3AFF53     BRA NZ, 0x114F4
133:                   OE_PIN = 1; // black
01164E  A8E2F4     BSET LATG, #7
134:                   return;
135:                 }
136:               
137:                 for (i = shifter_repeat; i > 0; --i) {
0114F4  80F0F4     MOV shifter_repeat, W4
0114F6  E00004     CP0 W4
0114F8  340086     BRA LE, 0x11606
0114FA  80F132     MOV data, W2
0114FC  EB0180     CLR W3
011600  518F84     SUB W3, W4, [W15]
011602  3AFF7D     BRA NZ, 0x114FE
011604  88F132     MOV W2, data
138:                   // push 32 bytes
139:                 #define dump DATA_CLK_PORT = *data++; CLK_PIN = 1;
140:                   dump dump dump dump dump dump dump dump
0114FE  FB8012     ZE [W2], W0
011500  881720     MOV W0, LATE
011502  A8C2E4     BSET LATE, #6
011504  904012     MOV.B [W2+1], W0
011506  FB8000     ZE W0, W0
011508  881720     MOV W0, LATE
01150A  A8C2E4     BSET LATE, #6
01150C  904022     MOV.B [W2+2], W0
01150E  FB8000     ZE W0, W0
011510  881720     MOV W0, LATE
011512  A8C2E4     BSET LATE, #6
011514  904032     MOV.B [W2+3], W0
011516  FB8000     ZE W0, W0
011518  881720     MOV W0, LATE
01151A  A8C2E4     BSET LATE, #6
01151C  904042     MOV.B [W2+4], W0
01151E  FB8000     ZE W0, W0
011520  881720     MOV W0, LATE
011522  A8C2E4     BSET LATE, #6
011524  904052     MOV.B [W2+5], W0
011526  FB8000     ZE W0, W0
011528  881720     MOV W0, LATE
01152A  A8C2E4     BSET LATE, #6
01152C  904062     MOV.B [W2+6], W0
01152E  FB8000     ZE W0, W0
011530  881720     MOV W0, LATE
011532  A8C2E4     BSET LATE, #6
011534  904072     MOV.B [W2+7], W0
011536  FB8000     ZE W0, W0
011538  881720     MOV W0, LATE
01153A  A8C2E4     BSET LATE, #6
141:                   dump dump dump dump dump dump dump dump
01153C  904802     MOV.B [W2+8], W0
01153E  FB8000     ZE W0, W0
011540  881720     MOV W0, LATE
011542  A8C2E4     BSET LATE, #6
011544  904812     MOV.B [W2+9], W0
011546  FB8000     ZE W0, W0
011548  881720     MOV W0, LATE
01154A  A8C2E4     BSET LATE, #6
01154C  904822     MOV.B [W2+10], W0
01154E  FB8000     ZE W0, W0
011550  881720     MOV W0, LATE
011552  A8C2E4     BSET LATE, #6
011554  904832     MOV.B [W2+11], W0
011556  FB8000     ZE W0, W0
011558  881720     MOV W0, LATE
01155A  A8C2E4     BSET LATE, #6
01155C  904842     MOV.B [W2+12], W0
01155E  FB8000     ZE W0, W0
011560  881720     MOV W0, LATE
011562  A8C2E4     BSET LATE, #6
011564  904852     MOV.B [W2+13], W0
011566  FB8000     ZE W0, W0
011568  881720     MOV W0, LATE
01156A  A8C2E4     BSET LATE, #6
01156C  904862     MOV.B [W2+14], W0
01156E  FB8000     ZE W0, W0
011570  881720     MOV W0, LATE
011572  A8C2E4     BSET LATE, #6
011574  904872     MOV.B [W2+15], W0
011576  FB8000     ZE W0, W0
011578  881720     MOV W0, LATE
01157A  A8C2E4     BSET LATE, #6
142:                   dump dump dump dump dump dump dump dump
01157C  905002     MOV.B [W2+16], W0
01157E  FB8000     ZE W0, W0
011580  881720     MOV W0, LATE
011582  A8C2E4     BSET LATE, #6
011584  905012     MOV.B [W2+17], W0
011586  FB8000     ZE W0, W0
011588  881720     MOV W0, LATE
01158A  A8C2E4     BSET LATE, #6
01158C  905022     MOV.B [W2+18], W0
01158E  FB8000     ZE W0, W0
011590  881720     MOV W0, LATE
011592  A8C2E4     BSET LATE, #6
011594  905032     MOV.B [W2+19], W0
011596  FB8000     ZE W0, W0
011598  881720     MOV W0, LATE
01159A  A8C2E4     BSET LATE, #6
01159C  905042     MOV.B [W2+20], W0
01159E  FB8000     ZE W0, W0
0115A0  881720     MOV W0, LATE
0115A2  A8C2E4     BSET LATE, #6
0115A4  905052     MOV.B [W2+21], W0
0115A6  FB8000     ZE W0, W0
0115A8  881720     MOV W0, LATE
0115AA  A8C2E4     BSET LATE, #6
0115AC  905062     MOV.B [W2+22], W0
0115AE  FB8000     ZE W0, W0
0115B0  881720     MOV W0, LATE
0115B2  A8C2E4     BSET LATE, #6
0115B4  905072     MOV.B [W2+23], W0
0115B6  FB8000     ZE W0, W0
0115B8  881720     MOV W0, LATE
0115BA  A8C2E4     BSET LATE, #6
143:                   dump dump dump dump dump dump dump dump
0115BC  905802     MOV.B [W2+24], W0
0115BE  FB8000     ZE W0, W0
0115C0  881720     MOV W0, LATE
0115C2  A8C2E4     BSET LATE, #6
0115C4  905812     MOV.B [W2+25], W0
0115C6  FB8000     ZE W0, W0
0115C8  881720     MOV W0, LATE
0115CA  A8C2E4     BSET LATE, #6
0115CC  905822     MOV.B [W2+26], W0
0115CE  FB8000     ZE W0, W0
0115D0  881720     MOV W0, LATE
0115D2  A8C2E4     BSET LATE, #6
0115D4  905832     MOV.B [W2+27], W0
0115D6  FB8000     ZE W0, W0
0115D8  881720     MOV W0, LATE
0115DA  A8C2E4     BSET LATE, #6
0115DC  905842     MOV.B [W2+28], W0
0115DE  FB8000     ZE W0, W0
0115E0  881720     MOV W0, LATE
0115E2  A8C2E4     BSET LATE, #6
0115E4  905852     MOV.B [W2+29], W0
0115E6  FB8000     ZE W0, W0
0115E8  881720     MOV W0, LATE
0115EA  A8C2E4     BSET LATE, #6
0115EC  905862     MOV.B [W2+30], W0
0115EE  FB8000     ZE W0, W0
0115F0  881720     MOV W0, LATE
0115F2  A8C2E4     BSET LATE, #6
0115F4  905872     MOV.B [W2+31], W0
0115F6  FB8000     ZE W0, W0
0115F8  881720     MOV W0, LATE
0115FA  B00202     ADD #0x20, W2
0115FC  A8C2E4     BSET LATE, #6
0115FE  E80183     INC W3, W3
144:                 #undef dump
145:                 }
146:               
147:                 OE_PIN = 1; // black
011606  A8E2F4     BSET LATG, #7
148:                 // latch
149:                 LAT_PIN = 1;
011608  A8C2F4     BSET LATG, #6
150:                 LAT_PIN = 0;
01160A  A9C2F4     BCLR LATG, #6
151:                 ADDR_PORT = address;
01160C  80F0E0     MOV address, W0
01160E  8816E0     MOV W0, LATD
152:               
153:                 OE_PIN = 0; // enable output
011610  A9E2F4     BCLR LATG, #7
154:               }
155:               
156:               int RgbLedMatrixFrameSize() {
0114D2  80F0F0     MOV shifter_repeat, W0
0114D4  203002     MOV #0x300, W2
0114D6  B98002     MUL.SS W0, W2, W0
157:                 return shifter_repeat * 32 * ROWS_PER_SUB_FRAME * SUB_FRAMES_PER_FRAME;
158:               }
0114DA  BE9F80     MOV.D W0, [W15++]
0114DC  BE9F82     MOV.D W2, [W15++]
0114DE  781F84     MOV W4, [W15++]
0114E0  F80032     PUSH DSRPAG
0114E2  202000     MOV #0x200, W0
0114E4  880190     MOV W0, DSRPAG
159:               
160:               static unsigned int times[] = {
161:                 6, 12, 36, 250
162:               };
163:               
164:               void __attribute__((__interrupt__, auto_psv)) _T4Interrupt() {
165:                 draw_row();
166:                 PR4 = times[sub_frame];
011612  408081     ADD W1, W1, W1
011614  21E320     MOV #0x1E32, W0
011616  780061     MOV [W1+W0], W0
011618  8808D0     MOV W0, PR4
011650  408081     ADD W1, W1, W1
011652  21E320     MOV #0x1E32, W0
011654  780061     MOV [W1+W0], W0
011656  8808D0     MOV W0, PR4
167:                 TMR4 = 0;
01161A  EF2114     CLR TMR4
011658  EF2114     CLR TMR4
168:                 _T4IF = 0; // clear
01161C  A96087     BCLR 0x87, #3
01165A  A96087     BCLR 0x87, #3
169:               }
01161E  F90032     POP DSRPAG
011620  78024F     MOV [--W15], W4
011622  BE014F     MOV.D [--W15], W2
011624  BE004F     MOV.D [--W15], W0
011626  064000     RETFIE
01165C  F90032     POP DSRPAG
01165E  78024F     MOV [--W15], W4
011660  BE014F     MOV.D [--W15], W2
011662  BE004F     MOV.D [--W15], W0
011664  064000     RETFIE
011666  37FFE0     BRA 0x11628
170:               
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/app_layer_v1/pwm.c  ------
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include "pwm.h"
31:                
32:                #include "Compiler.h"
33:                #include "logging.h"
34:                #include "platform.h"
35:                
36:                typedef struct {
37:                  unsigned int con1;
38:                  unsigned int con2;
39:                  unsigned int rs;
40:                  unsigned int r;
41:                  unsigned int tmr;
42:                } OC_REGS;
43:                
44:                #define OC_REG(num) (((volatile OC_REGS *) &OC1CON1) + num)
45:                
46:                void PWMInit() {
014BAA  201900     MOV #0x190, W0
014BAC  201EA1     MOV #0x1EA, W1
47:                  int i;
48:                  // disable PWMs
49:                  for (i = 0; i < NUM_PWM_MODULES; ++i) {
014BB2  500F81     SUB W0, W1, [W15]
014BB4  3AFFFC     BRA NZ, 0x14BAE
50:                    SetPwmPeriod(i, 0, 0);
51:                  }
52:                }
53:                
54:                void SetPwmDutyCycle(int pwm_num, int dc, int fraction) {
55:                  volatile OC_REGS* regs;
56:                  log_printf("SetPwmDutyCycle(%d, %d, %d)", pwm_num, dc, fraction);
57:                  regs = OC_REG(pwm_num);
014B90  B9026A     MUL.SU W0, #10, W4
014B92  201903     MOV #0x190, W3
014B94  418184     ADD W3, W4, W3
58:                  regs->con2 &= ~0x0600;
014B96  900013     MOV [W3+2], W0
014B98  2F9FF4     MOV #0xF9FF, W4
014B9A  600004     AND W0, W4, W0
014B9C  980190     MOV W0, [W3+2]
59:                  regs->con2 |= fraction << 9;
014B9E  900013     MOV [W3+2], W0
014BA0  DD1149     SL W2, #9, W2
014BA2  700002     IOR W0, W2, W0
014BA4  980190     MOV W0, [W3+2]
60:                  regs->r = dc;
014BA6  9801B1     MOV W1, [W3+6]
61:                }
62:                
63:                void SetPwmPeriod(int pwm_num, int period, int scale) {
64:                  volatile OC_REGS* regs;
65:                  log_printf("SetPwmPeriod(%d, %d, %d)", pwm_num, period, scale);
66:                  regs = OC_REG(pwm_num);
014B70  B9026A     MUL.SU W0, #10, W4
014B72  201900     MOV #0x190, W0
014B74  400184     ADD W0, W4, W3
67:                  regs->con1 = 0x0000;
014B76  EB0000     CLR W0
014B78  780980     MOV W0, [W3]
014BAE  EB0800     CLR [W0]
014BB0  40006A     ADD W0, #0xA, W0
68:                  if (period) {
014B7A  E00001     CP0 W1
014B7C  320008     BRA Z, 0x14B8E
69:                    static const int CLK_SRC[] = {
70:                      0x1C00, // 1x   - system clk
71:                      0x0C00, // 256x - timer 5
72:                      0x0800, // 64x  - timer 4
73:                      0x0400, // 8x   - timer 3
74:                    };
75:                    regs->r = 0;
014B7E  9801B0     MOV W0, [W3+6]
76:                    regs->rs = period;
014B80  9801A1     MOV W1, [W3+4]
77:                    regs->con2 = 0x001F;
014B82  2001F0     MOV #0x1F, W0
014B84  980190     MOV W0, [W3+2]
78:                    regs->con1 = 0x0006 | CLK_SRC[scale];
79:                  }
80:                }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/app_layer_v1/protocol.c  -
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include "protocol.h"
31:                
32:                #include <assert.h>
33:                #include <string.h>
34:                #include "libpic30.h"
35:                #include "blapi/version.h"
36:                #include "byte_queue.h"
37:                #include "features.h"
38:                #include "pwm.h"
39:                #include "adc.h"
40:                #include "digital.h"
41:                #include "logging.h"
42:                #include "platform.h"
43:                #include "uart.h"
44:                #include "spi.h"
45:                #include "i2c.h"
46:                #include "sync.h"
00C9BC  200428     MOV #0x42, W8
00C9BE  784418     MOV.B [W8], W8
00C9C0  FB8408     ZE W8, W8
00C9C2  DE4445     LSR W8, #5, W8
00C9EC  BFC042     MOV.B SR, WREG
00CA22  200421     MOV #0x42, W1
00CA24  784091     MOV.B [W1], W1
00CA26  FB8081     ZE W1, W1
00CA52  BFC042     MOV.B SR, WREG
00CA98  200428     MOV #0x42, W8
00CA9A  784418     MOV.B [W8], W8
00CA9C  FB8408     ZE W8, W8
00CA9E  DE4445     LSR W8, #5, W8
00CAB8  BFC042     MOV.B SR, WREG
00CADE  200428     MOV #0x42, W8
00CAE0  784418     MOV.B [W8], W8
00CAE2  FB8408     ZE W8, W8
00CAE4  DE4445     LSR W8, #5, W8
00CB06  BFC042     MOV.B SR, WREG
00CB7E  200428     MOV #0x42, W8
00CB80  784418     MOV.B [W8], W8
00CB82  FB8408     ZE W8, W8
00CB84  DE4445     LSR W8, #5, W8
00CBA2  BFC042     MOV.B SR, WREG
00CD46  200428     MOV #0x42, W8
00CD48  784418     MOV.B [W8], W8
00CD4A  FB8408     ZE W8, W8
00CD4C  DE4445     LSR W8, #5, W8
00CD66  BFC042     MOV.B SR, WREG
00D136  200428     MOV #0x42, W8
00D138  784418     MOV.B [W8], W8
00D13A  FB8408     ZE W8, W8
00D13C  DE4445     LSR W8, #5, W8
00D156  BFC042     MOV.B SR, WREG
00D18A  200428     MOV #0x42, W8
00D18C  784418     MOV.B [W8], W8
00D18E  FB8408     ZE W8, W8
00D190  DE4445     LSR W8, #5, W8
00D1AA  BFC042     MOV.B SR, WREG
00D1CA  200428     MOV #0x42, W8
00D1CC  784418     MOV.B [W8], W8
00D1CE  FB8408     ZE W8, W8
00D1D0  DE4445     LSR W8, #5, W8
00D1EA  BFC042     MOV.B SR, WREG
47:                #include "icsp.h"
00C9C4  BFC042     MOV.B SR, WREG
00C9C6  60407F     AND.B W0, #0x1F, W0
00C9C8  A05400     BSET.B W0, #5
00C9CA  B7E042     MOV.B WREG, SR
00C9EE  DD4445     SL W8, #5, W8
00C9F0  BFC042     MOV.B SR, WREG
00C9F2  60407F     AND.B W0, #0x1F, W0
00C9F4  704008     IOR.B W0, W8, W0
00C9F6  B7E042     MOV.B WREG, SR
00CA28  BFC042     MOV.B SR, WREG
00CA2A  60407F     AND.B W0, #0x1F, W0
00CA2C  A05400     BSET.B W0, #5
00CA2E  B7E042     MOV.B WREG, SR
00CA54  DD48C5     SL W9, #5, W1
00CA56  BFC042     MOV.B SR, WREG
00CA58  60407F     AND.B W0, #0x1F, W0
00CA5A  704001     IOR.B W0, W1, W0
00CA5C  B7E042     MOV.B WREG, SR
00CAA0  BFC042     MOV.B SR, WREG
00CAA2  60407F     AND.B W0, #0x1F, W0
00CAA4  A05400     BSET.B W0, #5
00CAA6  B7E042     MOV.B WREG, SR
00CABA  DD4445     SL W8, #5, W8
00CABC  BFC042     MOV.B SR, WREG
00CABE  60407F     AND.B W0, #0x1F, W0
00CAC0  704008     IOR.B W0, W8, W0
00CAC2  B7E042     MOV.B WREG, SR
00CAE6  BFC042     MOV.B SR, WREG
00CAE8  60407F     AND.B W0, #0x1F, W0
00CAEA  A05400     BSET.B W0, #5
00CAEC  B7E042     MOV.B WREG, SR
00CB08  DD4445     SL W8, #5, W8
00CB0A  BFC042     MOV.B SR, WREG
00CB0C  60407F     AND.B W0, #0x1F, W0
00CB0E  704008     IOR.B W0, W8, W0
00CB10  B7E042     MOV.B WREG, SR
00CB86  BFC042     MOV.B SR, WREG
00CB88  60407F     AND.B W0, #0x1F, W0
00CB8A  A05400     BSET.B W0, #5
00CB8C  B7E042     MOV.B WREG, SR
00CBA4  DD4445     SL W8, #5, W8
00CBA6  BFC042     MOV.B SR, WREG
00CBA8  60407F     AND.B W0, #0x1F, W0
00CBAA  704008     IOR.B W0, W8, W0
00CBAC  B7E042     MOV.B WREG, SR
00CD4E  BFC042     MOV.B SR, WREG
00CD50  60407F     AND.B W0, #0x1F, W0
00CD52  A05400     BSET.B W0, #5
00CD54  B7E042     MOV.B WREG, SR
00CD68  DD4445     SL W8, #5, W8
00CD6A  BFC042     MOV.B SR, WREG
00CD6C  60407F     AND.B W0, #0x1F, W0
00CD6E  704008     IOR.B W0, W8, W0
00CD70  B7E042     MOV.B WREG, SR
00D13E  BFC042     MOV.B SR, WREG
00D140  60407F     AND.B W0, #0x1F, W0
00D142  A05400     BSET.B W0, #5
00D144  B7E042     MOV.B WREG, SR
00D158  DD4445     SL W8, #5, W8
00D15A  BFC042     MOV.B SR, WREG
00D15C  60407F     AND.B W0, #0x1F, W0
00D15E  704008     IOR.B W0, W8, W0
00D160  B7E042     MOV.B WREG, SR
00D192  BFC042     MOV.B SR, WREG
00D194  60407F     AND.B W0, #0x1F, W0
00D196  A05400     BSET.B W0, #5
00D198  B7E042     MOV.B WREG, SR
00D1AC  DD4445     SL W8, #5, W8
00D1AE  BFC042     MOV.B SR, WREG
00D1B0  60407F     AND.B W0, #0x1F, W0
00D1B2  704008     IOR.B W0, W8, W0
00D1B4  B7E042     MOV.B WREG, SR
00D1D2  BFC042     MOV.B SR, WREG
00D1D4  60407F     AND.B W0, #0x1F, W0
00D1D6  A05400     BSET.B W0, #5
00D1D8  B7E042     MOV.B WREG, SR
00D1EC  DD4445     SL W8, #5, W8
00D1EE  BFC042     MOV.B SR, WREG
00D1F0  60407F     AND.B W0, #0x1F, W0
00D1F2  704008     IOR.B W0, W8, W0
00D1F4  B7E042     MOV.B WREG, SR
48:                #include "incap.h"
49:                #include "rgb_led_matrix.h"
50:                
51:                #define CHECK(cond) do { if (!(cond)) { log_printf("Check failed: %s", #cond); return FALSE; }} while(0)
52:                
00CB28  EF3E30     CLR 0x1E30
53:                const BYTE incoming_arg_size[MESSAGE_TYPE_LIMIT] = {
00CB2A  EF3E2C     CLR 0x1E2C
54:                  sizeof(HARD_RESET_ARGS),
00CB2C  EF3E2E     CLR 0x1E2E
55:                  sizeof(SOFT_RESET_ARGS),
56:                  sizeof(CHECK_INTERFACE_ARGS),
57:                  sizeof(SET_PIN_DIGITAL_OUT_ARGS),
58:                  sizeof(SET_DIGITAL_OUT_LEVEL_ARGS),
59:                  sizeof(SET_PIN_DIGITAL_IN_ARGS),
60:                  sizeof(SET_CHANGE_NOTIFY_ARGS),
61:                  sizeof(REGISTER_PERIODIC_DIGITAL_SAMPLING_ARGS),
62:                  sizeof(SET_PIN_PWM_ARGS),
63:                  sizeof(SET_PWM_DUTY_CYCLE_ARGS),
64:                  sizeof(SET_PWM_PERIOD_ARGS),
65:                  sizeof(SET_PIN_ANALOG_IN_ARGS),
66:                  sizeof(SET_ANALOG_IN_SAMPLING_ARGS),
67:                  sizeof(UART_CONFIG_ARGS),
68:                  sizeof(UART_DATA_ARGS),
69:                  sizeof(SET_PIN_UART_ARGS),
70:                  sizeof(SPI_CONFIGURE_MASTER_ARGS),
71:                  sizeof(SPI_MASTER_REQUEST_ARGS),
72:                  sizeof(SET_PIN_SPI_ARGS),
73:                  sizeof(I2C_CONFIGURE_MASTER_ARGS),
74:                  sizeof(I2C_WRITE_READ_ARGS),
75:                  sizeof(RESERVED_ARGS),
76:                  sizeof(ICSP_SIX_ARGS),
77:                  sizeof(ICSP_REGOUT_ARGS),
78:                  sizeof(ICSP_PROG_ENTER_ARGS),
79:                  sizeof(ICSP_PROG_EXIT_ARGS),
80:                  sizeof(ICSP_CONFIG_ARGS),
81:                  sizeof(INCAP_CONFIG_ARGS),
82:                  sizeof(SET_PIN_INCAP_ARGS),
83:                  sizeof(SOFT_CLOSE_ARGS),
84:                  sizeof(RGB_LED_MATRIX_ENABLE_ARGS),
85:                  sizeof(RGB_LED_MATRIX_FRAME_ARGS),
86:                  // BOOKMARK(add_feature): Add sizeof (argument for incoming message).
87:                  // Array is indexed by message type enum.
88:                };
89:                
90:                const BYTE outgoing_arg_size[MESSAGE_TYPE_LIMIT] = {
91:                  sizeof(ESTABLISH_CONNECTION_ARGS),
92:                  sizeof(SOFT_RESET_ARGS),
93:                  sizeof(CHECK_INTERFACE_RESPONSE_ARGS),
94:                  sizeof(RESERVED_ARGS),
95:                  sizeof(REPORT_DIGITAL_IN_STATUS_ARGS),
96:                  sizeof(RESERVED_ARGS),
97:                  sizeof(SET_CHANGE_NOTIFY_ARGS),
98:                  sizeof(REGISTER_PERIODIC_DIGITAL_SAMPLING_ARGS),
99:                  sizeof(RESERVED_ARGS),
100:                 sizeof(RESERVED_ARGS),
101:                 sizeof(RESERVED_ARGS),
102:                 sizeof(REPORT_ANALOG_IN_STATUS_ARGS),
103:                 sizeof(REPORT_ANALOG_IN_FORMAT_ARGS),
104:                 sizeof(UART_STATUS_ARGS),
105:                 sizeof(UART_DATA_ARGS),
106:                 sizeof(UART_REPORT_TX_STATUS_ARGS),
107:                 sizeof(SPI_STATUS_ARGS),
108:                 sizeof(SPI_DATA_ARGS),
109:                 sizeof(SPI_REPORT_TX_STATUS_ARGS),
110:                 sizeof(I2C_STATUS_ARGS),
111:                 sizeof(I2C_RESULT_ARGS),
112:                 sizeof(I2C_REPORT_TX_STATUS_ARGS),
113:                 sizeof(ICSP_REPORT_RX_STATUS_ARGS),
114:                 sizeof(ICSP_RESULT_ARGS),
115:                 sizeof(RESERVED_ARGS),
116:                 sizeof(RESERVED_ARGS),
00C9A0  BE9F88     MOV.D W8, [W15++]
00C9A2  BE9F8A     MOV.D W10, [W15++]
00C9A4  781F8C     MOV W12, [W15++]
00C9A6  780280     MOV W0, W5
00C9A8  780501     MOV W1, W10
00C9AA  780482     MOV W2, W9
00C9AC  780603     MOV W3, W12
00C9AE  780584     MOV W4, W11
117:                 sizeof(ICSP_CONFIG_ARGS),
118:                 sizeof(INCAP_STATUS_ARGS),
119:                 sizeof(INCAP_REPORT_ARGS),
120:                 sizeof(SOFT_CLOSE_ARGS),
121:                 sizeof(RESERVED_ARGS),
122:                 sizeof(RESERVED_ARGS),
123:               
124:                 // BOOKMARK(add_feature): Add sizeof (argument for outgoing message).
125:                 // Array is indexed by message type enum.
126:               };
127:               
128:               typedef enum {
129:                 STATE_OPEN,
130:                 STATE_CLOSING,
131:                 STATE_CLOSED
132:               } STATE;
133:               
134:               DEFINE_STATIC_BYTE_QUEUE(tx_queue, 4096);
135:               static int bytes_out;
136:               static int max_packet;
137:               static STATE state;
138:               
139:               typedef enum {
140:                 WAIT_TYPE,
141:                 WAIT_ARGS,
142:                 WAIT_VAR_ARGS
143:               } RX_MESSAGE_STATE;
144:               
145:               static INCOMING_MESSAGE rx_msg __attribute__((far));
146:               static int rx_buffer_cursor;
147:               static int rx_message_remaining;
148:               static RX_MESSAGE_STATE rx_message_state;
149:               
150:               static inline BYTE OutgoingMessageLength(const OUTGOING_MESSAGE* msg) {
151:                 return 1 + outgoing_arg_size[msg->type];
152:               }
153:               
154:               static inline int IncomingVarArgSize(const INCOMING_MESSAGE* msg) {
155:                 switch (msg->type) {
00CC78  78401C     MOV.B [W12], W0
00CC7A  504FF1     SUB.B W0, #0x11, [W15]
00CC7C  32FFCC     BRA Z, 0xCC16
00CC7E  36002A     BRA LEU, 0xCCD4
00CC80  504FF4     SUB.B W0, #0x14, [W15]
00CC82  3202C5     BRA Z, 0xD20E
00CC84  504FFF     SUB.B W0, #0x1F, [W15]
00CC86  32003A     BRA Z, 0xCCFC
00CC88  EB0000     CLR W0
00CCD4  504FEE     SUB.B W0, #0xE, [W15]
00CCD6  3AFFD8     BRA NZ, 0xCC88
156:                   case UART_DATA:
157:                     return msg->args.uart_data.size + 1;
00CCD8  B3C3F2     MOV #0x3F, W2
00CCDA  220011     MOV #0x2001, W1
00CCDC  614011     AND.B W2, [W1], W0
00CCDE  FB8000     ZE W0, W0
00CCE0  E80000     INC W0, W0
158:               
159:                   case SPI_MASTER_REQUEST:
160:                     if (msg->args.spi_master_request.data_size_neq_total) {
00CC16  220020     MOV #0x2002, W0
00CC18  E00410     CP0.B [W0]
00CC1A  3D0066     BRA GE, 0xCCE8
161:                       return msg->args.spi_master_request.data_size
00CC1C  220038     MOV #0x2003, W8
00CC1E  FB8098     ZE [W8], W1
00CC20  FB8010     ZE [W0], W0
00CC22  DE0046     LSR W0, #6, W0
00CC24  600061     AND W0, #0x1, W0
00CC26  408000     ADD W1, W0, W0
162:                           + msg->args.spi_master_request.res_size_neq_total;
163:                     } else {
164:                       return msg->args.spi_master_request.total_size
00CCE8  B3C3F3     MOV #0x3F, W3
00CCEA  61C090     AND.B W3, [W0], W1
00CCEC  FB8081     ZE W1, W1
00CCEE  FB8010     ZE [W0], W0
00CCF0  DE0046     LSR W0, #6, W0
00CCF2  600061     AND W0, #0x1, W0
00CCF4  408000     ADD W1, W0, W0
165:                           + msg->args.spi_master_request.res_size_neq_total;
166:                     }
167:               
168:                   case I2C_WRITE_READ:
169:                     return msg->args.i2c_write_read.write_size;
00D20E  220038     MOV #0x2003, W8
00D210  FB8018     ZE [W8], W0
170:               
171:                   case RGB_LED_MATRIX_FRAME:
172:                     return RgbLedMatrixFrameSize();
00CCFC  0723EA     RCALL RgbLedMatrixFrameSize
173:               
174:                   // BOOKMARK(add_feature): Add more cases here if incoming message has variable args.
175:                   default:
176:                     return 0;
177:                 }
178:               }
179:               
180:               void AppProtocolInit(CHANNEL_HANDLE h) {
181:                 _prog_addressT p;
182:                 bytes_out = 0;
00CB1E  EF3E1A     CLR bytes_out
183:                 rx_buffer_cursor = 0;
00CB20  EF3E14     CLR state
184:                 rx_message_remaining = 1;
00CB22  200011     MOV #0x1, W1
00CB24  88F091     MOV W1, led_counter
185:                 rx_message_state = WAIT_TYPE;
00CB26  EF3E10     CLR DUMPSYS_BUSY
186:                 ByteQueueClear(&tx_queue);
187:                 max_packet = ConnectionGetMaxPacket(h);
00CB2E  074BC1     RCALL ConnectionGetMaxPacket
00CB30  88F0C0     MOV W0, max_packet
188:                 state = STATE_OPEN;
00CB32  EF3E16     CLR filepath
189:               
190:                 OUTGOING_MESSAGE msg;
191:                 msg.type = ESTABLISH_CONNECTION;
00CB34  EB4000     CLR.B W0
00CB36  9FE780     MOV.B W0, [W15-32]
192:                 msg.args.establish_connection.magic = IOIO_MAGIC;
00CB38  200FF0     MOV #0xFF, W0
00CB3A  97B08F     MOV [W15-32], W1
00CB3C  608080     AND W1, W0, W1
00CB3E  249000     MOV #0x4900, W0
00CB40  708080     IOR W1, W0, W1
00CB42  9FB781     MOV W1, [W15-32]
00CB44  B304F0     IOR #0x4F, W0
00CB46  9FB790     MOV W0, [W15-30]
00CB48  97B02F     MOV [W15-28], W0
00CB4A  2FF001     MOV #0xFF00, W1
00CB4C  600001     AND W0, W1, W0
00CB4E  B304F0     IOR #0x4F, W0
00CB50  9FB7A0     MOV W0, [W15-28]
193:               
194:                 _init_prog_address(p, hardware_version);
195:                 _memcpy_p2d16(msg.args.establish_connection.hw_impl_ver, p, 8);
00CB52  EB0200     CLR W4
00CB54  200083     MOV #0x8, W3
00CB56  57817B     SUB W15, #0x1B, W2
00CB58  24F800     MOV #0x4F80, W0
00CB5A  201001     MOV #0x100, W1
00CB5C  07C417     RCALL _memcpy_helper
196:                 _init_prog_address(p, bootloader_version);
197:                 _memcpy_p2d16(msg.args.establish_connection.bl_impl_ver, p, 8);
00CB5E  EB0200     CLR W4
00CB60  200083     MOV #0x8, W3
00CB62  578173     SUB W15, #0x13, W2
00CB64  24F880     MOV #0x4F88, W0
00CB66  201001     MOV #0x100, W1
00CB68  07C411     RCALL _memcpy_helper
198:               
199:                 memcpy(msg.args.establish_connection.fw_impl_ver, FW_IMPL_VER, 8);
00CB6A  57806B     SUB W15, #0xB, W0
00CB6C  2EDD01     MOV #0xEDD0, W1
00CB6E  090007     REPEAT #0x7
00CB70  785831     MOV.B [W1++], [W0++]
00CB72  B10080     SUB #0x8, W0
200:               
201:                 AppProtocolSendMessage(&msg);
202:               }
00CB78  78044F     MOV [--W15], W8
00CB7A  FA8000     ULNK
00CB7C  060000     RETURN
00CBB6  BE9F88     MOV.D W8, [W15++]
00CBB8  BE9F8A     MOV.D W10, [W15++]
00CBBA  BE9F8C     MOV.D W12, [W15++]
00CBBC  781F8E     MOV W14, [W15++]
00CBBE  780480     MOV W0, W9
00CBC0  BE0502     MOV.D W2, W10
203:               
204:               void AppProtocolSendMessage(const OUTGOING_MESSAGE* msg) {
205:                 if (state != STATE_OPEN) return;
00CA90  E21E16     CP0 filepath
00CA92  320002     BRA Z, 0xCA98
00CB74  E21E16     CP0 filepath
00CB76  320003     BRA Z, 0xCB7E
00CD2C  E21E16     CP0 filepath
00CD2E  32022D     BRA Z, 0xD18A
00CD42  E21E16     CP0 filepath
00CD44  3AFF5F     BRA NZ, 0xCC04
00CDE6  E21E16     CP0 filepath
00CDE8  3201A6     BRA Z, 0xD136
00CF3A  E21E16     CP0 filepath
00CF3C  32FF04     BRA Z, 0xCD46
00CFBA  E21E16     CP0 filepath
00CFBC  320106     BRA Z, 0xD1CA
206:                 BYTE prev = SyncInterruptLevel(1);
207:                 ByteQueuePushBuffer(&tx_queue, (const BYTE*) msg, OutgoingMessageLength(msg));
00CAA8  FB8093     ZE [W3], W1
00CAAA  2ED900     MOV #0xED90, W0
00CAAC  78C160     MOV.B [W0+W1], W2
00CAAE  E84102     INC.B W2, W2
00CAB0  FB8102     ZE W2, W2
00CAB2  780083     MOV W3, W1
00CAB4  21E280     MOV #0x1E28, W0
00CAB6  072861     RCALL ByteQueuePushBuffer
00CB8E  97E00F     MOV.B [W15-32], W0
00CB90  FB8080     ZE W0, W1
00CB92  2ED900     MOV #0xED90, W0
00CB94  78C160     MOV.B [W0+W1], W2
00CB96  E84102     INC.B W2, W2
00CB98  FB8102     ZE W2, W2
00CB9A  2FFE01     MOV #0xFFE0, W1
00CB9C  40808F     ADD W1, W15, W1
00CB9E  21E280     MOV #0x1E28, W0
00CBA0  0727EC     RCALL ByteQueuePushBuffer
00CD56  FB809C     ZE [W12], W1
00CD58  2ED900     MOV #0xED90, W0
00CD5A  78C160     MOV.B [W0+W1], W2
00CD5C  E84102     INC.B W2, W2
00CD5E  FB8102     ZE W2, W2
00CD60  220001     MOV #0x2000, W1
00CD62  21E280     MOV #0x1E28, W0
00CD64  07270A     RCALL ByteQueuePushBuffer
00D146  FB809C     ZE [W12], W1
00D148  2ED900     MOV #0xED90, W0
00D14A  78C160     MOV.B [W0+W1], W2
00D14C  E84102     INC.B W2, W2
00D14E  FB8102     ZE W2, W2
00D150  220001     MOV #0x2000, W1
00D152  21E280     MOV #0x1E28, W0
00D154  072512     RCALL ByteQueuePushBuffer
00D19A  FB809C     ZE [W12], W1
00D19C  2ED900     MOV #0xED90, W0
00D19E  78C160     MOV.B [W0+W1], W2
00D1A0  E84102     INC.B W2, W2
00D1A2  FB8102     ZE W2, W2
00D1A4  220001     MOV #0x2000, W1
00D1A6  21E280     MOV #0x1E28, W0
00D1A8  0724E8     RCALL ByteQueuePushBuffer
00D1DA  FB809C     ZE [W12], W1
00D1DC  2ED900     MOV #0xED90, W0
00D1DE  78C160     MOV.B [W0+W1], W2
00D1E0  E84102     INC.B W2, W2
00D1E2  FB8102     ZE W2, W2
00D1E4  220001     MOV #0x2000, W1
00D1E6  21E280     MOV #0x1E28, W0
00D1E8  0724C8     RCALL ByteQueuePushBuffer
208:                 SyncInterruptLevel(prev);
209:               }
00CA94  78044F     MOV [--W15], W8
00CA96  060000     RETURN
00CACA  BE9F88     MOV.D W8, [W15++]
00CACC  781F8A     MOV W10, [W15++]
00CACE  780180     MOV W0, W3
00CAD0  780501     MOV W1, W10
00CAD2  780482     MOV W2, W9
210:               
211:               void AppProtocolSendMessageWithVarArg(const OUTGOING_MESSAGE* msg, const void* data, int size) {
212:                 if (state != STATE_OPEN) return;
00CAD4  E21E16     CP0 filepath
00CAD6  320003     BRA Z, 0xCADE
213:                 BYTE prev = SyncInterruptLevel(1);
214:                 ByteQueuePushBuffer(&tx_queue, (const BYTE*) msg, OutgoingMessageLength(msg));
00CAEE  FB8093     ZE [W3], W1
00CAF0  2ED900     MOV #0xED90, W0
00CAF2  78C160     MOV.B [W0+W1], W2
00CAF4  E84102     INC.B W2, W2
00CAF6  FB8102     ZE W2, W2
00CAF8  780083     MOV W3, W1
00CAFA  21E280     MOV #0x1E28, W0
00CAFC  07283E     RCALL ByteQueuePushBuffer
215:                 ByteQueuePushBuffer(&tx_queue, data, size);
00CAFE  780109     MOV W9, W2
00CB00  78008A     MOV W10, W1
00CB02  21E280     MOV #0x1E28, W0
00CB04  07283A     RCALL ByteQueuePushBuffer
216:                 SyncInterruptLevel(prev);
217:               }
00CAD8  78054F     MOV [--W15], W10
00CADA  BE044F     MOV.D [--W15], W8
00CADC  060000     RETURN
00CB1A  FA001E     LNK #0x1E
00CB1C  781F88     MOV W8, [W15++]
218:               
219:               void AppProtocolSendMessageWithVarArgSplit(const OUTGOING_MESSAGE* msg,
220:                                                          const void* data1, int size1,
221:                                                          const void* data2, int size2) {
222:                 if (state != STATE_OPEN) return;
00C9B0  E21E16     CP0 filepath
00C9B2  320004     BRA Z, 0xC9BC
223:                 BYTE prev = SyncInterruptLevel(1);
224:                 ByteQueuePushBuffer(&tx_queue, (const BYTE*) msg, OutgoingMessageLength(msg));
00C9CC  FB8095     ZE [W5], W1
00C9CE  2ED900     MOV #0xED90, W0
00C9D0  78C160     MOV.B [W0+W1], W2
00C9D2  E84102     INC.B W2, W2
00C9D4  FB8102     ZE W2, W2
00C9D6  780085     MOV W5, W1
00C9D8  21E280     MOV #0x1E28, W0
00C9DA  0728CF     RCALL ByteQueuePushBuffer
225:                 ByteQueuePushBuffer(&tx_queue, data1, size1);
00C9DC  780109     MOV W9, W2
00C9DE  78008A     MOV W10, W1
00C9E0  21E280     MOV #0x1E28, W0
00C9E2  0728CB     RCALL ByteQueuePushBuffer
226:                 ByteQueuePushBuffer(&tx_queue, data2, size2);
00C9E4  78010B     MOV W11, W2
00C9E6  78008C     MOV W12, W1
00C9E8  21E280     MOV #0x1E28, W0
00C9EA  0728C7     RCALL ByteQueuePushBuffer
227:                 SyncInterruptLevel(prev);
228:               }
00C9B4  78064F     MOV [--W15], W12
00C9B6  BE054F     MOV.D [--W15], W10
00C9B8  BE044F     MOV.D [--W15], W8
00C9BA  060000     RETURN
00CA02  FA0002     LNK #0x2
00CA04  BE9F88     MOV.D W8, [W15++]
00CA06  780400     MOV W0, W8
229:               
230:               void AppProtocolTasks(CHANNEL_HANDLE h) {
231:                 if (state == STATE_CLOSED) return;
00CA08  80F0B0     MOV filepath, W0
00CA0A  500FE2     SUB W0, #0x2, [W15]
00CA0C  320028     BRA Z, 0xCA5E
232:                 if (state == STATE_CLOSING && ByteQueueSize(&tx_queue) == 0) {
00CA0E  500FE1     SUB W0, #0x1, [W15]
00CA10  320029     BRA Z, 0xCA64
00CA64  E21E30     CP0 0x1E30
00CA66  3AFFD5     BRA NZ, 0xCA12
233:                   log_printf("Finished flushing, closing the channel.");
234:                   ConnectionCloseChannel(h);
00CA68  780008     MOV W8, W0
00CA6A  074B3E     RCALL ConnectionCloseChannel
235:                   state = STATE_CLOSED;
00CA6C  200020     MOV #0x2, W0
00CA6E  88F0B0     MOV W0, filepath
236:                   return;
237:                 }
238:                 UARTTasks();
00CA12  070C0A     RCALL UARTTasks
239:                 SPITasks();
00CA14  070948     RCALL SPITasks
240:                 I2CTasks();
00CA16  07124E     RCALL I2CTasks
241:                 ICSPTasks();
00CA18  071CD2     RCALL ICSPTasks
242:                 if (ConnectionCanSend(h)) {
00CA1A  780008     MOV W8, W0
00CA1C  0748ED     RCALL ConnectionCanSend
00CA1E  E00000     CP0 W0
00CA20  32001E     BRA Z, 0xCA5E
243:                   BYTE prev = SyncInterruptLevel(1);
00CA30  DE0CC5     LSR W1, #5, W9
244:                   const BYTE* data;
245:                   if (bytes_out) {
00CA32  80F0D1     MOV bytes_out, W1
00CA34  E00001     CP0 W1
00CA36  3A0026     BRA NZ, 0xCA84
246:                     ByteQueuePull(&tx_queue, bytes_out);
00CA84  21E280     MOV #0x1E28, W0
00CA86  072845     RCALL ByteQueuePull
247:                     bytes_out = 0;
00CA8C  781F88     MOV W8, [W15++]
00CA8E  780180     MOV W0, W3
248:                   }
249:                   ByteQueuePeek(&tx_queue, &data, &bytes_out);
00CA38  21E1A2     MOV #0x1E1A, W2
00CA3A  5780E6     SUB W15, #0x6, W1
00CA3C  21E280     MOV #0x1E28, W0
00CA3E  072876     RCALL ByteQueuePeek
250:                   if (bytes_out > 0) {
00CA40  80F0D2     MOV bytes_out, W2
00CA42  E00002     CP0 W2
00CA44  340006     BRA LE, 0xCA52
251:                     if (bytes_out > max_packet) bytes_out = max_packet;
00CA46  80F0C0     MOV max_packet, W0
00CA48  510F80     SUB W2, W0, [W15]
00CA4A  3C0016     BRA GT, 0xCA78
00CA78  780100     MOV W0, W2
00CA7A  88F0D0     MOV W0, bytes_out
252:                     ConnectionSend(h, data, bytes_out);
00CA4C  97B8DF     MOV [W15-6], W1
00CA4E  780008     MOV W8, W0
00CA50  074815     RCALL ConnectionSend
00CA7C  97B8DF     MOV [W15-6], W1
00CA7E  780008     MOV W8, W0
00CA80  0747FD     RCALL ConnectionSend
00CA82  37FFE7     BRA 0xCA52
253:                   }
254:                   SyncInterruptLevel(prev);
255:                 }
256:               }
00CA5E  BE044F     MOV.D [--W15], W8
00CA60  FA8000     ULNK
00CA62  060000     RETURN
00CA70  BE044F     MOV.D [--W15], W8
00CA72  FA8000     ULNK
00CA74  060000     RETURN
00CA76  37FFF6     BRA 0xCA64
257:               
258:               static void Echo() {
259:                 AppProtocolSendMessage((const OUTGOING_MESSAGE*) &rx_msg);
260:               }
261:               
262:               static BOOL MessageDone() {
263:                 // TODO: check pin capabilities
264:                 switch (rx_msg.type) {
00CC34  78401C     MOV.B [W12], W0
00CC36  FB8000     ZE W0, W0
00CC38  200001     MOV #0x0, W1
00CC3A  500FFF     SUB W0, #0x1F, [W15]
00CC3C  588FE0     SUBB W1, #0x0, [W15]
00CC3E  360029     BRA LEU, 0xCC92
00CC92  016000     BRA W0
00CC94  37013C     BRA 0xCF0E
00CC96  370150     BRA 0xCF38
00CC98  370156     BRA 0xCF46
00CC9A  37015B     BRA 0xCF52
00CC9C  370169     BRA 0xCF70
00CC9E  370175     BRA 0xCF8A
00CCA0  370184     BRA 0xCFAA
00CCA2  37FFCE     BRA 0xCC40
00CCA4  37019B     BRA 0xCFDC
00CCA6  3701AE     BRA 0xD004
00CCA8  3701C1     BRA 0xD02C
00CCAA  3701D7     BRA 0xD05A
00CCAC  3701E0     BRA 0xD06E
00CCAE  3701EC     BRA 0xD088
00CCB0  370204     BRA 0xD0BA
00CCB2  370212     BRA 0xD0D8
00CCB4  370227     BRA 0xD104
00CCB6  37009F     BRA 0xCDF6
00CCB8  3700C1     BRA 0xCE3C
00CCBA  3700F0     BRA 0xCE9C
00CCBC  3700FE     BRA 0xCEBA
00CCBE  37FFC0     BRA 0xCC40
00CCC0  3700E1     BRA 0xCE84
00CCC2  370120     BRA 0xCF04
00CCC4  370115     BRA 0xCEF0
00CCC6  370119     BRA 0xCEFA
00CCC8  37002D     BRA 0xCD24
00CCCA  370057     BRA 0xCD7A
00CCCC  370073     BRA 0xCDB4
00CCCE  37008B     BRA 0xCDE6
00CCD0  37001A     BRA 0xCD06
00CCD2  370022     BRA 0xCD18
265:                   case HARD_RESET:
266:                     CHECK(rx_msg.args.hard_reset.magic == IOIO_MAGIC);
00CF0E  220014     MOV #0x2001, W4
00CF10  FB8094     ZE [W4], W1
00CF12  FB801D     ZE [W13], W0
00CF14  DD0048     SL W0, #8, W0
00CF16  700101     IOR W0, W1, W2
00CF18  220038     MOV #0x2003, W8
00CF1A  FB8098     ZE [W8], W1
00CF1C  220040     MOV #0x2004, W0
00CF1E  FB8010     ZE [W0], W0
00CF20  DD0048     SL W0, #8, W0
00CF22  700181     IOR W0, W1, W3
00CF24  24F490     MOV #0x4F49, W0
00CF26  24F491     MOV #0x4F49, W1
00CF28  510F80     SUB W2, W0, [W15]
00CF2A  598F81     SUBB W3, W1, [W15]
00CF2C  3AFE89     BRA NZ, 0xCC40
267:                     HardReset();
00CF2E  0712A9     RCALL HardReset
268:                     break;
269:               
270:                   case SOFT_RESET:
271:                     SoftReset();
00CF38  0712D9     RCALL SoftReset
272:                     Echo();
273:                     break;
274:               
275:                   case SET_PIN_DIGITAL_OUT:
276:                     CHECK(rx_msg.args.set_pin_digital_out.pin < NUM_PINS);
00CF52  220015     MOV #0x2001, W5
00CF54  FB8095     ZE [W5], W1
00CF56  DE0842     LSR W1, #2, W0
00CF58  500F8E     SUB W0, W14, [W15]
00CF5A  3CFE72     BRA GT, 0xCC40
277:                     SetPinDigitalOut(rx_msg.args.set_pin_digital_out.pin,
00CF5C  784315     MOV.B [W5], W6
00CF5E  634161     AND.B W6, #0x1, W2
00CF60  FB8102     ZE W2, W2
00CF62  D10081     LSR W1, W1
00CF64  6080E1     AND W1, #0x1, W1
00CF66  071128     RCALL SetPinDigitalOut
278:                                      rx_msg.args.set_pin_digital_out.value,
279:                                      rx_msg.args.set_pin_digital_out.open_drain);
280:                     break;
281:               
282:                   case SET_DIGITAL_OUT_LEVEL:
283:                     CHECK(rx_msg.args.set_digital_out_level.pin < NUM_PINS);
00CF70  220011     MOV #0x2001, W1
00CF72  FB8011     ZE [W1], W0
00CF74  DE0042     LSR W0, #2, W0
00CF76  500F8E     SUB W0, W14, [W15]
00CF78  3CFE63     BRA GT, 0xCC40
284:                     SetDigitalOutLevel(rx_msg.args.set_digital_out_level.pin,
00CF7A  784111     MOV.B [W1], W2
00CF7C  6140E1     AND.B W2, #0x1, W1
00CF7E  FB8081     ZE W1, W1
00CF80  071F19     RCALL SetDigitalOutLevel
285:                                        rx_msg.args.set_digital_out_level.value);
286:                     break;
287:               
288:                   case SET_PIN_DIGITAL_IN:
289:                     CHECK(rx_msg.args.set_pin_digital_in.pin < NUM_PINS);
00CF8A  220013     MOV #0x2001, W3
00CF8C  FB8013     ZE [W3], W0
00CF8E  DE0142     LSR W0, #2, W2
00CF90  510F8E     SUB W2, W14, [W15]
00CF92  3CFE56     BRA GT, 0xCC40
290:                     CHECK(rx_msg.args.set_pin_digital_in.pull < 3);
00CF94  784213     MOV.B [W3], W4
00CF96  624063     AND.B W4, #0x3, W0
00CF98  FB8080     ZE W0, W1
00CF9A  508FE2     SUB W1, #0x2, [W15]
00CF9C  3CFE51     BRA GT, 0xCC40
291:                     SetPinDigitalIn(rx_msg.args.set_pin_digital_in.pin, rx_msg.args.set_pin_digital_in.pull);
00CF9E  780002     MOV W2, W0
00CFA0  0710D8     RCALL SetPinDigitalIn
292:                     break;
293:               
294:                   case SET_CHANGE_NOTIFY:
295:                     CHECK(rx_msg.args.set_change_notify.pin < NUM_PINS);
00CFAA  220015     MOV #0x2001, W5
00CFAC  FB8015     ZE [W5], W0
00CFAE  DE0042     LSR W0, #2, W0
00CFB0  500F8E     SUB W0, W14, [W15]
00CFB2  3CFE46     BRA GT, 0xCC40
296:                     if (rx_msg.args.set_change_notify.cn) {
00CFB4  784315     MOV.B [W5], W6
00CFB6  634061     AND.B W6, #0x1, W0
00CFB8  320002     BRA Z, 0xCFBE
297:                       Echo();
298:                     }
299:                     SetChangeNotify(rx_msg.args.set_change_notify.pin, rx_msg.args.set_change_notify.cn);
00CFBE  220010     MOV #0x2001, W0
00CFC0  784010     MOV.B [W0], W0
00CFC2  6040E1     AND.B W0, #0x1, W1
00CFC4  FB8081     ZE W1, W1
00CFC6  FB8000     ZE W0, W0
00CFC8  DE0042     LSR W0, #2, W0
00CFCA  071ED4     RCALL SetChangeNotify
00D1F6  220010     MOV #0x2001, W0
00D1F8  784010     MOV.B [W0], W0
00D1FA  6040E1     AND.B W0, #0x1, W1
00D1FC  FB8081     ZE W1, W1
00D1FE  FB8000     ZE W0, W0
00D200  DE0042     LSR W0, #2, W0
00D202  071DB8     RCALL SetChangeNotify
300:                     if (!rx_msg.args.set_change_notify.cn) {
00CFCC  220013     MOV #0x2001, W3
00CFCE  784193     MOV.B [W3], W3
00CFD0  61C061     AND.B W3, #0x1, W0
00CFD2  32FEB7     BRA Z, 0xCD42
00D204  220013     MOV #0x2001, W3
00D206  784193     MOV.B [W3], W3
00D208  61C061     AND.B W3, #0x1, W0
00D20A  3AFEE4     BRA NZ, 0xCFD4
00D20C  37FD9A     BRA 0xCD42
301:                       Echo();
302:                     }
303:                     break;
304:               
305:                   case SET_PIN_PWM:
306:                     CHECK(rx_msg.args.set_pin_pwm.pin < NUM_PINS);
00CFDC  B3C3F5     MOV #0x3F, W5
00CFDE  220014     MOV #0x2001, W4
00CFE0  62C014     AND.B W5, [W4], W0
00CFE2  FB8180     ZE W0, W3
00CFE4  518F8E     SUB W3, W14, [W15]
00CFE6  3CFE2C     BRA GT, 0xCC40
307:                     CHECK(rx_msg.args.set_pin_pwm.pwm_num < NUM_PWM_MODULES);
00CFE8  220022     MOV #0x2002, W2
00CFEA  784312     MOV.B [W2], W6
00CFEC  63406F     AND.B W6, #0xF, W0
00CFEE  FB8080     ZE W0, W1
00CFF0  508FE8     SUB W1, #0x8, [W15]
00CFF2  3CFE26     BRA GT, 0xCC40
308:                     SetPinPwm(rx_msg.args.set_pin_pwm.pin, rx_msg.args.set_pin_pwm.pwm_num,
00CFF4  FB8106     ZE W6, W2
00CFF6  DE1147     LSR W2, #7, W2
00CFF8  780003     MOV W3, W0
00CFFA  0710FE     RCALL SetPinPwm
309:                               rx_msg.args.set_pin_pwm.enable);
310:                     break;
311:               
312:                   case SET_PWM_DUTY_CYCLE:
313:                     CHECK(rx_msg.args.set_pwm_duty_cycle.pwm_num < NUM_PWM_MODULES);
00D004  220011     MOV #0x2001, W1
00D006  FB8011     ZE [W1], W0
00D008  DE0042     LSR W0, #2, W0
00D00A  6001EF     AND W0, #0xF, W3
00D00C  518FE8     SUB W3, #0x8, [W15]
00D00E  3CFE18     BRA GT, 0xCC40
314:                     SetPwmDutyCycle(rx_msg.args.set_pwm_duty_cycle.pwm_num,
00D010  784211     MOV.B [W1], W4
00D012  624163     AND.B W4, #0x3, W2
00D014  FB8102     ZE W2, W2
00D016  FB801D     ZE [W13], W0
00D018  220038     MOV #0x2003, W8
00D01A  FB8098     ZE [W8], W1
00D01C  DD08C8     SL W1, #8, W1
00D01E  708080     IOR W1, W0, W1
00D020  780003     MOV W3, W0
00D022  073DB6     RCALL SetPwmDutyCycle
315:                                     rx_msg.args.set_pwm_duty_cycle.dc,
316:                                     rx_msg.args.set_pwm_duty_cycle.fraction);
317:                     break;
318:               
319:                   case SET_PWM_PERIOD:
320:                     CHECK(rx_msg.args.set_pwm_period.pwm_num < NUM_PWM_MODULES);
00D02C  220015     MOV #0x2001, W5
00D02E  FB8095     ZE [W5], W1
00D030  D10001     LSR W1, W0
00D032  6001EF     AND W0, #0xF, W3
00D034  518FE8     SUB W3, #0x8, [W15]
00D036  3CFE04     BRA GT, 0xCC40
321:                     SetPwmPeriod(rx_msg.args.set_pwm_period.pwm_num,
00D038  784315     MOV.B [W5], W6
00D03A  634161     AND.B W6, #0x1, W2
00D03C  FB8102     ZE W2, W2
00D03E  DE0847     LSR W1, #7, W0
00D040  400000     ADD W0, W0, W0
00D042  710100     IOR W2, W0, W2
00D044  FB801D     ZE [W13], W0
00D046  220038     MOV #0x2003, W8
00D048  FB8098     ZE [W8], W1
00D04A  DD08C8     SL W1, #8, W1
00D04C  708080     IOR W1, W0, W1
00D04E  780003     MOV W3, W0
00D050  073D8F     RCALL SetPwmPeriod
322:                                  rx_msg.args.set_pwm_period.period,
323:                                  rx_msg.args.set_pwm_period.scale_l
324:                                  | (rx_msg.args.set_pwm_period.scale_h) << 1);
325:                     break;
326:               
327:                   case SET_PIN_ANALOG_IN:
328:                     CHECK(rx_msg.args.set_pin_analog_in.pin < NUM_PINS);
00D05A  220011     MOV #0x2001, W1
00D05C  784011     MOV.B [W1], W0
00D05E  504F8E     SUB.B W0, W14, [W15]
00D060  3EFDEF     BRA GTU, 0xCC40
329:                     SetPinAnalogIn(rx_msg.args.set_pin_analog_in.pin);
00D062  FB8000     ZE W0, W0
00D064  0711AB     RCALL SetPinAnalogIn
330:                     break;
331:               
332:                   case UART_DATA:
333:                     CHECK(rx_msg.args.uart_data.uart_num < NUM_UART_MODULES);
00D0BA  220012     MOV #0x2001, W2
00D0BC  FB8012     ZE [W2], W0
00D0BE  DE0046     LSR W0, #6, W0
00D0C0  500FE3     SUB W0, #0x3, [W15]
00D0C2  3CFDBE     BRA GT, 0xCC40
334:                     UARTTransmit(rx_msg.args.uart_data.uart_num,
00D0C4  B3C3F3     MOV #0x3F, W3
00D0C6  61C112     AND.B W3, [W2], W2
00D0C8  FB8102     ZE W2, W2
00D0CA  E80102     INC W2, W2
00D0CC  220021     MOV #0x2002, W1
00D0CE  070919     RCALL UARTTransmit
335:                                  rx_msg.args.uart_data.data,
336:                                  rx_msg.args.uart_data.size + 1);
337:                     break;
338:               
339:                   case UART_CONFIG:
340:                     CHECK(rx_msg.args.uart_config.uart_num < NUM_UART_MODULES);
00D088  220014     MOV #0x2001, W4
00D08A  FB8094     ZE [W4], W1
00D08C  DE0AC6     LSR W1, #6, W5
00D08E  528FE3     SUB W5, #0x3, [W15]
00D090  3CFDD7     BRA GT, 0xCC40
341:                     CHECK(rx_msg.args.uart_config.parity < 3);
00D092  784314     MOV.B [W4], W6
00D094  634063     AND.B W6, #0x3, W0
00D096  FB8200     ZE W0, W4
00D098  520FE2     SUB W4, #0x2, [W15]
00D09A  3CFDD2     BRA GT, 0xCC40
342:                     UARTConfig(rx_msg.args.uart_config.uart_num,
00D09C  DE09C2     LSR W1, #2, W3
00D09E  DE0943     LSR W1, #3, W2
00D0A0  610161     AND W2, #0x1, W2
00D0A2  FB801D     ZE [W13], W0
00D0A4  220038     MOV #0x2003, W8
00D0A6  FB8098     ZE [W8], W1
00D0A8  DD08C8     SL W1, #8, W1
00D0AA  708080     IOR W1, W0, W1
00D0AC  6181E1     AND W3, #0x1, W3
00D0AE  780005     MOV W5, W0
00D0B0  070A4F     RCALL UARTConfig
343:                                rx_msg.args.uart_config.rate,
344:                                rx_msg.args.uart_config.speed4x,
345:                                rx_msg.args.uart_config.two_stop_bits,
346:                                rx_msg.args.uart_config.parity);
347:                     break;
348:               
349:                   case SET_PIN_UART:
350:                     CHECK(rx_msg.args.set_pin_uart.pin < NUM_PINS);
00D0D8  B3C3F2     MOV #0x3F, W2
00D0DA  220011     MOV #0x2001, W1
00D0DC  614011     AND.B W2, [W1], W0
00D0DE  FB8200     ZE W0, W4
00D0E0  520F8E     SUB W4, W14, [W15]
00D0E2  3CFDAE     BRA GT, 0xCC40
351:                     CHECK(rx_msg.args.set_pin_uart.uart_num < NUM_UART_MODULES);
00D0E4  220022     MOV #0x2002, W2
00D0E6  784192     MOV.B [W2], W3
00D0E8  61C063     AND.B W3, #0x3, W0
00D0EA  FB8080     ZE W0, W1
00D0EC  508FE3     SUB W1, #0x3, [W15]
00D0EE  3CFDA8     BRA GT, 0xCC40
352:                     SetPinUart(rx_msg.args.set_pin_uart.pin,
00D0F0  FB8183     ZE W3, W3
00D0F2  DE1946     LSR W3, #6, W2
00D0F4  610161     AND W2, #0x1, W2
00D0F6  DE19C7     LSR W3, #7, W3
00D0F8  780004     MOV W4, W0
00D0FA  071089     RCALL SetPinUart
353:                                rx_msg.args.set_pin_uart.uart_num,
354:                                rx_msg.args.set_pin_uart.dir,
355:                                rx_msg.args.set_pin_uart.enable);
356:                     break;
357:               
358:                   case SPI_MASTER_REQUEST:
359:                     CHECK(rx_msg.args.spi_master_request.spi_num < NUM_SPI_MODULES);
00CDF6  220014     MOV #0x2001, W4
00CDF8  FB8014     ZE [W4], W0
00CDFA  DE03C6     LSR W0, #6, W7
00CDFC  538FE2     SUB W7, #0x2, [W15]
00CDFE  3CFF20     BRA GT, 0xCC40
360:                     CHECK(rx_msg.args.spi_master_request.ss_pin < NUM_PINS);
00CE00  B3C3F5     MOV #0x3F, W5
00CE02  62C014     AND.B W5, [W4], W0
00CE04  FB8080     ZE W0, W1
00CE06  508F8E     SUB W1, W14, [W15]
00CE08  3CFF1B     BRA GT, 0xCC40
361:                     {
362:                       const BYTE total_size = rx_msg.args.spi_master_request.total_size + 1;
00CE0A  220026     MOV #0x2002, W6
00CE0C  62C016     AND.B W5, [W6], W0
00CE0E  E84000     INC.B W0, W0
363:                       const BYTE data_size = rx_msg.args.spi_master_request.data_size_neq_total
364:                           ? rx_msg.args.spi_master_request.data_size
365:                           : total_size;
00CE10  784116     MOV.B [W6], W2
00CE12  E00402     CP0.B W2
00CE14  350226     BRA LT, 0xD262
00CE16  784180     MOV.B W0, W3
00CE18  220038     MOV #0x2003, W8
366:                       const BYTE res_size = rx_msg.args.spi_master_request.res_size_neq_total
367:                           ? rx_msg.args.spi_master_request.vararg[
368:                               rx_msg.args.spi_master_request.data_size_neq_total]
369:                           : total_size;
00CE1A  A36802     BTST.Z W2, #6
00CE1C  3A0210     BRA NZ, 0xD23E
00CE1E  FB8200     ZE W0, W4
00CE20  EB0280     CLR W5
00D23E  FB8200     ZE W0, W4
00D240  FB8016     ZE [W6], W0
00D242  DE0047     LSR W0, #7, W0
00D244  E88000     INC2 W0, W0
00D246  220012     MOV #0x2001, W2
00D248  784062     MOV.B [W2+W0], W0
00D24A  FB8000     ZE W0, W0
00D24C  520280     SUB W4, W0, W5
370:                       const BYTE* const data = &rx_msg.args.spi_master_request.vararg[
371:                           rx_msg.args.spi_master_request.data_size_neq_total
372:                           + rx_msg.args.spi_master_request.res_size_neq_total];
373:               
374:                       SPITransmit(rx_msg.args.spi_master_request.spi_num,
00CE22  FB8016     ZE [W6], W0
00CE24  DE0147     LSR W0, #7, W2
00CE26  DE0046     LSR W0, #6, W0
00CE28  600061     AND W0, #0x1, W0
00CE2A  410100     ADD W2, W0, W2
00CE2C  410108     ADD W2, W8, W2
00CE2E  FB8183     ZE W3, W3
00CE30  780007     MOV W7, W0
00CE32  070824     RCALL SPITransmit
00D24E  FB8016     ZE [W6], W0
00D250  DE0147     LSR W0, #7, W2
00D252  DE0046     LSR W0, #6, W0
00D254  600061     AND W0, #0x1, W0
00D256  410100     ADD W2, W0, W2
00D258  410108     ADD W2, W8, W2
00D25A  FB8183     ZE W3, W3
00D25C  780007     MOV W7, W0
00D25E  07060E     RCALL SPITransmit
00D260  37FDE9     BRA 0xCE34
375:                                   rx_msg.args.spi_master_request.ss_pin,
376:                                   data,
377:                                   data_size,
378:                                   total_size,
379:                                   total_size - res_size);
380:                     }
381:                     break;
382:               
383:                   case SPI_CONFIGURE_MASTER:
384:                     CHECK(rx_msg.args.spi_configure_master.spi_num < NUM_SPI_MODULES);
00D104  220013     MOV #0x2001, W3
00D106  FB8093     ZE [W3], W1
00D108  DE0845     LSR W1, #5, W0
00D10A  600063     AND W0, #0x3, W0
00D10C  500FE2     SUB W0, #0x2, [W15]
00D10E  3CFD98     BRA GT, 0xCC40
385:                     SPIConfigMaster(rx_msg.args.spi_configure_master.spi_num,
00D110  78421D     MOV.B [W13], W4
00D112  6242E1     AND.B W4, #0x1, W5
00D114  FB8184     ZE W4, W3
00D116  D10203     LSR W3, W4
00D118  DE19C2     LSR W3, #2, W3
00D11A  220016     MOV #0x2001, W6
00D11C  784316     MOV.B [W6], W6
00D11E  634167     AND.B W6, #0x7, W2
00D120  FB8102     ZE W2, W2
00D122  DE08C3     LSR W1, #3, W1
00D124  6080E3     AND W1, #0x3, W1
00D126  6282E1     AND W5, #0x1, W5
00D128  620261     AND W4, #0x1, W4
00D12A  6181E1     AND W3, #0x1, W3
00D12C  07076F     RCALL SPIConfigMaster
386:                                     rx_msg.args.spi_configure_master.scale,
387:                                     rx_msg.args.spi_configure_master.div,
388:                                     rx_msg.args.spi_configure_master.smp_end,
389:                                     rx_msg.args.spi_configure_master.clk_edge,
390:                                     rx_msg.args.spi_configure_master.clk_pol);
391:                     break;
392:               
393:                   case SET_PIN_SPI:
394:                     CHECK(rx_msg.args.set_pin_spi.mode < 3);
00CE3C  220026     MOV #0x2002, W6
00CE3E  FB8016     ZE [W6], W0
00CE40  DE0042     LSR W0, #2, W0
00CE42  600163     AND W0, #0x3, W2
00CE44  510FE2     SUB W2, #0x2, [W15]
00CE46  3CFEFC     BRA GT, 0xCC40
395:                     CHECK((!rx_msg.args.set_pin_spi.enable
00CE48  784096     MOV.B [W6], W1
00CE4A  60C07C     AND.B W1, #0x1C, W0
00CE4C  504FE4     SUB.B W0, #0x4, [W15]
00CE4E  320006     BRA Z, 0xCE5C
00CE50  220010     MOV #0x2001, W0
00CE52  B3C3F3     MOV #0x3F, W3
00CE54  61C010     AND.B W3, [W0], W0
00CE56  FB8000     ZE W0, W0
00CE58  500F8E     SUB W0, W14, [W15]
00CE5A  3CFEF2     BRA GT, 0xCC40
396:                           && rx_msg.args.set_pin_spi.mode == 1)
397:                           || rx_msg.args.set_pin_spi.pin < NUM_PINS);
398:                     CHECK((!rx_msg.args.set_pin_spi.enable
00CE5C  A34801     BTST.Z W1, #4
00CE5E  3A0184     BRA NZ, 0xD168
00CE60  60C06C     AND.B W1, #0xC, W0
00CE62  504FE4     SUB.B W0, #0x4, [W15]
00CE64  320181     BRA Z, 0xD168
00D168  784216     MOV.B [W6], W4
00D16A  624063     AND.B W4, #0x3, W0
00D16C  FB8000     ZE W0, W0
00D16E  500FE2     SUB W0, #0x2, [W15]
00D170  3CFD67     BRA GT, 0xCC40
399:                           && rx_msg.args.set_pin_spi.mode != 1)
400:                           || rx_msg.args.set_pin_spi.spi_num < NUM_SPI_MODULES);
401:                     SetPinSpi(rx_msg.args.set_pin_spi.pin,
00CE66  FB8196     ZE [W6], W3
00CE68  DE19C4     LSR W3, #4, W3
00CE6A  784316     MOV.B [W6], W6
00CE6C  6340E3     AND.B W6, #0x3, W1
00CE6E  FB8081     ZE W1, W1
00CE70  B3C3F6     MOV #0x3F, W6
00CE72  220015     MOV #0x2001, W5
00CE74  634015     AND.B W6, [W5], W0
00CE76  FB8000     ZE W0, W0
00CE78  6181E1     AND W3, #0x1, W3
00CE7A  0712B8     RCALL SetPinSpi
00D172  FB8196     ZE [W6], W3
00D174  DE19C4     LSR W3, #4, W3
00D176  784316     MOV.B [W6], W6
00D178  6340E3     AND.B W6, #0x3, W1
00D17A  FB8081     ZE W1, W1
00D17C  B3C3F6     MOV #0x3F, W6
00D17E  220015     MOV #0x2001, W5
00D180  634015     AND.B W6, [W5], W0
00D182  FB8000     ZE W0, W0
00D184  6181E1     AND W3, #0x1, W3
00D186  071132     RCALL SetPinSpi
00D188  37FE79     BRA 0xCE7C
402:                               rx_msg.args.set_pin_spi.spi_num,
403:                               rx_msg.args.set_pin_spi.mode,
404:                               rx_msg.args.set_pin_spi.enable);
405:                     break;
406:               
407:                   case I2C_CONFIGURE_MASTER:
408:                     CHECK(rx_msg.args.i2c_configure_master.i2c_num < NUM_I2C_MODULES);
00CE9C  220011     MOV #0x2001, W1
00CE9E  784091     MOV.B [W1], W1
00CEA0  60C063     AND.B W1, #0x3, W0
00CEA2  FB8000     ZE W0, W0
00CEA4  500FE2     SUB W0, #0x2, [W15]
00CEA6  3CFECC     BRA GT, 0xCC40
409:                     I2CConfigMaster(rx_msg.args.i2c_configure_master.i2c_num,
00CEA8  FB8081     ZE W1, W1
00CEAA  DE0947     LSR W1, #7, W2
00CEAC  DE08C5     LSR W1, #5, W1
00CEAE  6080E3     AND W1, #0x3, W1
00CEB0  07113E     RCALL I2CConfigMaster
410:                                     rx_msg.args.i2c_configure_master.rate,
411:                                     rx_msg.args.i2c_configure_master.smbus_levels);
412:                     break;
413:               
414:                   case I2C_WRITE_READ:
415:                     CHECK(rx_msg.args.i2c_write_read.i2c_num < NUM_I2C_MODULES);
00CEBA  220013     MOV #0x2001, W3
00CEBC  784193     MOV.B [W3], W3
00CEBE  61C063     AND.B W3, #0x3, W0
00CEC0  FB8280     ZE W0, W5
00CEC2  528FE2     SUB W5, #0x2, [W15]
00CEC4  3CFEBD     BRA GT, 0xCC40
416:                     {
417:                       unsigned int addr;
418:                       if (rx_msg.args.i2c_write_read.ten_bit_addr) {
00CEC6  784083     MOV.B W3, W1
00CEC8  A35801     BTST.Z W1, #5
00CECA  3201A6     BRA Z, 0xD218
419:                         addr = rx_msg.args.i2c_write_read.addr_lsb;
420:                         addr = addr << 8
00CECC  FB809D     ZE [W13], W1
00CECE  DD08C8     SL W1, #8, W1
00CED0  FB8003     ZE W3, W0
00CED2  DE0046     LSR W0, #6, W0
00CED4  400000     ADD W0, W0, W0
00CED6  708080     IOR W1, W0, W1
00CED8  B30F01     IOR #0xF0, W1
421:                                 | ((rx_msg.args.i2c_write_read.addr_msb << 1)
422:                                   | 0b11110000);
423:                       } else {
424:                         CHECK(rx_msg.args.i2c_write_read.addr_msb == 0
00D218  B3CC00     MOV #0xC0, W0
00D21A  61C000     AND.B W3, W0, W0
00D21C  3AFD11     BRA NZ, 0xCC40
00D21E  FB809D     ZE [W13], W1
00D220  DE0847     LSR W1, #7, W0
00D222  E00400     CP0.B W0
00D224  3AFD0D     BRA NZ, 0xCC40
00D226  DE0842     LSR W1, #2, W0
00D228  504FFE     SUB.B W0, #0x1E, [W15]
00D22A  32FD0A     BRA Z, 0xCC40
425:                               && rx_msg.args.i2c_write_read.addr_lsb >> 7 == 0
426:                               && rx_msg.args.i2c_write_read.addr_lsb >> 2 != 0b0011110);
427:                         addr = rx_msg.args.i2c_write_read.addr_lsb << 1;
00D22C  408081     ADD W1, W1, W1
428:                       }
429:                       I2CWriteRead(rx_msg.args.i2c_write_read.i2c_num,
00CEDA  220038     MOV #0x2003, W8
00CEDC  220040     MOV #0x2004, W0
00CEDE  FB8210     ZE [W0], W4
00CEE0  FB8198     ZE [W8], W3
00CEE2  220052     MOV #0x2005, W2
00CEE4  780005     MOV W5, W0
00CEE6  071075     RCALL I2CWriteRead
00D22E  220038     MOV #0x2003, W8
00D230  220040     MOV #0x2004, W0
00D232  FB8210     ZE [W0], W4
00D234  FB8198     ZE [W8], W3
00D236  220052     MOV #0x2005, W2
00D238  780005     MOV W5, W0
00D23A  070ECB     RCALL I2CWriteRead
00D23C  37FE55     BRA 0xCEE8
430:                                    addr,
431:                                    rx_msg.args.i2c_write_read.data,
432:                                    rx_msg.args.i2c_write_read.write_size,
433:                                    rx_msg.args.i2c_write_read.read_size);
434:                     }
435:                     break;
436:               
437:                   case SET_ANALOG_IN_SAMPLING:
438:                     CHECK(rx_msg.args.set_analog_pin_sampling.pin < NUM_PINS);
00D06E  B3C3F6     MOV #0x3F, W6
00D070  220015     MOV #0x2001, W5
00D072  634015     AND.B W6, [W5], W0
00D074  FB8000     ZE W0, W0
00D076  500F8E     SUB W0, W14, [W15]
00D078  3CFDE3     BRA GT, 0xCC40
439:                     ADCSetScan(rx_msg.args.set_analog_pin_sampling.pin,
00D07A  FB8095     ZE [W5], W1
00D07C  DE08C7     LSR W1, #7, W1
00D07E  072058     RCALL ADCSetScan
440:                                rx_msg.args.set_analog_pin_sampling.enable);
441:                     break;
442:               
443:                   case CHECK_INTERFACE:
444:                     CheckInterface(rx_msg.args.check_interface.interface_id);
00CF46  220010     MOV #0x2001, W0
00CF48  07129E     RCALL CheckInterface
445:                     break;
446:               
447:                   case ICSP_SIX:
448:                     ICSPSix(rx_msg.args.icsp_six.inst);
00CE84  220012     MOV #0x2001, W2
00CE86  FB8192     ZE [W2], W3
00CE88  FB811D     ZE [W13], W2
00CE8A  DD1148     SL W2, #8, W2
00CE8C  710003     IOR W2, W3, W0
00CE8E  220038     MOV #0x2003, W8
00CE90  FB8098     ZE [W8], W1
00CE92  071B84     RCALL ICSPSix
449:                     break;
450:               
451:                   case ICSP_REGOUT:
452:                     ICSPRegout();
00CF04  071A8E     RCALL ICSPRegout
453:                     break;
454:               
455:                   case ICSP_PROG_ENTER:
456:                     ICSPEnter();
00CEF0  071AE1     RCALL ICSPEnter
457:                     break;
458:               
459:                   case ICSP_PROG_EXIT:
460:                     ICSPExit();
00CEFA  071A2A     RCALL ICSPExit
461:                     break;
462:               
463:                   case ICSP_CONFIG:
464:                     if (rx_msg.args.icsp_config.enable) {
00CD24  220013     MOV #0x2001, W3
00CD26  784193     MOV.B [W3], W3
00CD28  61C061     AND.B W3, #0x1, W0
00CD2A  320002     BRA Z, 0xCD30
465:                       Echo();
466:                     }
467:                     ICSPConfigure(rx_msg.args.icsp_config.enable);
00CD30  220014     MOV #0x2001, W4
00CD32  784214     MOV.B [W4], W4
00CD34  624061     AND.B W4, #0x1, W0
00CD36  FB8000     ZE W0, W0
00CD38  071B16     RCALL ICSPConfigure
00D1B6  220014     MOV #0x2001, W4
00D1B8  784214     MOV.B [W4], W4
00D1BA  624061     AND.B W4, #0x1, W0
00D1BC  FB8000     ZE W0, W0
00D1BE  0718D3     RCALL ICSPConfigure
468:                     if (!rx_msg.args.icsp_config.enable) {
00CD3A  220015     MOV #0x2001, W5
00CD3C  784295     MOV.B [W5], W5
00CD3E  62C061     AND.B W5, #0x1, W0
00CD40  3AFF61     BRA NZ, 0xCC04
00D1C0  220015     MOV #0x2001, W5
00D1C2  784295     MOV.B [W5], W5
00D1C4  62C061     AND.B W5, #0x1, W0
00D1C6  3AFD1E     BRA NZ, 0xCC04
00D1C8  37FDBC     BRA 0xCD42
469:                       Echo();
470:                     }
471:                     break;
472:               
473:                   case INCAP_CONFIG:
474:                     CHECK(rx_msg.args.incap_config.incap_num < NUM_INCAP_MODULES);
00CD7A  220016     MOV #0x2001, W6
00CD7C  784316     MOV.B [W6], W6
00CD7E  63406F     AND.B W6, #0xF, W0
00CD80  FB8200     ZE W0, W4
00CD82  520FE8     SUB W4, #0x8, [W15]
00CD84  3CFF5D     BRA GT, 0xCC40
475:                     CHECK(!rx_msg.args.incap_config.double_prec
00CD86  220023     MOV #0x2002, W3
00CD88  E00413     CP0.B [W3]
00CD8A  3D0002     BRA GE, 0xCD90
00CD8C  A30804     BTST.Z W4, #0
00CD8E  3AFF58     BRA NZ, 0xCC40
476:                           || 0 == (rx_msg.args.incap_config.incap_num & 0x01));
477:                     CHECK(rx_msg.args.incap_config.mode < 6);
00CD90  FB8093     ZE [W3], W1
00CD92  DE0843     LSR W1, #3, W0
00CD94  600167     AND W0, #0x7, W2
00CD96  510FE5     SUB W2, #0x5, [W15]
00CD98  3CFF53     BRA GT, 0xCC40
478:                     CHECK(rx_msg.args.incap_config.clock < 4);
00CD9A  784193     MOV.B [W3], W3
00CD9C  61C063     AND.B W3, #0x3, W0
00CD9E  FB8000     ZE W0, W0
00CDA0  500FE3     SUB W0, #0x3, [W15]
00CDA2  3CFF4E     BRA GT, 0xCC40
479:                     InCapConfig(rx_msg.args.incap_config.incap_num,
00CDA4  DE08C7     LSR W1, #7, W1
00CDA6  780180     MOV W0, W3
00CDA8  780004     MOV W4, W0
00CDAA  070F19     RCALL InCapConfig
480:                                 rx_msg.args.incap_config.double_prec,
481:                                 rx_msg.args.incap_config.mode,
482:                                 rx_msg.args.incap_config.clock);
483:                     break;
484:               
485:                   case SET_PIN_INCAP:
486:                     CHECK(rx_msg.args.set_pin_incap.incap_num < NUM_INCAP_MODULES);
00CDB4  220022     MOV #0x2002, W2
00CDB6  784092     MOV.B [W2], W1
00CDB8  60C06F     AND.B W1, #0xF, W0
00CDBA  FB8080     ZE W0, W1
00CDBC  508FE8     SUB W1, #0x8, [W15]
00CDBE  3CFF40     BRA GT, 0xCC40
487:                     CHECK(!rx_msg.args.set_pin_incap.enable
00CDC0  E00412     CP0.B [W2]
00CDC2  3D0006     BRA GE, 0xCDD0
00CDC4  B3C3F4     MOV #0x3F, W4
00CDC6  220013     MOV #0x2001, W3
00CDC8  624013     AND.B W4, [W3], W0
00CDCA  FB8000     ZE W0, W0
00CDCC  500F8E     SUB W0, W14, [W15]
00CDCE  3CFF38     BRA GT, 0xCC40
488:                           || rx_msg.args.set_pin_incap.pin < NUM_PINS);
489:                     SetPinInCap(rx_msg.args.set_pin_incap.pin,
00CDD0  FB8112     ZE [W2], W2
00CDD2  DE1147     LSR W2, #7, W2
00CDD4  B3C3F6     MOV #0x3F, W6
00CDD6  220015     MOV #0x2001, W5
00CDD8  634015     AND.B W6, [W5], W0
00CDDA  FB8000     ZE W0, W0
00CDDC  071264     RCALL SetPinInCap
490:                                 rx_msg.args.set_pin_incap.incap_num,
491:                                 rx_msg.args.set_pin_incap.enable);
492:                     break;
493:               
494:                   case SOFT_CLOSE:
495:                     log_printf("Soft close requested");
496:                     Echo();
497:                     state = STATE_CLOSING;
00CDEA  200010     MOV #0x1, W0
00CDEC  88F0B0     MOV W0, filepath
00D162  200010     MOV #0x1, W0
00D164  88F0B0     MOV W0, filepath
00D166  37FE43     BRA 0xCDEE
498:                     break;
499:               
500:                   case RGB_LED_MATRIX_ENABLE:
501:                     RgbLedMatrixEnable(rx_msg.args.rgb_led_matrix_enable.len);
00CD06  220011     MOV #0x2001, W1
00CD08  784091     MOV.B [W1], W1
00CD0A  60C067     AND.B W1, #0x7, W0
00CD0C  FB8000     ZE W0, W0
00CD0E  07239B     RCALL RgbLedMatrixEnable
502:                     break;
503:               
504:                   case RGB_LED_MATRIX_FRAME:
505:                     RgbLedMatrixFrame(rx_msg.args.rgb_led_matrix_frame.data);
00CD18  220010     MOV #0x2001, W0
00CD1A  0723CC     RCALL RgbLedMatrixFrame
506:                     break;
507:               
508:                   // BOOKMARK(add_feature): Add incoming message handling to switch clause.
509:                   // Call Echo() if the message is to be echoed back.
510:               
511:                   default:
512:                     return FALSE;
513:                 }
514:                 return TRUE;
515:               }
516:               
517:               BOOL AppProtocolHandleIncoming(const BYTE* data, UINT32 data_len) {
518:                 assert(data);
519:                 if (state != STATE_OPEN) {
00CBC2  E21E16     CP0 filepath
00CBC4  3A003D     BRA NZ, 0xCC40
520:                   log_printf("Shouldn't get data after close!");
521:                   return FALSE;
522:                 }
523:               
524:                 while (data_len > 0) {
00CBC6  510FE0     SUB W2, #0x0, [W15]
00CBC8  598FE0     SUBB W3, #0x0, [W15]
00CBCA  32001F     BRA Z, 0xCC0A
00CBCC  22000C     MOV #0x2000, W12
00CBCE  22002D     MOV #0x2002, W13
00CBD0  20030E     MOV #0x30, W14
00CC04  550FE0     SUB W10, #0x0, [W15]
00CC06  5D8FE0     SUBB W11, #0x0, [W15]
00CC08  3AFFE4     BRA NZ, 0xCBD2
00CC0A  200010     MOV #0x1, W0
00CC40  EB0000     CLR W0
00CD10  550FE0     SUB W10, #0x0, [W15]
00CD12  5D8FE0     SUBB W11, #0x0, [W15]
00CD14  3AFF5E     BRA NZ, 0xCBD2
00CD16  37FF79     BRA 0xCC0A
00CD1C  550FE0     SUB W10, #0x0, [W15]
00CD1E  5D8FE0     SUBB W11, #0x0, [W15]
00CD20  3AFF58     BRA NZ, 0xCBD2
00CD22  37FF73     BRA 0xCC0A
00CD72  550FE0     SUB W10, #0x0, [W15]
00CD74  5D8FE0     SUBB W11, #0x0, [W15]
00CD76  3AFF2D     BRA NZ, 0xCBD2
00CD78  37FF48     BRA 0xCC0A
00CDAC  550FE0     SUB W10, #0x0, [W15]
00CDAE  5D8FE0     SUBB W11, #0x0, [W15]
00CDB0  3AFF10     BRA NZ, 0xCBD2
00CDB2  37FF2B     BRA 0xCC0A
00CDDE  550FE0     SUB W10, #0x0, [W15]
00CDE0  5D8FE0     SUBB W11, #0x0, [W15]
00CDE2  3AFEF7     BRA NZ, 0xCBD2
00CDE4  37FF12     BRA 0xCC0A
00CDEE  550FE0     SUB W10, #0x0, [W15]
00CDF0  5D8FE0     SUBB W11, #0x0, [W15]
00CDF2  3AFEEF     BRA NZ, 0xCBD2
00CDF4  37FF0A     BRA 0xCC0A
00CE34  550FE0     SUB W10, #0x0, [W15]
00CE36  5D8FE0     SUBB W11, #0x0, [W15]
00CE38  3AFECC     BRA NZ, 0xCBD2
00CE3A  37FEE7     BRA 0xCC0A
00CE7C  550FE0     SUB W10, #0x0, [W15]
00CE7E  5D8FE0     SUBB W11, #0x0, [W15]
00CE80  3AFEA8     BRA NZ, 0xCBD2
00CE82  37FEC3     BRA 0xCC0A
00CE94  550FE0     SUB W10, #0x0, [W15]
00CE96  5D8FE0     SUBB W11, #0x0, [W15]
00CE98  3AFE9C     BRA NZ, 0xCBD2
00CE9A  37FEB7     BRA 0xCC0A
00CEB2  550FE0     SUB W10, #0x0, [W15]
00CEB4  5D8FE0     SUBB W11, #0x0, [W15]
00CEB6  3AFE8D     BRA NZ, 0xCBD2
00CEB8  37FEA8     BRA 0xCC0A
00CEE8  550FE0     SUB W10, #0x0, [W15]
00CEEA  5D8FE0     SUBB W11, #0x0, [W15]
00CEEC  3AFE72     BRA NZ, 0xCBD2
00CEEE  37FE8D     BRA 0xCC0A
00CEF2  550FE0     SUB W10, #0x0, [W15]
00CEF4  5D8FE0     SUBB W11, #0x0, [W15]
00CEF6  3AFE6D     BRA NZ, 0xCBD2
00CEF8  37FE88     BRA 0xCC0A
00CEFC  550FE0     SUB W10, #0x0, [W15]
00CEFE  5D8FE0     SUBB W11, #0x0, [W15]
00CF00  3AFE68     BRA NZ, 0xCBD2
00CF02  37FE83     BRA 0xCC0A
00CF06  550FE0     SUB W10, #0x0, [W15]
00CF08  5D8FE0     SUBB W11, #0x0, [W15]
00CF0A  3AFE63     BRA NZ, 0xCBD2
00CF0C  37FE7E     BRA 0xCC0A
00CF30  550FE0     SUB W10, #0x0, [W15]
00CF32  5D8FE0     SUBB W11, #0x0, [W15]
00CF34  3AFE4E     BRA NZ, 0xCBD2
00CF36  37FE69     BRA 0xCC0A
00CF3E  550FE0     SUB W10, #0x0, [W15]
00CF40  5D8FE0     SUBB W11, #0x0, [W15]
00CF42  3AFE47     BRA NZ, 0xCBD2
00CF44  37FE62     BRA 0xCC0A
00CF4A  550FE0     SUB W10, #0x0, [W15]
00CF4C  5D8FE0     SUBB W11, #0x0, [W15]
00CF4E  3AFE41     BRA NZ, 0xCBD2
00CF50  37FE5C     BRA 0xCC0A
00CF68  550FE0     SUB W10, #0x0, [W15]
00CF6A  5D8FE0     SUBB W11, #0x0, [W15]
00CF6C  3AFE32     BRA NZ, 0xCBD2
00CF6E  37FE4D     BRA 0xCC0A
00CF82  550FE0     SUB W10, #0x0, [W15]
00CF84  5D8FE0     SUBB W11, #0x0, [W15]
00CF86  3AFE25     BRA NZ, 0xCBD2
00CF88  37FE40     BRA 0xCC0A
00CFA2  550FE0     SUB W10, #0x0, [W15]
00CFA4  5D8FE0     SUBB W11, #0x0, [W15]
00CFA6  3AFE15     BRA NZ, 0xCBD2
00CFA8  37FE30     BRA 0xCC0A
00CFD4  550FE0     SUB W10, #0x0, [W15]
00CFD6  5D8FE0     SUBB W11, #0x0, [W15]
00CFD8  3AFDFC     BRA NZ, 0xCBD2
00CFDA  37FE17     BRA 0xCC0A
00CFFC  550FE0     SUB W10, #0x0, [W15]
00CFFE  5D8FE0     SUBB W11, #0x0, [W15]
00D000  3AFDE8     BRA NZ, 0xCBD2
00D002  37FE03     BRA 0xCC0A
00D024  550FE0     SUB W10, #0x0, [W15]
00D026  5D8FE0     SUBB W11, #0x0, [W15]
00D028  3AFDD4     BRA NZ, 0xCBD2
00D02A  37FDEF     BRA 0xCC0A
00D052  550FE0     SUB W10, #0x0, [W15]
00D054  5D8FE0     SUBB W11, #0x0, [W15]
00D056  3AFDBD     BRA NZ, 0xCBD2
00D058  37FDD8     BRA 0xCC0A
00D066  550FE0     SUB W10, #0x0, [W15]
00D068  5D8FE0     SUBB W11, #0x0, [W15]
00D06A  3AFDB3     BRA NZ, 0xCBD2
00D06C  37FDCE     BRA 0xCC0A
00D080  550FE0     SUB W10, #0x0, [W15]
00D082  5D8FE0     SUBB W11, #0x0, [W15]
00D084  3AFDA6     BRA NZ, 0xCBD2
00D086  37FDC1     BRA 0xCC0A
00D0B2  550FE0     SUB W10, #0x0, [W15]
00D0B4  5D8FE0     SUBB W11, #0x0, [W15]
00D0B6  3AFD8D     BRA NZ, 0xCBD2
00D0B8  37FDA8     BRA 0xCC0A
00D0D0  550FE0     SUB W10, #0x0, [W15]
00D0D2  5D8FE0     SUBB W11, #0x0, [W15]
00D0D4  3AFD7E     BRA NZ, 0xCBD2
00D0D6  37FD99     BRA 0xCC0A
00D0FC  550FE0     SUB W10, #0x0, [W15]
00D0FE  5D8FE0     SUBB W11, #0x0, [W15]
00D100  3AFD68     BRA NZ, 0xCBD2
00D102  37FD83     BRA 0xCC0A
00D12E  550FE0     SUB W10, #0x0, [W15]
00D130  5D8FE0     SUBB W11, #0x0, [W15]
00D132  3AFD4F     BRA NZ, 0xCBD2
00D134  37FD6A     BRA 0xCC0A
525:                   // copy a chunk of data to rx_msg
526:                   if (data_len >= rx_message_remaining) {
00CBD2  80F092     MOV led_counter, W2
00CBD4  B91061     MUL.SU W2, #1, W0
00CBD6  550F80     SUB W10, W0, [W15]
00CBD8  5D8F81     SUBB W11, W1, [W15]
00CBDA  390039     BRA NC, 0xCC4E
527:                     memcpy(((BYTE *) &rx_msg) + rx_buffer_cursor, data, rx_message_remaining);
00CBDC  78000C     MOV W12, W0
00CBDE  B41E14     ADD state, WREG
00CBE0  780089     MOV W9, W1
00CBE2  07C57D     RCALL memcpy
528:                     data += rx_message_remaining;
00CBE4  80F092     MOV led_counter, W2
00CBE6  448482     ADD W9, W2, W9
529:                     data_len -= rx_message_remaining;
00CBE8  B91061     MUL.SU W2, #1, W0
00CBEA  550500     SUB W10, W0, W10
00CBEC  5D8581     SUBB W11, W1, W11
530:                     rx_buffer_cursor += rx_message_remaining;
00CBEE  780002     MOV W2, W0
00CBF0  B43E14     ADD state
531:                     rx_message_remaining = 0;
00CBF2  EF3E12     CLR led_counter
532:                   } else {
533:                     memcpy(((BYTE *) &rx_msg) + rx_buffer_cursor, data, data_len);
00CC4E  78000C     MOV W12, W0
00CC50  B41E14     ADD state, WREG
00CC52  78010A     MOV W10, W2
00CC54  780089     MOV W9, W1
00CC56  07C543     RCALL memcpy
534:                     rx_buffer_cursor += data_len;
00CC58  78000A     MOV W10, W0
00CC5A  B43E14     ADD state
535:                     rx_message_remaining -= data_len;
00CC5C  B53E12     SUB led_counter
00CC5E  B85560     MUL.UU W10, #0, W10
00CC60  37FFC9     BRA 0xCBF4
536:                     data_len = 0;
537:                   }
538:               
539:                   // change state
540:                   if (rx_message_remaining == 0) {
00CBF4  E21E12     CP0 led_counter
00CBF6  3A0006     BRA NZ, 0xCC04
541:                     switch (rx_message_state) {
00CBF8  80F080     MOV DUMPSYS_BUSY, W0
00CBFA  500FE1     SUB W0, #0x1, [W15]
00CBFC  32003B     BRA Z, 0xCC74
00CBFE  390031     BRA NC, 0xCC62
00CC00  500FE2     SUB W0, #0x2, [W15]
00CC02  320014     BRA Z, 0xCC2C
542:                       case WAIT_TYPE:
543:                         rx_message_state = WAIT_ARGS;
00CC62  200010     MOV #0x1, W0
00CC64  88F080     MOV W0, DUMPSYS_BUSY
544:                         rx_message_remaining = incoming_arg_size[rx_msg.type];
00CC66  FB809C     ZE [W12], W1
00CC68  2EDB00     MOV #0xEDB0, W0
00CC6A  78C0E0     MOV.B [W0+W1], W1
00CC6C  FB8001     ZE W1, W0
00CC6E  88F090     MOV W0, led_counter
545:                         if (rx_message_remaining) break;
00CC70  E00401     CP0.B W1
00CC72  3AFFC8     BRA NZ, 0xCC04
546:                         // fall-through on purpose
547:               
548:                       case WAIT_ARGS:
549:                         rx_message_state = WAIT_VAR_ARGS;
00CC74  200020     MOV #0x2, W0
00CC76  88F080     MOV W0, DUMPSYS_BUSY
550:                         rx_message_remaining = IncomingVarArgSize(&rx_msg);
00CC28  88F090     MOV W0, led_counter
00CC8A  88F090     MOV W0, led_counter
00CCE2  88F090     MOV W0, led_counter
00CCF6  88F090     MOV W0, led_counter
00CCFE  88F090     MOV W0, led_counter
00D212  88F090     MOV W0, led_counter
551:                         if (rx_message_remaining) break;
00CC2A  3AFFEC     BRA NZ, 0xCC04
00CC8C  E00000     CP0 W0
00CC8E  3AFFBA     BRA NZ, 0xCC04
00CC90  37FFCD     BRA 0xCC2C
00CCE4  3AFF8F     BRA NZ, 0xCC04
00CCE6  37FFA2     BRA 0xCC2C
00CCF8  3AFF85     BRA NZ, 0xCC04
00CCFA  37FF98     BRA 0xCC2C
00CD00  E00000     CP0 W0
00CD02  3AFF80     BRA NZ, 0xCC04
00CD04  37FF93     BRA 0xCC2C
00D214  3AFCF7     BRA NZ, 0xCC04
00D216  37FD0A     BRA 0xCC2C
552:                         // fall-through on purpose
553:               
554:                       case WAIT_VAR_ARGS:
555:                         rx_message_state = WAIT_TYPE;
00CC2C  EF3E10     CLR DUMPSYS_BUSY
556:                         rx_message_remaining = 1;
00CC2E  200010     MOV #0x1, W0
00CC30  88F090     MOV W0, led_counter
557:                         rx_buffer_cursor = 0;
00CC32  EF3E14     CLR state
558:                         if (!MessageDone()) return FALSE;
559:                         break;
560:                     }
561:                   }
562:                 }
563:                 return TRUE;
564:               }
00CC0C  78074F     MOV [--W15], W14
00CC0E  BE064F     MOV.D [--W15], W12
00CC10  BE054F     MOV.D [--W15], W10
00CC12  BE044F     MOV.D [--W15], W8
00CC14  060000     RETURN
00CC42  78074F     MOV [--W15], W14
00CC44  BE064F     MOV.D [--W15], W12
00CC46  BE054F     MOV.D [--W15], W10
00CC48  BE044F     MOV.D [--W15], W8
00CC4A  060000     RETURN
00CC4C  37FFE4     BRA 0xCC16
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/app_layer_v1/pins.c  -----
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include "pins.h"
31:                #include <p24Fxxxx.h>
32:                #include <assert.h>
33:                
34:                #define ARRAY_SIZE(x) (sizeof(x) / sizeof(x[0]))
35:                #define SFR volatile unsigned int
36:                
37:                unsigned int CNENB = 0x0000;
38:                unsigned int CNENC = 0x0000;
39:                unsigned int CNEND = 0x0000;
40:                unsigned int CNENE = 0x0000;
41:                unsigned int CNENF = 0x0000;
42:                unsigned int CNENG = 0x0000;
43:                
44:                unsigned int CNFORCEB = 0x0000;
45:                unsigned int CNFORCEC = 0x0000;
46:                unsigned int CNFORCED = 0x0000;
47:                unsigned int CNFORCEE = 0x0000;
48:                unsigned int CNFORCEF = 0x0000;
49:                unsigned int CNFORCEG = 0x0000;
50:                
51:                unsigned int CNBACKUPB = 0x0000;
52:                unsigned int CNBACKUPC = 0x0000;
53:                unsigned int CNBACKUPD = 0x0000;
54:                unsigned int CNBACKUPE = 0x0000;
55:                unsigned int CNBACKUPF = 0x0000;
56:                unsigned int CNBACKUPG = 0x0000;
57:                
58:                typedef struct {
59:                  SFR* tris;
60:                  SFR* ansel;
61:                  SFR* port;
62:                  SFR* lat;
63:                  SFR* odc;
64:                  unsigned int* fake_cnen;
65:                  unsigned int* cn_backup;
66:                  unsigned int* cn_force;
67:                  unsigned int pos_mask;
68:                  unsigned int neg_mask;
69:                } PORT_INFO;
70:                
71:                #if defined(__PIC24FJ256DA206__) || defined(__PIC24FJ128DA106__) || defined(__PIC24FJ128DA206__)
72:                #define ANSE (*((SFR*) 0))  // hack: there is no ANSE register on 64-pin devices
73:                #endif
74:                
75:                #define MAKE_PORT_INFO(port, num) { &TRIS##port, &ANS##port, &PORT##port, &LAT##port, &ODC##port, &CNEN##port, &CNBACKUP##port, &CNFORCE##port, (1 << num), ~(1 << num) }
76:                
77:                typedef struct {
78:                  SFR* cnen;
79:                  SFR* cnpu;
80:                  SFR* cnpd;
81:                  unsigned int pos_mask;
82:                  unsigned int neg_mask;
83:                } CN_INFO;
84:                
85:                #define MAKE_CN_INFO(num, bit) { &CNEN##num, &CNPU##num, &CNPD##num, (1 << bit), ~(1 << bit) }
86:                #define MAKE_RPOR(num) (((unsigned char*) &RPOR0) + num)
87:                
88:                #if HARDWARE >= HARDWARE_IOIO0000 && HARDWARE <= HARDWARE_IOIO0003
89:                  const PORT_INFO port_info[NUM_PINS] = {
90:                    MAKE_PORT_INFO(F, 3),   // LED
91:                    MAKE_PORT_INFO(C, 12),  // 1
92:                    MAKE_PORT_INFO(C, 15),  // 2
93:                    MAKE_PORT_INFO(D, 8),   // 3
94:                    MAKE_PORT_INFO(D, 9),   // 4
95:                    MAKE_PORT_INFO(D, 10),  // 5
96:                    MAKE_PORT_INFO(D, 11),  // 6
97:                    MAKE_PORT_INFO(D, 0),   // 7
98:                    MAKE_PORT_INFO(C, 13),  // 8
99:                    MAKE_PORT_INFO(C, 14),  // 9
100:                   MAKE_PORT_INFO(D, 1),   // 10
101:                   MAKE_PORT_INFO(D, 2),   // 11
102:                   MAKE_PORT_INFO(D, 3),   // 12
103:                   MAKE_PORT_INFO(D, 4),   // 13
104:                   MAKE_PORT_INFO(D, 5),   // 14
105:                   MAKE_PORT_INFO(D, 6),   // 15
106:                   MAKE_PORT_INFO(D, 7),   // 16
107:                   MAKE_PORT_INFO(F, 0),   // 17
108:                   MAKE_PORT_INFO(F, 1),   // 18
109:                   MAKE_PORT_INFO(E, 0),   // 19
110:                   MAKE_PORT_INFO(E, 1),   // 20
111:                   MAKE_PORT_INFO(E, 2),   // 21
112:                   MAKE_PORT_INFO(E, 3),   // 22
113:                   MAKE_PORT_INFO(E, 4),   // 23
114:                   MAKE_PORT_INFO(E, 5),   // 24
115:                   MAKE_PORT_INFO(E, 6),   // 25
116:                   MAKE_PORT_INFO(E, 7),   // 26
117:                   MAKE_PORT_INFO(G, 6),   // 27
118:                   MAKE_PORT_INFO(G, 7),   // 28
119:                   MAKE_PORT_INFO(G, 8),   // 29
120:                 #if HARDWARE == HARDWARE_IOIO0000
121:                   { 0, 0, 0, 0, 0, 0}, // MCLR (30)
122:                 #endif
123:                   MAKE_PORT_INFO(G, 9),   // 30 (31)
124:                   MAKE_PORT_INFO(B, 5),   // 31 (32)
125:                   MAKE_PORT_INFO(B, 4),   // 32 (33)
126:                   MAKE_PORT_INFO(B, 3),   // 33 (34)
127:                   MAKE_PORT_INFO(B, 2),   // 34 (35)
128:                   MAKE_PORT_INFO(B, 1),   // 35 (36)
129:                   MAKE_PORT_INFO(B, 0),   // 36 (37)
130:                   MAKE_PORT_INFO(B, 6),   // 37 (38)
131:                   MAKE_PORT_INFO(B, 7),   // 38 (39)
132:                   MAKE_PORT_INFO(B, 8),   // 39 (40)
133:                   MAKE_PORT_INFO(B, 9),   // 40 (41)
134:                   MAKE_PORT_INFO(B, 10),  // 41 (42)
135:                   MAKE_PORT_INFO(B, 11),  // 42 (43)
136:                   MAKE_PORT_INFO(B, 12),  // 43 (44)
137:                   MAKE_PORT_INFO(B, 13),  // 44 (45)
138:                   MAKE_PORT_INFO(B, 14),  // 45 (46)
139:                   MAKE_PORT_INFO(B, 15),  // 46 (47)
140:                   MAKE_PORT_INFO(F, 4),   // 47 (48)
141:                   MAKE_PORT_INFO(F, 5),   // 48 (49)
142:                 };
143:               
144:                 const CN_INFO cn_info[NUM_PINS] = {
145:                   MAKE_CN_INFO(5, 7),  // LED
146:                   MAKE_CN_INFO(2, 7),  // 1
147:                   MAKE_CN_INFO(2, 6),  // 2
148:                   MAKE_CN_INFO(4, 5),  // 3
149:                   MAKE_CN_INFO(4, 6),  // 4
150:                   MAKE_CN_INFO(4, 7),  // 5
151:                   MAKE_CN_INFO(4, 8),  // 6
152:                   MAKE_CN_INFO(4, 1),  // 7
153:                   MAKE_CN_INFO(1, 1),  // 8
154:                   MAKE_CN_INFO(1, 0),  // 9
155:                   MAKE_CN_INFO(4, 2),  // 10
156:                   MAKE_CN_INFO(4, 3),  // 11
157:                   MAKE_CN_INFO(4, 4),  // 12
158:                   MAKE_CN_INFO(1, 13),  // 13
159:                   MAKE_CN_INFO(1, 14),  // 14
160:                   MAKE_CN_INFO(1, 15),  // 15
161:                   MAKE_CN_INFO(2, 0),  // 16
162:                   MAKE_CN_INFO(5, 4),  // 17
163:                   MAKE_CN_INFO(5, 5),  // 18
164:                   MAKE_CN_INFO(4, 10),  // 19
165:                   MAKE_CN_INFO(4, 11),  // 20
166:                   MAKE_CN_INFO(4, 12),  // 21
167:                   MAKE_CN_INFO(4, 13),  // 22
168:                   MAKE_CN_INFO(4, 14),  // 23
169:                   MAKE_CN_INFO(4, 15),  // 24
170:                   MAKE_CN_INFO(5, 0),  // 25
171:                   MAKE_CN_INFO(5, 1),  // 26
172:                   MAKE_CN_INFO(1, 8),  // 27
173:                   MAKE_CN_INFO(1, 9),  // 28
174:                   MAKE_CN_INFO(1, 10),  // 29
175:                 #if HARDWARE == HARDWARE_IOIO0000
176:                   { 0, 0, 0, 0, 0}, // MCLR (30)
177:                 #endif
178:                   MAKE_CN_INFO(1, 11),  // 30 (31)
179:                   MAKE_CN_INFO(1, 7),  // 31 (32)
180:                   MAKE_CN_INFO(1, 6),  // 32 (33)
181:                   MAKE_CN_INFO(1, 5),  // 33 (34)
182:                   MAKE_CN_INFO(1, 4),  // 34 (35)
183:                   MAKE_CN_INFO(1, 3),  // 35 (36)
184:                   MAKE_CN_INFO(1, 2),  // 36 (37)
185:                   MAKE_CN_INFO(2, 8),  // 37 (38)
186:                   MAKE_CN_INFO(2, 9),  // 38 (39)
187:                   MAKE_CN_INFO(2, 10),  // 39 (40)
188:                   MAKE_CN_INFO(2, 11),  // 40 (41)
189:                   MAKE_CN_INFO(2, 12),  // 41 (42)
190:                   MAKE_CN_INFO(2, 13),  // 42 (43)
191:                   MAKE_CN_INFO(2, 14),  // 43 (44)
192:                   MAKE_CN_INFO(2, 15),  // 44 (45)
193:                   MAKE_CN_INFO(3, 0),  // 45 (46)
194:                   MAKE_CN_INFO(1, 12),  // 46 (47)
195:                   MAKE_CN_INFO(2, 1),  // 47 (48)
196:                   MAKE_CN_INFO(2, 2),  // 48 (49)
197:                 };
198:               
199:                 const signed char pin_to_rpin[NUM_PINS] = {
200:                   16, -1, -1,  2,  4,  3, 12, 11,
201:                   -1, 37, 24, 23, 22, 25, 20, -1,
202:                   -1, -1, -1, -1, -1, -1, -1, -1,
203:                   -1, -1, -1, 21, 26, 19,
204:                 #if HARDWARE == HARDWARE_IOIO0000
205:                                           -1,
206:                 #endif
207:                                           27, 18,
208:                   28, -1, 13,  1,  0,  6,  7,  8,
209:                    9, -1, -1, -1, -1, 14, 29, 10,
210:                   17  };
211:               
212:                 #if HARDWARE == HARDWARE_IOIO0000
213:                   static const signed char port_to_pin[7][16] = {
214:               //        0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
215:               /* B */ {37, 36, 35, 34, 33, 32, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47},
216:               /* C */ {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  8,  9,  2},
217:               /* D */ { 7, 10, 11, 12, 13, 14, 15, 16,  3,  4,  5,  6, -1, -1, -1, -1},
218:               /* E */ {19, 20, 21, 22, 23, 24, 25, 26, -1, -1, -1, -1, -1, -1, -1, -1},
219:               /* F */ {17, 18, -1,  0, 48, 49, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
220:               /* G */ {-1, -1, -1, -1, -1, -1, 27, 28, 29, 31, -1, -1, -1, -1, -1, -1}
221:                   };
222:                 #elif HARDWARE >= HARDWARE_IOIO0001 && HARDWARE <= HARDWARE_IOIO0003
223:                   static const signed char port_to_pin[7][16] = {
224:               //        0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
225:               /* B */ {36, 35, 34, 33, 32, 31, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46},
226:               /* C */ {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  8,  9,  2},
227:               /* D */ { 7, 10, 11, 12, 13, 14, 15, 16,  3,  4,  5,  6, -1, -1, -1, -1},
228:               /* E */ {19, 20, 21, 22, 23, 24, 25, 26, -1, -1, -1, -1, -1, -1, -1, -1},
229:               /* F */ {17, 18, -1,  0, 47, 48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
230:               /* G */ {-1, -1, -1, -1, -1, -1, 27, 28, 29, 30, -1, -1, -1, -1, -1, -1}
231:                   };
232:                 #endif
233:               
234:                 #if HARDWARE == HARDWARE_IOIO0000
235:                   static const signed char analog_to_pin[16] = {
236:                     37, 36, 35, 34, 33, 32, 38, 39,
237:                     40, 41, 42, 43, 44, 45, 46, 47
238:                   };
239:                 #elif HARDWARE >= HARDWARE_IOIO0001 && HARDWARE <= HARDWARE_IOIO0003
240:                   static const signed char analog_to_pin[16] = {
241:                     36, 35, 34, 33, 32, 31, 37, 38,
242:                     39, 40, 41, 42, 43, 44, 45, 46
243:                   };  
244:                 #endif
245:               
246:                 #if HARDWARE == HARDWARE_IOIO0000
247:                   #define MIN_ANALOG_PIN 32
248:                 #elif HARDWARE >= HARDWARE_IOIO0001 && HARDWARE <= HARDWARE_IOIO0003
249:                   #define MIN_ANALOG_PIN 31
250:                 #endif
251:               
252:                 #if HARDWARE >= HARDWARE_IOIO0000 && HARDWARE <= HARDWARE_IOIO0003
253:                   static const int pin_to_analog[16] = {
254:                      5 , 4 , 3 , 2 , 1 , 0 , 6 , 7 ,
255:                      8 , 9 , 10, 11, 12, 13, 14, 15
256:                   };
257:                 #endif
258:               
259:                 volatile unsigned char* pin_to_rpor[NUM_PINS] = {
260:                   MAKE_RPOR(16), 0            , 0            , MAKE_RPOR(2) ,
261:                   MAKE_RPOR(4) , MAKE_RPOR(3) , MAKE_RPOR(12), MAKE_RPOR(11),
262:                   0            , 0            , MAKE_RPOR(24), MAKE_RPOR(23),
263:                   MAKE_RPOR(22), MAKE_RPOR(25), MAKE_RPOR(20), 0            ,
264:                   0            , 0            , 0            , 0            ,
265:                   0            , 0            , 0            , 0            ,
266:                   0            , 0            , 0            , MAKE_RPOR(21),
267:                   MAKE_RPOR(26), MAKE_RPOR(19),
268:                 #if HARDWARE == HARDWARE_IOIO0000
269:                                                 0, // MCLR (30)
270:                 #endif
271:                                                 MAKE_RPOR(27), MAKE_RPOR(18),
272:                   MAKE_RPOR(28), 0            , MAKE_RPOR(13), MAKE_RPOR(1) ,
273:                   MAKE_RPOR(0) , MAKE_RPOR(6) , MAKE_RPOR(7) , MAKE_RPOR(8) ,
274:                   MAKE_RPOR(9) , 0            , 0            , 0            ,
275:                   0            , MAKE_RPOR(14), MAKE_RPOR(29), MAKE_RPOR(10),
276:                   MAKE_RPOR(17)
277:                 };
278:               #endif
279:               
280:               void PinSetTris(int pin, int val) {
281:                 const PORT_INFO* info = &port_info[pin];
011DEC  B90174     MUL.SU W0, #20, W2
011DEE  2E50A0     MOV #0xE50A, W0
011DF0  400002     ADD W0, W2, W0
282:                 if (val) {
011DF2  E00001     CP0 W1
011DF4  320004     BRA Z, 0x11DFE
283:                   *info->tris |= info->pos_mask;
011DF6  780090     MOV [W0], W1
011DF8  900800     MOV [W0+16], W0
011DFA  700891     IOR W0, [W1], [W1]
011DFC  060000     RETURN
284:                 } else {
285:                   *info->tris &= info->neg_mask;
286:                 }
287:               }
288:               
289:               void PinSetAnsel(int pin, int val) {
290:                 const PORT_INFO* info = &port_info[pin];
011E06  B90174     MUL.SU W0, #20, W2
011E08  2E50A0     MOV #0xE50A, W0
011E0A  400002     ADD W0, W2, W0
291:                 if (val) {
011E0C  E00001     CP0 W1
011E0E  320004     BRA Z, 0x11E18
292:                   *info->ansel |= info->pos_mask;
011E10  900090     MOV [W0+2], W1
011E12  900800     MOV [W0+16], W0
011E14  700891     IOR W0, [W1], [W1]
011E16  060000     RETURN
293:                 } else {
294:                   *info->ansel &= info->neg_mask;
295:                 }
296:               }
297:               
298:               void PinSetLat(int pin, int val) {
299:                 const PORT_INFO* info = &port_info[pin];
011E20  B90174     MUL.SU W0, #20, W2
011E22  2E50A0     MOV #0xE50A, W0
011E24  400002     ADD W0, W2, W0
300:                 if (val) {
011E26  E00001     CP0 W1
011E28  320004     BRA Z, 0x11E32
301:                   *info->lat |= info->pos_mask;
011E2A  9000B0     MOV [W0+6], W1
011E2C  900800     MOV [W0+16], W0
011E2E  700891     IOR W0, [W1], [W1]
011E30  060000     RETURN
302:                 } else {
303:                   *info->lat &= info->neg_mask;
304:                 }
305:               }
306:               
307:               int PinGetPort(int pin) {
308:                 const PORT_INFO* info = &port_info[pin];
011E3A  B90174     MUL.SU W0, #20, W2
011E3C  2E50A0     MOV #0xE50A, W0
011E3E  400002     ADD W0, W2, W0
309:                 return (*info->port & info->pos_mask) != 0;
011E40  9000A0     MOV [W0+4], W1
011E42  900800     MOV [W0+16], W0
011E44  600011     AND W0, [W1], W0
011E46  320001     BRA Z, 0x11E4A
011E48  200010     MOV #0x1, W0
310:               }
311:               
312:               void PinSetOdc(int pin, int val) {
313:                 const PORT_INFO* info = &port_info[pin];
011E4C  B90174     MUL.SU W0, #20, W2
011E4E  2E50A0     MOV #0xE50A, W0
011E50  400002     ADD W0, W2, W0
314:                 if (val) {
011E52  E00001     CP0 W1
011E54  320004     BRA Z, 0x11E5E
315:                   *info->odc |= info->pos_mask;
011E56  9000C0     MOV [W0+8], W1
011E58  900800     MOV [W0+16], W0
011E5A  700891     IOR W0, [W1], [W1]
011E5C  060000     RETURN
316:                 } else {
317:                   *info->odc &= info->neg_mask;
011E66  780280     MOV W0, W5
318:                 }
319:               }
320:               
321:               void PinSetCnen(int pin, int cnen) {
322:                 int cnie_backup = _CNIE;
011E68  BFC096     MOV.B IEC1, WREG
011E6A  DE0043     LSR W0, #3, W0
011E6C  600361     AND W0, #0x1, W6
323:                 const CN_INFO* cinfo = &cn_info[pin];
011E6E  B9296A     MUL.SU W5, #10, W2
011E70  2E3200     MOV #0xE320, W0
011E72  400202     ADD W0, W2, W4
324:                 const PORT_INFO* pinfo = &port_info[pin];
011E74  B92974     MUL.SU W5, #20, W2
011E76  2E50A0     MOV #0xE50A, W0
011E78  400102     ADD W0, W2, W2
325:                 _CNIE = 0;  // disable CN interrupts
011E7A  A96096     BCLR IEC1, #3
326:                 if (cnen) {
011E7C  E00001     CP0 W1
011E7E  32000C     BRA Z, 0x11E98
327:                   *cinfo->cnen |= cinfo->pos_mask;
011E80  780094     MOV [W4], W1
011E82  900034     MOV [W4+6], W0
011E84  700891     IOR W0, [W1], [W1]
328:                   *pinfo->fake_cnen |= pinfo->pos_mask;
011E86  9000D2     MOV [W2+10], W1
011E88  900802     MOV [W2+16], W0
011E8A  700891     IOR W0, [W1], [W1]
329:                 } else {
330:                   *cinfo->cnen &= cinfo->neg_mask;
011E98  780094     MOV [W4], W1
011E9A  900044     MOV [W4+8], W0
011E9C  600891     AND W0, [W1], [W1]
331:                   *pinfo->fake_cnen &= pinfo->neg_mask;
011E9E  9000D2     MOV [W2+10], W1
011EA0  900812     MOV [W2+18], W0
011EA2  600891     AND W0, [W1], [W1]
332:                 }
333:                 _CNIE = cnie_backup;  // enable CN interrupts
011E8C  DD30C3     SL W6, #3, W1
011E8E  BFC096     MOV.B IEC1, WREG
011E90  A13400     BCLR.B W0, #3
011E92  704001     IOR.B W0, W1, W0
011E94  B7E096     MOV.B WREG, IEC1
011EA4  DD30C3     SL W6, #3, W1
011EA6  BFC096     MOV.B IEC1, WREG
011EA8  A13400     BCLR.B W0, #3
011EAA  704001     IOR.B W0, W1, W0
011EAC  B7E096     MOV.B WREG, IEC1
334:               }
011E96  060000     RETURN
335:               
336:               void PinSetCnforce(int pin) {
337:                 int cnie_backup = _CNIE;
011EB2  200961     MOV #0x96, W1
011EB4  784091     MOV.B [W1], W1
011EB6  DE08C3     LSR W1, #3, W1
338:                 const PORT_INFO* pinfo = &port_info[pin];
011EB8  B90174     MUL.SU W0, #20, W2
011EBA  2E50A0     MOV #0xE50A, W0
011EBC  400002     ADD W0, W2, W0
339:                 _CNIE = 0;  // disable CN interrupts
011EBE  A96096     BCLR IEC1, #3
340:                 *pinfo->cn_force |= pinfo->pos_mask;
011EC0  900170     MOV [W0+14], W2
011EC2  900800     MOV [W0+16], W0
011EC4  700912     IOR W0, [W2], [W2]
341:                 _CNIE = cnie_backup;  // enable CN interrupts
011EC6  60C0E1     AND.B W1, #0x1, W1
011EC8  DD08C3     SL W1, #3, W1
011ECA  BFC096     MOV.B IEC1, WREG
011ECC  A13400     BCLR.B W0, #3
011ECE  704001     IOR.B W0, W1, W0
011ED0  B7E096     MOV.B WREG, IEC1
342:               }
343:               
344:               void PinSetCnpu(int pin, int cnpu) {
345:                 const CN_INFO* info = &cn_info[pin];
011ED4  B9016A     MUL.SU W0, #10, W2
011ED6  2E3200     MOV #0xE320, W0
011ED8  400002     ADD W0, W2, W0
346:                 if (cnpu) {
011EDA  E00001     CP0 W1
011EDC  320004     BRA Z, 0x11EE6
347:                   *info->cnpu |= info->pos_mask;
011EDE  900090     MOV [W0+2], W1
011EE0  900030     MOV [W0+6], W0
011EE2  700891     IOR W0, [W1], [W1]
011EE4  060000     RETURN
348:                 } else {
349:                   *info->cnpu &= info->neg_mask;
350:                 }
351:               }
352:               
353:               void PinSetCnpd(int pin, int cnpd) {
354:                 const CN_INFO* info = &cn_info[pin];
011EEE  B9016A     MUL.SU W0, #10, W2
011EF0  2E3200     MOV #0xE320, W0
011EF2  400002     ADD W0, W2, W0
355:                 if (cnpd) {
011EF4  E00001     CP0 W1
011EF6  320004     BRA Z, 0x11F00
356:                   *info->cnpd |= info->pos_mask;
011EF8  9000A0     MOV [W0+4], W1
011EFA  900030     MOV [W0+6], W0
011EFC  700891     IOR W0, [W1], [W1]
011EFE  060000     RETURN
357:                 } else {
358:                   *info->cnpd &= info->neg_mask;
011F08  780101     MOV W1, W2
359:                 }
360:               }
361:               
362:               void PinSetRpor(int pin, int per) {
363:                 if (pin_to_rpor[pin])
011F0A  400000     ADD W0, W0, W0
011F0C  21BEE1     MOV #0x1BEE, W1
011F0E  788060     MOV [W0+W1], W0
011F10  E00000     CP0 W0
011F12  320001     BRA Z, 0x11F16
364:                   *pin_to_rpor[pin] = per;
365:               }
366:               
367:               int PinFromPortB(int bit) { return port_to_pin[0][bit]; };
368:               int PinFromPortC(int bit) { return port_to_pin[1][bit]; };
369:               int PinFromPortD(int bit) { return port_to_pin[2][bit]; };
370:               int PinFromPortE(int bit) { return port_to_pin[3][bit]; };
371:               int PinFromPortF(int bit) { return port_to_pin[4][bit]; };
372:               int PinFromPortG(int bit) { return port_to_pin[5][bit]; };
373:               
374:               int PinFromAnalogChannel(int ch) { return analog_to_pin[ch]; }
375:               
376:               int PinToAnalogChannel(int pin) {
377:                if (pin < MIN_ANALOG_PIN
011F5A  50007F     SUB W0, #0x1F, W0
011F5C  EB8080     SETM W1
011F5E  500FEF     SUB W0, #0xF, [W15]
011F60  3E0003     BRA GTU, 0x11F68
378:                    || pin - MIN_ANALOG_PIN >= ARRAY_SIZE(pin_to_analog))
379:                   return -1;
380:                 return pin_to_analog[pin - MIN_ANALOG_PIN];
011F62  400080     ADD W0, W0, W1
011F64  2E8DE0     MOV #0xE8DE, W0
011F66  7880E0     MOV [W0+W1], W1
381:               }
382:               
383:               int PinToRpin(int pin) {
011F6C  2E2EE1     MOV #0xE2EE, W1
011F6E  784061     MOV.B [W1+W0], W0
011F70  FB0000     SE W0, W0
384:                 return pin_to_rpin[pin];
385:               }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/app_layer_v1/main.c  -----
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include "Compiler.h"
31:                #include "libconn/connection.h"
32:                #include "features.h"
33:                #include "protocol.h"
34:                #include "logging.h"
35:                
36:                #include "libsdcard.X/src/FSIO.h"
37:                #include "libsdcard.X/src/SD-SPI.h"
38:                #include "timer.h"
39:                
40:                
41:                
42:                // define in non-const arrays to ensure data space
43:                static char descManufacturer[] = "IOIO Open Source Project";
44:                static char descModel[] = "IOIO";
45:                static char descDesc[] = "IOIO Standard Application";
46:                static char descVersion[] = FW_IMPL_VER;
47:                static char descUri[] = "https://github.com/ytai/ioio/wiki/ADK";
48:                static char descSerial[] = "N/A";
49:                
50:                const char* accessoryDescs[6] = {
51:                  descManufacturer,
52:                  descModel,
53:                  descDesc,
54:                  descVersion,
55:                  descUri,
56:                  descSerial
57:                };
58:                
59:                typedef enum {
60:                  STATE_INIT,
61:                  STATE_OPEN_CHANNEL,
62:                  STATE_WAIT_CHANNEL_OPEN,
63:                  STATE_CONNECTED,
64:                  STATE_ERROR
65:                } STATE;
66:                
67:                static STATE state = STATE_INIT;
68:                static CHANNEL_HANDLE handle;
69:                
70:                void AppCallback(CHANNEL_HANDLE h, const void* data, UINT32 data_len);
71:                
72:                static inline CHANNEL_HANDLE OpenAvailableChannel() {
73:                  if (ConnectionTypeSupported(CHANNEL_TYPE_ADB)) {
74:                    if (ConnectionCanOpenChannel(CHANNEL_TYPE_ADB)) {
75:                      return ConnectionOpenChannelAdb("tcp:4545", &AppCallback);
76:                    }
77:                  } else if (ConnectionTypeSupported(CHANNEL_TYPE_ACC)) {
78:                    if (ConnectionCanOpenChannel(CHANNEL_TYPE_ACC)) {
79:                      return ConnectionOpenChannelAccessory(&AppCallback);
80:                    }
81:                  } else if (ConnectionTypeSupported(CHANNEL_TYPE_BT)) {
82:                    if (ConnectionCanOpenChannel(CHANNEL_TYPE_BT)) {
83:                      return ConnectionOpenChannelBtServer(&AppCallback);
84:                    }
85:                  }
86:                  return INVALID_CHANNEL_HANDLE;
87:                }
88:                
89:                void AppCallback(CHANNEL_HANDLE h, const void* data, UINT32 data_len) {
90:                  if (data) {
013A7C  E00001     CP0 W1
013A7E  320007     BRA Z, 0x13A8E
91:                    if (!AppProtocolHandleIncoming(data, data_len)) {
013A80  780001     MOV W1, W0
013A82  07C899     RCALL AppProtocolHandleIncoming
013A84  E00000     CP0 W0
013A86  3A0009     BRA NZ, 0x13A9A
92:                      // got corrupt input. need to close the connection and soft reset.
93:                      log_printf("Protocol error");
94:                      state = STATE_ERROR;
013A88  200040     MOV #0x4, W0
013A8A  88F1F0     MOV W0, state
013A8C  060000     RETURN
95:                    }
96:                  } else {
97:                    // connection closed, soft reset and re-establish
98:                    if (state == STATE_CONNECTED) {
013A8E  80F1F0     MOV state, W0
013A90  500FE3     SUB W0, #0x3, [W15]
013A92  3A0001     BRA NZ, 0x13A96
99:                      log_printf("Channel closed");
100:                     SoftReset();
013A94  07DD2B     RCALL SoftReset
101:                   } else {
102:                     log_printf("Channel failed to open");
103:                   }
104:                   state = STATE_OPEN_CHANNEL;
013A9C  FA004A     LNK #0x4A
013A9E  BE9F88     MOV.D W8, [W15++]
013AA0  781F8A     MOV W10, [W15++]
105:                 }
106:               }
107:               
108:               int main() {
109:                 log_init();
110:                 log_printf("***** Hello from app-layer! *******");
111:               
112:                 //ConnectionInit();
113:                 //SoftReset();
114:                 // Enable the matrix here if you want a default frame shown before connecting.
115:               
116:                 //Adding SD Card Code
117:               
118:                 FSFILE *pOldFile, *pNewFile;
119:                   char myData[50];
120:                   char bfr [20];
121:                   int bytesRead, bytesWritten;
122:                   char newFile[] = "newfile.txt";
013AA2  2FFB00     MOV #0xFFB0, W0
013AA4  40000F     ADD W0, W15, W0
013AA6  40046B     ADD W0, #0xB, W8
013AA8  2EE1A1     MOV #0xEE1A, W1
013AAA  09000B     REPEAT #0xB
013AAC  785C31     MOV.B [W1++], [W8++]
013AAE  B100C8     SUB #0xC, W8
123:                   char myFile[] = "myfile.txt";
013AB0  2EE262     MOV #0xEE26, W2
013AB2  09000A     REPEAT #0xA
013AB4  785832     MOV.B [W2++], [W0++]
013AB6  B100B0     SUB #0xB, W0
124:                   char const * writeArg = "w";
125:                   char const * readArg = "r";
126:               
127:                 if( !FSInit() )
013AB8  07AA2E     RCALL FSInit
013ABA  E00000     CP0 W0
013ABC  3A0001     BRA NZ, 0x13AC0
013ABE  37FFFF     BRA 0x13ABE
128:                   // Failed to initialize FAT16 ? do something?
129:                     while (1);
130:                 pNewFile = FSfopen (newFile, writeArg);
013AC0  2EE161     MOV #0xEE16, W1
013AC2  780008     MOV W8, W0
013AC4  07B7AE     RCALL FSfopen
013AC6  780500     MOV W0, W10
131:               // Open an existing file to read
132:               pOldFile = FSfopen (myFile, readArg);
013AC8  2EE181     MOV #0xEE18, W1
013ACA  2FFB00     MOV #0xFFB0, W0
013ACC  40000F     ADD W0, W15, W0
013ACE  07B7A9     RCALL FSfopen
013AD0  780480     MOV W0, W9
133:               
134:               if ( pOldFile == NULL )
013AD2  E00000     CP0 W0
013AD4  320011     BRA Z, 0x13AF8
135:                   // Either file is not present or card is not present
136:                   while (1);
137:               // Read 10 bytes of data from the file.
138:               bytesRead = FSfread((void*)myData, 41, 1, pOldFile);
013AD6  2FFC72     MOV #0xFFC7, W2
013AD8  478402     ADD W15, W2, W8
013ADA  780180     MOV W0, W3
013ADC  200012     MOV #0x1, W2
013ADE  200291     MOV #0x29, W1
013AE0  780008     MOV W8, W0
013AE2  07A39B     RCALL FSfread
139:               
140:               // read bfrSize (5) items (of size 1 byte). returns items count
141:               //bytesRead = FSfread( (void *)bfr, 1, sizeof bfr, pOldFile );
142:               // Write those fifteen bytes to the new file
143:               bytesWritten = FSfwrite ((void *) myData, 41, 1, pNewFile);
013AE4  78018A     MOV W10, W3
013AE6  200012     MOV #0x1, W2
013AE8  200291     MOV #0x29, W1
013AEA  780008     MOV W8, W0
013AEC  07A287     RCALL FSfwrite
144:               //bytesWritten = FSfwrite ((void *) bfr, 1, sizeof bfr, pNewFile);
145:               // After processing, close the file.
146:               //DelayMs(500);
147:               //DelayMs(500);
148:               //DelayMs(500);
149:               //DelayMs(500);
150:               
151:               FSfclose (pNewFile);
013AEE  78000A     MOV W10, W0
013AF0  07A12A     RCALL FSfclose
152:               FSfclose( pOldFile );
153:               
154:               while (1);
155:               
156:               
157:                /* while (1) {
158:                   BOOL connected = ConnectionTasks();
159:                   if (!connected
160:                       && state > STATE_OPEN_CHANNEL) {
161:                     // just got disconnected
162:                     log_printf("Disconnected");
163:                     SoftReset();
164:                     state = STATE_INIT;
165:                   }
166:                   switch (state) {
167:                     case STATE_INIT:
168:                       handle = INVALID_CHANNEL_HANDLE;
169:                       state = STATE_OPEN_CHANNEL;
170:                       break;
171:               
172:                     case STATE_OPEN_CHANNEL:
173:                       if ((handle = OpenAvailableChannel()) != INVALID_CHANNEL_HANDLE) {
174:                         log_printf("Connected");
175:                         state = STATE_WAIT_CHANNEL_OPEN;
176:                       }
177:                       break;
178:               
179:                     case STATE_WAIT_CHANNEL_OPEN:
180:                      if (ConnectionCanSend(handle)) {
181:                         log_printf("Channel open");
182:                         AppProtocolInit(handle);
183:                         state = STATE_CONNECTED;
184:                       }
185:                       break;
186:               
187:                     case STATE_CONNECTED:
188:                       AppProtocolTasks(handle);
189:                       break;
190:               
191:                     case STATE_ERROR:
192:                       ConnectionCloseChannel(handle);
193:                       SoftReset();
194:                       state = STATE_INIT;
195:                       break;
196:                   }
197:                 }*/
198:                 return 0;
199:               }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/app_layer_v1/incap.c  ----
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                // Here's the deal:
31:                // We want to measure the time between two edges and report it. We do not want
32:                // our reports to happen more often than 200 times a second.
33:                // We set timer 5 to fire an interrupt 200 times a second and from within this
34:                // interrupt we start a capture on any modules that should be enabled and are
35:                // not currently capturing.
36:                //
37:                // When measuring pulses (rising-to-falling or falling-to-rising):
38:                // Once the first edge is detected, an incap interrupt will fire. We set this
39:                // interrupt priority to 6, so that we can quickly prepare to the next edge
40:                // before we miss it. Then we can reduce the priority back to 1. When the next
41:                // interrupt comes, we have two time values in the incap FIFO, which we can
42:                // subtract to obtain the desired delta, and we send a report to the client.
43:                // Then, we can turn off the module and re-arm it to be triggered on the next
44:                // timer interrupt.
45:                //
46:                // When measuring period (rising-to-rising):
47:                // This is simpler: we set the module to fire after two captures and we set the
48:                // interrupt priority directly to 1. Then we handle the interrupt the same as
49:                // we handle the trailing edge of the first case.
50:                
51:                #include "incap.h"
52:                
53:                #include <assert.h>
54:                
55:                #include "Compiler.h"
56:                #include "platform.h"
57:                #include "logging.h"
58:                #include "pp_util.h"
59:                #include "sync.h"
60:                #include "protocol_defs.h"
61:                #include "protocol.h"
62:                #include "uart2.h"
63:                
64:                DEFINE_REG_SETTERS_1B(NUM_INCAP_MODULES, _IC, IF)
65:                DEFINE_REG_SETTERS_1B(NUM_INCAP_MODULES, _IC, IE)
66:                DEFINE_REG_SETTERS_1B(NUM_INCAP_MODULES, _IC, IP)
00E830  BE9F80     MOV.D W0, [W15++]
00E832  BE9F82     MOV.D W2, [W15++]
00E834  F80032     PUSH DSRPAG
00E836  202000     MOV #0x200, W0
00E838  880190     MOV W0, DSRPAG
67:                
68:                typedef struct {
69:                  volatile unsigned int con1;
70:                  volatile unsigned int con2;
71:                  volatile unsigned int buf;
72:                  volatile unsigned int tmr;
73:                } INCAP_REG;
74:                
75:                static INCAP_REG* incap_regs = (INCAP_REG *) & IC1CON1;
76:                
77:                typedef enum {
78:                  LEADING = 0,
79:                  TRAILING = 1
80:                } EDGE_STATE;
81:                
82:                // Records for each module whether the next interrupt is a leading edge or a
83:                // traling edge.
84:                static EDGE_STATE edge_states[NUM_INCAP_MODULES];
85:                
86:                // For each module: the value that needs to be written to con1 in order to
87:                // enable the module in the right mode.
88:                static WORD con1_vals[NUM_INCAP_MODULES];
89:                
90:                // For each module, if true, edge type will be flipped on every interrupt.
91:                // This is used for measuring pulses, as opposed to period.
92:                static unsigned flip[NUM_INCAP_MODULES];
93:                
94:                // A bit mask, in which if bit k is set, module number k needs to be turned on
95:                // upon the next timer interrupt.
96:                static unsigned armed = 0;
97:                
98:                static void InCapConfigInternal(int incap_num, int double_prec, int mode,
99:                                                int clock, int external);
100:               
101:               void InCapInit() {
102:                 log_printf("InCapInit()");
103:                 int i;
104:                 _T5IE = 0; // Make sure we don't trigger new captures.
00EBE4  A98097     BCLR 0x97, #4
00EBE6  EB0400     CLR W8
105:                 for (i = 0; i < NUM_INCAP_MODULES; ++i) {
00EBF4  E80408     INC W8, W8
00EBF6  540FE9     SUB W8, #0x9, [W15]
00EBF8  3AFFF7     BRA NZ, 0xEBE8
106:                   InCapConfigInternal(i, 0, 0, 0, 0);
00EBE8  EB0200     CLR W4
00EBEA  780184     MOV W4, W3
00EBEC  780104     MOV W4, W2
00EBEE  780084     MOV W4, W1
00EBF0  780008     MOV W8, W0
00EBF2  07FF5C     RCALL InCapConfigInternal
107:                 }
108:                 // Now we're safe - all modules are off and all interrupts are clear.
109:                 armed = 0;
00EBFA  EF3D70     CLR armed
110:               
111:                 PR5 = 312;  // 5ms period = 200Hz
00EBFC  201380     MOV #0x138, W0
00EBFE  8808E0     MOV W0, PR5
112:                 TMR5 = 0x0000;
00EC00  EF2118     CLR TMR5
113:                 _T5IF = 0;
00EC02  A98087     BCLR 0x87, #4
114:                 _T5IP = 1;
00EC04  BFC0B2     MOV.B IPC7, WREG
00EC06  B3CF81     MOV #0xF8, W1
00EC08  604001     AND.B W0, W1, W0
00EC0A  A00400     BSET.B W0, #0
00EC0C  B7E0B2     MOV.B WREG, IPC7
115:                 _T5IE = 1; // Now our timer will start firing 200 times a second.
00EC0E  A88097     BSET 0x97, #4
116:               }
117:               
118:               static inline void InCapArm(int incap_num, int double_prec) {
119:                 _T5IE = 0;
00E8F6  A98097     BCLR 0x97, #4
00E952  A98097     BCLR 0x97, #4
00EB5E  A98097     BCLR 0x97, #4
120:                 if (double_prec) {
00E8F8  E0000B     CP0 W11
00E8FA  32002E     BRA Z, 0xE958
00E954  E0000B     CP0 W11
00E956  3AFFD2     BRA NZ, 0xE8FC
00EB60  E0000B     CP0 W11
00EB62  320022     BRA Z, 0xEBA8
121:                   armed |= 3 << incap_num;
00E8FC  200030     MOV #0x3, W0
00E8FE  DD000E     SL W0, W14, W0
00E900  B73D70     IOR armed
00EB64  200030     MOV #0x3, W0
00EB66  DD0009     SL W0, W9, W0
00EB68  B73D70     IOR armed
122:                 } else {
123:                   armed |= 1 << incap_num;
00E958  200010     MOV #0x1, W0
00E95A  DD000E     SL W0, W14, W0
00E95C  B73D70     IOR armed
00EBA8  200010     MOV #0x1, W0
00EBAA  DD0009     SL W0, W9, W0
00EBAC  B73D70     IOR armed
124:                 }
125:                 _T5IE = 1;
00E902  A88097     BSET 0x97, #4
00E95E  A88097     BSET 0x97, #4
00E960  37FFD1     BRA 0xE904
00EB6A  A88097     BSET 0x97, #4
00EBAE  A88097     BSET 0x97, #4
00EBB0  37FFDD     BRA 0xEB6C
126:               }
127:               
128:               static inline void InCapDisarm(int incap_num, int double_prec) {
129:                 _T5IE = 0;
00EADA  A98097     BCLR 0x97, #4
130:                 if (double_prec) {
00EADC  E0000B     CP0 W11
00EADE  32005B     BRA Z, 0xEB96
131:                   armed &= ~(3 << incap_num);
00EAE0  200030     MOV #0x3, W0
00EAE2  DD0009     SL W0, W9, W0
00EAE4  EA8000     COM W0, W0
00EAE6  B63D70     AND armed
132:                 } else {
133:                   armed &= ~(1 << incap_num);
00EB96  200010     MOV #0x1, W0
00EB98  DD0009     SL W0, W9, W0
00EB9A  EA8000     COM W0, W0
00EB9C  B63D70     AND armed
00EB9E  37FFA4     BRA 0xEAE8
134:                 }
135:                 _T5IE = 1;
00EAE8  A88097     BSET 0x97, #4
136:               }
137:               
138:               static void InCapConfigInternal(int incap_num, int double_prec, int mode,
139:                                               int clock, int external) {
140:                 INCAP_REG * const reg = incap_regs + incap_num;
00EAC0  DD00C3     SL W0, #3, W1
00EAC2  80EA50     MOV incap_regs, W0
00EAC4  408500     ADD W1, W0, W10
141:                 INCAP_REG * const reg2 = reg + 1;
00EAC6  450768     ADD W10, #0x8, W14
142:                 OUTGOING_MESSAGE msg;
143:                 msg.type = INCAP_STATUS;
00EAC8  B3C1B0     MOV #0x1B, W0
00EACA  9FD7A0     MOV.B W0, [W15-46]
144:                 msg.args.incap_status.incap_num = incap_num;
00EACC  64806F     AND W9, #0xF, W0
00EACE  DD0048     SL W0, #8, W0
00EAD0  2F0FF1     MOV #0xF0FF, W1
00EAD2  97A91F     MOV [W15-46], W2
00EAD4  610101     AND W2, W1, W2
00EAD6  710180     IOR W2, W0, W3
00EAD8  9FAF93     MOV W3, [W15-46]
145:               
146:                 InCapDisarm(incap_num, double_prec);
147:                 Set_ICIE[incap_num](0); // Disable interrupts
00EAEA  448409     ADD W9, W9, W8
00EAEC  21D5E0     MOV #0x1D5E, W0
00EAEE  7800E8     MOV [W8+W0], W1
00EAF0  EB0000     CLR W0
00EAF2  010001     CALL W1
148:               
149:                 // We're safe here - nobody will touch the variables we're modifying.
150:               
151:                 // Turn off the module.
152:                 reg->con1 = 0x0000;
00EAF4  EB0D00     CLR [W10]
153:                 if (double_prec) {
00EAF6  E0000B     CP0 W11
00EAF8  320001     BRA Z, 0xEAFC
154:                   reg2->con1 = 0x0000;
00EAFA  EB0F00     CLR [W14]
155:                 }
156:               
157:                 if (mode) {
00EAFC  E0000C     CP0 W12
00EAFE  32003C     BRA Z, 0xEB78
158:                   // Whether to flip, indexed by (mode - 1)
159:                   static const unsigned FLIPS[] = {1, 1, 0, 0, 0};
160:                   // The ICM and ICI bits values to use, indexed by (mode - 1)
161:                   static const unsigned int ICM_ICI[] = {3, 2, 3 | (1 << 5), 4 | (1 << 5), 5 | (1 << 5)};
162:                   // The ICTSEL (clock select) bits values to use, indexed by clock
163:                   static const unsigned int ICTSEL[] = {7 << 10, 0 << 10, 2 << 10, 3 << 10};
164:               
165:                   if (external) {
00EB00  E0000D     CP0 W13
00EB02  3A0057     BRA NZ, 0xEBB2
166:                     msg.args.incap_status.enabled = 1;
00EBB2  280000     MOV #0x8000, W0
00EBB4  97A89F     MOV [W15-46], W1
00EBB6  708080     IOR W1, W0, W1
00EBB8  9FAF91     MOV W1, [W15-46]
167:                     AppProtocolSendMessage(&msg);
00EBBA  2FFD20     MOV #0xFFD2, W0
00EBBC  40000F     ADD W0, W15, W0
00EBBE  07EF66     RCALL AppProtocolSendMessage
168:                   }
169:                   flip[incap_num] = FLIPS[mode - 1];
00EB04  E9000C     DEC W12, W0
00EB06  400100     ADD W0, W0, W2
00EB08  2EE0C0     MOV #0xEE0C, W0
00EB0A  7900E0     MOV [W0+W2], W1
00EB0C  21D720     MOV #0x1D72, W0
00EB0E  783401     MOV W1, [W8+W0]
00EBC0  E9000C     DEC W12, W0
00EBC2  400100     ADD W0, W0, W2
00EBC4  2EE0C0     MOV #0xEE0C, W0
00EBC6  7900E0     MOV [W0+W2], W1
00EBC8  21D720     MOV #0x1D72, W0
00EBCA  783401     MOV W1, [W8+W0]
170:                   // We move straight to the trailing edge if we don't need to flip.
171:                   edge_states[incap_num] = flip[incap_num] ? LEADING : TRAILING;
00EB10  21D96C     MOV #0x1D96, W12
00EB12  EA0001     NEG W1, W0
00EB14  700001     IOR W0, W1, W0
00EB16  DE004F     LSR W0, #15, W0
00EB18  100061     SUBR W0, #0x1, W0
00EB1A  7E3400     MOV W0, [W8+W12]
00EBCC  21D96C     MOV #0x1D96, W12
00EBCE  EA0001     NEG W1, W0
00EBD0  700001     IOR W0, W1, W0
00EBD2  DE004F     LSR W0, #15, W0
00EBD4  100061     SUBR W0, #0x1, W0
00EBD6  7E3400     MOV W0, [W8+W12]
172:                   if (double_prec) {
00EB1C  E0000B     CP0 W11
00EB1E  3A0040     BRA NZ, 0xEBA0
173:                     // Enable 32-bit mode
174:                     reg2->con2 = (1 << 8);
00EBA0  201000     MOV #0x100, W0
00EBA2  980710     MOV W0, [W14+2]
175:                     reg->con2 = (1 << 8);
00EBA4  980510     MOV W0, [W10+2]
00EBA6  37FFBD     BRA 0xEB22
176:                   } else {
177:                     reg->con2 = 0;
00EB20  98051B     MOV W11, [W10+2]
178:                   }
179:                   // Prepare the values required to turn on the module in the right mode in
180:                   // con1_vals, to be picked up by the timer interrupt.
181:                   con1_vals[incap_num] = ICTSEL[clock] | ICM_ICI[mode - 1];
00EB22  97B98F     MOV [W15-16], W3
00EB24  418083     ADD W3, W3, W1
00EB26  2EDFA0     MOV #0xEDFA, W0
00EB28  7880E0     MOV [W0+W1], W1
00EB2A  2EE020     MOV #0xEE02, W0
00EB2C  790060     MOV [W0+W2], W0
00EB2E  708080     IOR W1, W0, W1
00EB30  21D842     MOV #0x1D84, W2
00EB32  793401     MOV W1, [W8+W2]
182:                   if (double_prec) {
00EB34  E0000B     CP0 W11
00EB36  320002     BRA Z, 0xEB3C
183:                     con1_vals[incap_num + 1] = con1_vals[incap_num];
00EB38  E88008     INC2 W8, W0
00EB3A  793001     MOV W1, [W0+W2]
184:                   }
185:               
186:                   Set_ICIF[incap_num](0); // Clear interrupts
00EB3C  21D4C0     MOV #0x1D4C, W0
00EB3E  7800E8     MOV [W8+W0], W1
00EB40  EB0000     CLR W0
00EB42  010001     CALL W1
187:                   Set_ICIP[incap_num](edge_states[incap_num] == LEADING ? 6 : 1);  // First edge is high-priority.
00EB44  21D380     MOV #0x1D38, W0
00EB46  780168     MOV [W8+W0], W2
00EB48  7E0068     MOV [W8+W12], W0
00EB4A  200061     MOV #0x6, W1
00EB4C  E00000     CP0 W0
00EB4E  320001     BRA Z, 0xEB52
00EB50  200011     MOV #0x1, W1
00EB52  780001     MOV W1, W0
00EB54  010002     CALL W2
188:                   Set_ICIE[incap_num](1); // Enable interrupts
00EB56  21D5E0     MOV #0x1D5E, W0
00EB58  7800E8     MOV [W8+W0], W1
00EB5A  200010     MOV #0x1, W0
00EB5C  010001     CALL W1
189:               
190:                   InCapArm(incap_num, double_prec);
191:                   // The next T5 interrupt will enable the module.
192:                 } else {
193:                   if (external) {
00EB78  E0000D     CP0 W13
00EB7A  32FFF8     BRA Z, 0xEB6C
194:                     msg.args.incap_status.enabled = 0;
00EB7C  97A89F     MOV [W15-46], W1
00EB7E  A1F001     BCLR W1, #15
00EB80  9FAF91     MOV W1, [W15-46]
195:                     AppProtocolSendMessage(&msg);
00EB82  2FFD20     MOV #0xFFD2, W0
00EB84  40000F     ADD W0, W15, W0
00EB86  07EF82     RCALL AppProtocolSendMessage
196:                   }
197:                 }
198:               }
00EB6C  78074F     MOV [--W15], W14
00EB6E  BE064F     MOV.D [--W15], W12
00EB70  BE054F     MOV.D [--W15], W10
00EB72  BE044F     MOV.D [--W15], W8
00EB74  B1022F     SUB #0x22, W15
00EB76  060000     RETURN
00EB88  78074F     MOV [--W15], W14
00EB8A  BE064F     MOV.D [--W15], W12
00EB8C  BE054F     MOV.D [--W15], W10
00EB8E  BE044F     MOV.D [--W15], W8
00EB90  B1022F     SUB #0x22, W15
00EB92  060000     RETURN
00EB94  37FFF1     BRA 0xEB78
199:               
200:               void InCapConfig(int incap_num, int double_prec, int mode, int clock) {
201:                 log_printf("InCapConfig(%d, %d, %d, %d)", incap_num, double_prec, mode,
202:                            clock);
203:                 InCapConfigInternal(incap_num, double_prec, mode, clock, 1);
00EBDE  200014     MOV #0x1, W4
00EBE0  37FF65     BRA InCapConfigInternal
204:               }
00EBE2  781F88     MOV W8, [W15++]
205:               
206:               inline static int NumBytes16(WORD val) {
207:                 return val > 0xFF ? 2 : 1;
00E8C0  200FF0     MOV #0xFF, W0
00E8C2  508F80     SUB W1, W0, [W15]
00E8C4  36003D     BRA LEU, 0xE940
00E8C6  200022     MOV #0x2, W2
00E8C8  784002     MOV.B W2, W0
00E92C  200042     MOV #0x4, W2
00E92E  200FF0     MOV #0xFF, W0
00E930  528F80     SUB W5, W0, [W15]
00E932  3EFFCA     BRA GTU, 0xE8C8
00E934  200032     MOV #0x3, W2
00E936  784002     MOV.B W2, W0
00E938  37FFC8     BRA 0xE8CA
00E93A  200FF0     MOV #0xFF, W0
00E93C  520F80     SUB W4, W0, [W15]
00E93E  3EFFC3     BRA GTU, 0xE8C6
00E940  200012     MOV #0x1, W2
00E942  784002     MOV.B W2, W0
00E944  37FFC2     BRA 0xE8CA
208:               }
209:               
210:               inline static int NumBytes32(DWORD val) {
211:                 if (((DWORD_VAL) val).word.HW) {
00E928  E00005     CP0 W5
00E92A  320007     BRA Z, 0xE93A
212:                   return 2 + NumBytes16(((DWORD_VAL) val).word.HW);
213:                 } else {
214:                   return NumBytes16(((DWORD_VAL) val).word.LW);
215:                 }
216:               }
217:               
218:               inline static void ReportCapture(int incap_num, int double_prec) {
219:                 INCAP_REG * const reg = incap_regs + incap_num;
220:                 INCAP_REG * const reg2 = reg + 1;
221:                 int size;
222:                 DWORD_VAL delta_time;
223:                 OUTGOING_MESSAGE msg;
224:                 msg.type = INCAP_REPORT;
00E8A2  2FFD00     MOV #0xFFD0, W0
00E8A4  478180     ADD W15, W0, W3
00E8A6  B3C1C0     MOV #0x1C, W0
00E8A8  784980     MOV.B W0, [W3]
225:                 msg.args.incap_report.incap_num = incap_num;
00E8AA  67006F     AND W14, #0xF, W0
00E8AC  DD0048     SL W0, #8, W0
00E8AE  2F0FF1     MOV #0xF0FF, W1
00E8B0  608993     AND W1, [W3], [W3]
00E8B2  700993     IOR W0, [W3], [W3]
226:                 if (double_prec) {
00E8B4  E0000B     CP0 W11
00E8B6  3A002C     BRA NZ, 0xE910
227:                   assert(reg->con1 & (1 << 3));  // Buffer not empty.
228:                   assert(reg2->con1 & (1 << 3));  // Buffer not empty.
229:                   DWORD_VAL base = {.word.HW = reg2->buf,
230:                     .word.LW = reg->buf};
00E910  900628     MOV [W8+4], W12
00E912  9006A6     MOV [W6+4], W13
231:                   // 32-bit mode
232:                   assert(reg->con1 & (1 << 3));  // Buffer not empty.
233:                   assert(reg2->con1 & (1 << 3));  // Buffer not empty.
234:                   delta_time.word.HW = reg2->buf;
00E914  9000A6     MOV [W6+4], W1
00E916  9FA7F1     MOV W1, [W15-50]
235:                   delta_time.word.LW = reg->buf;
00E918  900028     MOV [W8+4], W0
00E91A  9FA7E0     MOV W0, [W15-52]
236:                   delta_time.Val -= base.Val;
00E91C  97A06F     MOV [W15-52], W0
00E91E  97A0FF     MOV [W15-50], W1
00E920  50020C     SUB W0, W12, W4
00E922  58828D     SUBB W1, W13, W5
00E924  9FA7E4     MOV W4, [W15-52]
00E926  9FA7F5     MOV W5, [W15-50]
237:                   log_printf("%lu", delta_time.Val);
238:                   size = NumBytes32(delta_time.Val);
239:                 } else {
240:                   // 16-bit mode
241:                   assert(reg->con1 & (1 << 3));  // Buffer not empty.
242:                   const WORD base = reg->buf;
00E8B8  900028     MOV [W8+4], W0
243:                   assert(reg->con1 & (1 << 3));  // Buffer not empty.
244:                   delta_time.word.LW = reg->buf - base;
00E8BA  9000A8     MOV [W8+4], W1
00E8BC  508080     SUB W1, W0, W1
00E8BE  9FA7E1     MOV W1, [W15-52]
245:                   log_printf("%u", delta_time.word.LW);  // TEMP!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
246:                   size = NumBytes16(delta_time.word.LW);
247:                 }
248:                 msg.args.incap_report.size = size;
00E8CA  DD00CE     SL W0, #14, W1
00E8CC  23FFF0     MOV #0x3FFF, W0
00E8CE  600993     AND W0, [W3], [W3]
00E8D0  708993     IOR W1, [W3], [W3]
249:                 AppProtocolSendMessageWithVarArg(&msg, &delta_time, size);
00E8D2  2FFCC1     MOV #0xFFCC, W1
00E8D4  40808F     ADD W1, W15, W1
00E8D6  780003     MOV W3, W0
00E8D8  9FBF86     MOV W6, [W15-16]
00E8DA  07F0F7     RCALL AppProtocolSendMessageWithVarArg
250:               }
251:               
252:               static void ICInterrupt(int incap_num) {
253:                 Set_ICIF[incap_num](0); // Clear fast - don't want to miss any edge!
00E876  400500     ADD W0, W0, W10
00E878  21D4C0     MOV #0x1D4C, W0
00E87A  7800EA     MOV [W10+W0], W1
00E87C  EB0000     CLR W0
00E87E  010001     CALL W1
254:               
255:                 INCAP_REG * const reg = incap_regs + incap_num;
00E880  DD70C3     SL W14, #3, W1
00E882  80EA50     MOV incap_regs, W0
00E884  408400     ADD W1, W0, W8
256:                 INCAP_REG * const reg2 = reg + 1;
00E886  440368     ADD W8, #0x8, W6
257:                 const int double_prec = reg->con2 & (1 << 8);
00E888  900598     MOV [W8+2], W11
00E88A  B2100B     AND #0x100, W11
258:               
259:                 // Toggle bit 0 of con1 to invert edge polarity if we need to.
260:                 const unsigned f = flip[incap_num];
00E88C  21D720     MOV #0x1D72, W0
00E88E  78006A     MOV [W10+W0], W0
00E890  9FB7F0     MOV W0, [W15-18]
261:                 reg->con1 ^= f;
00E892  680C18     XOR W0, [W8], [W8]
262:                 if (double_prec) {
00E894  E0000B     CP0 W11
00E896  320001     BRA Z, 0xE89A
263:                   reg2->con1 ^= f;
00E898  680B16     XOR W0, [W6], [W6]
264:                 }
265:               
266:                 if (edge_states[incap_num] == LEADING) {
00E89A  21D961     MOV #0x1D96, W1
00E89C  78806A     MOV [W10+W1], W0
00E89E  E00000     CP0 W0
00E8A0  320060     BRA Z, 0xE962
267:                   // We're on the first edge of a pulse. Should never get here on rising-to-
268:                   // rising or falling-to-falling measurements.
269:                   edge_states[incap_num] = TRAILING;
00E962  200010     MOV #0x1, W0
00E964  78B500     MOV W0, [W10+W1]
270:                   Set_ICIP[incap_num](1);
00E966  21D381     MOV #0x1D38, W1
00E968  7880EA     MOV [W10+W1], W1
00E96A  010001     CALL W1
271:                 } else {
272:                   // We're on the second edge.
273:                   ReportCapture(incap_num, double_prec);
274:                   // Disable the module. T5 will enable it.
275:                   reg->con1 = 0x0000;
00E8DC  EB0480     CLR W9
00E8DE  780C09     MOV W9, [W8]
276:                   if (double_prec) {
00E8E0  97BB0F     MOV [W15-16], W6
00E8E2  E0000B     CP0 W11
00E8E4  320001     BRA Z, 0xE8E8
277:                     reg2->con1 = 0x0000;
00E8E6  780B09     MOV W9, [W6]
278:                   }
279:                   // Clear again - we might have gotten another interrupt by now. Module is
280:                   // off now, won't get another one.
281:                   Set_ICIF[incap_num](0);
00E8E8  21D4C0     MOV #0x1D4C, W0
00E8EA  7800EA     MOV [W10+W0], W1
00E8EC  780009     MOV W9, W0
00E8EE  010001     CALL W1
282:               
283:                   // For non-flipping modes, we're always on the trailing edge, and we get
284:                   // an interrupt every two captures.
285:                   if (f) {
00E8F0  97B0FF     MOV [W15-18], W1
00E8F2  E00001     CP0 W1
00E8F4  3A0028     BRA NZ, 0xE946
286:                     edge_states[incap_num] = LEADING;
00E946  21D960     MOV #0x1D96, W0
00E948  783509     MOV W9, [W10+W0]
287:                     Set_ICIP[incap_num](6);
00E94A  21D380     MOV #0x1D38, W0
00E94C  7800EA     MOV [W10+W0], W1
00E94E  200060     MOV #0x6, W0
00E950  010001     CALL W1
288:                   }
289:               
290:                   InCapArm(incap_num, double_prec); // Ready to go again.
291:                 }
292:               }
00E904  78074F     MOV [--W15], W14
00E906  BE064F     MOV.D [--W15], W12
00E908  BE054F     MOV.D [--W15], W10
00E90A  BE044F     MOV.D [--W15], W8
00E90C  B1028F     SUB #0x28, W15
00E90E  060000     RETURN
00E97A  F80036     PUSH RCOUNT
00E97C  BE9F80     MOV.D W0, [W15++]
00E97E  BE9F82     MOV.D W2, [W15++]
00E980  BE9F84     MOV.D W4, [W15++]
00E982  BE9F86     MOV.D W6, [W15++]
00E984  F80032     PUSH DSRPAG
00E986  202000     MOV #0x200, W0
00E988  880190     MOV W0, DSRPAG
293:               
294:               void __attribute__((__interrupt__, auto_psv)) _T5Interrupt() {
295:                 // Trigger all the armed modules by copying the value from con1_vals to their
296:                 // con1 register.
297:                 // It is important that we do this in reverse order, since in cascade (32-bit)
298:                 // mode, the higher module needs to be started first.
299:                 // At the end of the process - everything is un-armed.
300:               #define MASK (1 << (NUM_INCAP_MODULES - 1))
301:                 int i = NUM_INCAP_MODULES;
302:                 while (armed) {
00E83A  80EB81     MOV armed, W1
00E83C  E00001     CP0 W1
00E83E  320010     BRA Z, 0xE860
00E840  80EA50     MOV incap_regs, W0
00E842  B00400     ADD #0x40, W0
00E844  780101     MOV W1, W2
00E846  21D943     MOV #0x1D94, W3
00E85A  E00001     CP0 W1
00E85C  3AFFF5     BRA NZ, 0xE848
00E85E  88EB81     MOV W1, armed
303:                   --i;
304:                   if (armed & MASK) {
00E848  A38802     BTST.Z W2, #8
00E84A  320003     BRA Z, 0xE852
305:                     incap_regs[i].con1 = con1_vals[i];
00E84C  780813     MOV [W3], [W0]
306:                     armed &= ~MASK;
00E84E  780082     MOV W2, W1
00E850  A18001     BCLR W1, #8
307:                   }
308:                   armed <<= 1;
00E852  408081     ADD W1, W1, W1
00E854  780101     MOV W1, W2
00E856  E98183     DEC2 W3, W3
00E858  500068     SUB W0, #0x8, W0
309:                 }
310:                 _T5IF = 0; // clear
00E860  A98087     BCLR 0x87, #4
311:               #undef MASK
312:               }
00E86A  B0028F     ADD #0x28, W15
00E86C  BE9F88     MOV.D W8, [W15++]
00E86E  BE9F8A     MOV.D W10, [W15++]
00E870  BE9F8C     MOV.D W12, [W15++]
00E872  781F8E     MOV W14, [W15++]
00E874  780700     MOV W0, W14
313:               
314:               #define DEFINE_INTERRUPT(num, unused) \
315:               void __attribute__((__interrupt__, auto_psv)) _IC##num##Interrupt() { \
316:                 ICInterrupt(num - 1); \
317:               }
318:               
319:               REPEAT_1B(DEFINE_INTERRUPT, NUM_INCAP_MODULES)
00E99C  F80036     PUSH RCOUNT
00E99E  BE9F80     MOV.D W0, [W15++]
00E9A0  BE9F82     MOV.D W2, [W15++]
00E9A2  BE9F84     MOV.D W4, [W15++]
00E9A4  BE9F86     MOV.D W6, [W15++]
00E9A6  F80032     PUSH DSRPAG
00E9A8  202000     MOV #0x200, W0
00E9AA  880190     MOV W0, DSRPAG
00E9BE  F80036     PUSH RCOUNT
00E9C0  BE9F80     MOV.D W0, [W15++]
00E9C2  BE9F82     MOV.D W2, [W15++]
00E9C4  BE9F84     MOV.D W4, [W15++]
00E9C6  BE9F86     MOV.D W6, [W15++]
00E9C8  F80032     PUSH DSRPAG
00E9CA  202000     MOV #0x200, W0
00E9CC  880190     MOV W0, DSRPAG
00E9E0  F80036     PUSH RCOUNT
00E9E2  BE9F80     MOV.D W0, [W15++]
00E9E4  BE9F82     MOV.D W2, [W15++]
00E9E6  BE9F84     MOV.D W4, [W15++]
00E9E8  BE9F86     MOV.D W6, [W15++]
00E9EA  F80032     PUSH DSRPAG
00E9EC  202000     MOV #0x200, W0
00E9EE  880190     MOV W0, DSRPAG
00EA02  F80036     PUSH RCOUNT
00EA04  BE9F80     MOV.D W0, [W15++]
00EA06  BE9F82     MOV.D W2, [W15++]
00EA08  BE9F84     MOV.D W4, [W15++]
00EA0A  BE9F86     MOV.D W6, [W15++]
00EA0C  F80032     PUSH DSRPAG
00EA0E  202000     MOV #0x200, W0
00EA10  880190     MOV W0, DSRPAG
00EA24  F80036     PUSH RCOUNT
00EA26  BE9F80     MOV.D W0, [W15++]
00EA28  BE9F82     MOV.D W2, [W15++]
00EA2A  BE9F84     MOV.D W4, [W15++]
00EA2C  BE9F86     MOV.D W6, [W15++]
00EA2E  F80032     PUSH DSRPAG
00EA30  202000     MOV #0x200, W0
00EA32  880190     MOV W0, DSRPAG
00EA46  F80036     PUSH RCOUNT
00EA48  BE9F80     MOV.D W0, [W15++]
00EA4A  BE9F82     MOV.D W2, [W15++]
00EA4C  BE9F84     MOV.D W4, [W15++]
00EA4E  BE9F86     MOV.D W6, [W15++]
00EA50  F80032     PUSH DSRPAG
00EA52  202000     MOV #0x200, W0
00EA54  880190     MOV W0, DSRPAG
00EA68  F80036     PUSH RCOUNT
00EA6A  BE9F80     MOV.D W0, [W15++]
00EA6C  BE9F82     MOV.D W2, [W15++]
00EA6E  BE9F84     MOV.D W4, [W15++]
00EA70  BE9F86     MOV.D W6, [W15++]
00EA72  F80032     PUSH DSRPAG
00EA74  202000     MOV #0x200, W0
00EA76  880190     MOV W0, DSRPAG
00EA8A  F80036     PUSH RCOUNT
00EA8C  BE9F80     MOV.D W0, [W15++]
00EA8E  BE9F82     MOV.D W2, [W15++]
00EA90  BE9F84     MOV.D W4, [W15++]
00EA92  BE9F86     MOV.D W6, [W15++]
00EA94  F80032     PUSH DSRPAG
00EA96  202000     MOV #0x200, W0
00EA98  880190     MOV W0, DSRPAG
00EAAC  B0022F     ADD #0x22, W15
00EAAE  BE9F88     MOV.D W8, [W15++]
00EAB0  BE9F8A     MOV.D W10, [W15++]
00EAB2  BE9F8C     MOV.D W12, [W15++]
00EAB4  781F8E     MOV W14, [W15++]
00EAB6  780480     MOV W0, W9
00EAB8  780581     MOV W1, W11
00EABA  780602     MOV W2, W12
00EABC  9FBF83     MOV W3, [W15-16]
00EABE  780684     MOV W4, W13
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/app_layer_v1/icsp.c  -----
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include "icsp.h"
31:                
32:                #include "byte_queue.h"
33:                #include "pins.h"
34:                #include "logging.h"
35:                #include "features.h"
36:                #include "HardwareProfile.h"
37:                #include "timer.h"
38:                #include "protocol.h"
39:                
40:                #define PGC_PIN 37
41:                #define PGD_PIN 38
42:                #define MCLR_PIN 36
43:                
44:                #define RX_BUF_SIZE 64
45:                //#define TX_BUF_SIZE 64
46:                
47:                #define PGD_OUT() PinSetTris(PGD_PIN, 0)
48:                #define PGD_IN() PinSetTris(PGD_PIN, 1)
49:                
50:                // TODO: do not use delay
51:                
52:                static int num_rx_since_last_report;
01039A  EF3D34     CLR 0x1D34
53:                static BYTE_QUEUE rx_queue;
01039C  EF3D30     CLR 0x1D30
54:                //static BYTE_QUEUE tx_queue;
01039E  EF3D32     CLR 0x1D32
55:                static BYTE rx_buffer[RX_BUF_SIZE];
56:                //static BYTE tx_buffer[TX_BUF_SIZE];
57:                
58:                static void ClockBitsOut(BYTE b, int nbits) {
010392  21CEC0     MOV #0x1CEC, W0
010394  88E960     MOV W0, rx_queue
59:                  while (nbits-- > 0) {
010396  200400     MOV #0x40, W0
010398  88E970     MOV W0, 0x1D2E
010444  E90489     DEC W9, W9
010446  448FE1     ADD W9, #0x1, [W15]
010448  3AFFF2     BRA NZ, 0x1042E
0104FE  E90489     DEC W9, W9
010500  448FE1     ADD W9, #0x1, [W15]
010502  3AFFF2     BRA NZ, 0x104E8
010504  B3CC20     MOV #0xC2, W0
010506  200079     MOV #0x7, W9
01051E  E90489     DEC W9, W9
010520  448FE1     ADD W9, #0x1, [W15]
010522  3AFFF2     BRA NZ, 0x10508
010524  B3C120     MOV #0x12, W0
010526  200079     MOV #0x7, W9
01053E  E90489     DEC W9, W9
010540  448FE1     ADD W9, #0x1, [W15]
010542  3AFFF2     BRA NZ, 0x10528
010544  B3C8A0     MOV #0x8A, W0
010546  200089     MOV #0x8, W9
010560  3AFFF3     BRA NZ, 0x10548
010596  3AFFF5     BRA NZ, 0x10582
0105BC  E90408     DEC W8, W8
0105BE  440FE1     ADD W8, #0x1, [W15]
0105C0  3AFFF4     BRA NZ, 0x105AA
0105DE  3AFFF3     BRA NZ, 0x105C6
010604  3AFFF3     BRA NZ, 0x105EC
010626  E90489     DEC W9, W9
010628  448FE1     ADD W9, #0x1, [W15]
01062A  3AFFF2     BRA NZ, 0x10610
60:                    PinSetLat(PGD_PIN, b & 1);
01042E  FB8400     ZE W0, W8
010430  6400E1     AND W8, #0x1, W1
010432  200260     MOV #0x26, W0
010434  070CF5     RCALL PinSetLat
0104E8  FB8400     ZE W0, W8
0104EA  6400E1     AND W8, #0x1, W1
0104EC  200260     MOV #0x26, W0
0104EE  070C98     RCALL PinSetLat
010508  FB8400     ZE W0, W8
01050A  6400E1     AND W8, #0x1, W1
01050C  200260     MOV #0x26, W0
01050E  070C88     RCALL PinSetLat
010528  FB8400     ZE W0, W8
01052A  6400E1     AND W8, #0x1, W1
01052C  200260     MOV #0x26, W0
01052E  070C78     RCALL PinSetLat
010548  FB8400     ZE W0, W8
01054A  6400E1     AND W8, #0x1, W1
01054C  200260     MOV #0x26, W0
01054E  070C68     RCALL PinSetLat
010582  EB0080     CLR W1
010584  200260     MOV #0x26, W0
010586  070C4C     RCALL PinSetLat
0105AA  EB0080     CLR W1
0105AC  200260     MOV #0x26, W0
0105AE  070C38     RCALL PinSetLat
0105C6  FB8400     ZE W0, W8
0105C8  6400E1     AND W8, #0x1, W1
0105CA  200260     MOV #0x26, W0
0105CC  070C29     RCALL PinSetLat
0105EC  FB8400     ZE W0, W8
0105EE  6400E1     AND W8, #0x1, W1
0105F0  200260     MOV #0x26, W0
0105F2  070C16     RCALL PinSetLat
010610  FB8400     ZE W0, W8
010612  6400E1     AND W8, #0x1, W1
010614  200260     MOV #0x26, W0
010616  070C04     RCALL PinSetLat
61:                    PinSetLat(PGC_PIN, 1);
010436  200011     MOV #0x1, W1
010438  200250     MOV #0x25, W0
01043A  070CF2     RCALL PinSetLat
0104F0  200011     MOV #0x1, W1
0104F2  200250     MOV #0x25, W0
0104F4  070C95     RCALL PinSetLat
010510  200011     MOV #0x1, W1
010512  200250     MOV #0x25, W0
010514  070C85     RCALL PinSetLat
010530  200011     MOV #0x1, W1
010532  200250     MOV #0x25, W0
010534  070C75     RCALL PinSetLat
010550  200011     MOV #0x1, W1
010552  200250     MOV #0x25, W0
010554  070C65     RCALL PinSetLat
010588  200011     MOV #0x1, W1
01058A  200250     MOV #0x25, W0
01058C  070C49     RCALL PinSetLat
0105B0  200011     MOV #0x1, W1
0105B2  200250     MOV #0x25, W0
0105B4  070C35     RCALL PinSetLat
0105CE  200011     MOV #0x1, W1
0105D0  200250     MOV #0x25, W0
0105D2  070C26     RCALL PinSetLat
0105F4  200011     MOV #0x1, W1
0105F6  200250     MOV #0x25, W0
0105F8  070C13     RCALL PinSetLat
010618  200011     MOV #0x1, W1
01061A  200250     MOV #0x25, W0
01061C  070C01     RCALL PinSetLat
62:                    PinSetLat(PGC_PIN, 0);
01043C  EB0080     CLR W1
01043E  200250     MOV #0x25, W0
010440  070CEF     RCALL PinSetLat
0104F6  EB0080     CLR W1
0104F8  200250     MOV #0x25, W0
0104FA  070C92     RCALL PinSetLat
010516  EB0080     CLR W1
010518  200250     MOV #0x25, W0
01051A  070C82     RCALL PinSetLat
010536  EB0080     CLR W1
010538  200250     MOV #0x25, W0
01053A  070C72     RCALL PinSetLat
010556  EB0080     CLR W1
010558  200250     MOV #0x25, W0
01055A  070C62     RCALL PinSetLat
01058E  EB0080     CLR W1
010590  200250     MOV #0x25, W0
010592  070C46     RCALL PinSetLat
010594  E90408     DEC W8, W8
0105B6  EB0080     CLR W1
0105B8  200250     MOV #0x25, W0
0105BA  070C32     RCALL PinSetLat
0105D4  EB0080     CLR W1
0105D6  200250     MOV #0x25, W0
0105D8  070C23     RCALL PinSetLat
0105FA  EB0080     CLR W1
0105FC  200250     MOV #0x25, W0
0105FE  070C10     RCALL PinSetLat
01061E  EB0080     CLR W1
010620  200250     MOV #0x25, W0
010622  070BFE     RCALL PinSetLat
63:                    b >>= 1;
010442  D10008     LSR W8, W0
0104FC  D10008     LSR W8, W0
01051C  D10008     LSR W8, W0
01053C  D10008     LSR W8, W0
01055C  D10008     LSR W8, W0
01055E  E90489     DEC W9, W9
0105DA  D10008     LSR W8, W0
0105DC  E90489     DEC W9, W9
010600  D10008     LSR W8, W0
010602  E90489     DEC W9, W9
010624  D10008     LSR W8, W0
64:                  }
65:                }
66:                
67:                static BYTE ClockBitsIn(int nbits) {
68:                  int i;
69:                  BYTE b = 0;
70:                  for (i = 0; i < nbits; ++i) {
010462  E80408     INC W8, W8
010464  540FE8     SUB W8, #0x8, [W15]
010466  3AFFF5     BRA NZ, 0x10452
010468  EB4480     CLR.B W9
01046A  EB0400     CLR W8
010480  E80408     INC W8, W8
010482  540FE8     SUB W8, #0x8, [W15]
010484  3AFFF3     BRA NZ, 0x1046C
0104A4  E80408     INC W8, W8
0104A6  540FE8     SUB W8, #0x8, [W15]
0104A8  3AFFF3     BRA NZ, 0x10490
71:                    PinSetLat(PGC_PIN, 1);
010452  200011     MOV #0x1, W1
010454  200250     MOV #0x25, W0
010456  070CE4     RCALL PinSetLat
01046C  200011     MOV #0x1, W1
01046E  200250     MOV #0x25, W0
010470  070CD7     RCALL PinSetLat
010490  200011     MOV #0x1, W1
010492  200250     MOV #0x25, W0
010494  070CC5     RCALL PinSetLat
72:                    b |= (PinGetPort(PGD_PIN) << i);
010458  200260     MOV #0x26, W0
01045A  070CEF     RCALL PinGetPort
010472  200260     MOV #0x26, W0
010474  070CE2     RCALL PinGetPort
010476  DD0008     SL W0, W8, W0
010478  74C480     IOR.B W9, W0, W9
010496  200260     MOV #0x26, W0
010498  070CD0     RCALL PinGetPort
01049A  DD0008     SL W0, W8, W0
01049C  74C480     IOR.B W9, W0, W9
73:                    PinSetLat(PGC_PIN, 0);
01045C  EB0080     CLR W1
01045E  200250     MOV #0x25, W0
010460  070CDF     RCALL PinSetLat
01047A  EB0080     CLR W1
01047C  200250     MOV #0x25, W0
01047E  070CD0     RCALL PinSetLat
01049E  EB0080     CLR W1
0104A0  200250     MOV #0x25, W0
0104A2  070CBE     RCALL PinSetLat
74:                  }
75:                  return b;
76:                }
77:                
78:                static inline void ClockByteOut(BYTE b) {
79:                  ClockBitsOut(b, 8);
80:                }
81:                
82:                static inline BYTE ClockByteIn() {
83:                  return ClockBitsIn(8);
84:                }
85:                
86:                void ICSPEnter() {
87:                  log_printf("ICSPEnter()");
88:                  // pulse reset
89:                  PinSetLat(MCLR_PIN, 1);
0104B6  200011     MOV #0x1, W1
0104B8  200240     MOV #0x24, W0
0104BA  070CB2     RCALL PinSetLat
0104BC  205140     MOV #0x514, W0
0104BE  200001     MOV #0x0, W1
90:                  Delay10us(50);
0104C0  500061     SUB W0, #0x1, W0
0104C2  5880E0     SUBB W1, #0x0, W1
0104C4  400FE1     ADD W0, #0x1, [W15]
0104C6  488FE0     ADDC W1, #0x0, [W15]
0104C8  3AFFFB     BRA NZ, 0x104C0
91:                  PinSetLat(MCLR_PIN, 0);
0104CA  EB0080     CLR W1
0104CC  200240     MOV #0x24, W0
0104CE  070CA8     RCALL PinSetLat
0104D0  20A6A0     MOV #0xA6A, W0
0104D2  200001     MOV #0x0, W1
92:                  DelayMs(1);
0104D4  500061     SUB W0, #0x1, W0
0104D6  5880E0     SUBB W1, #0x0, W1
0104D8  400FE1     ADD W0, #0x1, [W15]
0104DA  488FE0     ADDC W1, #0x0, [W15]
0104DC  3AFFFB     BRA NZ, 0x104D4
93:                  PGD_OUT();
0104DE  EB0080     CLR W1
0104E0  200260     MOV #0x26, W0
0104E2  070C84     RCALL PinSetTris
0104E4  B3CB20     MOV #0xB2, W0
0104E6  200079     MOV #0x7, W9
94:                  // enter code
95:                  ClockByteOut(0xB2);
96:                  ClockByteOut(0xC2);
97:                  ClockByteOut(0x12);
98:                  ClockByteOut(0x8A);
99:                  // mclr high
100:                 PinSetLat(MCLR_PIN, 1);
010562  200011     MOV #0x1, W1
010564  200240     MOV #0x24, W0
010566  070C5C     RCALL PinSetLat
010568  200322     MOV #0x32, W2
01056A  200003     MOV #0x0, W3
01056C  20A6A0     MOV #0xA6A, W0
01056E  200001     MOV #0x0, W1
101:                 DelayMs(50);
010570  500061     SUB W0, #0x1, W0
010572  5880E0     SUBB W1, #0x0, W1
010574  400FE1     ADD W0, #0x1, [W15]
010576  488FE0     ADDC W1, #0x0, [W15]
010578  3AFFFB     BRA NZ, 0x10570
01057A  510161     SUB W2, #0x1, W2
01057C  5981E0     SUBB W3, #0x0, W3
01057E  3AFFF6     BRA NZ, 0x1056C
010580  200058     MOV #0x5, W8
102:                 // extra 5 bits for first SIX
103:                 ClockBitsOut(0, 5);
104:               }
01059C  BE9F88     MOV.D W8, [W15++]
01059E  BE9F8A     MOV.D W10, [W15++]
0105A0  BE0500     MOV.D W0, W10
105:               
106:               void ICSPExit() {
107:                 log_printf("ICSPExit()");
108:                 PinSetLat(MCLR_PIN, 0);
010350  EB0080     CLR W1
010352  200240     MOV #0x24, W0
010354  070D65     RCALL PinSetLat
010356  205140     MOV #0x514, W0
010358  200001     MOV #0x0, W1
109:                 Delay10us(50);
01035A  500061     SUB W0, #0x1, W0
01035C  5880E0     SUBB W1, #0x0, W1
01035E  400FE1     ADD W0, #0x1, [W15]
010360  488FE0     ADDC W1, #0x0, [W15]
010362  3AFFFB     BRA NZ, 0x1035A
110:               }
010366  781F88     MOV W8, [W15++]
010368  780400     MOV W0, W8
111:               
112:               void ICSPSix(DWORD inst) {
113:                 log_printf("ICSPSix(0x%06lx)", inst);
114:                 PGD_OUT();
0105A2  EB0080     CLR W1
0105A4  200260     MOV #0x26, W0
0105A6  070C22     RCALL PinSetTris
0105A8  200038     MOV #0x3, W8
115:                 ClockBitsOut(0, 4);
116:                 ClockByteOut(inst);
0105C2  78400A     MOV.B W10, W0
0105C4  200089     MOV #0x8, W9
117:                 inst >>= 8;
0105E0  DD5848     SL W11, #8, W0
0105E2  DE5548     LSR W10, #8, W10
0105E4  70050A     IOR W0, W10, W10
0105E6  DE5DC8     LSR W11, #8, W11
118:                 ClockByteOut(inst);
0105E8  78400A     MOV.B W10, W0
0105EA  200089     MOV #0x8, W9
119:                 inst >>= 8;
120:                 ClockByteOut(inst);
010606  DD5948     SL W11, #8, W2
010608  DE5048     LSR W10, #8, W0
01060A  710000     IOR W2, W0, W0
01060C  DE58C8     LSR W11, #8, W1
01060E  200079     MOV #0x7, W9
121:               }
122:               
123:               void ICSPRegout() {
124:                 log_printf("ICSPRegout()");
125:                 PGD_OUT();
010424  EB0080     CLR W1
010426  200260     MOV #0x26, W0
010428  070CE1     RCALL PinSetTris
01042A  B3C010     MOV #0x1, W0
01042C  200039     MOV #0x3, W9
126:                 ClockBitsOut(1, 4);
127:                 PGD_IN();
01044A  200011     MOV #0x1, W1
01044C  200260     MOV #0x26, W0
01044E  070CCE     RCALL PinSetTris
010450  EB0400     CLR W8
128:                 ClockByteIn();  // skip 8 bits
129:                 ByteQueuePushByte(&rx_queue, ClockByteIn());
010486  FB8089     ZE W9, W1
010488  21D2C0     MOV #0x1D2C, W0
01048A  070B5F     RCALL ByteQueuePushByte
01048C  EB4480     CLR.B W9
01048E  EB0400     CLR W8
130:                 ByteQueuePushByte(&rx_queue, ClockByteIn());
0104AA  FB8089     ZE W9, W1
0104AC  21D2C0     MOV #0x1D2C, W0
0104AE  070B4D     RCALL ByteQueuePushByte
131:               }
0104B4  BE9F88     MOV.D W8, [W15++]
132:               
133:               void ICSPConfigure(int enable) {
134:                 log_printf("ICSPConfigure(%d)", enable);
135:                 if (enable) {
01036A  E00000     CP0 W0
01036C  32001C     BRA Z, 0x103A6
136:                   SetPinDigitalOut(PGC_PIN, 0, 0);
01036E  EB0100     CLR W2
010370  EB0080     CLR W1
010372  200250     MOV #0x25, W0
010374  07F721     RCALL SetPinDigitalOut
137:                   SetPinDigitalOut(PGD_PIN, 0, 0);
010376  EB0100     CLR W2
010378  EB0080     CLR W1
01037A  200260     MOV #0x26, W0
01037C  07F71D     RCALL SetPinDigitalOut
138:                   SetPinDigitalOut(MCLR_PIN, 0, 0);
01037E  EB0100     CLR W2
010380  EB0080     CLR W1
010382  200240     MOV #0x24, W0
010384  07F719     RCALL SetPinDigitalOut
139:                   // pull PGD up for reads.
140:                   PinSetCnpu(PGD_PIN, 1);
010386  200011     MOV #0x1, W1
010388  200260     MOV #0x26, W0
01038A  070DA4     RCALL PinSetCnpu
141:                   PinSetCnpd(PGD_PIN, 0);
01038C  EB0080     CLR W1
01038E  200260     MOV #0x26, W0
010390  070DAE     RCALL PinSetCnpd
142:               
143:                   ByteQueueInit(&rx_queue, rx_buffer, RX_BUF_SIZE);
144:                   num_rx_since_last_report = RX_BUF_SIZE;
0103A0  88E9B0     MOV W0, num_rx_since_last_report
145:                 } else {
146:                   SetPinDigitalIn(PGC_PIN, 0);
0103A6  780080     MOV W0, W1
0103A8  200250     MOV #0x25, W0
0103AA  07F6D3     RCALL SetPinDigitalIn
147:                   SetPinDigitalIn(PGD_PIN, 0);
0103AC  780088     MOV W8, W1
0103AE  200260     MOV #0x26, W0
0103B0  07F6D0     RCALL SetPinDigitalIn
148:                   SetPinDigitalIn(MCLR_PIN, 0);
0103B2  780088     MOV W8, W1
0103B4  200240     MOV #0x24, W0
0103B6  07F6CD     RCALL SetPinDigitalIn
149:                 }
150:               }
0103A2  78044F     MOV [--W15], W8
0103A4  060000     RETURN
0103BE  FA003A     LNK #0x3A
0103C0  BE9F88     MOV.D W8, [W15++]
151:               
152:               static void ICSPReportRxStatus() {
153:                 int report;
154:                 report = num_rx_since_last_report;
155:                 num_rx_since_last_report = 0;
0103D4  EF3D36     CLR num_rx_since_last_report
156:                 OUTGOING_MESSAGE msg;
157:                 msg.type = ICSP_REPORT_RX_STATUS;
0103D6  2FFDF1     MOV #0xFFDF, W1
0103D8  478001     ADD W15, W1, W0
0103DA  B3C161     MOV #0x16, W1
0103DC  784801     MOV.B W1, [W0]
158:                 msg.args.icsp_report_rx_status.bytes_to_add = report;
0103DE  9FE782     MOV.B W2, [W15-32]
0103E0  DE10C8     LSR W2, #8, W1
0103E2  9FE791     MOV.B W1, [W15-31]
159:                 AppProtocolSendMessage(&msg);
0103E4  07E353     RCALL AppProtocolSendMessage
160:               }
161:               
162:               void ICSPTasks() {
163:                 while (ByteQueueSize(&rx_queue)) {
0103C2  E21D34     CP0 0x1D34
0103C4  3A0014     BRA NZ, 0x103EE
010406  E21D34     CP0 0x1D34
010408  32FFDE     BRA Z, 0x103C6
010422  BE9F88     MOV.D W8, [W15++]
164:                   OUTGOING_MESSAGE msg;
165:                   msg.type = ICSP_RESULT;
0103F4  9FC7A8     MOV.B W8, [W15-62]
01040A  9FC7A8     MOV.B W8, [W15-62]
166:                   ByteQueuePullToBuffer(&rx_queue, &msg.args.icsp_result.reg, 2);
0103F6  200022     MOV #0x2, W2
0103F8  780089     MOV W9, W1
0103FA  21D2C0     MOV #0x1D2C, W0
0103FC  070BF6     RCALL ByteQueuePullToBuffer
01040C  200022     MOV #0x2, W2
01040E  780089     MOV W9, W1
010410  21D2C0     MOV #0x1D2C, W0
010412  070BEB     RCALL ByteQueuePullToBuffer
167:                   num_rx_since_last_report += 2;
0103FE  ECBD36     INC2 num_rx_since_last_report
010414  ECBD36     INC2 num_rx_since_last_report
168:                   log_printf("ICSP read word: 0x%04x", msg.args.icsp_result.reg);
169:                   AppProtocolSendMessage(&msg);
010400  2FFC20     MOV #0xFFC2, W0
010402  40000F     ADD W0, W15, W0
010404  07E343     RCALL AppProtocolSendMessage
010416  2FFC20     MOV #0xFFC2, W0
010418  40000F     ADD W0, W15, W0
01041A  07E338     RCALL AppProtocolSendMessage
170:                 }
171:                 if (num_rx_since_last_report > RX_BUF_SIZE / 2) {
0103C6  80E9B2     MOV num_rx_since_last_report, W2
0103C8  200200     MOV #0x20, W0
0103CA  510F80     SUB W2, W0, [W15]
0103CC  3C0003     BRA GT, 0x103D4
172:                   ICSPReportRxStatus();
173:                 }
174:               }
0103CE  BE044F     MOV.D [--W15], W8
0103D0  FA8000     ULNK
0103D2  060000     RETURN
0103E6  BE044F     MOV.D [--W15], W8
0103E8  FA8000     ULNK
0103EA  060000     RETURN
0103EC  37FFF3     BRA 0x103D4
0103EE  2FFC30     MOV #0xFFC3, W0
0103F0  478480     ADD W15, W0, W9
0103F2  B3C178     MOV #0x17, W8
175:               
176:               
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/app_layer_v1/i2c.c  ------
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include "i2c.h"
31:                
32:                #include <assert.h>
33:                #include "Compiler.h"
34:                #include "platform.h"
35:                #include "sync.h"
36:                #include "byte_queue.h"
37:                #include "logging.h"
38:                #include "pp_util.h"
39:                #include "protocol.h"
40:                
41:                #define PACKED __attribute__ ((packed))
42:                
43:                #define RX_BUF_SIZE 128
44:                #define TX_BUF_SIZE 256
45:                
46:                typedef enum {
00EEE0  200428     MOV #0x42, W8
00EEE2  784418     MOV.B [W8], W8
00EEE4  FB8408     ZE W8, W8
00EEE6  DE4445     LSR W8, #5, W8
00EEFA  BFC042     MOV.B SR, WREG
00EF30  200428     MOV #0x42, W8
00EF32  784418     MOV.B [W8], W8
00EF34  FB8408     ZE W8, W8
00EF36  DE4445     LSR W8, #5, W8
00EF46  BFC042     MOV.B SR, WREG
00EF86  200421     MOV #0x42, W1
00EF88  784091     MOV.B [W1], W1
00EF96  BFC042     MOV.B SR, WREG
00EFE6  200428     MOV #0x42, W8
00EFE8  784418     MOV.B [W8], W8
00EFEA  FB8408     ZE W8, W8
00EFEC  DE4445     LSR W8, #5, W8
00F018  BFC042     MOV.B SR, WREG
47:                  STATE_START,
00EEE8  BFC042     MOV.B SR, WREG
00EEEA  60407F     AND.B W0, #0x1F, W0
00EEEC  A07400     BSET.B W0, #7
00EEEE  B7E042     MOV.B WREG, SR
00EEFC  DD4445     SL W8, #5, W8
00EEFE  BFC042     MOV.B SR, WREG
00EF00  60407F     AND.B W0, #0x1F, W0
00EF02  704008     IOR.B W0, W8, W0
00EF04  B7E042     MOV.B WREG, SR
00EF38  BFC042     MOV.B SR, WREG
00EF3A  60407F     AND.B W0, #0x1F, W0
00EF3C  A07400     BSET.B W0, #7
00EF3E  B7E042     MOV.B WREG, SR
00EF48  DD4445     SL W8, #5, W8
00EF4A  BFC042     MOV.B SR, WREG
00EF4C  60407F     AND.B W0, #0x1F, W0
00EF4E  704008     IOR.B W0, W8, W0
00EF50  B7E042     MOV.B WREG, SR
00EF8A  BFC042     MOV.B SR, WREG
00EF8C  60407F     AND.B W0, #0x1F, W0
00EF8E  A07400     BSET.B W0, #7
00EF90  B7E042     MOV.B WREG, SR
00EF98  B3CE00     MOV #0xE0, W0
00EF9A  60C080     AND.B W1, W0, W1
00EF9C  BFC042     MOV.B SR, WREG
00EF9E  60407F     AND.B W0, #0x1F, W0
00EFA0  704001     IOR.B W0, W1, W0
00EFA2  B7E042     MOV.B WREG, SR
00EFEE  BFC042     MOV.B SR, WREG
00EFF0  60407F     AND.B W0, #0x1F, W0
00EFF2  A07400     BSET.B W0, #7
00EFF4  B7E042     MOV.B WREG, SR
00F01A  DD4445     SL W8, #5, W8
00F01C  BFC042     MOV.B SR, WREG
00F01E  60407F     AND.B W0, #0x1F, W0
00F020  704008     IOR.B W0, W8, W0
00F022  B7E042     MOV.B WREG, SR
48:                  STATE_ADDR1_WRITE,
49:                  STATE_ADDR2_WRITE,
50:                  STATE_WRITE_DATA,
51:                  STATE_STOP_WRITE_ONLY,
52:                  STATE_RESTART,
00F06C  980048     MOV W8, [W0+8]
00F07C  980048     MOV W8, [W0+8]
53:                  STATE_ADDR_READ,
00F06E  980028     MOV W8, [W0+4]
00F07E  980028     MOV W8, [W0+4]
54:                  STATE_ACK_ADDR_READ,
00F070  980038     MOV W8, [W0+6]
00F080  980038     MOV W8, [W0+6]
55:                  STATE_READ_DATA,
56:                  STATE_ACK_READ_DATA
57:                } MESSAGE_STATE;
58:                
00F064  200A01     MOV #0xA0, W1
00F066  448801     ADD W9, W1, [W0]
00F074  200201     MOV #0x20, W1
00F076  448801     ADD W9, W1, [W0]
59:                typedef struct PACKED {
00F068  201002     MOV #0x100, W2
00F06A  980012     MOV W2, [W0+2]
00F078  200801     MOV #0x80, W1
00F07A  980011     MOV W1, [W0+2]
60:                  union {
61:                    struct {
62:                      BYTE addr1;
63:                      BYTE addr2;
64:                    };
65:                    WORD addr;
66:                  };
67:                  BYTE write_size;
68:                  BYTE read_size;
69:                } TX_MESSAGE_HEADER;
70:                
71:                typedef struct {
72:                  MESSAGE_STATE message_state;
73:                  TX_MESSAGE_HEADER cur_tx_header;
74:                  int num_tx_since_last_report;
75:                  int bytes_remaining;
76:                
77:                  BYTE_QUEUE rx_queue;
78:                  int num_messages_rx_queue;
79:                  BYTE_QUEUE tx_queue;
80:                
81:                  BYTE rx_buffer[RX_BUF_SIZE];
82:                  BYTE tx_buffer[TX_BUF_SIZE];
83:                } I2C_STATE;
84:                
85:                I2C_STATE i2c_states[NUM_I2C_MODULES];
86:                
87:                typedef struct {
88:                  unsigned int rcv;
89:                  unsigned int trn;
90:                  unsigned int brg;
91:                  unsigned int con;
92:                  unsigned int stat;
93:                  unsigned int add;
94:                  unsigned int mask;
95:                } I2CREG;
96:                
97:                #define _I2CREG_REF_COMMA(num, dummy) (volatile I2CREG*) &I2C##num##RCV,
98:                
99:                volatile I2CREG* i2c_reg[NUM_I2C_MODULES] = {
100:                 REPEAT_1B(_I2CREG_REF_COMMA, NUM_I2C_MODULES, 0)
101:               };
102:               
103:               DEFINE_REG_SETTERS_1B(NUM_I2C_MODULES, _MI2C, IF)
104:               DEFINE_REG_SETTERS_1B(NUM_I2C_MODULES, _MI2C, IE)
105:               DEFINE_REG_SETTERS_1B(NUM_I2C_MODULES, _MI2C, IP)
00ECBA  BE9F88     MOV.D W8, [W15++]
00ECBC  BE9F8A     MOV.D W10, [W15++]
106:               
107:               static void I2CConfigMasterInternal(int i2c_num, int rate, int smbus_levels, int external);
108:               
109:               void I2CInit() {
00F134  EB0400     CLR W8
00F136  21DF29     MOV #0x1DF2, W9
110:                 log_printf("I2CInit()");
111:                 int i;
112:                 for (i = 0; i < NUM_I2C_MODULES; ++i) {
00F148  E80408     INC W8, W8
00F14A  540FE3     SUB W8, #0x3, [W15]
00F14C  3AFFF5     BRA NZ, 0xF138
113:                   Set_MI2CIP[i](4);  // interrupt priority 4
00F138  7800B9     MOV [W9++], W1
00F13A  200040     MOV #0x4, W0
00F13C  010001     CALL W1
114:                   I2CConfigMasterInternal(i, 0, 0, 0);
00F13E  EB0180     CLR W3
00F140  780103     MOV W3, W2
00F142  780083     MOV W3, W1
00F144  780008     MOV W8, W0
00F146  07FF73     RCALL I2CConfigMasterInternal
115:                 }
116:               }
117:               
118:               static inline void I2CSendStatus(int i2c_num, int enabled) {
119:                 OUTGOING_MESSAGE msg;
120:                 msg.type = I2C_STATUS;
00F0C4  2FFD31     MOV #0xFFD3, W1
00F0C6  478001     ADD W15, W1, W0
00F0C8  B3C131     MOV #0x13, W1
00F0CA  784801     MOV.B W1, [W0]
00F0EA  B3C130     MOV #0x13, W0
00F0EC  9F77E0     MOV.B W0, [W15-74]
121:                 msg.args.i2c_status.i2c_num = i2c_num;
00F0CC  6541E3     AND.B W10, #0x3, W3
00F0CE  97D0CF     MOV.B [W15-44], W1
00F0D0  B3CFC2     MOV #0xFC, W2
00F0D2  60C082     AND.B W1, W2, W1
00F0D4  70C083     IOR.B W1, W3, W1
00F0EE  650063     AND W10, #0x3, W0
00F0F0  DD0048     SL W0, #8, W0
00F0F2  2FCFF1     MOV #0xFCFF, W1
00F0F4  97993F     MOV [W15-74], W2
00F0F6  610101     AND W2, W1, W2
00F0F8  710080     IOR W2, W0, W1
122:                 msg.args.i2c_status.enabled = enabled;
00F0D6  A17401     BCLR.B W1, #7
00F0D8  9FD7C1     MOV.B W1, [W15-44]
00F0FA  280000     MOV #0x8000, W0
00F0FC  708100     IOR W1, W0, W2
00F0FE  9F9FB2     MOV W2, [W15-74]
123:                 AppProtocolSendMessage(&msg);
00F0DA  07ECD8     RCALL AppProtocolSendMessage
00F100  2FFB60     MOV #0xFFB6, W0
00F102  40000F     ADD W0, W15, W0
00F104  07ECC3     RCALL AppProtocolSendMessage
124:               }
125:               
126:               static void I2CConfigMasterInternal(int i2c_num, int rate, int smbus_levels, int external) {
127:                 volatile I2CREG* regs = i2c_reg[i2c_num];
00F040  400580     ADD W0, W0, W11
00F042  21DE00     MOV #0x1DE0, W0
00F044  7806EB     MOV [W11+W0], W13
128:                 I2C_STATE* i2c = i2c_states + i2c_num;
00F046  201A00     MOV #0x1A0, W0
00F048  B9D000     MUL.SS W10, W0, W0
00F04A  2170E2     MOV #0x170E, W2
00F04C  410480     ADD W2, W0, W9
129:                 static const unsigned int brg_values[] = { 0x9D, 0x25, 0x0D };
130:               
131:                 if (external) {
132:                   log_printf("I2CConfigMaster(%d, %d, %d)", i2c_num, rate, smbus_levels);
133:                 }
134:                 Set_MI2CIE[i2c_num](0);  // disable interrupt
00F04E  21DE60     MOV #0x1DE6, W0
00F050  7800EB     MOV [W11+W0], W1
00F052  EB0000     CLR W0
00F054  010001     CALL W1
135:                 regs->con = 0x0000;  // disable module
00F056  EB0400     CLR W8
00F058  9806B8     MOV W8, [W13+6]
136:                 Set_MI2CIF[i2c_num](0);  // clear interrupt
00F05A  21DEC0     MOV #0x1DEC, W0
00F05C  7800EB     MOV [W11+W0], W1
00F05E  780008     MOV W8, W0
00F060  010001     CALL W1
137:                 ByteQueueInit(&i2c->tx_queue, i2c->tx_buffer, TX_BUF_SIZE);
00F062  448076     ADD W9, #0x16, W0
138:                 ByteQueueInit(&i2c->rx_queue, i2c->rx_buffer, RX_BUF_SIZE);
00F072  44806A     ADD W9, #0xA, W0
139:                 i2c->num_tx_since_last_report = 0;
00F082  9804B8     MOV W8, [W9+6]
140:                 i2c->num_messages_rx_queue = 0;
00F084  980CA8     MOV W8, [W9+20]
141:                 i2c->message_state = STATE_START;
00F086  780C88     MOV W8, [W9]
142:                 if (rate) {
00F088  E0000C     CP0 W12
00F08A  32001A     BRA Z, 0xF0C0
143:                   if (external) {
00F08C  E0000E     CP0 W14
00F08E  3A002D     BRA NZ, 0xF0EA
144:                     I2CSendStatus(i2c_num, 1);
145:                   }
146:                   i2c->num_tx_since_last_report = TX_BUF_SIZE;
00F090  201000     MOV #0x100, W0
00F092  9804B0     MOV W0, [W9+6]
00F106  201000     MOV #0x100, W0
00F108  9804B0     MOV W0, [W9+6]
147:                   regs->brg = brg_values[rate - 1];
00F094  46000C     ADD W12, W12, W0
00F096  E98000     DEC2 W0, W0
00F098  2EE7C1     MOV #0xEE7C, W1
00F09A  7800E1     MOV [W1+W0], W1
00F09C  9806A1     MOV W1, [W13+4]
00F10A  46000C     ADD W12, W12, W0
00F10C  E98000     DEC2 W0, W0
00F10E  2EE7C1     MOV #0xEE7C, W1
00F110  7800E1     MOV [W1+W0], W1
00F112  9806A1     MOV W1, [W13+4]
148:                   regs->con = (1 << 15)               // enable
00F09E  282001     MOV #0x8200, W1
00F0A0  560FE2     SUB W12, #0x2, [W15]
00F0A2  32003B     BRA Z, 0xF11A
00F0A4  97B90F     MOV [W15-16], W2
00F0A6  DD1048     SL W2, #8, W0
00F0A8  708000     IOR W1, W0, W0
00F0AA  9806B0     MOV W0, [W13+6]
00F114  282001     MOV #0x8200, W1
00F116  560FE2     SUB W12, #0x2, [W15]
00F118  3AFFC5     BRA NZ, 0xF0A4
00F11A  280001     MOV #0x8000, W1
00F11C  97B90F     MOV [W15-16], W2
00F11E  DD1048     SL W2, #8, W0
00F120  708000     IOR W1, W0, W0
00F122  9806B0     MOV W0, [W13+6]
149:                               | ((rate != 2) << 9)    // disable slew rate unless 400KHz mode
150:                               | (smbus_levels << 8);  // use SMBus levels
151:                   Set_MI2CIF[i2c_num](1);  // signal interrupt
00F0AC  21DEC0     MOV #0x1DEC, W0
00F0AE  7800EB     MOV [W11+W0], W1
00F0B0  200010     MOV #0x1, W0
00F0B2  010001     CALL W1
152:                 } else {
153:                   if (external) {
00F0C0  E0000E     CP0 W14
00F0C2  32FFF8     BRA Z, 0xF0B4
154:                     I2CSendStatus(i2c_num, 0);
155:                   }
156:                 }
157:               }
00F0B4  78074F     MOV [--W15], W14
00F0B6  BE064F     MOV.D [--W15], W12
00F0B8  BE054F     MOV.D [--W15], W10
00F0BA  BE044F     MOV.D [--W15], W8
00F0BC  B103EF     SUB #0x3E, W15
00F0BE  060000     RETURN
00F0DC  78074F     MOV [--W15], W14
00F0DE  BE064F     MOV.D [--W15], W12
00F0E0  BE054F     MOV.D [--W15], W10
00F0E2  BE044F     MOV.D [--W15], W8
00F0E4  B103EF     SUB #0x3E, W15
00F0E6  060000     RETURN
00F0E8  37FFEB     BRA 0xF0C0
158:               
159:               void I2CConfigMaster(int i2c_num, int rate, int smbus_levels) {
160:                 I2CConfigMasterInternal(i2c_num, rate, smbus_levels, 1);
00F12E  200013     MOV #0x1, W3
00F130  37FF7E     BRA I2CConfigMasterInternal
161:               }
00F132  BE9F88     MOV.D W8, [W15++]
162:               
163:               static void I2CReportTxStatus(int i2c_num) {
164:                 int report;
165:                 I2C_STATE* i2c = &i2c_states[i2c_num];
166:                 BYTE prev = SyncInterruptLevel(4);
167:                 report = i2c->num_tx_since_last_report;
00EF92  780113     MOV [W3], W2
168:                 i2c->num_tx_since_last_report = 0;
00EF94  EB0980     CLR [W3]
169:                 SyncInterruptLevel(prev);
170:                 OUTGOING_MESSAGE msg;
171:                 msg.type = I2C_REPORT_TX_STATUS;
00EFA4  B3C150     MOV #0x15, W0
00EFA6  9FD790     MOV.B W0, [W15-47]
172:                 msg.args.i2c_report_tx_status.i2c_num = i2c_num;
173:                 msg.args.i2c_report_tx_status.bytes_to_add = report;
00EFA8  DD10C2     SL W2, #2, W1
00EFAA  97E9EF     MOV.B [W15-18], W3
00EFAC  61C063     AND.B W3, #0x3, W0
00EFAE  704001     IOR.B W0, W1, W0
00EFB0  9FD7A0     MOV.B W0, [W15-46]
00EFB2  DE1146     LSR W2, #6, W2
00EFB4  9FD7B2     MOV.B W2, [W15-45]
174:                 AppProtocolSendMessage(&msg);
00EF60  B01A00     ADD #0x1A0, W0
00EF62  9FBF80     MOV W0, [W15-16]
00EF64  97E8EF     MOV.B [W15-18], W1
00EF66  E84081     INC.B W1, W1
00EF68  60C0E3     AND.B W1, #0x3, W1
00EF6A  9FEFE1     MOV.B W1, [W15-18]
00EF6C  B01A0D     ADD #0x1A0, W13
00EFB6  2FFD10     MOV #0xFFD1, W0
00EFB8  40000F     ADD W0, W15, W0
00EFBA  07ED68     RCALL AppProtocolSendMessage
00EFBC  97B80F     MOV [W15-16], W0
00EFBE  B01A00     ADD #0x1A0, W0
00EFC0  9FBF80     MOV W0, [W15-16]
00EFC2  97E8EF     MOV.B [W15-18], W1
00EFC4  E84081     INC.B W1, W1
00EFC6  60C0E3     AND.B W1, #0x3, W1
00EFC8  9FEFE1     MOV.B W1, [W15-18]
00EFCA  B01A0D     ADD #0x1A0, W13
175:               }
176:               
177:               void I2CTasks() {
00EEBE  217140     MOV #0x1714, W0
00EEC0  9FBF80     MOV W0, [W15-16]
00EEC2  EB4080     CLR.B W1
00EEC4  9FEFE1     MOV.B W1, [W15-18]
00EEC6  21722D     MOV #0x1722, W13
00EEC8  2FFB43     MOV #0xFFB4, W3
00EECA  478583     ADD W15, W3, W11
178:                 int i;
179:                 for (i = 0; i < NUM_I2C_MODULES; ++i) {
00EF6E  50CFE3     SUB.B W1, #0x3, [W15]
00EF70  3AFFAD     BRA NZ, 0xEECC
00EFD2  FA0004     LNK #0x4
00EFD4  BE9F88     MOV.D W8, [W15++]
00EFD6  BE9F8A     MOV.D W10, [W15++]
00EFD8  781F8C     MOV W12, [W15++]
00EFDA  780600     MOV W0, W12
00EFDC  780502     MOV W2, W10
00EFDE  780483     MOV W3, W9
180:                   int size1, size2, size;
181:                   const BYTE *data1, *data2;
182:                   I2C_STATE* i2c = &i2c_states[i];
183:                   BYTE_QUEUE* q = &i2c->rx_queue;
00EECC  400664     ADD W0, #0x4, W12
00EECE  608063     AND W1, #0x3, W0
00EED0  DD0748     SL W0, #8, W14
184:                   BYTE prev;
185:                   while (i2c->num_messages_rx_queue) {
00EED2  E0001D     CP0 [W13]
00EED4  320040     BRA Z, 0xEF56
00EF52  E0001D     CP0 [W13]
00EF54  3AFFC0     BRA NZ, 0xEED6
186:                     OUTGOING_MESSAGE msg;
187:                     msg.type = I2C_RESULT;
00EED6  B3C140     MOV #0x14, W0
00EED8  784D80     MOV.B W0, [W11]
188:                     msg.args.i2c_result.i2c_num = i;
00EEDA  2FCFF0     MOV #0xFCFF, W0
00EEDC  600D9B     AND W0, [W11], [W11]
00EEDE  770D9B     IOR W14, [W11], [W11]
189:                     prev = SyncInterruptLevel(4);
190:                     msg.args.i2c_result.size = ByteQueuePullByte(q);
00EEF0  78000C     MOV W12, W0
00EEF2  0715E6     RCALL ByteQueuePullByte
00EEF4  784080     MOV.B W0, W1
00EEF6  9F77E0     MOV.B W0, [W15-74]
191:                     --i2c->num_messages_rx_queue;
00EEF8  E90E9D     DEC [W13], [W13]
192:                     SyncInterruptLevel(prev);
193:                     log_printf("I2C %d received %d bytes", i, msg.args.i2c_result.size);
194:                     if (msg.args.i2c_result.size != 0xFF && msg.args.i2c_result.size > 0) {
00EF06  E94001     DEC.B W1, W0
00EF08  404FE3     ADD.B W0, #0x3, [W15]
00EF0A  3E0039     BRA GTU, 0xEF7E
195:                       ByteQueuePeekMax(q, msg.args.i2c_result.size, &data1, &size1, &data2,
00EF0C  FB8081     ZE W1, W1
00EF0E  2FFAC3     MOV #0xFFAC, W3
00EF10  41818F     ADD W3, W15, W3
00EF12  E88283     INC2 W3, W5
00EF14  418266     ADD W3, #0x6, W4
00EF16  2FFAC3     MOV #0xFFAC, W3
00EF18  41818F     ADD W3, W15, W3
00EF1A  418164     ADD W3, #0x4, W2
00EF1C  78000C     MOV W12, W0
00EF1E  0715E6     RCALL ByteQueuePeekMax
196:                                        &size2);
197:                       size = size1 + size2;
00EF20  97956F     MOV [W15-84], W10
00EF22  9794FF     MOV [W15-82], W9
198:                       assert(size == msg.args.i2c_result.size);
199:                       AppProtocolSendMessageWithVarArgSplit(&msg, data1, size1, data2, size2);
00EF24  97988F     MOV [W15-80], W1
00EF26  780209     MOV W9, W4
00EF28  97999F     MOV [W15-78], W3
00EF2A  78010A     MOV W10, W2
00EF2C  78000B     MOV W11, W0
00EF2E  07ED38     RCALL AppProtocolSendMessageWithVarArgSplit
200:                       prev = SyncInterruptLevel(4);
201:                       ByteQueuePull(q, size);
00EF40  450089     ADD W10, W9, W1
00EF42  78000C     MOV W12, W0
00EF44  0715E6     RCALL ByteQueuePull
202:                       SyncInterruptLevel(prev);
203:                     } else {
204:                       AppProtocolSendMessage(&msg);
00EF7E  78000B     MOV W11, W0
00EF80  07ED85     RCALL AppProtocolSendMessage
00EF82  37FFA7     BRA 0xEED2
00EF84  780181     MOV W1, W3
205:                     }
206:                   }
207:                   if (i2c->num_tx_since_last_report > TX_BUF_SIZE / 2) {
00EF56  200800     MOV #0x80, W0
00EF58  97B88F     MOV [W15-16], W1
00EF5A  100F91     SUBR W0, [W1], [W15]
00EF5C  3C0013     BRA GT, 0xEF84
00EF5E  780001     MOV W1, W0
208:                     I2CReportTxStatus(i);
209:                   }
210:                 }
211:               }
00EF72  78074F     MOV [--W15], W14
00EF74  BE064F     MOV.D [--W15], W12
00EF76  BE054F     MOV.D [--W15], W10
00EF78  BE044F     MOV.D [--W15], W8
00EF7A  B1048F     SUB #0x48, W15
00EF7C  060000     RETURN
212:               
213:               void I2CWriteRead(int i2c_num, unsigned int addr, const void* data,
214:                                 int write_bytes, int read_bytes) {
215:                 I2C_STATE* i2c = i2c_states + i2c_num;
216:                 TX_MESSAGE_HEADER hdr;
217:                 BYTE prev;
218:                 log_printf("I2CWriteRead(%d, 0x%x, %p, %d, %d)", i2c_num, addr,
219:                            data, write_bytes, read_bytes);
220:                 hdr.addr = addr;
00EFE0  9FBF91     MOV W1, [W15-14]
221:                 hdr.write_size = write_bytes;
00EFE2  9FF7C3     MOV.B W3, [W15-12]
222:                 hdr.read_size = read_bytes;
00EFE4  9FF7D4     MOV.B W4, [W15-11]
223:                 prev = SyncInterruptLevel(4);
224:                 ByteQueuePushBuffer(&i2c->tx_queue, &hdr, sizeof hdr);
00EFF6  201A00     MOV #0x1A0, W0
00EFF8  B9E100     MUL.SS W12, W0, W2
00EFFA  217240     MOV #0x1724, W0
00EFFC  410580     ADD W2, W0, W11
00EFFE  200042     MOV #0x4, W2
00F000  5780EE     SUB W15, #0xE, W1
00F002  78000B     MOV W11, W0
00F004  0715BA     RCALL ByteQueuePushBuffer
225:                 ByteQueuePushBuffer(&i2c->tx_queue, data, write_bytes);
00F006  780109     MOV W9, W2
00F008  78008A     MOV W10, W1
00F00A  78000B     MOV W11, W0
00F00C  0715B6     RCALL ByteQueuePushBuffer
226:                 Set_MI2CIE[i2c_num](1);
00F00E  46008C     ADD W12, W12, W1
00F010  21DE60     MOV #0x1DE6, W0
00F012  7800E1     MOV [W1+W0], W1
00F014  200010     MOV #0x1, W0
00F016  010001     CALL W1
227:                 SyncInterruptLevel(prev);
228:               }
00F02E  B003EF     ADD #0x3E, W15
00F030  BE9F88     MOV.D W8, [W15++]
00F032  BE9F8A     MOV.D W10, [W15++]
00F034  BE9F8C     MOV.D W12, [W15++]
00F036  781F8E     MOV W14, [W15++]
00F038  780500     MOV W0, W10
00F03A  780601     MOV W1, W12
00F03C  9FBF82     MOV W2, [W15-16]
00F03E  780703     MOV W3, W14
229:               
230:               static void MI2CInterrupt(int i2c_num) {
231:                 I2C_STATE* i2c = i2c_states + i2c_num;
00ECBE  201A02     MOV #0x1A0, W2
00ECC0  B98102     MUL.SS W0, W2, W2
00ECC2  2170E1     MOV #0x170E, W1
00ECC4  408402     ADD W1, W2, W8
232:                 volatile I2CREG* reg = i2c_reg[i2c_num];
00ECC6  400480     ADD W0, W0, W9
00ECC8  21DE00     MOV #0x1DE0, W0
00ECCA  780569     MOV [W9+W0], W10
233:               
234:                 Set_MI2CIF[i2c_num](0);  // clear interrupt
00ECCC  21DEC0     MOV #0x1DEC, W0
00ECCE  7800E9     MOV [W9+W0], W1
00ECD0  EB0000     CLR W0
00ECD2  010001     CALL W1
235:                 switch (i2c->message_state) {
00ECD4  780018     MOV [W8], W0
00ECD6  200001     MOV #0x0, W1
00ECD8  500FE9     SUB W0, #0x9, [W15]
00ECDA  588FE0     SUBB W1, #0x0, [W15]
00ECDC  3E001E     BRA GTU, 0xED1A
00ECDE  016000     BRA W0
00ECE0  37001F     BRA 0xED20
00ECE2  370093     BRA 0xEE0A
00ECE4  370086     BRA 0xEDF2
00ECE6  370006     BRA 0xECF4
00ECE8  37006D     BRA 0xEDC4
00ECEA  37007D     BRA 0xEDE6
00ECEC  370072     BRA 0xEDD2
00ECEE  37005B     BRA 0xEDA6
00ECF0  370046     BRA 0xED7E
00ECF2  37002C     BRA 0xED4C
236:                   case STATE_START:
237:                     ByteQueuePullToBuffer(&i2c->tx_queue, &i2c->cur_tx_header,
00ED20  E88088     INC2 W8, W1
00ED22  440076     ADD W8, #0x16, W0
00ED24  200042     MOV #0x4, W2
00ED26  071761     RCALL ByteQueuePullToBuffer
238:                                           sizeof(TX_MESSAGE_HEADER));
239:                     i2c->num_tx_since_last_report += sizeof(TX_MESSAGE_HEADER);
00ED28  900038     MOV [W8+6], W0
00ED2A  400064     ADD W0, #0x4, W0
00ED2C  980430     MOV W0, [W8+6]
240:                     i2c->bytes_remaining = i2c->cur_tx_header.write_size;
00ED2E  904048     MOV.B [W8+4], W0
00ED30  FB8000     ZE W0, W0
00ED32  980440     MOV W0, [W8+8]
241:                     reg->con |= 0x0001;  // send start bit
00ED34  90003A     MOV [W10+6], W0
00ED36  A00000     BSET W0, #0
00ED38  980530     MOV W0, [W10+6]
242:                     if (i2c->bytes_remaining) {
00ED3A  900048     MOV [W8+8], W0
00ED3C  E00000     CP0 W0
00ED3E  3A0081     BRA NZ, 0xEE42
243:                       i2c->message_state = STATE_ADDR1_WRITE;
00EE42  200010     MOV #0x1, W0
00EE44  780C00     MOV W0, [W8]
244:                     } else {
245:                       i2c->message_state = STATE_ADDR_READ;
246:                     }
247:                     break;
248:                     
249:                   case STATE_ADDR1_WRITE:
250:                     reg->trn = i2c->cur_tx_header.addr1;
00EE0A  904028     MOV.B [W8+2], W0
00EE0C  FB8000     ZE W0, W0
00EE0E  980510     MOV W0, [W10+2]
251:                     if (i2c->cur_tx_header.addr1 >> 3 == 0b00011110) {
00EE10  904028     MOV.B [W8+2], W0
00EE12  FB8000     ZE W0, W0
00EE14  DE0043     LSR W0, #3, W0
00EE16  504FFE     SUB.B W0, #0x1E, [W15]
00EE18  3AFFF2     BRA NZ, 0xEDFE
252:                       i2c->message_state = STATE_ADDR2_WRITE;
00EE1A  200020     MOV #0x2, W0
00EE1C  780C00     MOV W0, [W8]
253:                     } else {
254:                       i2c->message_state = STATE_WRITE_DATA;
255:                     }
256:                     break;
257:                     
258:                   case STATE_ADDR2_WRITE:
259:                     if (reg->stat >> 15) goto error;
00EDF2  90004A     MOV [W10+8], W0
00EDF4  E00000     CP0 W0
00EDF6  35FFDA     BRA LT, error
260:                     reg->trn = i2c->cur_tx_header.addr2;
00EDF8  904038     MOV.B [W8+3], W0
00EDFA  FB8000     ZE W0, W0
00EDFC  980510     MOV W0, [W10+2]
261:                     i2c->message_state = STATE_WRITE_DATA;
00EDFE  200030     MOV #0x3, W0
00EE00  780C00     MOV W0, [W8]
262:                     break;
263:                     
264:                   case STATE_WRITE_DATA:
265:                     if (reg->stat >> 15) goto error;
00ECF4  90004A     MOV [W10+8], W0
00ECF6  E00000     CP0 W0
00ECF8  350059     BRA LT, error
266:                     {
267:                       BYTE b = ByteQueuePullByte(&i2c->tx_queue);
00ECFA  440076     ADD W8, #0x16, W0
00ECFC  0716E1     RCALL ByteQueuePullByte
268:                       reg->trn = b;
00ECFE  FB8000     ZE W0, W0
00ED00  980510     MOV W0, [W10+2]
269:                     }
270:                     ++i2c->num_tx_since_last_report;
00ED02  900038     MOV [W8+6], W0
00ED04  E80000     INC W0, W0
00ED06  980430     MOV W0, [W8+6]
271:                     if (--i2c->bytes_remaining == 0) {
00ED08  900048     MOV [W8+8], W0
00ED0A  E90000     DEC W0, W0
00ED0C  980440     MOV W0, [W8+8]
00ED0E  3A0005     BRA NZ, 0xED1A
272:                       i2c->message_state = i2c->cur_tx_header.read_size
00ED10  904058     MOV.B [W8+5], W0
00ED12  FB8000     ZE W0, W0
00ED14  E90000     DEC W0, W0
00ED16  DE004F     LSR W0, #15, W0
00ED18  100C65     SUBR W0, #0x5, [W8]
273:                                            ? STATE_RESTART
274:                                            : STATE_STOP_WRITE_ONLY;
275:                     }
276:                     break;
277:               
278:                   case STATE_STOP_WRITE_ONLY:
279:                     if (reg->stat >> 15) goto error;
00EDC4  90004A     MOV [W10+8], W0
00EDC6  DE00CF     LSR W0, #15, W1
00EDC8  3AFFF1     BRA NZ, error
280:                     ByteQueuePushByte(&i2c->rx_queue, 0x00);
00EDCA  44006A     ADD W8, #0xA, W0
00EDCC  0716BE     RCALL ByteQueuePushByte
00EDCE  4405F6     ADD W8, #0x16, W11
00EDD0  37FFC2     BRA done
281:                     goto done;
282:                     
283:                   case STATE_RESTART:
284:                     reg->con |= 0x0002;  // send restart
00EDE6  90003A     MOV [W10+6], W0
00EDE8  A01000     BSET W0, #1
00EDEA  980530     MOV W0, [W10+6]
285:                     i2c->message_state = STATE_ADDR_READ;
00ED40  200060     MOV #0x6, W0
00ED42  780C00     MOV W0, [W8]
00EDEC  200060     MOV #0x6, W0
00EDEE  780C00     MOV W0, [W8]
00EDF0  37FFA9     BRA 0xED44
286:                     break;
287:                     
288:                   case STATE_ADDR_READ:
289:                     reg->trn = i2c->cur_tx_header.addr1 | 0x01;  // read address
00EDD2  904028     MOV.B [W8+2], W0
00EDD4  A00400     BSET.B W0, #0
00EDD6  FB8000     ZE W0, W0
00EDD8  980510     MOV W0, [W10+2]
290:                     i2c->message_state = STATE_ACK_ADDR_READ;
00EDDA  200070     MOV #0x7, W0
00EDDC  780C00     MOV W0, [W8]
291:                     break;
292:               
293:                   case STATE_ACK_ADDR_READ:
294:                     if (reg->stat >> 15) goto error;
00EDA6  90004A     MOV [W10+8], W0
00EDA8  E00000     CP0 W0
00EDAA  3D003D     BRA GE, 0xEE26
295:                     // from now on, we can no longer fail.
296:                     i2c->bytes_remaining = i2c->cur_tx_header.read_size;
00EE26  9040D8     MOV.B [W8+5], W1
00EE28  FB8001     ZE W1, W0
00EE2A  980440     MOV W0, [W8+8]
297:                     ByteQueuePushByte(&i2c->rx_queue, i2c->cur_tx_header.read_size);
00EE2C  44006A     ADD W8, #0xA, W0
00EE2E  07168D     RCALL ByteQueuePushByte
298:                     reg->con |= 0x0008;  // RCEN
299:                     i2c->message_state = STATE_READ_DATA;
300:                     break;
301:               
302:                   case STATE_READ_DATA:
303:                     ByteQueuePushByte(&i2c->rx_queue, reg->rcv);
00ED7E  78009A     MOV [W10], W1
00ED80  44006A     ADD W8, #0xA, W0
00ED82  0716E3     RCALL ByteQueuePushByte
304:                     reg->con &= ~(1 << 5);  // reset ack state
00ED84  90003A     MOV [W10+6], W0
00ED86  A15000     BCLR W0, #5
00ED88  980530     MOV W0, [W10+6]
305:                     reg->con |= (1 << 4)
00ED8A  9000BA     MOV [W10+6], W1
00ED8C  900048     MOV [W8+8], W0
00ED8E  200302     MOV #0x30, W2
00ED90  500FE1     SUB W0, #0x1, [W15]
00ED92  320001     BRA Z, 0xED96
00ED94  200102     MOV #0x10, W2
00ED96  710001     IOR W2, W1, W0
00ED98  980530     MOV W0, [W10+6]
306:                                 | (i2c->bytes_remaining == 1) << 5;  // nack last byte
307:                     i2c->message_state = STATE_ACK_READ_DATA;
00ED9A  200090     MOV #0x9, W0
00ED9C  780C00     MOV W0, [W8]
308:                     break;
309:               
310:                   case STATE_ACK_READ_DATA:
311:                     if (--i2c->bytes_remaining == 0) {
00ED4C  900048     MOV [W8+8], W0
00ED4E  E90000     DEC W0, W0
00ED50  980440     MOV W0, [W8+8]
00ED52  3A006E     BRA NZ, 0xEE30
00ED54  4405F6     ADD W8, #0x16, W11
312:                       goto done;
313:                     } else {
314:                       reg->con |= 0x0008;  // RCEN
00EE30  90003A     MOV [W10+6], W0
00EE32  A03000     BSET W0, #3
00EE34  980530     MOV W0, [W10+6]
315:                       i2c->message_state = STATE_READ_DATA;
00EE36  200080     MOV #0x8, W0
00EE38  780C00     MOV W0, [W8]
316:                     }
317:                     break;
318:                 }
319:                 return;
320:                 
321:               error:
322:                 log_printf("I2C error");
323:                 // pull remainder of tx message
324:                 ByteQueuePull(&i2c->tx_queue, i2c->bytes_remaining);
00EDAC  9000C8     MOV [W8+8], W1
00EDAE  4405F6     ADD W8, #0x16, W11
00EDB0  78000B     MOV W11, W0
00EDB2  0716AF     RCALL ByteQueuePull
325:                 i2c->num_tx_since_last_report += i2c->bytes_remaining;
00EDB4  900038     MOV [W8+6], W0
00EDB6  9000C8     MOV [W8+8], W1
00EDB8  400001     ADD W0, W1, W0
00EDBA  980430     MOV W0, [W8+6]
326:                 ByteQueuePushByte(&i2c->rx_queue, 0xFF);
00EDBC  44006A     ADD W8, #0xA, W0
00EDBE  EBC080     SETM.B W1
00EDC0  0716C4     RCALL ByteQueuePushByte
00EDC2  37FFC9     BRA done
327:               
328:               done:
329:                 ++i2c->num_messages_rx_queue;
00ED56  900828     MOV [W8+20], W0
00ED58  E80000     INC W0, W0
00ED5A  980C20     MOV W0, [W8+20]
330:                 reg->con |= (1 << 2);  // send stop bit
00ED5C  90003A     MOV [W10+6], W0
00ED5E  A02000     BSET W0, #2
00ED60  980530     MOV W0, [W10+6]
331:                 i2c->message_state = STATE_START;
00ED62  EB0C00     CLR [W8]
332:                 Set_MI2CIE[i2c_num](ByteQueueSize(&i2c->tx_queue) > 0);
00ED64  EB0100     CLR W2
00ED66  90004B     MOV [W11+8], W0
00ED68  E00000     CP0 W0
00ED6A  340001     BRA LE, 0xED6E
00ED6C  200012     MOV #0x1, W2
00ED6E  21DE60     MOV #0x1DE6, W0
00ED70  7800E9     MOV [W9+W0], W1
00ED72  780002     MOV W2, W0
00ED74  010001     CALL W1
333:               }
00ED1A  BE054F     MOV.D [--W15], W10
00ED1C  BE044F     MOV.D [--W15], W8
00ED1E  060000     RETURN
00ED44  BE054F     MOV.D [--W15], W10
00ED46  BE044F     MOV.D [--W15], W8
00ED48  060000     RETURN
00ED4A  37FFEA     BRA 0xED20
00ED76  BE054F     MOV.D [--W15], W10
00ED78  BE044F     MOV.D [--W15], W8
00ED7A  060000     RETURN
00ED7C  37FFD1     BRA 0xED20
00ED9E  BE054F     MOV.D [--W15], W10
00EDA0  BE044F     MOV.D [--W15], W8
00EDA2  060000     RETURN
00EDA4  37FFBD     BRA 0xED20
00EDDE  BE054F     MOV.D [--W15], W10
00EDE0  BE044F     MOV.D [--W15], W8
00EDE2  060000     RETURN
00EDE4  37FF9D     BRA 0xED20
00EE02  BE054F     MOV.D [--W15], W10
00EE04  BE044F     MOV.D [--W15], W8
00EE06  060000     RETURN
00EE08  37FF8B     BRA 0xED20
00EE1E  BE054F     MOV.D [--W15], W10
00EE20  BE044F     MOV.D [--W15], W8
00EE22  060000     RETURN
00EE24  37FF7D     BRA 0xED20
00EE3A  BE054F     MOV.D [--W15], W10
00EE3C  BE044F     MOV.D [--W15], W8
00EE3E  060000     RETURN
00EE40  37FF6F     BRA 0xED20
00EE4E  F80036     PUSH RCOUNT
00EE50  BE9F80     MOV.D W0, [W15++]
00EE52  BE9F82     MOV.D W2, [W15++]
00EE54  BE9F84     MOV.D W4, [W15++]
00EE56  BE9F86     MOV.D W6, [W15++]
00EE58  F80032     PUSH DSRPAG
00EE5A  202000     MOV #0x200, W0
00EE5C  880190     MOV W0, DSRPAG
334:               
335:               #define DEFINE_INTERRUPT_HANDLERS(i2c_num)                                     \
336:                 void __attribute__((__interrupt__, auto_psv)) _MI2C##i2c_num##Interrupt() {  \
337:                   MI2CInterrupt(i2c_num - 1);                                                \
338:                 }
339:               
340:               #if NUM_I2C_MODULES > 3
341:                 #error Currently only devices with 3 or less I2Cs are supported. Please fix below.
342:               #endif
343:               
344:               #if NUM_I2C_MODULES >= 1
345:                 DEFINE_INTERRUPT_HANDLERS(1)
00EE70  F80036     PUSH RCOUNT
00EE72  BE9F80     MOV.D W0, [W15++]
00EE74  BE9F82     MOV.D W2, [W15++]
00EE76  BE9F84     MOV.D W4, [W15++]
00EE78  BE9F86     MOV.D W6, [W15++]
00EE7A  F80032     PUSH DSRPAG
00EE7C  202000     MOV #0x200, W0
00EE7E  880190     MOV W0, DSRPAG
346:               #endif
347:               
348:               #if NUM_I2C_MODULES >= 2
349:                 DEFINE_INTERRUPT_HANDLERS(2)
00EE92  F80036     PUSH RCOUNT
00EE94  BE9F80     MOV.D W0, [W15++]
00EE96  BE9F82     MOV.D W2, [W15++]
00EE98  BE9F84     MOV.D W4, [W15++]
00EE9A  BE9F86     MOV.D W6, [W15++]
00EE9C  F80032     PUSH DSRPAG
00EE9E  202000     MOV #0x200, W0
00EEA0  880190     MOV W0, DSRPAG
350:               #endif
351:               
352:               #if NUM_I2C_MODULES >= 3
353:                 DEFINE_INTERRUPT_HANDLERS(3)
00EEB4  B0048F     ADD #0x48, W15
00EEB6  BE9F88     MOV.D W8, [W15++]
00EEB8  BE9F8A     MOV.D W10, [W15++]
00EEBA  BE9F8C     MOV.D W12, [W15++]
00EEBC  781F8E     MOV W14, [W15++]
354:               #endif
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/app_layer_v1/features.c  -
00F152  BE9F88     MOV.D W8, [W15++]
00F154  BE0400     MOV.D W0, W8
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include "features.h"
31:                
32:                #include <string.h>
33:                
34:                #include "Compiler.h"
35:                #include "pins.h"
36:                #include "logging.h"
37:                #include "protocol.h"
38:                #include "adc.h"
39:                #include "pwm.h"
40:                #include "uart.h"
41:                #include "spi.h"
42:                #include "i2c.h"
43:                #include "timers.h"
44:                #include "pp_util.h"
45:                #include "incap.h"
46:                
47:                ////////////////////////////////////////////////////////////////////////////////
48:                // Pin modes
49:                ////////////////////////////////////////////////////////////////////////////////
50:                
51:                #define ARRAY_LEN(x) (sizeof(x) / sizeof((x)[0]))
52:                
53:                static int PinIsMatrix(int i) {
54:                  static const int MATRIX_PINS[] = { 7, 10, 11, 19, 20, 21, 22, 23, 24, 25, 27, 28 };
55:                  int j;
56:                  for (j = 0; j < ARRAY_LEN(MATRIX_PINS); ++j) {
00F516  508F80     SUB W1, W0, [W15]
00F518  32002C     BRA Z, 0xF572
57:                    if (MATRIX_PINS[j] == i) return 1;
00F508  20007A     MOV #0x7, W10
00F50A  200019     MOV #0x1, W9
00F50C  DD4445     SL W8, #5, W8
00F50E  550F89     SUB W10, W9, [W15]
00F510  320006     BRA Z, 0xF51E
00F512  2ED7A0     MOV #0xED7A, W0
00F514  2ED901     MOV #0xED90, W1
00F51A  548FB0     SUB W9, [W0++], [W15]
00F51C  3AFFFC     BRA NZ, 0xF516
58:                  }
59:                  return 0;
60:                }
61:                
62:                static void PinsInit() {
63:                  int i;
64:                  _CNIE = 0;
00F4FE  A96096     BCLR IEC1, #3
65:                  // reset pin states
66:                  SetPinDigitalOut(0, 1, 1);  // LED pin: output, open-drain, high (off)
00F500  200012     MOV #0x1, W2
00F502  200011     MOV #0x1, W1
00F504  EB0000     CLR W0
00F506  07FE58     RCALL SetPinDigitalOut
67:                  for (i = 1; i < NUM_PINS; ++i) {
00F51E  E80489     INC W9, W9
00F520  200310     MOV #0x31, W0
00F522  548F80     SUB W9, W0, [W15]
00F524  3AFFF4     BRA NZ, 0xF50E
00F526  EB0080     CLR W1
00F578  E80489     INC W9, W9
00F57A  200310     MOV #0x31, W0
00F57C  548F80     SUB W9, W0, [W15]
00F57E  3AFFC7     BRA NZ, 0xF50E
00F580  37FFD2     BRA 0xF526
68:                    if (!PinIsMatrix(i)) {
69:                      SetPinDigitalIn(i, 0);    // all other pins: input, no-pull
00F572  EB0080     CLR W1
00F574  780009     MOV W9, W0
00F576  07FDED     RCALL SetPinDigitalIn
70:                    }
71:                  }
72:                  for (i = 0; i < NUM_UART_MODULES; ++i) {
00F52C  E80081     INC W1, W1
00F52E  508FE3     SUB W1, #0x3, [W15]
00F530  3C000C     BRA GT, 0xF54A
00F544  E80081     INC W1, W1
00F546  508FE3     SUB W1, #0x3, [W15]
00F548  34FFF4     BRA LE, 0xF532
73:                    SetPinUart(0, i, 0, 0);  // UART RX disabled
74:                  }
75:                  // clear and enable global CN interrupts
76:                  _CNIF = 0;
00F54A  A96086     BCLR IFS1, #3
77:                  _CNIE = 1;
00F54C  A86096     BSET IEC1, #3
78:                  _CNIP = 1;  // CN interrupt priority is 1 so it can write an outgoing message
00F54E  BFC0AD     MOV.B 0xAD, WREG
00F550  B3C8F1     MOV #0x8F, W1
00F552  604001     AND.B W0, W1, W0
00F554  A04400     BSET.B W0, #4
00F556  B7E0AD     MOV.B WREG, 0xAD
79:                }
80:                
81:                void SetPinDigitalOut(int pin, int value, int open_drain) {
82:                  log_printf("SetPinDigitalOut(%d, %d, %d)", pin, value, open_drain);
83:                  SAVE_PIN_FOR_LOG(pin);
84:                  ADCSetScan(pin, 0);
00F1C0  EB0080     CLR W1
00F1C2  070FB6     RCALL ADCSetScan
85:                  PinSetAnsel(pin, 0);
00F1C4  EB0080     CLR W1
00F1C6  780008     MOV W8, W0
00F1C8  07161E     RCALL PinSetAnsel
86:                  PinSetRpor(pin, 0);
00F1CA  EB0080     CLR W1
00F1CC  780008     MOV W8, W0
00F1CE  07169C     RCALL PinSetRpor
87:                  PinSetCnen(pin, 0);
00F1D0  EB0080     CLR W1
00F1D2  780008     MOV W8, W0
00F1D4  071648     RCALL PinSetCnen
88:                  PinSetCnpu(pin, 0);
00F1D6  EB0080     CLR W1
00F1D8  780008     MOV W8, W0
00F1DA  07167C     RCALL PinSetCnpu
89:                  PinSetCnpd(pin, 0);
00F1DC  EB0080     CLR W1
00F1DE  780008     MOV W8, W0
00F1E0  071686     RCALL PinSetCnpd
90:                  PinSetLat(pin, value);
00F1E2  BE0008     MOV.D W8, W0
00F1E4  07161D     RCALL PinSetLat
91:                  PinSetOdc(pin, open_drain);
00F1E6  78008A     MOV W10, W1
00F1E8  780008     MOV W8, W0
00F1EA  071630     RCALL PinSetOdc
92:                  PinSetTris(pin, 0);
00F1EC  EB0080     CLR W1
00F1EE  780008     MOV W8, W0
00F1F0  0715FD     RCALL PinSetTris
93:                }
00F1F8  780181     MOV W1, W3
94:                
95:                void SetPinDigitalIn(int pin, int pull) {
96:                  log_printf("SetPinDigitalIn(%d, %d)", pin, pull);
97:                  SAVE_PIN_FOR_LOG(pin);
98:                  ADCSetScan(pin, 0);
00F156  EB0080     CLR W1
00F158  070FEB     RCALL ADCSetScan
99:                  PinSetAnsel(pin, 0);
00F15A  EB0080     CLR W1
00F15C  780008     MOV W8, W0
00F15E  071653     RCALL PinSetAnsel
100:                 PinSetRpor(pin, 0);
00F160  EB0080     CLR W1
00F162  780008     MOV W8, W0
00F164  0716D1     RCALL PinSetRpor
101:                 PinSetCnen(pin, 0);
00F166  EB0080     CLR W1
00F168  780008     MOV W8, W0
00F16A  07167D     RCALL PinSetCnen
102:                 switch (pull) {
00F16C  548FE1     SUB W9, #0x1, [W15]
00F16E  32000D     BRA Z, 0xF18A
00F170  548FE2     SUB W9, #0x2, [W15]
00F172  320016     BRA Z, 0xF1A0
103:                   case 1:
104:                     PinSetCnpd(pin, 0);
00F18A  EB0080     CLR W1
00F18C  780008     MOV W8, W0
00F18E  0716AF     RCALL PinSetCnpd
105:                     PinSetCnpu(pin, 1);
00F190  BE0008     MOV.D W8, W0
00F192  0716A0     RCALL PinSetCnpu
106:                     break;
107:               
108:                   case 2:
109:                     PinSetCnpu(pin, 0);
00F1A0  EB0080     CLR W1
00F1A2  780008     MOV W8, W0
00F1A4  071697     RCALL PinSetCnpu
110:                     PinSetCnpd(pin, 1);
00F1A6  200011     MOV #0x1, W1
00F1A8  780008     MOV W8, W0
00F1AA  0716A1     RCALL PinSetCnpd
111:                     break;
112:               
113:                   default:
114:                     PinSetCnpu(pin, 0);
00F174  EB0080     CLR W1
00F176  780008     MOV W8, W0
00F178  0716AD     RCALL PinSetCnpu
115:                     PinSetCnpd(pin, 0);
00F17A  EB0080     CLR W1
00F17C  780008     MOV W8, W0
00F17E  0716B7     RCALL PinSetCnpd
116:                 }
117:                 PinSetTris(pin, 1);
00F180  200011     MOV #0x1, W1
00F182  780008     MOV W8, W0
00F184  071633     RCALL PinSetTris
00F194  200011     MOV #0x1, W1
00F196  780008     MOV W8, W0
00F198  071629     RCALL PinSetTris
00F1AC  200011     MOV #0x1, W1
00F1AE  780008     MOV W8, W0
00F1B0  07161D     RCALL PinSetTris
118:               }
00F186  BE044F     MOV.D [--W15], W8
00F188  060000     RETURN
00F19A  BE044F     MOV.D [--W15], W8
00F19C  060000     RETURN
00F19E  37FFF5     BRA 0xF18A
00F1B8  BE9F88     MOV.D W8, [W15++]
00F1BA  781F8A     MOV W10, [W15++]
00F1BC  BE0400     MOV.D W0, W8
00F1BE  780502     MOV W2, W10
119:               
120:               void SetPinPwm(int pin, int pwm_num, int enable) {
121:                 log_printf("SetPinPwm(%d, %d)", pin, pwm_num);
122:                 SAVE_PIN_FOR_LOG(pin);
123:                 PinSetRpor(pin, enable ? (pwm_num == 8 ? 35 : 18 + pwm_num) : 0);
00F1FA  E00002     CP0 W2
00F1FC  320005     BRA Z, 0xF208
00F1FE  200231     MOV #0x23, W1
00F200  518FE8     SUB W3, #0x8, [W15]
00F202  320001     BRA Z, 0xF206
00F204  4180F2     ADD W3, #0x12, W1
00F206  371680     BRA PinSetRpor
00F20E  781F88     MOV W8, [W15++]
00F210  780200     MOV W0, W4
00F212  780401     MOV W1, W8
00F214  780083     MOV W3, W1
124:               }
125:               
126:               void SetPinUart(int pin, int uart_num, int dir, int enable) {
127:                 log_printf("SetPinUart(%d, %d, %d, %d)", pin, uart_num, dir, enable);
128:                 SAVE_PIN_FOR_LOG(pin);
129:                 SAVE_UART_FOR_LOG(uart_num);
130:                 if (dir) {
00F216  E00002     CP0 W2
00F218  320009     BRA Z, 0xF22C
131:                   // TX
132:                   const BYTE rp[] = { 3, 5, 28, 30 };
133:                   PinSetRpor(pin, enable ? rp[uart_num] : 0);
00F21A  E00003     CP0 W3
00F21C  320003     BRA Z, 0xF224
00F21E  2ED400     MOV #0xED40, W0
00F220  7C4060     MOV.B [W0+W8], W0
00F222  FB8080     ZE W0, W1
00F224  780004     MOV W4, W0
00F226  071670     RCALL PinSetRpor
134:                 } else {
135:                   // RX
136:                   int rpin = enable ? PinToRpin(pin) : 0x3F;
00F22C  2003F0     MOV #0x3F, W0
00F22E  E00003     CP0 W3
00F230  3A0013     BRA NZ, 0xF258
00F258  780004     MOV W4, W0
00F25A  071688     RCALL PinToRpin
137:                   switch (uart_num) {
00F232  540FE1     SUB W8, #0x1, [W15]
00F234  320015     BRA Z, 0xF260
00F236  540FE1     SUB W8, #0x1, [W15]
00F238  340029     BRA LE, 0xF28C
00F23A  540FE2     SUB W8, #0x2, [W15]
00F23C  32001C     BRA Z, 0xF276
00F23E  540FE3     SUB W8, #0x3, [W15]
00F240  3AFFF3     BRA NZ, 0xF228
00F25C  540FE1     SUB W8, #0x1, [W15]
00F25E  3AFFEB     BRA NZ, 0xF236
00F28C  E00008     CP0 W8
00F28E  3AFFCC     BRA NZ, 0xF228
00F532  508FE1     SUB W1, #0x1, [W15]
00F534  320026     BRA Z, 0xF582
00F536  34002B     BRA LE, 0xF58E
00F538  508FE2     SUB W1, #0x2, [W15]
00F53A  320026     BRA Z, 0xF588
00F53C  508FE3     SUB W1, #0x3, [W15]
00F53E  3AFFF6     BRA NZ, 0xF52C
00F58E  E00001     CP0 W1
00F590  3AFFCD     BRA NZ, 0xF52C
138:                     case 0:
139:                       _U1RXR = rpin;
00F290  B243F0     AND.B #0x3F, W0
00F292  206A41     MOV #0x6A4, W1
00F294  784091     MOV.B [W1], W1
00F296  B3CC02     MOV #0xC0, W2
00F298  60C082     AND.B W1, W2, W1
00F29A  70C080     IOR.B W1, W0, W1
00F29C  780001     MOV W1, W0
00F29E  B7E6A4     MOV.B WREG, RPINR18
00F528  B3C3F0     MOV #0x3F, W0
00F52A  B766A4     IOR.B RPINR18
140:                       break;
141:               
142:                     case 1:
143:                       _U2RXR = rpin;
00F260  B243F0     AND.B #0x3F, W0
00F262  206A61     MOV #0x6A6, W1
00F264  784091     MOV.B [W1], W1
00F266  B3CC02     MOV #0xC0, W2
00F268  60C082     AND.B W1, W2, W1
00F26A  70C080     IOR.B W1, W0, W1
00F26C  780001     MOV W1, W0
00F26E  B7E6A6     MOV.B WREG, RPINR19
00F582  B3C3F0     MOV #0x3F, W0
00F584  B766A6     IOR.B RPINR19
00F586  37FFD2     BRA 0xF52C
144:                       break;
145:               
146:                     case 2:
147:                       _U3RXR = rpin;
00F276  B243F0     AND.B #0x3F, W0
00F278  206A31     MOV #0x6A3, W1
00F27A  784091     MOV.B [W1], W1
00F27C  B3CC02     MOV #0xC0, W2
00F27E  60C082     AND.B W1, W2, W1
00F280  70C080     IOR.B W1, W0, W1
00F282  780001     MOV W1, W0
00F284  B7E6A3     MOV.B WREG, 0x6A3
00F588  B3C3F0     MOV #0x3F, W0
00F58A  B766A3     IOR.B 0x6A3
00F58C  37FFCF     BRA 0xF52C
148:                       break;
149:               
150:                     case 3:
151:                       _U4RXR = rpin;
00F242  B243F0     AND.B #0x3F, W0
00F244  206B61     MOV #0x6B6, W1
00F246  784091     MOV.B [W1], W1
00F248  B3CC02     MOV #0xC0, W2
00F24A  60C082     AND.B W1, W2, W1
00F24C  70C080     IOR.B W1, W0, W1
00F24E  780001     MOV W1, W0
00F250  B7E6B6     MOV.B WREG, RPINR27
00F540  B3C3F0     MOV #0x3F, W0
00F542  B766B6     IOR.B RPINR27
152:                       break;
153:                   }
154:                 }
155:               }
00F228  78044F     MOV [--W15], W8
00F22A  060000     RETURN
00F252  78044F     MOV [--W15], W8
00F254  060000     RETURN
00F256  37FFEA     BRA 0xF22C
00F270  78044F     MOV [--W15], W8
00F272  060000     RETURN
00F274  37FFDB     BRA 0xF22C
00F286  78044F     MOV [--W15], W8
00F288  060000     RETURN
00F28A  37FFD0     BRA 0xF22C
00F2A6  781F88     MOV W8, [W15++]
00F2A8  780401     MOV W1, W8
156:               
157:               void SetPinInCap(int pin, int incap_num, int enable) {
158:                 log_printf("SetPinInCap(%d, %d, %d)", pin, incap_num, enable);
159:                   int rpin = enable ? PinToRpin(pin) : 0x3F;
00F2AA  2003F1     MOV #0x3F, W1
00F2AC  E00002     CP0 W2
00F2AE  3A0020     BRA NZ, 0xF2F0
00F2F0  07163D     RCALL PinToRpin
00F2F2  780080     MOV W0, W1
160:               
161:                   switch (incap_num) {
00F2B0  540FE4     SUB W8, #0x4, [W15]
00F2B2  320022     BRA Z, 0xF2F8
00F2B4  540FE4     SUB W8, #0x4, [W15]
00F2B6  340009     BRA LE, 0xF2CA
00F2B8  540FE6     SUB W8, #0x6, [W15]
00F2BA  320044     BRA Z, 0xF344
00F2BC  350029     BRA LT, 0xF310
00F2BE  540FE7     SUB W8, #0x7, [W15]
00F2C0  320071     BRA Z, 0xF3A4
00F2C2  540FE8     SUB W8, #0x8, [W15]
00F2C4  320063     BRA Z, 0xF38C
00F2CA  540FE1     SUB W8, #0x1, [W15]
00F2CC  320047     BRA Z, 0xF35C
00F2CE  34002C     BRA LE, 0xF328
00F2D0  540FE2     SUB W8, #0x2, [W15]
00F2D2  320050     BRA Z, 0xF374
00F2D4  540FE3     SUB W8, #0x3, [W15]
00F2D6  3AFFF7     BRA NZ, 0xF2C6
00F2F4  540FE4     SUB W8, #0x4, [W15]
00F2F6  3AFFDE     BRA NZ, 0xF2B4
00F328  E00008     CP0 W8
00F32A  3AFFCD     BRA NZ, 0xF2C6
162:               #define CASE(num, unused)    \
163:                     case num - 1:          \
164:                       _IC##num##R = rpin;  \
165:                       break;
166:                     REPEAT_1B(CASE, NUM_INCAP_MODULES);
00F2D8  B3C3F2     MOV #0x3F, W2
00F2DA  60C002     AND.B W1, W2, W0
00F2DC  206911     MOV #0x691, W1
00F2DE  784091     MOV.B [W1], W1
00F2E0  B3CC02     MOV #0xC0, W2
00F2E2  60C082     AND.B W1, W2, W1
00F2E4  70C080     IOR.B W1, W0, W1
00F2E6  780001     MOV W1, W0
00F2E8  B7E691     MOV.B WREG, 0x691
00F2F8  B3C3F2     MOV #0x3F, W2
00F2FA  60C002     AND.B W1, W2, W0
00F2FC  206921     MOV #0x692, W1
00F2FE  784091     MOV.B [W1], W1
00F300  B3CC02     MOV #0xC0, W2
00F302  60C082     AND.B W1, W2, W1
00F304  70C080     IOR.B W1, W0, W1
00F306  780001     MOV W1, W0
00F308  B7E692     MOV.B WREG, RPINR9
00F310  B3C3F2     MOV #0x3F, W2
00F312  60C002     AND.B W1, W2, W0
00F314  206931     MOV #0x693, W1
00F316  784091     MOV.B [W1], W1
00F318  B3CC02     MOV #0xC0, W2
00F31A  60C082     AND.B W1, W2, W1
00F31C  70C080     IOR.B W1, W0, W1
00F31E  780001     MOV W1, W0
00F320  B7E693     MOV.B WREG, 0x693
00F32C  B3C3F2     MOV #0x3F, W2
00F32E  60C002     AND.B W1, W2, W0
00F330  2068E1     MOV #0x68E, W1
00F332  784091     MOV.B [W1], W1
00F334  B3CC02     MOV #0xC0, W2
00F336  60C082     AND.B W1, W2, W1
00F338  70C080     IOR.B W1, W0, W1
00F33A  780001     MOV W1, W0
00F33C  B7E68E     MOV.B WREG, RPINR7
00F344  B3C3F2     MOV #0x3F, W2
00F346  60C002     AND.B W1, W2, W0
00F348  206941     MOV #0x694, W1
00F34A  784091     MOV.B [W1], W1
00F34C  B3CC02     MOV #0xC0, W2
00F34E  60C082     AND.B W1, W2, W1
00F350  70C080     IOR.B W1, W0, W1
00F352  780001     MOV W1, W0
00F354  B7E694     MOV.B WREG, RPINR10
00F35C  B3C3F2     MOV #0x3F, W2
00F35E  60C002     AND.B W1, W2, W0
00F360  2068F1     MOV #0x68F, W1
00F362  784091     MOV.B [W1], W1
00F364  B3CC02     MOV #0xC0, W2
00F366  60C082     AND.B W1, W2, W1
00F368  70C080     IOR.B W1, W0, W1
00F36A  780001     MOV W1, W0
00F36C  B7E68F     MOV.B WREG, 0x68F
00F374  B3C3F2     MOV #0x3F, W2
00F376  60C002     AND.B W1, W2, W0
00F378  206901     MOV #0x690, W1
00F37A  784091     MOV.B [W1], W1
00F37C  B3CC02     MOV #0xC0, W2
00F37E  60C082     AND.B W1, W2, W1
00F380  70C080     IOR.B W1, W0, W1
00F382  780001     MOV W1, W0
00F384  B7E690     MOV.B WREG, RPINR8
00F38C  B3C3F2     MOV #0x3F, W2
00F38E  60C002     AND.B W1, W2, W0
00F390  2069F1     MOV #0x69F, W1
00F392  784091     MOV.B [W1], W1
00F394  B3CC02     MOV #0xC0, W2
00F396  60C082     AND.B W1, W2, W1
00F398  70C080     IOR.B W1, W0, W1
00F39A  780001     MOV W1, W0
00F39C  B7E69F     MOV.B WREG, 0x69F
00F3A4  B3C3F2     MOV #0x3F, W2
00F3A6  60C002     AND.B W1, W2, W0
00F3A8  206951     MOV #0x695, W1
00F3AA  784091     MOV.B [W1], W1
00F3AC  B3CC02     MOV #0xC0, W2
00F3AE  60C082     AND.B W1, W2, W1
00F3B0  70C080     IOR.B W1, W0, W1
00F3B2  780001     MOV W1, W0
00F3B4  B7E695     MOV.B WREG, 0x695
167:                   }
168:               }
00F2C6  78044F     MOV [--W15], W8
00F2C8  060000     RETURN
00F2EA  78044F     MOV [--W15], W8
00F2EC  060000     RETURN
00F2EE  37FFED     BRA 0xF2CA
00F30A  78044F     MOV [--W15], W8
00F30C  060000     RETURN
00F30E  37FFDD     BRA 0xF2CA
00F322  78044F     MOV [--W15], W8
00F324  060000     RETURN
00F326  37FFD1     BRA 0xF2CA
00F33E  78044F     MOV [--W15], W8
00F340  060000     RETURN
00F342  37FFC3     BRA 0xF2CA
00F356  78044F     MOV [--W15], W8
00F358  060000     RETURN
00F35A  37FFB7     BRA 0xF2CA
00F36E  78044F     MOV [--W15], W8
00F370  060000     RETURN
00F372  37FFAB     BRA 0xF2CA
00F386  78044F     MOV [--W15], W8
00F388  060000     RETURN
00F38A  37FF9F     BRA 0xF2CA
00F39E  78044F     MOV [--W15], W8
00F3A0  060000     RETURN
00F3A2  37FF93     BRA 0xF2CA
00F3BC  781F88     MOV W8, [W15++]
00F3BE  780400     MOV W0, W8
169:               
170:               void SetPinAnalogIn(int pin) {
171:                 log_printf("SetPinAnalogIn(%d)", pin);
172:                 SAVE_PIN_FOR_LOG(pin);
173:                 PinSetRpor(pin, 0);
00F3C0  EB0080     CLR W1
00F3C2  0715A2     RCALL PinSetRpor
174:                 PinSetCnen(pin, 0);
00F3C4  EB0080     CLR W1
00F3C6  780008     MOV W8, W0
00F3C8  07154E     RCALL PinSetCnen
175:                 PinSetCnpu(pin, 0);
00F3CA  EB0080     CLR W1
00F3CC  780008     MOV W8, W0
00F3CE  071582     RCALL PinSetCnpu
176:                 PinSetCnpd(pin, 0);
00F3D0  EB0080     CLR W1
00F3D2  780008     MOV W8, W0
00F3D4  07158C     RCALL PinSetCnpd
177:                 PinSetAnsel(pin, 1);
00F3D6  200011     MOV #0x1, W1
00F3D8  780008     MOV W8, W0
00F3DA  071515     RCALL PinSetAnsel
178:                 PinSetTris(pin, 1);
00F3DC  200011     MOV #0x1, W1
00F3DE  780008     MOV W8, W0
00F3E0  071505     RCALL PinSetTris
179:                 ADCSetScan(pin, 0);
00F3E2  EB0080     CLR W1
00F3E4  780008     MOV W8, W0
00F3E6  070EA4     RCALL ADCSetScan
180:               }
00F3EC  781F88     MOV W8, [W15++]
00F3EE  780200     MOV W0, W4
00F3F0  780401     MOV W1, W8
00F3F2  780083     MOV W3, W1
181:               
182:               void SetPinSpi(int pin, int spi_num, int mode, int enable) {
183:                 log_printf("SetPinSpi(%d, %d, %d, %d)", pin, spi_num, mode, enable);
184:                 SAVE_PIN_FOR_LOG(pin);
185:                 switch (mode) {
00F3F4  510FE1     SUB W2, #0x1, [W15]
00F3F6  320010     BRA Z, 0xF418
00F3F8  510FE2     SUB W2, #0x2, [W15]
00F3FA  320022     BRA Z, 0xF440
00F3FC  E00002     CP0 W2
00F3FE  320002     BRA Z, 0xF404
186:                   case 0:  // data out
187:                     {
188:                       const BYTE rp[] = { 7, 10, 32 };
189:                       PinSetRpor(pin, enable ? rp[spi_num] : 0);
00F404  E00003     CP0 W3
00F406  320003     BRA Z, 0xF40E
00F408  2ED470     MOV #0xED47, W0
00F40A  7C4060     MOV.B [W0+W8], W0
00F40C  FB8080     ZE W0, W1
190:                     }
191:                     break;
192:               
193:                     case 1:  // data in
194:                     {
195:                       int rpin = enable ? PinToRpin(pin) : 0x3F;
00F418  2003F0     MOV #0x3F, W0
00F41A  E00003     CP0 W3
00F41C  3A0019     BRA NZ, 0xF450
00F450  780004     MOV W4, W0
00F452  07158C     RCALL PinToRpin
00F454  37FFE4     BRA 0xF41E
196:                       switch (spi_num) {
00F41E  540FE1     SUB W8, #0x1, [W15]
00F420  320025     BRA Z, 0xF46C
00F422  540FE2     SUB W8, #0x2, [W15]
00F424  320018     BRA Z, 0xF456
00F426  E00008     CP0 W8
00F428  3AFFEB     BRA NZ, 0xF400
197:                         case 0:
198:                           _SDI1R = rpin;
00F42A  B243F0     AND.B #0x3F, W0
00F42C  206A81     MOV #0x6A8, W1
00F42E  784091     MOV.B [W1], W1
00F430  B3CC02     MOV #0xC0, W2
00F432  60C082     AND.B W1, W2, W1
00F434  70C080     IOR.B W1, W0, W1
00F436  780001     MOV W1, W0
00F438  B7E6A8     MOV.B WREG, RPINR20
199:                           break;
200:               
201:                         case 1:
202:                           _SDI2R = rpin;
00F46C  B243F0     AND.B #0x3F, W0
00F46E  206AC1     MOV #0x6AC, W1
00F470  784091     MOV.B [W1], W1
00F472  B3CC02     MOV #0xC0, W2
00F474  60C082     AND.B W1, W2, W1
00F476  70C080     IOR.B W1, W0, W1
00F478  780001     MOV W1, W0
00F47A  B7E6AC     MOV.B WREG, RPINR22
203:                           break;
204:               
205:                         case 2:
206:                           _SDI3R = rpin;
00F456  B243F0     AND.B #0x3F, W0
00F458  206B81     MOV #0x6B8, W1
00F45A  784091     MOV.B [W1], W1
00F45C  B3CC02     MOV #0xC0, W2
00F45E  60C082     AND.B W1, W2, W1
00F460  70C080     IOR.B W1, W0, W1
00F462  780001     MOV W1, W0
00F464  B7E6B8     MOV.B WREG, RPINR28
207:                           break;
208:                       }
209:                     }
210:                     break;
211:               
212:                     case 2:  // clk out
213:                     {
214:                       const BYTE rp[] = { 8, 11, 33 };
215:                       PinSetRpor(pin, enable ? rp[spi_num] : 0);
00F40E  780004     MOV W4, W0
00F410  07157B     RCALL PinSetRpor
00F440  E00003     CP0 W3
00F442  32FFE5     BRA Z, 0xF40E
00F444  2ED440     MOV #0xED44, W0
00F446  7C4060     MOV.B [W0+W8], W0
00F448  FB8080     ZE W0, W1
00F44A  780004     MOV W4, W0
00F44C  07155D     RCALL PinSetRpor
00F44E  37FFE1     BRA 0xF412
216:                     }
217:                     break;
218:                 }
219:               }
00F400  78044F     MOV [--W15], W8
00F402  060000     RETURN
00F412  78044F     MOV [--W15], W8
00F414  060000     RETURN
00F416  37FFF6     BRA 0xF404
00F43A  78044F     MOV [--W15], W8
00F43C  060000     RETURN
00F43E  37FFE2     BRA 0xF404
00F466  78044F     MOV [--W15], W8
00F468  060000     RETURN
00F46A  37FFCC     BRA 0xF404
220:               
221:               ////////////////////////////////////////////////////////////////////////////////
222:               // Reset
223:               ////////////////////////////////////////////////////////////////////////////////
224:               
225:               void HardReset() {
226:                 log_printf("HardReset()");
227:                 log_printf("Rebooting...");
228:                 Reset();
00F482  FE0000     RESET
229:               }
00F486  FA001E     LNK #0x1E
00F488  781F88     MOV W8, [W15++]
00F48A  780400     MOV W0, W8
230:               
231:               void SoftReset() {
232:                 BYTE ipl_backup = SRbits.IPL;
00F4F0  200428     MOV #0x42, W8
00F4F2  784418     MOV.B [W8], W8
00F4F4  FB8408     ZE W8, W8
00F4F6  DE4445     LSR W8, #5, W8
233:                 SRbits.IPL = 7;  // disable interrupts
00F4F8  B3CE00     MOV #0xE0, W0
00F4FA  B76042     IOR.B SR
234:                 log_printf("SoftReset()");
235:                 TimersInit();
00F4FC  0737F8     RCALL TimersInit
236:                 PinsInit();
237:                 PWMInit();
00F558  072B28     RCALL PWMInit
238:                 ADCInit();
00F55A  070DCD     RCALL ADCInit
239:                 UARTInit();
00F55C  07F7FB     RCALL UARTInit
240:                 SPIInit();
00F55E  07F558     RCALL SPIInit
241:                 I2CInit();
00F560  07FDE8     RCALL I2CInit
242:                 InCapInit();
00F562  07FB3F     RCALL InCapInit
243:               
244:                 // TODO: reset all peripherals!
245:                 SRbits.IPL = ipl_backup;  // enable interrupts
00F564  BFC042     MOV.B SR, WREG
00F566  60407F     AND.B W0, #0x1F, W0
00F568  704008     IOR.B W0, W8, W0
00F56A  B7E042     MOV.B WREG, SR
246:               }
00F56C  78054F     MOV [--W15], W10
00F56E  BE044F     MOV.D [--W15], W8
00F570  060000     RETURN
247:               
248:               void CheckInterface(BYTE interface_id[8]) {
249:                 OUTGOING_MESSAGE msg;
250:                 msg.type = CHECK_INTERFACE_RESPONSE;
00F48C  B3C020     MOV #0x2, W0
00F48E  9FE780     MOV.B W0, [W15-32]
251:                 msg.args.check_interface_response.supported
00F490  200082     MOV #0x8, W2
00F492  2ED4A1     MOV #0xED4A, W1
00F494  780008     MOV W8, W0
00F496  07B12A     RCALL memcmp
00F498  E00000     CP0 W0
00F49A  3A000D     BRA NZ, 0xF4B6
00F49C  B3C011     MOV #0x1, W1
00F49E  608061     AND W1, #0x1, W0
00F4A0  DD0048     SL W0, #8, W0
00F4A2  97B08F     MOV [W15-32], W1
00F4A4  A18001     BCLR W1, #8
00F4A6  708080     IOR W1, W0, W1
00F4A8  9FB781     MOV W1, [W15-32]
00F4EC  BE9F88     MOV.D W8, [W15++]
00F4EE  781F8A     MOV W10, [W15++]
252:                     = (memcmp(interface_id, PROTOCOL_IID_IOIO0003, 8) == 0)
253:                       || (memcmp(interface_id, PROTOCOL_IID_IOIO0002, 8) == 0)
254:                       || (memcmp(interface_id, PROTOCOL_IID_IOIO0001, 8) == 0)
255:                       || (memcmp(interface_id, PROTOCOL_IID_YTAI0001, 8) == 0)
256:                       || (memcmp(interface_id, PROTOCOL_IID_YTAI0002, 8) == 0);
257:                 AppProtocolSendMessage(&msg);
00F4AA  2FFE00     MOV #0xFFE0, W0
00F4AC  40000F     ADD W0, W15, W0
00F4AE  07EAEE     RCALL AppProtocolSendMessage
258:               }
00F4B0  78044F     MOV [--W15], W8
00F4B2  FA8000     ULNK
00F4B4  060000     RETURN
259:               
260:               // BOOKMARK(add_feature): Add feature implementation.
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/app_layer_v1/fake  -------
005478  57806A     SUB W15, #0xA, W0
00547A  DAC000     URUN
00541A  500FE2     SUB W0, #0x2, [W15]
00541C  3E0028     BRA GTU, 0x546E
00541E  838910     MOV __C30_UART, W0
005420  500FE1     SUB W0, #0x1, [W15]
005422  320008     BRA Z, 0x5434
005424  202380     MOV #0x238, W0
005426  E00000     CP0 W0
005428  320005     BRA Z, 0x5434
00542A  202304     MOV #0x230, W4
00542C  202325     MOV #0x232, W5
00542E  202346     MOV #0x234, W6
005430  780180     MOV W0, W3
005432  370004     BRA 0x543C
005434  202204     MOV #0x220, W4
005436  202225     MOV #0x222, W5
005438  202246     MOV #0x224, W6
00543A  202283     MOV #0x228, W3
00543C  904014     MOV.B [W4+1], W0
00543E  E00400     CP0.B W0
005440  350004     BRA LT, 0x544A
0053EE  838900     MOV __curbrk, W0
0053F0  E00000     CP0 W0
0053F2  3A0003     BRA NZ, 0x53FA
005442  EB0980     CLR [W3]
0053F4  070047     RCALL brk
0053F6  E00000     CP0 W0
0053F8  35000A     BRA LT, 0x540E
0053FA  838900     MOV __curbrk, W0
005444  904014     MOV.B [W4+1], W0
005446  A07400     BSET.B W0, #7
005448  984210     MOV.B W0, [W4+1]
005486  E00000     CP0 W0
005488  3A0004     BRA NZ, 0x5492
00544A  904015     MOV.B [W5+1], W0
00544C  A32800     BTST.Z W0, #2
00544E  3A0003     BRA NZ, 0x5456
00548A  271240     MOV #0x7124, W0
00548C  8B8900     MOV W0, __curbrk
00548E  780101     MOV W1, W2
005490  370006     BRA 0x549E
005450  904015     MOV.B [W5+1], W0
005452  A02400     BSET.B W0, #2
005454  984290     MOV.B W0, [W5+1]
005492  EB8100     SETM W2
005494  277240     MOV #0x7724, W0
005496  508F80     SUB W1, W0, [W15]
005498  3E0002     BRA GTU, 0x549E
0053FC  E00009     CP0 W9
0053FE  3A0002     BRA NZ, 0x5404
005456  EB0180     CLR W3
005458  370007     BRA 0x5468
005468  518F82     SUB W3, W2, [W15]
00546A  3AFFF7     BRA NZ, 0x545A
00546C  370008     BRA 0x547E
00549A  8B8901     MOV W1, __curbrk
00549C  EB0100     CLR W2
005400  780400     MOV W0, W8
005402  370006     BRA 0x5410
00545A  904015     MOV.B [W5+1], W0
00545C  A30800     BTST.Z W0, #0
00545E  32FFFD     BRA Z, 0x545A
005404  780400     MOV W0, W8
005460  78C063     MOV.B [W3+W1], W0
005462  FB0000     SE W0, W0
005464  780B00     MOV W0, [W6]
005466  E80183     INC W3, W3
005406  400009     ADD W0, W9, W0
005408  07003D     RCALL brk
00540A  E00000     CP0 W0
00540C  3D0001     BRA GE, 0x5410
00540E  EB8400     SETM W8
005416  FA000A     LNK #0xA
005418  780180     MOV W0, W3
00546E  200030     MOV #0x3, W0
005470  9FBFB0     MOV W0, [W15-10]
005472  9FBFC3     MOV W3, [W15-8]
005474  9FBFD1     MOV W1, [W15-6]
005476  9FBFE2     MOV W2, [W15-4]
00547C  97B96F     MOV [W15-4], W2
005484  780080     MOV W0, W1
0053EA  BE9F88     MOV.D W8, [W15++]
0053EC  780480     MOV W0, W9
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/app_layer_v1/digital.c  --
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                #include "digital.h"
30:                
31:                #include "Compiler.h"
32:                #include "logging.h"
33:                #include "pins.h"
34:                #include "protocol.h"
35:                #include "sync.h"
36:                
37:                void SetDigitalOutLevel(int pin, int value) {
38:                  log_printf("SetDigitalOutLevel(%d, %d)", pin, value);
39:                  SAVE_PIN_FOR_LOG(pin);
40:                  BYTE prev = SyncInterruptLevel(4);
41:                  PinSetLat(pin, value);
010DCC  070829     RCALL PinSetLat
42:                  SyncInterruptLevel(prev);
43:                }
010DDE  F80036     PUSH RCOUNT
010DE0  BE9F80     MOV.D W0, [W15++]
010DE2  BE9F82     MOV.D W2, [W15++]
010DE4  BE9F84     MOV.D W4, [W15++]
010DE6  BE9F86     MOV.D W6, [W15++]
010DE8  BE9F88     MOV.D W8, [W15++]
010DEA  BE9F8A     MOV.D W10, [W15++]
010DEC  F80032     PUSH DSRPAG
010DEE  202000     MOV #0x200, W0
010DF0  880190     MOV W0, DSRPAG
010DF2  FA00AE     LNK #0xAE
44:                
45:                void SetChangeNotify(int pin, int changeNotify) {
46:                  int cnie_backup = _CNIE;
010D7C  BFC096     MOV.B IEC1, WREG
010D7E  DE0043     LSR W0, #3, W0
010D80  600561     AND W0, #0x1, W10
010DB6  200428     MOV #0x42, W8
010DB8  784418     MOV.B [W8], W8
010DBA  FB8408     ZE W8, W8
010DBC  DE4445     LSR W8, #5, W8
010DCE  BFC042     MOV.B SR, WREG
47:                  log_printf("SetChangeNotify(%d, %d)", pin, changeNotify);
010DBE  200422     MOV #0x42, W2
010DC0  784112     MOV.B [W2], W2
010DC2  61417F     AND.B W2, #0x1F, W2
010DC4  A07402     BSET.B W2, #7
010DC6  FD0100     EXCH W0, W2
010DC8  B7E042     MOV.B WREG, SR
010DCA  FD0100     EXCH W0, W2
010DD0  DD4445     SL W8, #5, W8
010DD2  BFC042     MOV.B SR, WREG
010DD4  60407F     AND.B W0, #0x1F, W0
010DD6  704008     IOR.B W0, W8, W0
010DD8  B7E042     MOV.B WREG, SR
48:                  SAVE_PIN_FOR_LOG(pin);
49:                  _CNIE = 0;
010D82  A96096     BCLR IEC1, #3
50:                  PinSetCnen(pin, changeNotify);
010D84  780009     MOV W9, W0
010D86  07086F     RCALL PinSetCnen
51:                  if (changeNotify) {
010D88  E00008     CP0 W8
010D8A  3A0008     BRA NZ, 0x10D9C
52:                    PinSetCnforce(pin);
010D9C  780009     MOV W9, W0
010D9E  070889     RCALL PinSetCnforce
53:                    _CNIF = 1;  // force a status message on the new pin
010DA0  A86086     BSET IFS1, #3
54:                  }
55:                  _CNIE = cnie_backup;
010D8C  DD50C3     SL W10, #3, W1
010D8E  BFC096     MOV.B IEC1, WREG
010D90  A13400     BCLR.B W0, #3
010D92  704001     IOR.B W0, W1, W0
010D94  B7E096     MOV.B WREG, IEC1
010DA2  DD50C3     SL W10, #3, W1
010DA4  BFC096     MOV.B IEC1, WREG
010DA6  A13400     BCLR.B W0, #3
010DA8  704001     IOR.B W0, W1, W0
010DAA  B7E096     MOV.B WREG, IEC1
56:                }
010D96  78054F     MOV [--W15], W10
010D98  BE044F     MOV.D [--W15], W8
010D9A  060000     RETURN
010DB4  781F88     MOV W8, [W15++]
57:                
58:                static void SendDigitalInStatusMessage(int pin, int value) {
59:                  log_printf("SendDigitalInStatusMessage(%d, %d)", pin, value);
60:                  SAVE_PIN_FOR_LOG(pin);
61:                  OUTGOING_MESSAGE msg;
62:                  msg.type = REPORT_DIGITAL_IN_STATUS;
010EE0  B3C041     MOV #0x4, W1
010EE2  9ED7A1     MOV.B W1, [W15-174]
010F0E  B3C041     MOV #0x4, W1
010F10  784D81     MOV.B W1, [W11]
010F32  B3C041     MOV #0x4, W1
010F34  784C81     MOV.B W1, [W9]
010F58  B3C041     MOV #0x4, W1
010F5A  784D81     MOV.B W1, [W11]
010F7C  B3C041     MOV #0x4, W1
010F7E  784C81     MOV.B W1, [W9]
010FA2  B3C041     MOV #0x4, W1
010FA4  784D81     MOV.B W1, [W11]
63:                  msg.args.report_digital_in_status.pin = pin;
010EE4  DD004A     SL W0, #10, W0
010EE6  203FF1     MOV #0x3FF, W1
010EE8  97291F     MOV [W15-174], W2
010EEA  610101     AND W2, W1, W2
010EEC  710080     IOR W2, W0, W1
010F12  DD0042     SL W0, #2, W0
010F14  96F08F     MOV.B [W15-144], W1
010F16  60C0E2     AND.B W1, #0x2, W1
010F36  DD004A     SL W0, #10, W0
010F38  203FF1     MOV #0x3FF, W1
010F3A  608C99     AND W1, [W9], [W9]
010F3C  700C99     IOR W0, [W9], [W9]
010F5C  DD0042     SL W0, #2, W0
010F5E  9768AF     MOV.B [W15-86], W1
010F60  60C0E2     AND.B W1, #0x2, W1
010F80  DD004A     SL W0, #10, W0
010F82  203FF1     MOV #0x3FF, W1
010F84  608C99     AND W1, [W9], [W9]
010F86  700C99     IOR W0, [W9], [W9]
010FA6  DD0042     SL W0, #2, W0
010FA8  97E0CF     MOV.B [W15-28], W1
010FAA  60C0E2     AND.B W1, #0x2, W1
64:                  msg.args.report_digital_in_status.level = value;
010EEE  648061     AND W9, #0x1, W0
010EF0  DD0048     SL W0, #8, W0
010EF2  780101     MOV W1, W2
010EF4  A18002     BCLR W2, #8
010EF6  710080     IOR W2, W0, W1
010EF8  9F2F91     MOV W1, [W15-174]
010F18  64C161     AND.B W9, #0x1, W2
010F1A  70C080     IOR.B W1, W0, W1
010F1C  70C082     IOR.B W1, W2, W1
010F1E  9EF781     MOV.B W1, [W15-144]
010F3E  650061     AND W10, #0x1, W0
010F40  DD0048     SL W0, #8, W0
010F42  A18019     BCLR [W9], #8
010F44  700C99     IOR W0, [W9], [W9]
010F62  64C161     AND.B W9, #0x1, W2
010F64  70C080     IOR.B W1, W0, W1
010F66  70C082     IOR.B W1, W2, W1
010F68  9F6FA1     MOV.B W1, [W15-86]
010F88  650061     AND W10, #0x1, W0
010F8A  DD0048     SL W0, #8, W0
010F8C  A18019     BCLR [W9], #8
010F8E  700C99     IOR W0, [W9], [W9]
010FAC  64C161     AND.B W9, #0x1, W2
010FAE  70C080     IOR.B W1, W0, W1
010FB0  70C082     IOR.B W1, W2, W1
010FB2  9FE7C1     MOV.B W1, [W15-28]
65:                  AppProtocolSendMessage(&msg);
010EFA  2FF520     MOV #0xFF52, W0
010EFC  40000F     ADD W0, W15, W0
010EFE  07DDC6     RCALL AppProtocolSendMessage
010F20  78000B     MOV W11, W0
010F22  07DDB4     RCALL AppProtocolSendMessage
010F46  780009     MOV W9, W0
010F48  07DDA1     RCALL AppProtocolSendMessage
010F6A  78000B     MOV W11, W0
010F6C  07DD8F     RCALL AppProtocolSendMessage
010F90  780009     MOV W9, W0
010F92  07DD7C     RCALL AppProtocolSendMessage
010FB4  78000B     MOV W11, W0
010FB6  07DD6A     RCALL AppProtocolSendMessage
66:                }
67:                
68:                #define CHECK_PORT_CHANGE(name)                                        \
69:                  do {                                                                 \
70:                    unsigned int i = 0;                                                \
71:                    unsigned int port = PORT##name;                                    \
72:                    unsigned int changed = (CNFORCE##name | (port ^ CNBACKUP##name))   \
73:                                           & CNEN##name;                               \
74:                    CNBACKUP##name = port;                                             \
75:                    CNFORCE##name = 0x0000;                                            \
76:                    while (changed) {                                                  \
77:                      if (changed & 1) {                                               \
78:                        SendDigitalInStatusMessage(PinFromPort##name(i), (port & 1));  \
79:                      }                                                                \
80:                      ++i;                                                             \
81:                      port >>= 1;                                                      \
82:                      changed >>= 1;                                                   \
83:                    }                                                                  \
84:                  } while (0)
85:                
86:                
87:                void __attribute__((__interrupt__, auto_psv)) _CNInterrupt() {
88:                  _CNIF = 0;
010DF4  A96086     BCLR IFS1, #3
89:                  log_printf("_CNInterrupt()");
90:                
91:                  CHECK_PORT_CHANGE(B);
010DF6  801659     MOV PORTB, W9
010DF8  80E2D0     MOV CNBACKUPB, W0
010DFA  6C8000     XOR W9, W0, W0
010DFC  B71C66     IOR CNFORCEB, WREG
010DFE  80E391     MOV CNENB, W1
010E00  608400     AND W1, W0, W8
010E02  88E2D9     MOV W9, CNBACKUPB
010E04  EF3C66     CLR CNFORCEB
010E06  320007     BRA Z, 0x10E16
010E08  EB0500     CLR W10
010E0A  A30808     BTST.Z W8, #0
010E0C  3A0067     BRA NZ, 0x10EDC
010E0E  E8050A     INC W10, W10
010E10  D10489     LSR W9, W9
010E12  D10408     LSR W8, W8
010E14  3AFFFA     BRA NZ, 0x10E0A
010EDC  78000A     MOV W10, W0
010EDE  07081C     RCALL PinFromPortB
010F00  E8050A     INC W10, W10
010F02  D10489     LSR W9, W9
010F04  D10408     LSR W8, W8
010F06  3AFF81     BRA NZ, 0x10E0A
010F08  37FF86     BRA 0x10E16
92:                  CHECK_PORT_CHANGE(C);
010E16  801699     MOV PORTC, W9
010E18  80E2C0     MOV CNBACKUPC, W0
010E1A  6C8000     XOR W9, W0, W0
010E1C  B71C64     IOR CNFORCEC, WREG
010E1E  80E382     MOV CNENC, W2
010E20  610400     AND W2, W0, W8
010E22  88E2C9     MOV W9, CNBACKUPC
010E24  EF3C64     CLR CNFORCEC
010E26  320009     BRA Z, 0x10E3A
010E28  EB0500     CLR W10
010E2A  2FF6F0     MOV #0xFF6F, W0
010E2C  478580     ADD W15, W0, W11
010E2E  A30808     BTST.Z W8, #0
010E30  3A006C     BRA NZ, 0x10F0A
010E32  E8050A     INC W10, W10
010E34  D10489     LSR W9, W9
010E36  D10408     LSR W8, W8
010E38  3AFFFA     BRA NZ, 0x10E2E
010F0A  78000A     MOV W10, W0
010F0C  070809     RCALL PinFromPortC
010F24  E8050A     INC W10, W10
010F26  D10489     LSR W9, W9
010F28  D10408     LSR W8, W8
010F2A  3AFF81     BRA NZ, 0x10E2E
010F2C  37FF86     BRA 0x10E3A
93:                  CHECK_PORT_CHANGE(D);
010E3A  8016DA     MOV PORTD, W10
010E3C  80E2B0     MOV CNBACKUPD, W0
010E3E  6D0000     XOR W10, W0, W0
010E40  B71C62     IOR CNFORCED, WREG
010E42  80E371     MOV CNEND, W1
010E44  608400     AND W1, W0, W8
010E46  88E2BA     MOV W10, CNBACKUPD
010E48  EF3C62     CLR CNFORCED
010E4A  320009     BRA Z, 0x10E5E
010E4C  EB0580     CLR W11
010E4E  2FF8C9     MOV #0xFF8C, W9
010E50  478489     ADD W15, W9, W9
010E52  A30808     BTST.Z W8, #0
010E54  3A006C     BRA NZ, 0x10F2E
010E56  E8058B     INC W11, W11
010E58  D1050A     LSR W10, W10
010E5A  D10408     LSR W8, W8
010E5C  3AFFFA     BRA NZ, 0x10E52
010F2E  78000B     MOV W11, W0
010F30  0707FC     RCALL PinFromPortD
010F4A  E8058B     INC W11, W11
010F4C  D1050A     LSR W10, W10
010F4E  D10408     LSR W8, W8
010F50  3AFF80     BRA NZ, 0x10E52
010F52  37FF85     BRA 0x10E5E
94:                  CHECK_PORT_CHANGE(E);
010E5E  801719     MOV PORTE, W9
010E60  80E2A0     MOV CNBACKUPE, W0
010E62  6C8000     XOR W9, W0, W0
010E64  B71C60     IOR CNFORCEE, WREG
010E66  80E362     MOV CNENE, W2
010E68  610400     AND W2, W0, W8
010E6A  88E2A9     MOV W9, CNBACKUPE
010E6C  EF3C60     CLR CNFORCEE
010E6E  320009     BRA Z, 0x10E82
010E70  EB0500     CLR W10
010E72  2FFA9B     MOV #0xFFA9, W11
010E74  47858B     ADD W15, W11, W11
010E76  A30808     BTST.Z W8, #0
010E78  3A006D     BRA NZ, 0x10F54
010E7A  E8050A     INC W10, W10
010E7C  D10489     LSR W9, W9
010E7E  D10408     LSR W8, W8
010E80  3AFFFA     BRA NZ, 0x10E76
010F54  78000A     MOV W10, W0
010F56  0707EE     RCALL PinFromPortE
010F6E  E8050A     INC W10, W10
010F70  D10489     LSR W9, W9
010F72  D10408     LSR W8, W8
010F74  3AFF80     BRA NZ, 0x10E76
010F76  37FF85     BRA 0x10E82
95:                  CHECK_PORT_CHANGE(F);
010E82  80175A     MOV PORTF, W10
010E84  80E290     MOV CNBACKUPF, W0
010E86  6D0000     XOR W10, W0, W0
010E88  B71C5E     IOR CNFORCEF, WREG
010E8A  80E351     MOV CNENF, W1
010E8C  608400     AND W1, W0, W8
010E8E  88E29A     MOV W10, CNBACKUPF
010E90  EF3C5E     CLR CNFORCEF
010E92  320009     BRA Z, 0x10EA6
010E94  EB0580     CLR W11
010E96  2FFC69     MOV #0xFFC6, W9
010E98  478489     ADD W15, W9, W9
010E9A  A30808     BTST.Z W8, #0
010E9C  3A006D     BRA NZ, 0x10F78
010E9E  E8058B     INC W11, W11
010EA0  D1050A     LSR W10, W10
010EA2  D10408     LSR W8, W8
010EA4  3AFFFA     BRA NZ, 0x10E9A
010F78  78000B     MOV W11, W0
010F7A  0707E1     RCALL PinFromPortF
010F94  E8058B     INC W11, W11
010F96  D1050A     LSR W10, W10
010F98  D10408     LSR W8, W8
010F9A  3AFF7F     BRA NZ, 0x10E9A
010F9C  37FF84     BRA 0x10EA6
96:                  CHECK_PORT_CHANGE(G);
010EA6  801799     MOV PORTG, W9
010EA8  80E280     MOV CNBACKUPG, W0
010EAA  6C8000     XOR W9, W0, W0
010EAC  B71C5C     IOR CNFORCEG, WREG
010EAE  80E342     MOV CNENG, W2
010EB0  610400     AND W2, W0, W8
010EB2  88E289     MOV W9, CNBACKUPG
010EB4  EF3C5C     CLR CNFORCEG
010EB6  320008     BRA Z, 0x10EC8
010EB8  EB0500     CLR W10
010EBA  5785FD     SUB W15, #0x1D, W11
010EBC  A30808     BTST.Z W8, #0
010EBE  3A006F     BRA NZ, 0x10F9E
010EC0  E8050A     INC W10, W10
010EC2  D10489     LSR W9, W9
010EC4  D10408     LSR W8, W8
010EC6  3AFFFA     BRA NZ, 0x10EBC
010F9E  78000A     MOV W10, W0
010FA0  0707D3     RCALL PinFromPortG
97:                }
010EC8  FA8000     ULNK
010ECA  F90032     POP DSRPAG
010ECC  BE054F     MOV.D [--W15], W10
010ECE  BE044F     MOV.D [--W15], W8
010ED0  BE034F     MOV.D [--W15], W6
010ED2  BE024F     MOV.D [--W15], W4
010ED4  BE014F     MOV.D [--W15], W2
010ED6  BE004F     MOV.D [--W15], W0
010ED8  F90036     POP RCOUNT
010EDA  064000     RETFIE
010D74  BE9F88     MOV.D W8, [W15++]
010D76  781F8A     MOV W10, [W15++]
010D78  780480     MOV W0, W9
010D7A  780401     MOV W1, W8
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/app_layer_v1/byte_queue.c  
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                #include "byte_queue.h"
30:                
31:                #include <assert.h>
32:                #include <string.h>
33:                #include "logging.h"
34:                
35:                void ByteQueueOverflow() {
36:                  // TODO: do something
37:                  log_printf("Buffer overflow!");
38:                }
011AC0  780100     MOV W0, W2
39:                
40:                void ByteQueuePushByte(BYTE_QUEUE* q, BYTE b) {
41:                  if (q->size == q->capacity) {
011B4E  9000C0     MOV [W0+8], W1
011B50  900010     MOV [W0+2], W0
011B52  508F80     SUB W1, W0, [W15]
011B54  32000B     BRA Z, 0x11B6C
42:                    ByteQueueOverflow();
43:                    return;
44:                  }
45:                  q->buf[q->write_cursor++] = b;
011B56  900032     MOV [W2+6], W0
011B58  780092     MOV [W2], W1
011B5A  787083     MOV.B W3, [W1+W0]
011B5C  E80000     INC W0, W0
011B5E  980130     MOV W0, [W2+6]
46:                  if (q->write_cursor == q->capacity) {
011B60  900092     MOV [W2+2], W1
011B62  500F81     SUB W0, W1, [W15]
011B64  320004     BRA Z, 0x11B6E
47:                    q->write_cursor = 0;
011B6E  EB0000     CLR W0
011B70  980130     MOV W0, [W2+6]
48:                  }
49:                  ++q->size;
011B66  900042     MOV [W2+8], W0
011B68  E80000     INC W0, W0
011B6A  980140     MOV W0, [W2+8]
011B6C  060000     RETURN
011B7A  BE9F88     MOV.D W8, [W15++]
011B7C  BE9F8A     MOV.D W10, [W15++]
011B7E  780400     MOV W0, W8
011B80  780581     MOV W1, W11
011B82  780482     MOV W2, W9
50:                }
51:                
52:                BYTE ByteQueuePullByte(BYTE_QUEUE* q) {
53:                  BYTE ret;
54:                  assert(q->size);
55:                  ret = q->buf[q->read_cursor++];
011AC2  900020     MOV [W0+4], W0
011AC4  780092     MOV [W2], W1
011AC6  7841E1     MOV.B [W1+W0], W3
011AC8  E80000     INC W0, W0
011ACA  980120     MOV W0, [W2+4]
56:                  if (q->read_cursor == q->capacity) {
011ACC  900092     MOV [W2+2], W1
011ACE  500F81     SUB W0, W1, [W15]
011AD0  320005     BRA Z, 0x11ADC
57:                    q->read_cursor = 0;
011ADC  EB0000     CLR W0
011ADE  980120     MOV W0, [W2+4]
58:                  }
59:                  --q->size;
011AD2  900042     MOV [W2+8], W0
011AD4  E90000     DEC W0, W0
011AD6  980140     MOV W0, [W2+8]
011AD8  FB8003     ZE W3, W0
011AE0  900042     MOV [W2+8], W0
011AE2  E90000     DEC W0, W0
011AE4  980140     MOV W0, [W2+8]
011AE6  FB8003     ZE W3, W0
60:                  return ret;
61:                }
011ADA  060000     RETURN
011AEC  780380     MOV W0, W7
62:                
63:                void ByteQueuePullToBuffer(BYTE_QUEUE* q, void* buffer, int size) {
64:                  const BYTE *data1, *data2;
65:                  int size1, size2;
66:                  assert(q->size >= size);
67:                  ByteQueuePeekMax(q, size, &data1, &size1, &data2, &size2);
68:                  if (size1) memcpy(buffer, data1, size1);
011C10  E00009     CP0 W9
011C12  3A001C     BRA NZ, 0x11C4C
011C3C  E00009     CP0 W9
011C3E  32FFEA     BRA Z, 0x11C14
011C40  370005     BRA 0x11C4C
011C4C  780109     MOV W9, W2
011C4E  780085     MOV W5, W1
011C50  78000C     MOV W12, W0
011C52  079D45     RCALL memcpy
69:                  if (size2) memcpy(((BYTE *) buffer) + size1, data2, size2);
011C14  E0000B     CP0 W11
011C16  3A0015     BRA NZ, 0x11C42
011C42  460009     ADD W12, W9, W0
011C44  78010B     MOV W11, W2
011C46  78008D     MOV W13, W1
011C48  079D4A     RCALL memcpy
011C4A  37FFE6     BRA 0x11C18
70:                  ByteQueuePull(q, size);
71:                }
011C2E  BE064F     MOV.D [--W15], W12
011C30  BE054F     MOV.D [--W15], W10
011C32  BE044F     MOV.D [--W15], W8
011C34  060000     RETURN
72:                
73:                void ByteQueuePushBuffer(BYTE_QUEUE* q, const void* buf, int len) {
74:                  if (!len) return;
011B84  E00002     CP0 W2
011B86  320016     BRA Z, 0x11BB4
75:                  if (q->size + len > q->capacity) {
011B88  900110     MOV [W0+2], W2
011B8A  900040     MOV [W0+8], W0
011B8C  448000     ADD W9, W0, W0
011B8E  500F82     SUB W0, W2, [W15]
011B90  3C0011     BRA GT, 0x11BB4
76:                    ByteQueueOverflow();
77:                    return;
78:                  }
79:                  if (q->write_cursor + len <= q->capacity) {
011B92  9000B8     MOV [W8+6], W1
011B94  448001     ADD W9, W1, W0
011B96  510F80     SUB W2, W0, [W15]
011B98  350010     BRA LT, 0x11BBA
80:                    memcpy(q->buf + q->write_cursor, buf, len);
011B9A  408018     ADD W1, [W8], W0
011B9C  780109     MOV W9, W2
011B9E  78008B     MOV W11, W1
011BA0  079D9E     RCALL memcpy
81:                    q->write_cursor += len;
011BA2  900038     MOV [W8+6], W0
011BA4  448000     ADD W9, W0, W0
011BA6  980430     MOV W0, [W8+6]
82:                    if (q->write_cursor == q->capacity) {
011BA8  900098     MOV [W8+2], W1
011BAA  500F81     SUB W0, W1, [W15]
011BAC  320018     BRA Z, 0x11BDE
83:                      q->write_cursor -= q->capacity;
011BDE  EB0000     CLR W0
011BE0  980430     MOV W0, [W8+6]
84:                    }
85:                  } else {
86:                    int size_first = q->capacity - q->write_cursor;
011BBA  510501     SUB W2, W1, W10
87:                    memcpy(q->buf + q->write_cursor, buf, size_first);
011BBC  408018     ADD W1, [W8], W0
011BBE  78010A     MOV W10, W2
011BC0  78008B     MOV W11, W1
011BC2  079D8D     RCALL memcpy
88:                    memcpy(q->buf, ((const BYTE*) buf) + size_first, len - size_first);
011BC4  780018     MOV [W8], W0
011BC6  54810A     SUB W9, W10, W2
011BC8  45808A     ADD W11, W10, W1
011BCA  079D89     RCALL memcpy
89:                    q->write_cursor += len - q->capacity;
011BCC  900018     MOV [W8+2], W0
011BCE  548000     SUB W9, W0, W0
011BD0  9000B8     MOV [W8+6], W1
011BD2  400001     ADD W0, W1, W0
011BD4  980430     MOV W0, [W8+6]
90:                  }
91:                  q->size += len;
011BAE  900048     MOV [W8+8], W0
011BB0  448000     ADD W9, W0, W0
011BB2  980440     MOV W0, [W8+8]
011BD6  900048     MOV [W8+8], W0
011BD8  448000     ADD W9, W0, W0
011BDA  980440     MOV W0, [W8+8]
011BDC  37FFEB     BRA 0x11BB4
011BEA  BE9F88     MOV.D W8, [W15++]
011BEC  BE9F8A     MOV.D W10, [W15++]
011BEE  BE9F8C     MOV.D W12, [W15++]
011BF0  780400     MOV W0, W8
011BF2  780601     MOV W1, W12
011BF4  780502     MOV W2, W10
92:                }
011BB4  BE054F     MOV.D [--W15], W10
011BB6  BE044F     MOV.D [--W15], W8
011BB8  060000     RETURN
93:                
94:                void ByteQueuePeek(BYTE_QUEUE* q, const BYTE** data, int* size) {
95:                  *data = q->buf + q->read_cursor;
011B2C  9001A0     MOV [W0+4], W3
011B2E  418890     ADD W3, [W0], [W1]
96:                  if (!q->size) {
011B30  9000C0     MOV [W0+8], W1
011B32  E00001     CP0 W1
011B34  3A0002     BRA NZ, 0x11B3A
97:                    *size = 0;
011B36  780901     MOV W1, [W2]
011B38  060000     RETURN
98:                  } else if (q->write_cursor <= q->read_cursor) {
011B3A  9000B0     MOV [W0+6], W1
011B3C  508F83     SUB W1, W3, [W15]
011B3E  340002     BRA LE, 0x11B44
99:                    *size = q->capacity - q->read_cursor;
011B4A  780100     MOV W0, W2
011B4C  784181     MOV.B W1, W3
100:                 } else {
101:                   *size = q->write_cursor - q->read_cursor;
011B40  508903     SUB W1, W3, [W2]
011B42  060000     RETURN
102:                 }
103:               }
104:               
105:               /*
106:               void ByteQueuePeekAll(BYTE_QUEUE* q, const BYTE** data1, int* size1,
107:                                     const BYTE** data2, int* size2) {
108:                 *data1 = q->buf + q->read_cursor;
109:                 if (q->write_cursor < q->read_cursor) {
110:                   *size1 = q->capacity - q->read_cursor;
111:                   *data2 = q->buf;
112:                   *size2 = q->write_cursor;
113:                 } else {
114:                   *size1 = q->write_cursor - q->read_cursor;
115:                   *size2 = 0;
116:                 }
117:               }
118:               */
119:               
120:               void ByteQueuePeekMax(BYTE_QUEUE* q, int max_size, const BYTE** data1,
121:                                     int* size1, const BYTE** data2, int* size2) {
122:                 if (max_size > q->size) max_size = q->size;
011AEE  900340     MOV [W0+8], W6
011AF0  530F81     SUB W6, W1, [W15]
011AF2  350001     BRA LT, 0x11AF6
011AF4  780301     MOV W1, W6
011BF6  9001C0     MOV [W0+8], W3
011BF8  510F83     SUB W2, W3, [W15]
011BFA  3C0001     BRA GT, 0x11BFE
011BFC  780182     MOV W2, W3
123:                 *data1 = q->buf + q->read_cursor;
011AF6  9000A7     MOV [W7+4], W1
011AF8  408917     ADD W1, [W7], [W2]
011BFE  780098     MOV [W8], W1
011C00  900128     MOV [W8+4], W2
011C02  408282     ADD W1, W2, W5
124:                 if (q->read_cursor + max_size > q->capacity) {
011AFA  900117     MOV [W7+2], W2
011AFC  430001     ADD W6, W1, W0
011AFE  500F82     SUB W0, W2, [W15]
011B00  340005     BRA LE, 0x11B0C
011C04  900218     MOV [W8+2], W4
011C06  418002     ADD W3, W2, W0
011C08  500F84     SUB W0, W4, [W15]
011C0A  3C0015     BRA GT, 0x11C36
011C0C  780483     MOV W3, W9
011C0E  EB0580     CLR W11
125:                   *size1 = q->capacity - q->read_cursor;
011B02  510001     SUB W2, W1, W0
011B04  780980     MOV W0, [W3]
011C36  520482     SUB W4, W2, W9
126:                   *data2 = q->buf;
011B06  780A17     MOV [W7], [W4]
011C38  780681     MOV W1, W13
127:                   *size2 = max_size - *size1;
011B08  530A80     SUB W6, W0, [W5]
011B0A  060000     RETURN
011C3A  518589     SUB W3, W9, W11
128:                 } else {
129:                   *size1 = max_size;
011B0C  780986     MOV W6, [W3]
130:                   *size2 = 0;
011B12  780100     MOV W0, W2
131:                 }
132:               }
133:               
134:               void ByteQueuePull(BYTE_QUEUE* q, int size) {
135:                 assert(size <= q->size);
136:                 q->read_cursor += size;
011B14  900020     MOV [W0+4], W0
011B16  408180     ADD W1, W0, W3
011B18  980123     MOV W3, [W2+4]
011C18  900028     MOV [W8+4], W0
011C1A  450080     ADD W10, W0, W1
011C1C  980421     MOV W1, [W8+4]
137:                 q->size -= size;
011B1A  900042     MOV [W2+8], W0
011B1C  500001     SUB W0, W1, W0
011B1E  980140     MOV W0, [W2+8]
011C1E  900048     MOV [W8+8], W0
011C20  50000A     SUB W0, W10, W0
011C22  980440     MOV W0, [W8+8]
138:                 if (q->read_cursor >= q->capacity) {
011B20  900012     MOV [W2+2], W0
011B22  518F80     SUB W3, W0, [W15]
011B24  350002     BRA LT, 0x11B2A
011C24  900018     MOV [W8+2], W0
011C26  508F80     SUB W1, W0, [W15]
011C28  350002     BRA LT, 0x11C2E
139:                   q->read_cursor -= q->capacity;
011C2A  508000     SUB W1, W0, W0
011C2C  980420     MOV W0, [W8+4]
140:                 }
141:               }
---  /Users/mchintamani/Documents/Manju/personal/pixelart_rebase/ioio/firmware/app_layer_v1/adc.c  ------
010FC2  F80036     PUSH RCOUNT
010FC4  BE9F80     MOV.D W0, [W15++]
010FC6  BE9F82     MOV.D W2, [W15++]
010FC8  BE9F84     MOV.D W4, [W15++]
010FCA  BE9F86     MOV.D W6, [W15++]
010FCC  BE9F88     MOV.D W8, [W15++]
010FCE  BE9F8A     MOV.D W10, [W15++]
010FD0  F80032     PUSH DSRPAG
010FD2  202000     MOV #0x200, W0
010FD4  880190     MOV W0, DSRPAG
010FD6  FA0032     LNK #0x32
1:                 /*
2:                  * Copyright 2011 Ytai Ben-Tsvi. All rights reserved.
3:                  *
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without modification, are
6:                  * permitted provided that the following conditions are met:
7:                  *
8:                  *    1. Redistributions of source code must retain the above copyright notice, this list of
9:                  *       conditions and the following disclaimer.
10:                 *
11:                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
12:                 *       of conditions and the following disclaimer in the documentation and/or other materials
13:                 *       provided with the distribution.
14:                 *
15:                 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
16:                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
17:                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARSHAN POURSOHI OR
18:                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
19:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
20:                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
21:                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
22:                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
23:                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24:                 *
25:                 * The views and conclusions contained in the software and documentation are those of the
26:                 * authors and should not be interpreted as representing official policies, either expressed
27:                 * or implied.
28:                 */
29:                
30:                #include "adc.h"
31:                
32:                #include <assert.h>
33:                #include "Compiler.h"
34:                #include "logging.h"
35:                #include "protocol.h"
36:                #include "pins.h"
37:                
38:                static unsigned int analog_scan_bitmask;
39:                static int analog_scan_num_channels;
40:                
41:                // we need to generate a priority 1 interrupt in order to send a message
42:                // containing ADC-captured data.
43:                // this is the reasononing:
44:                // we need to protect the outgoing-message buffer from concurrent access. this
45:                // is achieved by making sure it is only written to by priority 1 code.
46:                // however, in the case of ADC, we must service the "done" interrupt quickly
47:                // to stop the ADC before our buffer gets overwritten, so this would be a
48:                // priority 6 interrupt. then, in order to write to the output buffer, it would
49:                // trigger the priority 1 interrupt using GFX1, that will read the ADC data and
50:                // write to the buffer.
51:                // we've "abused" CRC interrupt that is never used in order to generate the
52:                // interrupt - we just manually raise its IF flag whenever we need an interrupt
53:                // and service this interrupt.
54:                static inline void ScanDoneInterruptInit() {
55:                  _CRCIP = 1;
011120  BFC0C5     MOV.B 0xC5, WREG
011122  B3C8F1     MOV #0x8F, W1
011124  604001     AND.B W0, W1, W0
011126  A04400     BSET.B W0, #4
011128  B7E0C5     MOV.B WREG, 0xC5
56:                }
57:                
58:                // call this function to generate the priority 1 interrupt.
59:                static inline void ScanDoneInterruptTrigger() {
60:                  _CRCIF = 1;
0110EE  A8608C     BSET IFS4, #3
61:                }
62:                
63:                // timer 3 is clocked @2MHz
64:                // we set its period to 2000 so that a match occurs @1KHz
65:                // used for ADC
66:                static inline void Timer3Init() {
67:                  PR3   = 0xFFFF;  // period is 65536 clocks = 30.5KHz
0110FE  EFA10E     SETM PR3
68:                  _T3IP = 1;       // interrupt priority 1 (this interrupt may write to outgoing channel)
011100  BFC0A8     MOV.B IPC2, WREG
011102  B3CF81     MOV #0xF8, W1
011104  604001     AND.B W0, W1, W0
011106  A00400     BSET.B W0, #0
011108  B7E0A8     MOV.B WREG, IPC2
69:                }
70:                
71:                static inline void ADCStart() {
72:                  // Clear any possibly remaining interrupts before enabling them.
73:                  _AD1IF = 0;
01119E  A9A085     BCLR 0x85, #5
74:                  _CRCIF = 0;
0111A0  A9608C     BCLR IFS4, #3
75:                
76:                  _ADON = 1;  // ADC on
0111A2  A8E321     BSET 0x321, #7
77:                
78:                  _CRCIE = 1;  // We can enable interrupts now, they won't fire.
0111A4  A8609C     BSET IEC4, #3
79:                  _AD1IE = 1;
0111A6  A8A095     BSET 0x95, #5
80:                
81:                  // Reset counter and start triggering.
82:                  TMR3  = 0x0000;  // reset counter
0111A8  880850     MOV W0, TMR3
83:                  _T3IF = 0;
0111AA  A90085     BCLR 0x85, #0
84:                  _T3IE = 1;  // We're ready to handle trigger interrupts.
0111AC  A80095     BSET 0x95, #0
85:                }
86:                
87:                // IMPORTANT:
88:                // A post-condition of this function is that no interrupts (related to this
89:                // module) will fire.
90:                static inline void ADCStop() {
91:                  // Disable interrupts
92:                  _T3IE = 0;
0110F6  A90095     BCLR 0x95, #0
011164  A90095     BCLR 0x95, #0
93:                  _AD1IE = 0;
0110F8  A9A095     BCLR 0x95, #5
011166  A9A095     BCLR 0x95, #5
94:                  _CRCIE = 0;
0110FA  A9609C     BCLR IEC4, #3
011168  A9609C     BCLR IEC4, #3
95:                  // No more interrupts at this point.
96:                  _ADON = 0;         // ADC off
0110FC  A9E321     BCLR 0x321, #7
01116A  A9E321     BCLR 0x321, #7
97:                }
98:                
99:                void ADCInit() {
100:                 ADCStop();        // Just in case we were running. No interrupts after this point.
101:                 Timer3Init();  // initiliaze the timer. stopped if already running.
102:               
103:                 // Now nothing will interrupt us
104:                 AD1CON1 = 0x00E0;  // ADC off, auto-convert
01110A  200E00     MOV #0xE0, W0
01110C  881900     MOV W0, AD1CON1
105:                 AD1CON2 = 0x0400;  // Avdd Avss ref, scan inputs, single buffer, interrupt on every sample
01110E  B03200     ADD #0x320, W0
011110  881910     MOV W0, AD1CON2
106:                 AD1CON3 = 0x1F01;  // system clock, 31 Tad acquisition time, ADC clock @8MHz
011112  21F010     MOV #0x1F01, W0
011114  881920     MOV W0, AD1CON3
107:                 AD1CHS  = 0x0000;  // Sample AN0 against negative reference.
011116  EB0100     CLR W2
011118  881942     MOV W2, AD1CHS
108:                 AD1CSSL = 0x0000;  // reset scan mask.
01111A  881982     MOV W2, AD1CSSL
109:               
110:                 _AD1IP = 7;        // high priority to stop automatic sampling
01111C  B3C700     MOV #0x70, W0
01111E  B760AA     IOR.B IPC3
111:               
112:                 ScanDoneInterruptInit();  // when triggered, generates an immediate interrupt to read ADC buffer
113:               
114:                 analog_scan_bitmask = 0x0000;
01112A  88F1E2     MOV W2, analog_scan_bitmask
115:                 analog_scan_num_channels = 0;
01112C  88F1D2     MOV W2, analog_scan_num_channels
116:               }
011130  FA0032     LNK #0x32
011132  BE9F88     MOV.D W8, [W15++]
011134  BE9F8A     MOV.D W10, [W15++]
011136  780401     MOV W1, W8
117:               
118:               static inline int CountOnes(unsigned int val) {
119:                 int res = 0;
120:                 while (val) {
01106C  EB0400     CLR W8
01106E  E00000     CP0 W0
011070  3A0032     BRA NZ, 0x110D6
011072  780400     MOV W0, W8
0110D4  32FFCF     BRA Z, 0x11074
0110E2  F80032     PUSH DSRPAG
0110E4  781F88     MOV W8, [W15++]
0110E6  202008     MOV #0x200, W8
0110E8  880198     MOV W8, DSRPAG
0110EA  78044F     MOV [--W15], W8
121:                   if (val & 1) ++res;
0110D6  A30800     BTST.Z W0, #0
0110D8  32FFFC     BRA Z, 0x110D2
0110DA  E80408     INC W8, W8
122:                   val >>= 1;
0110D2  D10000     LSR W0, W0
0110DC  D10000     LSR W0, W0
123:                 }
124:                 return res;
125:               }
126:               
127:               static inline void ReportAnalogInStatus() {
128:                 volatile unsigned int* buf = &ADC1BUF0;
129:                 int num_channels = CountOnes(AD1CSSL);
01106A  801980     MOV AD1CSSL, W0
130:                 int i;
131:                 BYTE var_arg[16];
132:                 int var_arg_pos = 0;
133:                 int group_header_pos;
134:                 int pos_in_group;
135:                 int value;
136:                 OUTGOING_MESSAGE msg;
137:                 msg.type = REPORT_ANALOG_IN_STATUS;
011074  5784FE     SUB W15, #0x1E, W9
011076  B3C0B0     MOV #0xB, W0
011078  784C80     MOV.B W0, [W9]
138:                 for (i = 0; i < num_channels; i++) {
01107A  EB0280     CLR W5
01107C  E00008     CP0 W8
01107E  340019     BRA LE, 0x110B2
011080  EB0200     CLR W4
011082  203006     MOV #0x300, W6
0110AC  E80204     INC W4, W4
0110AE  540F84     SUB W8, W4, [W15]
0110B0  3AFFE9     BRA NZ, 0x11084
139:                   pos_in_group = i & 3;
011084  6200E3     AND W4, #0x3, W1
140:                   if (pos_in_group == 0) {
011086  3A0005     BRA NZ, 0x11092
141:                     group_header_pos = var_arg_pos;
142:                     var_arg[var_arg_pos++] = 0;  // reset header
011088  2FFD20     MOV #0xFFD2, W0
01108A  40000F     ADD W0, W15, W0
01108C  7AF001     MOV.B W1, [W0+W5]
01108E  780385     MOV W5, W7
011090  E80285     INC W5, W5
143:                   }
144:                   value = buf[i];
011092  780136     MOV [W6++], W2
145:                   //log_printf("%d", value);
146:                   var_arg[group_header_pos] |= (value & 3) << (pos_in_group * 2);  // two LSb to group header
011094  2FFD20     MOV #0xFFD2, W0
011096  40000F     ADD W0, W15, W0
011098  400187     ADD W0, W7, W3
01109A  610063     AND W2, #0x3, W0
01109C  408081     ADD W1, W1, W1
01109E  DD0001     SL W0, W1, W0
0110A0  704993     IOR.B W0, [W3], [W3]
147:                   var_arg[var_arg_pos++] = value >> 2;  // eight MSb to channel byte
0110A2  DE9142     ASR W2, #2, W2
0110A4  2FFD21     MOV #0xFFD2, W1
0110A6  40808F     ADD W1, W15, W1
0110A8  7AF082     MOV.B W2, [W1+W5]
0110AA  E80285     INC W5, W5
148:                 }
149:                 AppProtocolSendMessageWithVarArg(&msg, var_arg, var_arg_pos);
0110B2  780105     MOV W5, W2
0110B4  2FFD21     MOV #0xFFD2, W1
0110B6  40808F     ADD W1, W15, W1
0110B8  780009     MOV W9, W0
0110BA  07DD07     RCALL AppProtocolSendMessageWithVarArg
150:               }
151:               
152:               static inline void ReportAnalogInFormat() {
153:                 unsigned int mask = analog_scan_bitmask;
154:                 int channel = 0;
155:                 BYTE var_arg[16 / 4 * 5];
156:                 int var_arg_pos = 0;
157:                 OUTGOING_MESSAGE msg;
158:                 msg.type = REPORT_ANALOG_IN_FORMAT;
010FF4  5785FE     SUB W15, #0x1E, W11
010FF6  B3C0C0     MOV #0xC, W0
010FF8  784D80     MOV.B W0, [W11]
01116C  2FFDA0     MOV #0xFFDA, W0
01116E  478580     ADD W15, W0, W11
011170  B3C0C0     MOV #0xC, W0
011172  784D80     MOV.B W0, [W11]
159:                 msg.args.report_analog_in_format.num_pins = analog_scan_num_channels;
010FFA  9FE7B3     MOV.B W3, [W15-29]
011174  9FDFB3     MOV.B W3, [W15-37]
160:                 while (mask) {
010FFC  E00008     CP0 W8
010FFE  32001A     BRA Z, 0x11034
011000  EB0480     CLR W9
011002  780509     MOV W9, W10
01100C  E00008     CP0 W8
01100E  3AFFFA     BRA NZ, 0x11004
011034  780108     MOV W8, W2
011056  F80036     PUSH RCOUNT
011058  BE9F80     MOV.D W0, [W15++]
01105A  BE9F82     MOV.D W2, [W15++]
01105C  BE9F84     MOV.D W4, [W15++]
01105E  BE9F86     MOV.D W6, [W15++]
011060  BE9F88     MOV.D W8, [W15++]
011062  F80032     PUSH DSRPAG
011064  202000     MOV #0x200, W0
011066  880190     MOV W0, DSRPAG
011068  FA002E     LNK #0x2E
011176  E00008     CP0 W8
011178  3A0030     BRA NZ, 0x111DA
01117A  780508     MOV W8, W10
0111DA  780483     MOV W3, W9
0111DC  780503     MOV W3, W10
0111E6  E00008     CP0 W8
0111E8  32FFC9     BRA Z, 0x1117C
161:                   if (mask & 1) {
011004  A30808     BTST.Z W8, #0
011006  3A001C     BRA NZ, 0x11040
0111DE  A30808     BTST.Z W8, #0
0111E0  3A0006     BRA NZ, 0x111EE
0111EA  A30808     BTST.Z W8, #0
0111EC  32FFFA     BRA Z, 0x111E2
162:                     var_arg[var_arg_pos++] = PinFromAnalogChannel(channel);
011040  780009     MOV W9, W0
011042  070787     RCALL PinFromAnalogChannel
011044  2FFCE1     MOV #0xFFCE, W1
011046  40808F     ADD W1, W15, W1
011048  7D7080     MOV.B W0, [W1+W10]
01104A  E8050A     INC W10, W10
0111EE  780009     MOV W9, W0
0111F0  0706B0     RCALL PinFromAnalogChannel
0111F2  2FFC61     MOV #0xFFC6, W1
0111F4  40808F     ADD W1, W15, W1
0111F6  7D7080     MOV.B W0, [W1+W10]
0111F8  E8050A     INC W10, W10
163:                   }
164:                   mask >>= 1;
011008  D10408     LSR W8, W8
01104C  D10408     LSR W8, W8
0111E2  D10408     LSR W8, W8
0111FA  D10408     LSR W8, W8
165:                   ++channel;
01100A  E80489     INC W9, W9
01104E  E80489     INC W9, W9
0111E4  E80489     INC W9, W9
0111FC  E80489     INC W9, W9
166:                 }
167:                 AppProtocolSendMessageWithVarArg(&msg, var_arg, var_arg_pos);
011010  78010A     MOV W10, W2
011012  2FFCE1     MOV #0xFFCE, W1
011014  40808F     ADD W1, W15, W1
011016  78000B     MOV W11, W0
011018  07DD58     RCALL AppProtocolSendMessageWithVarArg
011036  2FFCE1     MOV #0xFFCE, W1
011038  40808F     ADD W1, W15, W1
01103A  78000B     MOV W11, W0
01103C  07DD46     RCALL AppProtocolSendMessageWithVarArg
01103E  37FFED     BRA 0x1101A
01117C  78010A     MOV W10, W2
01117E  2FFC61     MOV #0xFFC6, W1
011180  40808F     ADD W1, W15, W1
011182  78000B     MOV W11, W0
011184  07DCA2     RCALL AppProtocolSendMessageWithVarArg
168:               }
169:               
170:               static inline void ADCTrigger() {
171:                 assert(analog_scan_num_channels != 0);
172:                 // Has format changed since our previous report?
173:                 if (AD1CSSL != analog_scan_bitmask) {
010FD8  801980     MOV AD1CSSL, W0
010FDA  80F1E8     MOV analog_scan_bitmask, W8
010FDC  500F88     SUB W0, W8, [W15]
010FDE  32001D     BRA Z, 0x1101A
174:                   AD1CSSL = analog_scan_bitmask;
010FE0  881988     MOV W8, AD1CSSL
175:                   _SMPI = analog_scan_num_channels - 1;
010FE2  80F1D3     MOV analog_scan_num_channels, W3
010FE4  E94083     DEC.B W3, W1
010FE6  60C0FF     AND.B W1, #0x1F, W1
010FE8  DD08C2     SL W1, #2, W1
010FEA  BFC322     MOV.B AD1CON2, WREG
010FEC  B3C832     MOV #0x83, W2
010FEE  604002     AND.B W0, W2, W0
010FF0  704001     IOR.B W0, W1, W0
010FF2  B7E322     MOV.B WREG, AD1CON2
176:                   ReportAnalogInFormat();
177:                 }
178:                 _ASAM = 1;  // start a sample
01101A  A84320     BSET AD1CON1, #2
179:               }
180:               
181:               void ADCSetScan(int pin, int enable) {
182:                 int channel = PinToAnalogChannel(pin);
011138  070710     RCALL PinToAnalogChannel
183:                 int mask;
184:                 if (channel == -1) return;
01113A  400FE1     ADD W0, #0x1, [W15]
01113C  320025     BRA Z, 0x11188
185:                 mask = 1 << channel;
01113E  200014     MOV #0x1, W4
011140  DD2100     SL W4, W0, W2
186:                 if (!!(mask & analog_scan_bitmask) == enable) return;
011142  80F1E1     MOV analog_scan_bitmask, W1
011144  EB0180     CLR W3
011146  610001     AND W2, W1, W0
011148  3A0023     BRA NZ, 0x11190
01114A  518F88     SUB W3, W8, [W15]
01114C  32001D     BRA Z, 0x11188
011190  780184     MOV W4, W3
011192  37FFDB     BRA 0x1114A
187:               
188:                 if (enable) {
01114E  E00008     CP0 W8
011150  3A0021     BRA NZ, 0x11194
189:                   if (analog_scan_num_channels) {
011194  80F1D0     MOV analog_scan_num_channels, W0
011196  E00000     CP0 W0
011198  3A0015     BRA NZ, 0x111C4
190:                     // already running, just add the new channel
191:                     _T3IE = 0;
0111C4  A90095     BCLR 0x95, #0
192:                     // These two variables are shared with the triggering code, ran from
193:                     // timer 3 interrupt context.
194:                     ++analog_scan_num_channels;
0111C6  E80000     INC W0, W0
0111C8  88F1D0     MOV W0, analog_scan_num_channels
195:                     analog_scan_bitmask |= mask;
0111CA  710001     IOR W2, W1, W0
0111CC  88F1E0     MOV W0, analog_scan_bitmask
196:                     _T3IE = 1;
0111CE  A80095     BSET 0x95, #0
197:                   } else {
198:                     // first channel, start running
199:                     analog_scan_num_channels = 1;
01119A  88F1D4     MOV W4, analog_scan_num_channels
200:                     analog_scan_bitmask = mask;
01119C  88F1E2     MOV W2, analog_scan_bitmask
201:                     ADCStart();
202:                   }
203:                 } else {
204:                   _T3IE = 0;
011152  A90095     BCLR 0x95, #0
205:                   --analog_scan_num_channels;
011154  80F1D3     MOV analog_scan_num_channels, W3
011156  E90183     DEC W3, W3
011158  88F1D3     MOV W3, analog_scan_num_channels
206:                   analog_scan_bitmask &= ~mask;
01115A  EA8002     COM W2, W0
01115C  608400     AND W1, W0, W8
01115E  88F1E8     MOV W8, analog_scan_bitmask
207:                   if (analog_scan_num_channels) {
011160  E00003     CP0 W3
011162  3A002A     BRA NZ, 0x111B8
208:                     _T3IE = 1;
0111B8  A80095     BSET 0x95, #0
209:                   } else {
210:                     // This was the last channel. At this point no new samples will be
211:                     // triggered, but we may be in the middle of a sample.
212:                     ADCStop();
213:                     // Now we're safe. Report the change in format.
214:                     ReportAnalogInFormat();
215:                     AD1CSSL = 0;  // To let the next trigger detect that this is the last
011186  EF2330     CLR AD1CSSL
216:                                   // reported format.
217:                   }
218:                 }
219:               }
011188  BE054F     MOV.D [--W15], W10
01118A  BE044F     MOV.D [--W15], W8
01118C  FA8000     ULNK
01118E  060000     RETURN
0111AE  BE054F     MOV.D [--W15], W10
0111B0  BE044F     MOV.D [--W15], W8
0111B2  FA8000     ULNK
0111B4  060000     RETURN
0111B6  37FFEC     BRA 0x11190
0111BA  BE054F     MOV.D [--W15], W10
0111BC  BE044F     MOV.D [--W15], W8
0111BE  FA8000     ULNK
0111C0  060000     RETURN
0111C2  37FFE6     BRA 0x11190
0111D0  BE054F     MOV.D [--W15], W10
0111D2  BE044F     MOV.D [--W15], W8
0111D4  FA8000     ULNK
0111D6  060000     RETURN
0111D8  37FFDB     BRA 0x11190
220:               
221:               void __attribute__((__interrupt__, auto_psv)) _T3Interrupt() {
222:                 ADCTrigger();
223:                 _T3IE = 0;  // disable interrupts. will be re-enabled when sampling is done.
01101C  A90095     BCLR 0x95, #0
224:                 _T3IF = 0;  // clear
01101E  A90085     BCLR 0x85, #0
225:               }
011020  FA8000     ULNK
011022  F90032     POP DSRPAG
011024  BE054F     MOV.D [--W15], W10
011026  BE044F     MOV.D [--W15], W8
011028  BE034F     MOV.D [--W15], W6
01102A  BE024F     MOV.D [--W15], W4
01102C  BE014F     MOV.D [--W15], W2
01102E  BE004F     MOV.D [--W15], W0
011030  F90036     POP RCOUNT
011032  064000     RETFIE
226:               
227:               void __attribute__((__interrupt__, auto_psv)) _CRCInterrupt() {
228:                 ReportAnalogInStatus();
229:                 _T3IE = 1;   // ready for next trigger.
0110BC  A80095     BSET 0x95, #0
230:                 _CRCIF = 0;  // clear
0110BE  A9608C     BCLR IFS4, #3
231:               }
0110C0  FA8000     ULNK
0110C2  F90032     POP DSRPAG
0110C4  BE044F     MOV.D [--W15], W8
0110C6  BE034F     MOV.D [--W15], W6
0110C8  BE024F     MOV.D [--W15], W4
0110CA  BE014F     MOV.D [--W15], W2
0110CC  BE004F     MOV.D [--W15], W0
0110CE  F90036     POP RCOUNT
0110D0  064000     RETFIE
232:               
233:               void __attribute__((__interrupt__, auto_psv)) _ADC1Interrupt() {
234:                 _ASAM = 0;  // Stop sampling
0110EC  A94320     BCLR AD1CON1, #2
235:                 ScanDoneInterruptTrigger();
236:                 _AD1IF = 0;  // clear
0110F0  A9A085     BCLR 0x85, #5
237:               }
